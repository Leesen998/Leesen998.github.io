<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[只是单纯地发个图片 hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 hexo deploy Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>first test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法基础1())]]></title>
    <url>%2F2016%2F12%2F08%2Fchapter1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、2、3、4、5、6、 01算法复杂度大O记号同样地出于保守的估计，我们首先关注T(n)的渐进上界。为此可引入所谓“大O记号”（big-O notation） 。具体地，若存在正的常数c和函数f(n)，使得对任何n &gt;&gt; 2都有T(n) &lt;= c∙f(n)则可认为在n足够大之后， f(n)给出了T(n)增长速度的一个渐进上界。此时，记之为：T(n) = O(f(n))由这一定义，可导出大O记号的以下性质：(1) 对于任一常数c &gt; 0，有O(f(n)) = O(c∙f(n))(2) 对于任意常数a &gt; b &gt; 0，有O(n^a + n^b) = O(n^a) 大Ω记号为了对算法的复杂度最好情况做出估计，需要借助另一个记号。如果存在正的常数c和函数g(n)，使得对于任何n &gt;&gt; 2都有T(n)  c∙g(n)就可以认为，在n足够大之后， g(n)给出了T(n)的一个渐进下界。此时，我们记之为：T(n) = Ω(g(n))这里的Ω称作“大Ω记号” （big-Ω notation）。与大O记号恰好相反，大Ω记号是对算法执行效率的乐观估计—对于规模为n的任意输入，算法的运行时间都不低于Ω(g(n))。比如，即便在最好情况下，起泡排序也至少需要T(n) = Ω(n)的计算时间。 大Θ记号借助大O记号、大Ω记号，可以对算法的时间复杂度作出定量的界定，亦即，从渐进的趋势看， T(n)介于Ω(g(n))与O(f(n))之间。若恰巧出现g(n) = f(n)的情况，则可以使用另一记号来表示。如果存在正的常数c1 &lt; c2和函数h(n)，使得对于任何n &gt;&gt; 2都有 c1∙h(n) &lt;= T(n) &lt;= c2∙h(n)就可以认为在n足够大之后， h(n)给出了T(n)的一个确界。此时，我们记之为：T(n) = Θ(h(n))这里的Θ称作“大Θ记号” （big-Θ notation） ，它是对算法复杂度的准确估计 复杂度分析常数O(1) 问题与算法首先考查如下问题：任给一个整数子集S, |S| = n ≥ 3，从中找出一个元素a ∈ S，使得a ≠ max(S)且a ≠ min(S)。亦即，在最大、最小者之外任取一个元素，称作“非极端元素” 或“平常元素” 。任取三个元素x, y, z ∈ S; //既然S是集合，返三个元素必于异通过比较对它们做排序; //设排序结枅为：min{x, y, z}, median(x, y, z), max{x, y, z}输出median(x, y, z); 对数O(logn) 问题与算法123456int i =1,n=1000,j=0; while(i&lt;n)&#123; i*=2; j++; &#125; 每次i乘以2，也就是说，至多经过1 + log2（n）次循环， i必然超过n，从而算法终止由大O记号定义，在用函数logrn界定渐进复杂度时，常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn。比如，尽管此处底数为常数2，却可直接记作O(logn)。此类算法称作具有“对数时间复杂度” 线性O(n) 问题与算法考查如下问题：计算给定n个整数的总和。 该问题可由代码1.3中的算法sumI()解决。123456int sumI(int A[], int n) &#123; //数组求和算法（迭代版） int sum = 0; //初始化累计器，O(1) for (int i = 0; i &lt; n; i++) //对全部共O(n)个元素，逐一 sum += A[i]; //累计，O(1) return sum; //返回回累计值，O(1)&#125; //O(1) + O(n)*O(1) + O(1) = O(n+2) = O(n) 首先，对s的初始化需要O(1)时间。算法的主体部分是一个循环，每一轮循环中只需进行一次累加运算，这属于基本操作，可在O(1)时间内完成。每经过一轮循环，都将一个元素累加至s，故总共需要做n轮循环， 于是该算法的运行时间应为：O(1) + O(1)×n = O(n+1) = O(n) 多项式O(polynomial(n))若运行时间可以表示和度量为T(n) = O(f(n))的形式，而且f(x)为多项式，则对应的算法称作“多项式时间复杂度算法” （polynomial-time algorithm)。所实现起泡排序bubblesort()算法的时间复杂度应为T(n) = O(n^2)， 故该算法即属于此类。当然， 以上所介绍的线性时间复杂度算法， 也属于多项式时间复杂度算法的特例，其中线性多项式f(n) = n的次数为1 复杂度层次常用的时间复杂度所耗费的时间从小到大依次是：O(1) &lt; O(logn) &lt; (n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 02递归线性递归数组求和以下仍以下数组求和问题为例，采用线性递归模式设计另一算法。首先注意到，若n =0则总和必为0，这也是最终的平凡情况。否则一般地，数组的总和可理解为前n-1个整数（即A[0,n-2]）之和，再加上A[]的最后一个元素（即A[n-1]）。 按这一思路，可设计出sum()算法如代码1.5所示12345678910111213//线性递归,数组求和public class Test &#123; public static void main(String[] args) &#123; int [] arr = &#123;1,2,3&#125;; int result = func(arr,arr.length); System.out.println(result); &#125; private static int func(int [] arr,int n)&#123; return (n&lt;1) ? 0:func(arr,n-1)+arr[n-1]; // n &lt; 1平凡情况，递归基 //return 0; //直接（非递归式）计算 &#125;&#125; 由此实例可看出递归算法保证有穷性的基本技巧。 具体地，首先必须判断并处理n = 0之类的平凡情况，以免因无限递归而导致系统溢出。这类平凡情况统称“递归基”（base case ofrecursion）。 可能有多种平凡情况，但至少要有一种，且这类情况迟早必出现。比如，算法sum()的递归基只包含一种情况，只需简单地判断n是否已经减小到0 算法sum()是通过更深一层的自我调用来实现的，而且该函数的每一实例对自身的调用至多一次。于是，在每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归” （linear recursion） ，它也是递归的最基本形式该图清晰地给出了算法执行的整个过程：首先对参数n进行调用，再转向对参数n-1的调用，再转向对参数n-2的调用， …，直至最终的参数0。在抵达递归基后不再递归，而是将平凡的解（长度为0数组的总和0）返回给对参数1的调用；累加上A[0]之后，再返回给对参数2的调用；累加上A[1]之后，继续返回给对参数3的调用； …；如此依次返回，直到最终返回给对参数n的调用，此时，只需累加A[n-1]即得到整个数组的总和 时间复杂度：具体地， 就以上的sum()算法而言，每一递归实例中非递归部分所涉及的计算无非三类（判断n是否为0、累加sum(n-1)与A[n-1]、返回当前总和） ，而且它们至多各执行一次。鉴于它们均属于常数时间成本的基本操作，每个递归实例实际所需的计算时间都应为常数O(3)。由图还可以看出， 对于长度为n的输入数组，递归深度应为n+1，故整个sum()算法共需运行(n+1) * O(3) = O(n)时间 空间复杂度：在创建了最后一个递归实例（即到达递归基）时，占用的空间量达到最大——准确地说，等于所有递归实例各自所占空间量的总和。这里每一递归实例所需存放的数据，无非是调用参数（数组A的起始地址和长度n）以及用于累加总和的临时变量。这些数据各自只需常数规模的空间，其总量也应为常数。故此可知，sum()算法的空间复杂度线性正比于其递归的深度， 亦即O(n) 递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N). 减而治之线性递归模式往往对应于所谓减而治之（decrease-and-conquer） 的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。按照减而治之策略，此处随着递归的深入，调用参数将单调地线性递减。因此无论最初输入的n有多大，递归调用的总次数都是有限的， 故算法的执行迟早会终止，即满足有穷性。当抵达递归基时，算法将执行非递归的计算（这里是返回0） 递推方程该方法无需绘出具体的调用过程，而是通过对递归模式的数学归纳，导出关于复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度分析的任务转化为递归方程（组）的求解 仍以代码线性递归版sum()算法为例， 将该算法处理长度为n的数组所需的时间成本记作T(n)。我们将该算法的思路重新表述如下：为解决问题sum(A, n)，需递归地解决问题sum(A,n-1)，然后累加上A[n-1]。按照这一新的理解，求解sum(A, n)所需的时间，应该等于求解sum(A,n-1)所需的时间，另加一次整数加法运算所需的时间。 根据以上分析，可以得到关于T(n)的如下一般性的递推关系：T(n) = T(n-1) + O(1) = T(n-1) + c1，其中c1为常数另一方面，当递归过程抵达递归基时，求解平凡问题sum(A, 0)只需（用于直接返回0的）常数时间。如此，即可获得如下边界条件：T(0) = O(1) = c2， 其中c2为常数联立以上两个方程， 最终可以解得：T(n) = c1n + c2 = O(n) 递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N). 线性递归版sum()算法共需O(n)的附加空间 多递归基为保证有穷性， 所有递归算法都首先必须设有递归基，且确保对应的语句总能执行到。实际上， 针对算法中可能出现的每一类平凡情况，都需要设置对应的递归基，因此同一算法的递归基可能（显式或隐式地）不止一个。以下考察数组倒置问题， 也就是将数组中各元素的次序前后翻转。 比如，若输入数组为：A[] = {3, 1, 4, 1, 5, 9, 2, 6}则倒置后为：A[] = {6, 2, 9, 5, 1, 4, 1, 3} 12345678910111213//多递归基，数组倒置private static void reserse(int [] a,int left,int right)&#123; if(left&lt;0 || right&gt;=a.length)&#123; return; &#125; if(left &lt; right)&#123; int temp =a[left]; a[left] =a[right]; a[right] = temp; reserse(a,left+1,right-1); &#125; ////else隐含了两种递归基 &#125; 可见，每深入递归一层，待倒置区间的长度 left - right + 1都缩短2个单元。因此， 所有递归实例所对应区间长度的奇偶性一致。需要特别留意的是， 此处递归基实际上分为两种情况： left = right（原数组长度为奇数）或left = right + 1（原数组长度为偶数）。当然，无论如何reverse()算法都必然会终止于这两种平凡情况之一，因此递归的深度应为：[(n + 1) / 2] = O(n)在算法终止之前，递归每深入一层都会通过一次对换使得当前的A[left]与A[right]就位，因此该算法的时间复杂度也应线性正比于递归深度，即O(n)。 二分递归分而治之面对输入规模庞大的应用问题，每每感慨于头绪纷杂而无从下手的你，不妨从先哲孙子的名言中获取灵感“凡治众如治寡，分数是也” 。是的，解决此类问题的有效方法之一，就是将其分解为若干规模更小的子问题， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer） 策略 123456789101112//二分递归，数组求和private static int sum(int [] a,int left,int right)&#123; if(left&lt;0 || right&gt;=a.length)&#123; return -1; &#125; if(left == right)&#123; return a[left]; &#125; int medium = (left+right)/2; return sum(a,left,medium) + sum(a,medium+1,right); &#125; 针对n = 8的情况给出了sum(A, 0, 7)执行过程的递归跟踪。其中各方框都标注有对应的lo和hi值， 即子数组区间的起、止单元。可见，按照调用的关系及次序，该方法的所有实例构成一个层次结构（即二叉树）。沿着这个层次结构每下降一层，每个递归实例sum(lo, hi)都分裂为一对更小的实例sum(lo, mi)和sum(mi+1, hi)——准确地说，每经过一次递归调用， 子问题对应的数组区间长度hi-lo+1都将减半。 算法启动后经连续m = log2n次递归调用，数组区间的长度从最初的n首次缩减至1，并到达第一个递归基。实际上，刚到达任一递归基时，已执行的递归调用总是比递归返回多m = log2n次。更一般地，到达区间长度为2^k的任一递归实例之前，已执行的递归调用总是比递归返回多m-k次。因此，递归深度（即任一时刻的活跃递归实例的总数）不会超过m+1。鉴于每个递归实例仅需常数空间， 故除数组本身所占的空间，该算法只需要O(m+1) = O(logn)的附加空间。我们还记得， 代码1.5 中线性递归版sum()算法共需O(n)的附加空间，就这一点而言，新的二分递归版sum()算法有很大改进 02异常的继续体系和错误的区别1234567891011121314151617181920212223242526272829* A: 异常的继承体系 Throwable: 它是所有错误与异常的超类（祖宗类） |- Error 错误 |- Exception 编译期异常,进行编译JAVA程序时出现的问题 |- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题* B：异常与错误的区别* a："异常Exception" * 指程序在"编译、运行期间"发生了某种"异常(XxxException)"，我们可以对异常进行具体的处理。 * 若不处理异常，程序将会结束运行。 * 案例演示： public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr[0]); System.out.println(arr[3]); // 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException， // 由于没有处理异常，导致程序无法继续执行，程序结束。 System.out.println("over"); // 由于上面代码发生了异常，此句代码不会执行 &#125; * b："错误Error" * 指程序在"运行期间"发生了某种"错误(XxxError)"，Error错误通常"没有具体的处理方式"，程序将会结束运行。 * Error错误的发生往往都是"系统级别"的问题，都是"jvm所在系统"发生的，并反馈给jvm的。 * 我们无法针对处理，"只能修正代码"。 * 案例演示： public static void main(String[] args) &#123; int[] arr = new int[1024*1024*100]; //该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间， //导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。 &#125; 03异常对象的产生原因和处理方式1234567891011121314151617181920212223242526272829303132333435* A: 异常对象的产生原因* 案例代码： * 工具类 class ArrayTools&#123; //对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr,int index) &#123; int element = arr[index]; return element; &#125; &#125; * 测试类 class ExceptionDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;34,12,67&#125;; int num = ArrayTools.getElement(arr,4) System.out.println("num="+num); System.out.println("over"); &#125; &#125;* 原因分析： * a: 由于没找到4索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。 这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。 java将这些信息直接封装到异常对象中。new ArrayIndexOutOfBoundsException(4); * b：throw new ArrayIndexOutOfBoundsException(4);产生异常对象。JVM将产生的异常抛给调用者main()方法。 * c：main()方法接收到了数组索引越界异常对象。 由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。 当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。* B：异常的处理方式* a：JVM的默认处理方式 * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。 * 一旦有异常发生，其后来的代码不能继续执行。* b：解决程序中异常的手动方式 * a)：编写处理代码 try...catch...finally * b)：抛出 throws * 04方法内部抛出对象throw关键字1234567891011121314151617在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。* A: 什么时候使用throw关键字？ * 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断， 数据若不合法，就应该告诉调用者，传递合法的数据进来。 这时需要使用抛出异常的方式来告诉调用者。* B: 使用throw关键字具体操作 * a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 * b: 通过关键字throw将这个异常对象告知给调用者。throw 异常对象； throw 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。* C: throw关键字使用格式 * throw new 异常类名(参数); * 例如： throw new NullPointerException("要访问的arr数组不存在"); throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");* D：案例演示 * throw的使用 * 05方法声明异常关键字throws123456789101112131415161718192021222324252627282930313233* A: 声明 * 将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常， 而"没有捕获处理"（稍后讲解该方式），那么"必须通过"throws进行声明，让"调用者去处理"。* B: 声明异常格式 * 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… &#123; &#125;* C：注意事项： * throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。* D：代码演示： * 多个异常的处理"//方法声明异常关键字" throwspublic class ExceptionDemoTest &#123; public static void main(String[] args) throws Exception &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;;// func(arr); func(trt); &#125; private static int func(int [] arr) throws Exception&#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 06try…catch异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344* A: 捕获 * Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理* B: 捕获异常格式 try &#123; "//需要被检测的语句。" &#125; catch(异常类 变量) &#123; //参数。 "//异常的处理语句。" &#125; finally &#123; "//一定会被执行的语句。" &#125;* C: 格式说明 * a: try * 该代码块中编写可能产生异常的代码。 * b: catch * 用来进行某种异常的捕获，实现对捕获到的异常进行处理。 * c: finally： * "有一些特定的代码无论异常是否发生，都需要执行"。 * 另外，因为"异常会引发程序【跳转】到"catch语句处，"导致有些语句执行不到"。 * 而finally就是解决这个问题的，在finally代码块中存放的"代码都是【一定】会被执行"的。 * d：try...catch..."处理掉异常后，程序可以继续执行"* D：案例演示 * 捕获异常格式"//try…catch异常处理"public class TryCatchDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere); int result = func(arr);"//异常发生后后，程序将发生跳转到catch处执行" System.out.println("ano: "+ ano);"//try异常后面的语句不会执行" System.out.println("result: "+ result); &#125;catch(Exception ex)&#123; System.out.println(ex); &#125; System.out.println("程序继续执行..."); &#125; 07多catch处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* A：一个try 多个catch组合 * 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。* B：多catch处理的格式 void show()&#123; //不用throws try&#123; throw new Exception();//产生异常，直接捕获处理 &#125;catch(XxxException e)&#123; //处理方式 &#125;catch(YyyException e)&#123; //处理方式 &#125;catch(ZzzException e)&#123; //处理方式 &#125; &#125; 注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个catch中异常变量名为e。"//多catch处理"public class TryCatchDemo_1 &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere); int result = func(arr);//异常发生后后，程序将发生跳转到catch出执行 System.out.println("ano: "+ ano);//try异常后面的语句不会执行// System.out.println("result: "+ result); &#125; catch(NullPointerException nullex)&#123; System.out.println(nullex); &#125; catch(ArrayIndexOutOfBoundsException outboundex)&#123; System.out.println(outboundex); &#125; System.out.println("程序继续执行..."); &#125; private static int func(int [] arr) throws NullPointerException,ArrayIndexOutOfBoundsException &#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 08多catch处理细节12345678910* A：细节：多个catch小括号中，写的是异常类的类名，有没有顺序的概念？ * 有顺序关系。* B："平级异常"： * 抛出的"异常类之间","没有""继承关系","没有顺序" NullPointerException extends RuntimeException NoSuchElementException extends RuntimeException ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException* C："上下级关系(继承关系)的异常" * 越高级的"父类",越"写在下面"，《考虑多态的影响》 NullPointerException extends RuntimeException extends Exception 09finally代码块123456789101112131415161718192021222324252627282930313233343536373839404142* A: finally的特点 * "无论"try...catch语句"有没有异常出现"，被finally控制的"语句体"一定"会执行"， * "除非"发生"异常时"在catch语句中 有 "System.exit(0)" 或者 try语句外部"前面""有异常"出现;* B：finally的作用 * finally,无论程序是否有异常出现,程序必须执行释放资源在 如：IO流操作和数据库操作中会见到public class FinallyDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere);// int result = func(arr);//异常发生后后，程序将发生跳转到catch处执行 System.out.println("ano: "+ ano);//try异常后面的语句不会执行 &#125;catch(Exception ex)&#123; System.out.println(ex); &#125; finally&#123; System.out.println("无论有无异常，这里的代码均会执行..."); &#125; &#125; private static int func(int [] arr) throws Exception&#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 09finally代码块中有return语句123456789101112131415161718192021警告： 当 finally 子句包含 return 语句时， 将会出现一种意想不到的结果。假设利用 return语句从 try语句块中退出。在"方法返回前"，finally 子句的内容"将【先被】执行"。如果 finally 子句中也有一个 return 语句， 这个"返回值"将会"【覆盖】""原始的返回值"。例子： public static int f(int n) &#123; try &#123; int r = n * n; return r; &#125; finally &#123; if (n == 2) return 0; &#125; &#125;如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值 4 10try…catch…finally代码块详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TryCatchFinallyDemo &#123; public static void main(String[] args) &#123; InputStream in = new FileInputStream(. . .); try &#123; "//1" "code that might throw exceptions" "//2" &#125; catch (IOException e) &#123; "// 3" "show error message" "// 4" &#125; finally &#123; "// 5" in.close()； &#125; "//6" &#125;&#125;在上面这段代码中，有下列 3 种情况会执行 finally 子句：1 ) "代码【没有】抛出异常"。 在这种情况下， 程序首先执行 try 语句块中的"全部代码"，然后执行 finally 子句中的代码 。随后， 继续执行 try...finally 语句块之"后的"第一条"语句"。也就是说，执行标注的 1、 2、 5、 6 处。2 ) "抛出"一个在 catch 子句中"捕获的异常"。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，"直到发生异常为止"。此时，将"跳过" try语句块中的"剩余代码"， 转去"执行与该异常匹配"的 catch 子句中的代码， 最后执行 finally 子句中的代码。【分为以下2种情况】： A:如果 catch 子句"没有抛出异常"， 程序将执行 try 语句块之后的第一条语句。 在这里，执行标注 1、 3、 4、5、 6 处的语句。 B:如果 catch 子句"抛出了一个异常"， "异常"将被"抛回"这个方法的"调用者"。 在这里， 执行标注1、 3、 5 处的语句，"注意"语句6"将不再执行"。3 ) 代码"抛出了一个异常"， "但这个异常【不是】"由 catch 子句"捕获"的。在这种情况下， 程序将执行 try 语句块中的所有语句，"直到有异常被抛出为止"。此时， 将"跳过" try 语句块中的"剩余代码"， 然后执行 finally子句中的语句， 并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。"注意"语句6"将不再执行"。即：try语句"抛出异常"，但是catch"没有捕获"的"异常"或者 catch语句"自身出现异常"，6处的代码"不会执行"try 语句"可以只有" finally 子句，而"没有"catch 子句。例如，下面这条 try 语句： InputStream in = ...； try &#123; code that might throw exceptions &#125; finally &#123; in.close()； &#125; 10调用抛出异常方法try和throws处理方式123456789101112131415161718192021222324* A: 在实际开发中使用哪种异常处理方式呢，* 继续向上throws Exception 还是用 try...catch...finally处理异常 ？ * 能自己处理的尽量自己处理。(建议用try...catch)例如：public Date parse(String source) throws ParseException从给定字符串的开始解析文本，以生成一个日期。该方法不使用给定字符串的整个文本。 该方法本身会 throws ParseException (声明可能抛出的异常)public class TryCatch_ThowsDemo &#123; public static void main(String[] args) &#123; try&#123; func(); &#125; catch(ParseException ex)&#123; System.out.println(ex); &#125; &#125; public static void func() throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date dd = sdf.parse("2088-8-8"); System.out.println(dd); &#125;&#125; 11运行时期异常RuntimeException的特点1234567891011121314151617* A: 运行时期异常的概述: * RuntimeException和"他的所有子类异常",都属于"运行时期异常"。 如常见的 NullPointerException,ArrayIndexOutOfBoundsException 等都属于运行时期异常.* B：运行时期异常的特点 * a：方法中"抛出运行时期异常",方法定义中"无需"throws"声明",调用者也"无需处理此异常"。 * b："运行时期异常一旦发生,【一定】是源代码发生了错误，需要程序人员【修改】【源代码】"。 设计原因: 运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码 运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义(1) 抛出"Exception"，"必须要"throws"声明"，一声明就"告知""调用者"进行"捕获"，一旦"问题处理了"调用者的"程序会继续执行"。(2) 抛出"RuntimeExcpetion","不需要"throws"声明"的，这时调用是"不需要编写捕获代码"的，因为调用者根本就不知道有问题。一旦发生RuntimeException，"调用者程序会停掉"，并有jvm将信息显示到屏幕，让调用者看到问题，"修正代码"。 12运行异常的案例12345678910111213141516171819202122232425262728293031323334353637* A: 计算圆的面积案例 定义方法,计算圆形的面积 传递参数0,或者负数,计算的时候没有问题 但是,违反了真实情况 参数小于=0, 停止程序,不要在计算了* B：数组索引越界案例 使用数组中不存在的索引public class RuntimeExceptionDemo &#123; public static void main(String[] args) &#123; double d = getArea(1); System.out.println(d); &#125; /* * 定义方法,计算圆形的面积 * 传递参数0,或者负数,计算的时候没有问题 * 但是,违反了真实情况 * 参数小于=0, 停止程序,不要在计算了 * */ 方法中"抛出运行时期异常",方法定义中"无需"throws"声明",调用者也"无需处理此异常" public static double getArea(double r)&#123; if(r &lt;= 0) throw new RuntimeException("圆形不存在"); return r*r*Math.PI; &#125; public static void function()&#123; int[] arr = &#123;1,2,3&#125;; //对数组的5索引进行判断,如果5索引大于100,请将3索引上的数据/2,否则除以3 //索引根本就没有 if(arr[3] &gt; 100)&#123; arr[3] = arr[3]/2; &#125;else&#123; arr[3] = arr[3]/3; &#125;&#125; 13方法重写时候异常的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657* A：方法重写时候异常的处理* a："子类"覆盖"父类"方法时，* 如果"父类"的"方法""声明异常"，"子类""只能"声明"父类异常"或者"父类异常的子类"，或者"不声明"。 例如： class Fu &#123; public void method () throws RuntimeException &#123; &#125; &#125; class Zi extends Fu &#123; public void method() throws RuntimeException &#123; &#125; "//抛出父类一样的异常" public void method() throws NullPointerException&#123; &#125; "//抛出父类异常的子类" public void method()&#123;&#125; "//不声明异常" &#125;* b：当"父类方法"声明"多个异常"时，"子类""覆盖"时"只能"声明"多个异常"的"子集"(注意是"子集")。 例如： class Fu &#123; public void method () throws NullPointerException, ClassCastException&#123; &#125; &#125; class Zi extends Fu &#123; public void method()throws NullPointerException, ClassCastException &#123; &#125; public void method() throws NullPointerException&#123; &#125; "//抛出父类异常中的一部分" public void method() throws ClassCastException &#123; &#125; "//抛出父类异常中的一部分" &#125;* c：当"父类"被覆盖的"方法""没有""异常声明"时，"子类"覆盖时"不能""声明异常"。 例如： class Fu &#123; public void method ()&#123; &#125; &#125; class Zi extends Fu &#123; public void method() throws Exception &#123; &#125; ！！！error /"错误的方式" &#125;* B：问题：父类中会存在下列这种情况，接口也有这种情况。 接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？回答：无法进行throws声明，只能catch的捕获。 万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。interface Inter &#123; public abstract void method();&#125;class Zi implements Inter &#123; public void method()&#123; //无法声明 throws Exception int[] arr = null; if (arr == null) &#123; //只能捕获处理 try&#123; throw new Exception("哥们，你定义的数组arr是空的!"); &#125; catch(Exception e)&#123; System.out.println("父方法中没有异常抛出，子类中不能抛出Exception异常"); //我们把异常对象e，采用RuntimeException异常方式抛出 throw new RuntimeException(e); &#125; &#125; &#125;&#125; 14Throwable类方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556* A: 常见方法 * a："getMessage()方法" 返回该异常的详细信息字符串，即"异常提示信息" * b："toString()方法" 返回该"异常的名称"与"详细信息字符串" * c："printStackTrace()方法" 在控制台输出"该异常的名称"与"详细信息字符串"、"异常出现的代码【位置】"* B：案例演示 异常的常用方法代码演示 try &#123; Person p= null; if (p==null) &#123; throw new NullPointerException(“出现空指针异常了，请检查对象是否为null”); &#125; &#125; catch (NullPointerException e) &#123; String message = e.getMesage(); System.out.println(message ); String result = e.toString(); System.out.println(result); e.printStackTrace(); &#125;public class ThrowableDemo &#123; public static void main(String[] args) &#123; try&#123; func(); &#125; catch(Exception ex)&#123; System.out.println(ex); System.out.println("--------------------------------------------1"); System.out.println(ex.getMessage()); System.out.println("--------------------------------------------2"); System.out.println(ex.toString()); System.out.println("---------------------------------------------3"); ex.printStackTrace(); &#125; &#125; private static void func() throws Exception&#123; int[] arr =&#123;1,2,3&#125;; for(int i=0;i&lt;5;i++)&#123; if(i&gt;=arr.length)&#123; throw new ArrayIndexOutOfBoundsException("数组长度是"+ arr.length +", 数组越界了..."); &#125; System.out.println(arr[i]); &#125; &#125;&#125; 15自定义异常类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113* A: 自定义异常的定义例如NullPointerException异常类源代码：public class NullPointerException extends RuntimeException &#123; public NullPointerException() &#123; super();"//调用父类构造方法" &#125; public NullPointerException(String s) &#123; super(s);"//调用父类具有异常信息的构造方法" &#125;&#125;* a：通过阅读源码，发现规律： 每个异常中都"调用了父类的构造方法"，把"异常描述信息""传递"给了"父类"， 让"父类"帮我们"进行异常信息的封装"。* b："格式"： Class 异常名 extends Exception&#123; "//或继承RuntimeException" public 异常名()&#123; &#125; public 异常名(String s)&#123; super(s); &#125; &#125; * c：自定义异常"继承Exception"演示class MyException extends Exception&#123; /* 为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。 */ public MyException()&#123; super(); &#125; public MyException(String message) &#123; // 如果自定义异常需要异常信息， //可以通过调用父类的带有字符串参数的构造函数即可。 super(message); &#125;&#125;* d：自定义异常"继承RuntimeException"演示* class MyException extends RuntimeException&#123; /* 为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。 */ MyException()&#123; super(); &#125; MyException(String message) &#123; // 如果自定义异常需要异常信息， //可以通过调用父类的带有字符串参数的构造函数即可。 super(message); &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————* B：自定义异常的练习 在Person类的有参数构造方法中，进行年龄范围的判断， 若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。 要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。"//自定义异常类"public class AgeException extends Exception &#123; public AgeException()&#123; &#125; public AgeException(String message)&#123; super(message); &#125;&#125;"//Person类"public class Person &#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) throws AgeException&#123; if(age &lt;0 || age&gt;200)&#123; throw new AgeException("年龄输入有误:" + age); &#125; this.name =name; this.age =age; &#125; @Override public String toString()&#123; return "姓名： "+ name + " |年龄: "+ age; &#125;&#125;"//测试类"public class ExceptionTestDemo &#123; public static void main(String[] args) &#123; try &#123; Person p= new Person("张楠", 209); System.out.println(p.toString()); &#125; catch(AgeException aex)&#123; aex.printStackTrace(); &#125; &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————* C：关于构造方法"抛出异常总结"(1) 抛出"Exception"，"必须要"throws"声明"，一声明就"告知""调用者"进行"捕获"，一旦"问题处理了"调用者的"程序会继续执行"。(2) 抛出"RuntimeExcpetion","不需要"throws"声明"的，这时调用是"不需要编写捕获代码"的，因为调用者根本就不知道有问题。一旦发生RuntimeException，"调用者程序会停掉"，并有jvm将信息显示到屏幕，让调用者看到问题，"修正代码"。 16总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 异常：就是程序中出现的不正常的现象(错误与异常) 异常的继承体系: Throwable: 它是所有错误与异常的超类（祖宗类） |- Error 错误，修改java源代码 |- Exception 编译期异常, javac.exe进行编译的时候报错 |- RuntimeException 运行期异常, java出现运行过程中出现的问题 异常处理的两种方式： 1，出现问题，自己解决 try…catch…finally try&#123; 可能出现异常的代码 &#125; catch(异常类名 对象名)&#123; 异常处理代码 &#125; finally &#123; 异常操作中一定要执行的代码 &#125; 2，出现问题，别人解决 throws 格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2,...&#123;&#125; public void method() throws Exception&#123;&#125;—————————————————————————————————————————————————————————————————————————————————————————— 异常分类异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。 严重错误Error，无法通过处理的错误 编译时异常Exception，编译时无法编译通过。如日期格式化异常 运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如空指针异常 异常基本操作 创建异常对象 抛出异常 处理异常： 捕获处理，将异常获取，使用try/catch做分支处理 try&#123; 需要检测的异常；&#125; catch(异常对象) &#123; 通常我们只使用一个方法：printStackTrace打印异常信息&#125; "声明抛出处理"，"出现异常后不处理"，"声明抛出给调用者处理"。 方法声明上加throws 异常类名 "注意"：异常的处理，指处理"异常"的"一种可能性"，即有了异常处理的代码，"不一定"会"产生异常"。如果没有产生异常，则代码正常执行，如果产生了异常，则中断当前执行代码，执行异常处理代码。—————————————————————————————————————————————————————————————————————————————————————————— 异常注意事项 多异常处理捕获处理： 1多个异常可以分别处理 2多个异常一次捕获多次处理 3多个异常一次捕获，采用同一种方式处理声明抛出异常： 声明上使用,一次声明多个异常 —————————————————————————————————————————————————————————————————————————————————————————— "运行时异常"被抛出可以"不处理"。"即不捕获""也不声明抛出" 如果"父类"抛出了"多个异常","子类覆盖父类方法"时,"只能"抛出相同的异常或者是他的"子集" "父类"方法"没有"抛出异常，"子类覆盖父类该方法"时也"不可抛出异常"。 此时子类产生该异常，只能捕获处理，不能声明抛出 当"多"catch异常处理时，捕获处理，"前边的类""不能"是"后边类"的"父类" 自定义异常如果Java没有提供你需要的异常，则可以自定义异常类。定义方法：编译时异常继承Exception，运行时异常继承RuntimeException。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础31(类加载器,反射)]]></title>
    <url>%2F2016%2F12%2F02%2Fday33%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、类加载器2、反射构造方法3、反射成员变量4、反射成员方法5、反射配置文件运行类中的方法 01类加载器1234567891011121314151617181920212223242526272829303132333435363738* A.类的加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 * a 加载 * 就是指将class文件读入内存，并为之创建一个Class对象。* 任何类被使用时系统都会建立一个Class对象 * b 连接* 验证 是否有正确的内部结构，并和其他类协调一致* 准备 负责为类的静态成员分配内存，并设置默认初始化值* 解析 将类的二进制数据中的符号引用替换为直接引用 * c 初始化 * 就是我们以前讲过的初始化步骤（new 对象）* 注：简单的说就是：把.class文件加载到内存里，并把这个.class文件封装成一个Class类型的对象。* * B.类的加载时机 以下的情况，会加载这个类。 * a. 创建类的实例 * b. 类的静态变量，或者为静态变量赋值 * c. 类的静态方法 * d. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 * e. 初始化某个类的子类 * f. 直接使用java.exe命令来运行某个主类* C: 类加载器(了解)负责将.class文件加载到内在中，并为之生成对应的Class对象。 * a. Bootstrap ClassLoader 根类加载器* 也被称为引导类加载器，负责Java核心类的加载* 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 * b. Extension ClassLoader 扩展类加载器* 负责JRE的扩展目录中jar包的加载。* 在JDK中JRE的lib目录下ext目录 * c. System ClassLoader 系统类加载器* 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。* 我们用的是System ClassLoader 系统类加载器 02 反射定义123456789101112* a. JAVA反射机制是在运行状态中， 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。* b.反射技术条件：运行状态已知：一个类或一个对象(根本是已知.class文件)结果：得到这个类或对象的所有方法和属性* 注: 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。* * B. Class类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107* a. Class类及Class对象的了解要想解剖一个类，必须先了解Class对象。阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。* b. 得到Class对象* 1. 有三个方法* 方式一: 通过Object类中的getClass()方法 Person person = new Person(); Class clazz = person.getClass(); 方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。 Class clazz = Person.class; 方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。 Class c3 = Class.forName("Person"); 注：第三种和前两种的区别是： 前两种你必须明确Person类型. 后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了* 2. 得到Class对象的三个方法代码演示： 代码演示 /* * 获取.class字节码文件对象的方式 * 1：通过Object类中的getObject()方法 * 2: 通过 类名.class 获取到字节码文件对象 * 3: 反射中的方法, * public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException * 返回与带有给定字符串名的类或接口相关联的 Class 对象 */ public class ReflectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 1： 通过Object类中的getObject()方法 // Person p1 = new Person(); // Class c1 = p1.getClass(); // System.out.println("c1 = "+ c1); // 2: 通过 类名.class 获取到字节码文件对象 // Class c2 = Person.class; // System.out.println("c2 = "+ c2); // 3: 反射中的方法 Class c3 = Class.forName("cn.itcast_01_Reflect.Person");// 包名.类名 System.out.println("c3 = " + c3); &#125; &#125; Person类 package cn.itcast_01_Reflect; public class Person &#123; //成员变量 public String name; public int age; private String address; //构造方法 public Person() &#123; System.out.println("空参数构造方法"); &#125; public Person(String name) &#123; this.name = name; System.out.println("带有String的构造方法"); &#125; //私有的构造方法 private Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println("带有String，int的构造方法"); &#125; public Person(String name, int age, String address)&#123; this.name = name; this.age = age; this.address = address; System.out.println("带有String, int, String的构造方法"); &#125; //成员方法 //没有返回值没有参数的方法 public void method1()&#123; System.out.println("没有返回值没有参数的方法"); &#125; //没有返回值，有参数的方法 public void method2(String name)&#123; System.out.println("没有返回值，有参数的方法 name= "+ name); &#125; //有返回值，没有参数 public int method3()&#123; System.out.println("有返回值，没有参数的方法"); return 123; &#125; //有返回值，有参数的方法 public String method4(String name)&#123; System.out.println("有返回值，有参数的方法"); return "哈哈" + name; &#125; //私有方法 private void method5()&#123; System.out.println("私有方法"); &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", address=" + address+ "]"; &#125; &#125;* 注: Class类型的唯一性 因为一个.class文件在内存里只生成一个Class对象，所以无论那一种方法得到Class对象，得到的都是同一个对象。 * C.通过反射获取无参构造方法并使用12345678910111213141516171819202122232425262728293031323334353637383940414243* a. 得到无参构造方法public Constructor&lt;?&gt;[] getConstructors() 获取所有的public 修饰的构造方法。 选择无参构造方法，不建议使用。public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法。 不传参数得到无参构造方法。* b. 运行无参构造方法public T newInstance(Object... initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 因为是无参构造，所以不传参数。* c. 通过反射获取无参构造方法并使用的代码演示： package cn.itcast.demo1; import java.lang.reflect.Constructor; /* * 通过反射获取class文件中的构造方法,运行构造方法 * 运行构造方法,创建对象 * 获取class文件对象 * 从class文件对象中,获取需要的成员 * * Constructor 描述构造方法对象类 */ public class ReflectDemo1 &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("cn.itcast.demo1.Person"); //使用class文件对象,获取类中的构造方法 // Constructor[] getConstructors() 获取class文件对象中的所有公共的构造方法 /*Constructor[] cons = c.getConstructors(); for(Constructor con : cons)&#123; System.out.println(con); &#125;*/ //获取指定的构造方法,空参数的构造方法 Constructor con = c.getConstructor(); //运行空参数构造方法,Constructor类方法 newInstance()运行获取到的构造方法 Object obj = con.newInstance(); System.out.println(obj.toString()); &#125; &#125; * D. 通过反射获取有参构造方法并使用123456789101112131415161718192021222324252627282930313233* a. 得到有参的构造方法public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取public修饰, 指定参数类型所对应的构造方法。 传相应的参数类型得到有参构造方法。* b. 运行无参构造方法public T newInstance(Object... initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 因为是有参构造，所以传相应的参数值。* c. 通过反射获取有参构造方法并使用的代码演示：package cn.itcast.demo1;import java.lang.reflect.Constructor;/* * 通过反射,获取有参数的构造方法并运行 * 方法getConstructor,传递可以构造方法相对应的参数列表即可 */public class ReflectDemo2 &#123; public static void main(String[] args)throws Exception &#123; Class c = Class.forName("cn.itcast.demo1.Person"); //获取带有,String和int参数的构造方法 //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) //Class&lt;?&gt;... parameterTypes 传递要获取的构造方法的参数列表 Constructor con = c.getConstructor(String.class,int.class); //运行构造方法 // T newInstance(Object... initargs) //Object... initargs 运行构造方法后,传递的实际参数 Object obj = con.newInstance("张三",20); System.out.println(obj); &#125;&#125; * E. 通过反射获取有参构造方法并使用快捷方式12345678910111213141516171819202122* a. 使用的前提类有空参的公共构造方法。（如果是同包，默认权限也可以）* b. 使用的基础Class类的 public T newInstance() 方法 创建此 Class 对象所表示的类的一个新实例。* c. 通过反射获取有参构造方法并使用快捷方式的代码演示：* package cn.itcast.demo1;/* * 反射获取构造方法并运行,有快捷点的方式 * 有前提: * 被反射的类,必须具有空参数构造方法 * 构造方法权限必须public */public class ReflectDemo3 &#123; public static void main(String[] args) throws Exception &#123; Class c = Class.forName("cn.itcast.demo1.Person"); // Class类中定义方法, T newInstance() 直接创建被反射类的对象实例 Object obj = c.newInstance(); System.out.println(obj); &#125;&#125; * F. 通过反射获取私有构造方法并使用123456789101112131415161718192021222324252627282930313233343536373839404142* a. 得到私有的构造方法public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取指定参数类型所对应的构造方法(包含私有的)。public Constructor&lt;?&gt;[] getDeclaredConstructors() 获取所有的构造方法(包含私有的)。* b. 运行私有构造方法public void setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值。 设置为true,这个方法保证我们得到的私有构造方法的运行。（取消运行时期的权限检查。）public T newInstance(Object... initargs) 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 * c. 通过反射获取私有构造方法并使用的代码演示：package cn.itcast.demo1;import java.lang.reflect.Constructor;/* * 反射获取私有的构造方法运行 * 不推荐,破坏了程序的封装性,安全性 * 暴力反射 */public class ReflectDemo4 &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("cn.itcast.demo1.Person"); //Constructor[] getDeclaredConstructors()获取所有的构造方法,包括私有的 /*Constructor[] cons = c.getDeclaredConstructors(); for(Constructor con : cons)&#123; System.out.println(con); &#125;*/ //Constructor getDeclaredConstructor(Class...c)获取到指定参数列表的构造方法 Constructor con = c.getDeclaredConstructor(int.class,String.class); //Constructor类,父类AccessibleObject,定义方法setAccessible(boolean b) con.setAccessible(true); Object obj = con.newInstance(18,"lisi"); System.out.println(obj); &#125;&#125;* 注：不推荐，破坏了程序的封装性,安全性。 * G. 反射获取成员变量并改值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* a. 获取成员变量* 得到公共的成员变量 public Field getField(String name) 返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 public Field[] getFields() 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 * 得到所有的成员变量(包括私有的，如果要进行修改私有成员变量，要先进行public void setAccessible(boolean flag) 设置。) public Field getDeclaredField(String name) 返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 public Field[] getDeclaredFields() 返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 * b. 修改成员变量(Field)的值* 修改公共的成员变量 public void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 obj指的是修改的是那个对象的这个成员变量值。* c. 反射获取成员变量并改值的代码演示package cn.itcast.demo1;import java.lang.reflect.Field;/* * 反射获取成员变量,并修改值 * Person类中的成员String name */public class ReflectDemo5 &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("cn.itcast.demo1.Person"); Object obj = c.newInstance(); //获取成员变量 Class类的方法 getFields() class文件中的所有公共的成员变量 //返回值是Field[] Field类描述成员变量对象的类 /*Field[] fields = c.getFields(); for(Field f : fields)&#123; System.out.println(f); &#125;*/ //获取指定的成员变量 String name //Class类的方法 Field getField(传递字符串类型的变量名) 获取指定的成员变量 Field field = c.getField("name"); //Field类的方法 void set(Object obj, Object value) ,修改成员变量的值 //Object obj 必须有对象的支持, Object value 修改后的值 field.set(obj,"王五"); System.out.println(obj); &#125;&#125; * H. 反射获取空参数成员方法并运行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* a. 获取空参数成员方法* 得到公共的成员方法 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 public Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。* 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行* * public void setAccessible(boolean flag) 设置。) public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 public Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 * b. 使用Method方法对象public Object invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 obj 指的是调这个方法的对象。 args 指的是调用这个方法所要用到的参数列表。 返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.* c. 反射获取空参数成员方法并运行代码演示package cn.itcast.demo1;import java.lang.reflect.Method;/* * 反射获取成员方法并运行 * public void eat()&#123;&#125; */public class ReflectDemo6 &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("cn.itcast.demo1.Person"); Object obj = c.newInstance(); //获取class对象中的成员方法 // Method[] getMethods()获取的是class文件中的所有公共成员方法,包括继承的 // Method类是描述成员方法的对象 /*Method[] methods = c.getMethods(); for(Method m : methods)&#123; System.out.println(m); &#125;*/ //获取指定的方法eat运行 // Method getMethod(String methodName,Class...c) // methodName获取的方法名 c 方法的参数列表 Method method = c.getMethod("eat"); //使用Method类中的方法,运行获取到的方法eat //Object invoke(Object obj, Object...o) method.invoke(obj); &#125;&#125; * I. 反射获取有参数成员方法并运行1234567891011121314151617181920212223242526272829303132333435* a. 获取有参数成员方法* 得到公共的成员方法 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 public Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。* 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。) public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 public Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 * b. 使用Method方法对象public Object invoke(Object obj, Object... args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 obj 指的是调这个方法的对象。 args 指的是调用这个方法所要用到的参数列表。 返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.* c. 反射获取有参数成员方法并运行代码演示package cn.itcast.demo1;import java.lang.reflect.Method;/* * 反射获取有参数的成员方法并执行 * public void sleep(String,int,double)&#123;&#125; */public class ReflectDemo7 &#123; public static void main(String[] args) throws Exception&#123; Class c = Class.forName("cn.itcast.demo1.Person"); Object obj = c.newInstance(); //调用Class类的方法getMethod获取指定的方法sleep Method method = c.getMethod("sleep", String.class,int.class,double.class); //调用Method类的方法invoke运行sleep方法 method.invoke(obj, "休眠",100,888.99); &#125;&#125; * J. 反射泛型擦除1234567891011121314151617181920212223242526272829303132333435363738* a. 使用情况例如：在泛型为String的集合里，添加Integer的数据ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(100);* b. 能用泛型擦除的理论伪泛型：在编译后的.class文件里面是没有泛型的。类型为Object。用反射的方法绕过编译，得到Class文件对象，直接调用add方法。* c. 反射泛型擦除的代码演示package cn.itcast.demo2;import java.lang.reflect.Method;import java.util.ArrayList;/* * 定义集合类,泛型String * 要求向集合中添加Integer类型 * * 反射方式,获取出集合ArrayList类的class文件对象 * 通过class文件对象,调用add方法 * * 对反射调用方法是否理解 */public class ReflectTest &#123; public static void main(String[] args)throws Exception &#123; ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add("a"); //反射方式,获取出集合ArrayList类的class文件对象 Class c = array.getClass(); //获取ArrayList.class文件中的方法add Method method = c.getMethod("add",Object.class); //使用invoke运行ArrayList方法add method.invoke(array, 150); method.invoke(array, 1500); method.invoke(array, 15000); System.out.println(array); &#125;&#125; * K. 反射通过配置文件来决定运行的步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* a. 操作依据 通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法* b. 实现步骤: * 1. 准备配置文件,键值对 * 2. IO流读取配置文件 Reader * 3. 文件中的键值对存储到集合中 Properties * 集合保存的键值对,就是类名和方法名 * 4. 反射获取指定类的class文件对象 * 5. class文件对象,获取指定的方法 * 6. 运行方法* c. 代码演示代码：package cn.itcast.demo3;import java.io.FileReader;import java.lang.reflect.Method;import java.util.Properties;/* * 调用Person方法,调用Student方法,调用Worker方法 * 类不清楚,方法也不清楚 * 通过配置文件实现此功能 * 运行的类名和方法名字,以键值对的形式,写在文本中 * 运行哪个类,读取配置文件即可 * 实现步骤: * 1. 准备配置文件,键值对 * 2. IO流读取配置文件 Reader * 3. 文件中的键值对存储到集合中 Properties * 集合保存的键值对,就是类名和方法名 * 4. 反射获取指定类的class文件对象 * 5. class文件对象,获取指定的方法 * 6. 运行方法 */public class Test &#123; public static void main(String[] args) throws Exception&#123; //IO流读取配置文件 FileReader r = new FileReader("config.properties"); //创建集合对象 Properties pro = new Properties(); //调用集合方法load,传递流对象 pro.load(r); r.close(); //通过键获取值 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); //反射获取指定类的class文件对象 Class c = Class.forName(className); Object obj = c.newInstance(); //获取指定的方法名 Method method = c.getMethod(methodName); method.invoke(obj); &#125;&#125;配置文件：#className=cn.itcast.demo3.Student#methodName=studyclassName=cn.itcast.demo3.PersonmethodName=eat#className=cn.itcast.demo3.Worker#methodName=job 总结 把今天的知识点总结一遍。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础30(网络编程)]]></title>
    <url>%2F2016%2F12%2F01%2Fday32%E7%AC%94%E8%AE%B0%20%2F</url>
    <content type="text"><![CDATA[1、网络三要素及传输协议2、实现UDP协议的发送端和接收端3、实现TCP协议的客户端和服务器4、TCP上传文件案例 01网络模型*A:网络模型 TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。 应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 02IP地址*A:IP地址 在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机， 目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。 由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式， 每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100” 127.0.0.1 为本地主机地址(本地回环地址) 03端口号*A:端口号通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，不同的应用程序是通过端口号区分的。端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535，其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用 04InetAddress类12345678910111213141516171819202122232425262728293031323334353637383940414243444546*A:InetAddress类 /* * 表示互联网中的IP地址 * java.net.InetAddress * 静态方法 * static InetAddress getLocalHost() LocalHost本地主机 * 返回本地主机,返回值InetAddress对象 * * static InetAddress getByName(String hostName)传递主机名,获取IP地址对象 * * 非静态方法 * String getHoustAddress()获取主机IP地址 * String getHoustName()获取主机名 * */ public class InetAddressDemo &#123; public static void main(String[] args)throws UnknownHostException &#123; function_1(); &#125; /* * static InetAddress getByName(String hostName)传递主机名,获取IP地址对象 */ public static void function_1()throws UnknownHostException &#123; InetAddress inet = InetAddress.getByName("www.baidu.com"); System.out.println(inet); &#125; /* * static InetAddress getLocalHost() LocalHost本地主机 */ public static void function() throws UnknownHostException&#123; InetAddress inet = InetAddress.getLocalHost(); //输出结果就是主机名,和 IP地址 System.out.println(inet.toString()); String ip = inet.getHostAddress(); String name = inet.getHostName(); System.out.println(ip+" "+name); /*String host = inet.toString(); String[] str = host.split("/"); for(String s : str)&#123; System.out.println(s); &#125;*/ &#125; &#125; 05UDP协议A:UDP协议 a:UDP协议概述: UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。 简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 b:UDP协议特点: 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议， 因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 06TCP协议*A:TCP协议TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端， 由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 07数据包和发送对象介绍*A:数据包和发送对象介绍:DatagramPacket数据包的作用就如同是“集装箱”， 可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。 在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。 DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包DatagramPacket:封装数据DatagramSocket:发送DatagramPacket 08UDP发送端1234567891011121314151617181920212223242526272829303132333435*A:UDP发送端 /* * 实现UDP协议的发送端: * 实现封装数据的类 java.net.DatagramPacket 将你的数据包装 * 实现数据传输的类 java.net.DatagramSocket 将数据包发出去 * * 实现步骤: * 1. 创建DatagramPacket对象,封装数据, 接收的地址和端口 * 2. 创建DatagramSocket * 3. 调用DatagramSocket类方法send,发送数据包 * 4. 关闭资源 * * DatagramPacket构造方法: * DatagramPacket(byte[] buf, int length, InetAddress address, int port) * * DatagramSocket构造方法: * DatagramSocket()空参数 * 方法: send(DatagramPacket d) * */ public class UDPSend &#123; public static void main(String[] args) throws IOException&#123; //创建数据包对象,封装要发送的数据,接收端IP,端口 byte[] date = "你好UDP".getBytes(); //创建InetAddress对象,封装自己的IP地址 InetAddress inet = InetAddress.getByName("127.0.0.1"); DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000); //创建DatagramSocket对象,数据包的发送和接收对象 DatagramSocket ds = new DatagramSocket(); //调用ds对象的方法send,发送数据包 ds.send(dp); //关闭资源 ds.close(); &#125; &#125; 09UDP接收端12345678910111213141516171819202122232425262728293031323334353637*A:UDP接收端 /* * 实现UDP接收端 * 实现封装数据包 java.net.DatagramPacket 将数据接收 * 实现输出传输 java.net.DatagramSocket 接收数据包 * * 实现步骤: * 1. 创建DatagramSocket对象,绑定端口号 * 要和发送端端口号一致 * 2. 创建字节数组,接收发来的数据 * 3. 创建数据包对象DatagramPacket * 4. 调用DatagramSocket对象方法 * receive(DatagramPacket dp)接收数据,数据放在数据包中 * 5. 拆包 * 发送的IP地址 * 数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象 * 返回值是InetAddress对象 * 接收到的字节个数 * 数据包对象DatagramPacket方法 getLength() * 发送方的端口号 * 数据包对象DatagramPacket方法 getPort()发送端口 * 6. 关闭资源 */ public class UDPReceive &#123; public static void main(String[] args)throws IOException &#123; //创建数据包传输对象DatagramSocket 绑定端口号 DatagramSocket ds = new DatagramSocket(6000); //创建字节数组 byte[] data = new byte[1024]; //创建数据包对象,传递字节数组 DatagramPacket dp = new DatagramPacket(data, data.length); //调用ds对象的方法receive传递数据包 ds.receive(dp); &#125; &#125; 10UDP接收端的拆包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647*A:UDP接收端的拆包 /* * 实现UDP接收端 * 实现封装数据包 java.net.DatagramPacket 将数据接收 * 实现输出传输 java.net.DatagramSocket 接收数据包 * * 实现步骤: * 1. 创建DatagramSocket对象,绑定端口号 * 要和发送端端口号一致 * 2. 创建字节数组,接收发来的数据 * 3. 创建数据包对象DatagramPacket * 4. 调用DatagramSocket对象方法 * receive(DatagramPacket dp)接收数据,数据放在数据包中 * 5. 拆包 * 发送的IP地址 * 数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象 * 返回值是InetAddress对象 * 接收到的字节个数 * 数据包对象DatagramPacket方法 getLength() * 发送方的端口号 * 数据包对象DatagramPacket方法 getPort()发送端口 * 6. 关闭资源 */ public class UDPReceive &#123; public static void main(String[] args)throws IOException &#123; //创建数据包传输对象DatagramSocket 绑定端口号 DatagramSocket ds = new DatagramSocket(6000); //创建字节数组 byte[] data = new byte[1024]; //创建数据包对象,传递字节数组 DatagramPacket dp = new DatagramPacket(data, data.length); //调用ds对象的方法receive传递数据包 ds.receive(dp); //获取发送端的IP地址对象 String ip=dp.getAddress().getHostAddress(); //获取发送的端口号 int port = dp.getPort(); //获取接收到的字节个数 int length = dp.getLength(); System.out.println(new String(data,0,length)+"..."+ip+":"+port); ds.close(); &#125; &#125; 11键盘输入的聊天12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455*A:键盘输入的聊天 *a:发送端: /* * 实现UDP发送,键盘输入的形式 * 输入完毕,发送给接收端 */ public class UDPSend &#123; public static void main(String[] args) throws IOException&#123; Scanner sc = new Scanner(System.in); DatagramSocket ds = new DatagramSocket(); InetAddress inet = InetAddress.getByName("127.0.0.1"); while(true)&#123; String message = sc.nextLine(); /*if("886".equals(message))&#123; break; &#125;*/ byte[] date = message.getBytes(); DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000); ds.send(dp); &#125; // ds.close(); &#125; &#125; /* * 实现UDP接收端 * 永不停歇的接收端 */ public class UDPReceive &#123; public static void main(String[] args)throws IOException &#123; //创建数据包传输对象DatagramSocket 绑定端口号 DatagramSocket ds = new DatagramSocket(6000); //创建字节数组 byte[] data = new byte[1024]; //创建数据包对象,传递字节数组 while(true)&#123; DatagramPacket dp = new DatagramPacket(data, data.length); //调用ds对象的方法receive传递数据包 ds.receive(dp); //获取发送端的IP地址对象 String ip=dp.getAddress().getHostAddress(); //获取发送的端口号 int port = dp.getPort(); //获取接收到的字节个数 int length = dp.getLength(); System.out.println(new String(data,0,length)+"..."+ip+":"+port); &#125; //ds.close(); &#125; &#125; 12TCP的客户端和服务器*A:TCP的客户端和服务器TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。 13TCP的客户端程序12345678910111213141516171819202122232425262728293031*A:TCP的客户端程序 /* * 实现TCP客户端,连接到服务器 * 和服务器实现数据交换 * 实现TCP客户端程序的类 java.net.Socket * * 构造方法: * Socket(String host, int port) 传递服务器IP和端口号 * 注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常 * * OutputStream getOutputStream() 返回套接字的输出流 * 作用: 将数据输出,输出到服务器 * * InputStream getInputStream() 返回套接字的输入流 * 作用: 从服务器端读取数据 * * 客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行 */ public class TCPClient &#123; public static void main(String[] args)throws IOException &#123; //创建Socket对象,连接服务器 Socket socket = new Socket("127.0.0.1", 8888); //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器 OutputStream out = socket.getOutputStream(); out.write("服务器OK".getBytes()); socket.close(); &#125; &#125; 14TCP的服务器程序accept方法1234567891011121314151617181920212223242526A:TCP的服务器程序accept方法 /* * 实现TCP服务器程序 * 表示服务器程序的类 java.net.ServerSocket * 构造方法: * ServerSocket(int port) 传递端口号 * * 很重要的事情: 必须要获得客户端的套接字对象Socket * Socket accept() */ public class TCPServer &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server = new ServerSocket(8888); //调用服务器套接字对象中的方法accept() 获取客户端套接字对象 Socket socket = server.accept(); //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据 InputStream in = socket.getInputStream(); byte[] data = new byte[1024]; int len = in.read(data); System.out.println(new String(data,0,len)); socket.close(); server.close(); &#125; &#125; 15TCP的服务器程序读取客户端数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051A:TCP的服务器程序读取客户端数据 /* * 实现TCP客户端,连接到服务器 * 和服务器实现数据交换 * 实现TCP客户端程序的类 java.net.Socket * * 构造方法: * Socket(String host, int port) 传递服务器IP和端口号 * 注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常 * * OutputStream getOutputStream() 返回套接字的输出流 * 作用: 将数据输出,输出到服务器 * * InputStream getInputStream() 返回套接字的输入流 * 作用: 从服务器端读取数据 * * 客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行 */ public class TCPClient &#123; public static void main(String[] args)throws IOException &#123; //创建Socket对象,连接服务器 Socket socket = new Socket("127.0.0.1", 8888); //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器 OutputStream out = socket.getOutputStream(); out.write("服务器OK".getBytes()); socket.close(); &#125; &#125; /* * 实现TCP服务器程序 * 表示服务器程序的类 java.net.ServerSocket * 构造方法: * ServerSocket(int port) 传递端口号 * * 很重要的事情: 必须要获得客户端的套接字对象Socket * Socket accept() */ public class TCPServer &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server = new ServerSocket(8888); //调用服务器套接字对象中的方法accept() 获取客户端套接字对象 Socket socket = server.accept(); //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据 InputStream in = socket.getInputStream(); byte[] data = new byte[1024]; int len = in.read(data); System.out.println(new String(data,0,len)); &#125; &#125; 16TCP的服务器和客户端的数据交换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A:TCP的服务器和客户端的数据交换 /* * 实现TCP客户端,连接到服务器 * 和服务器实现数据交换 * 实现TCP客户端程序的类 java.net.Socket * * 构造方法: * Socket(String host, int port) 传递服务器IP和端口号 * 注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常 * * OutputStream getOutputStream() 返回套接字的输出流 * 作用: 将数据输出,输出到服务器 * * InputStream getInputStream() 返回套接字的输入流 * 作用: 从服务器端读取数据 * * 客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行 */ public class TCPClient &#123; public static void main(String[] args)throws IOException &#123; //创建Socket对象,连接服务器 Socket socket = new Socket("127.0.0.1", 8888); //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器 OutputStream out = socket.getOutputStream(); out.write("服务器OK".getBytes()); //读取服务器发回的数据,使用socket套接字对象中的字节输入流 InputStream in = socket.getInputStream(); byte[] data = new byte[1024]; int len = in.read(data); System.out.println(new String(data,0,len)); socket.close(); &#125; &#125; /* * 实现TCP服务器程序 * 表示服务器程序的类 java.net.ServerSocket * 构造方法: * ServerSocket(int port) 传递端口号 * * 很重要的事情: 必须要获得客户端的套接字对象Socket * Socket accept() */ public class TCPServer &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server = new ServerSocket(8888); //调用服务器套接字对象中的方法accept() 获取客户端套接字对象 Socket socket = server.accept(); //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据 InputStream in = socket.getInputStream(); byte[] data = new byte[1024]; int len = in.read(data); System.out.println(new String(data,0,len)); //服务器向客户端回数据,字节输出流,通过客户端套接字对象获取字节输出流 OutputStream out = socket.getOutputStream(); out.write("收到,谢谢".getBytes()); socket.close(); server.close(); &#125; &#125; 17TCP的中的流对象*A:TCP的中的流对象 18TCP图片上传案例分析*A:图片上传案例分析 19TCP上传客户端12345678910111213141516171819202122232425262728293031323334353637383940*A TCP上传客户端 /* * 实现TCP图片上传客户端 * 实现步骤: * 1. Socket套接字连接服务器 * 2. 通过Socket获取字节输出流,写图片 * 3. 使用自己的流对象,读取图片数据源 * FileInputStream * 4. 读取图片,使用字节输出流,将图片写到服务器 * 采用字节数组进行缓冲 * 5. 通过Socket套接字获取字节输入流 * 读取服务器发回来的上传成功 * 6. 关闭资源 */ public class TCPClient &#123; public static void main(String[] args) throws IOException&#123; Socket socket = new Socket("127.0.0.1", 8000); //获取字节输出流,图片写到服务器 OutputStream out = socket.getOutputStream(); //创建字节输入流,读取本机上的数据源图片 FileInputStream fis = new FileInputStream("c:\\t.jpg"); //开始读写字节数组 int len = 0 ; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; out.write(bytes, 0, len); &#125; //给服务器写终止序列 //socket.shutdownOutput(); //获取字节输入流,读取服务器的上传成功 InputStream in = socket.getInputStream(); len = in.read(bytes); System.out.println(new String(bytes,0,len)); fis.close(); socket.close(); &#125; &#125; 20TCP上传服务器123456789101112131415161718192021222324252627282930313233343536373839404142A:TCP上传服务器 /* * TCP图片上传服务器 * 1. ServerSocket套接字对象,监听端口8000 * 2. 方法accept()获取客户端的连接对象 * 3. 客户端连接对象获取字节输入流,读取客户端发送图片 * 4. 创建File对象,绑定上传文件夹 * 判断文件夹存在, 不存,在创建文件夹 * 5. 创建字节输出流,数据目的File对象所在文件夹 * 6. 字节流读取图片,字节流将图片写入到目的文件夹中 * 7. 将上传成功会写客户端 * 8. 关闭资源 * */ public class TCPServer &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); //通过客户端连接对象,获取字节输入流,读取客户端图片 InputStream in = socket.getInputStream(); //将目的文件夹封装到File对象 File upload = new File("d:\\upload"); if(!upload.exists()) upload.mkdirs(); //创建字节输出流,将图片写入到目的文件夹中 FileOutputStream fos = new FileOutputStream(upload+"t.jpg"); //读写字节数组 byte[] bytes = new byte[1024]; int len = 0 ; while((len = in.read(bytes))!=-1)&#123; fos.write(bytes, 0, len); &#125; //通过客户端连接对象获取字节输出流 //上传成功写回客户端 socket.getOutputStream().write("上传成功".getBytes()); fos.close(); socket.close(); server.close(); &#125; &#125; 21TCP图片上传问题解决123456789101112131415161718192021222324252627282930313233343536373839/* * 实现TCP图片上传客户端 * 实现步骤: * 1. Socket套接字连接服务器 * 2. 通过Socket获取字节输出流,写图片 * 3. 使用自己的流对象,读取图片数据源 * FileInputStream * 4. 读取图片,使用字节输出流,将图片写到服务器 * 采用字节数组进行缓冲 * 5. 通过Socket套接字获取字节输入流 * 读取服务器发回来的上传成功 * 6. 关闭资源 */public class TCPClient &#123; public static void main(String[] args) throws IOException&#123; Socket socket = new Socket("127.0.0.1", 8000); //获取字节输出流,图片写到服务器 OutputStream out = socket.getOutputStream(); //创建字节输入流,读取本机上的数据源图片 FileInputStream fis = new FileInputStream("c:\\t.jpg"); //开始读写字节数组 int len = 0 ; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; out.write(bytes, 0, len); &#125; //给服务器写终止序列 socket.shutdownOutput();//想服务端写入一个结束标志 //获取字节输入流,读取服务器的上传成功 InputStream in = socket.getInputStream(); len = in.read(bytes); System.out.println(new String(bytes,0,len)); fis.close(); socket.close(); &#125;&#125; TCP上传文件名123456789101112131415161718192021222324252627282930313233343536373839404142434445*A:TCP上传文件名 /* * TCP图片上传服务器 * 1. ServerSocket套接字对象,监听端口8000 * 2. 方法accept()获取客户端的连接对象 * 3. 客户端连接对象获取字节输入流,读取客户端发送图片 * 4. 创建File对象,绑定上传文件夹 * 判断文件夹存在, 不存,在创建文件夹 * 5. 创建字节输出流,数据目的File对象所在文件夹 * 6. 字节流读取图片,字节流将图片写入到目的文件夹中 * 7. 将上传成功会写客户端 * 8. 关闭资源 * */ public class TCPServer &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); //通过客户端连接对象,获取字节输入流,读取客户端图片 InputStream in = socket.getInputStream(); //将目的文件夹封装到File对象 File upload = new File("d:\\upload"); if(!upload.exists()) upload.mkdirs(); //防止文件同名被覆盖,从新定义文件名字 //规则: 域名+毫秒值+6位随机数 String filename="itcast"+System.currentTimeMillis()+new Random().nextInt(999999)+".jpg"; //创建字节输出流,将图片写入到目的文件夹中 FileOutputStream fos = new FileOutputStream(upload+File.separator+filename); //读写字节数组 byte[] bytes = new byte[1024]; int len = 0 ; while((len = in.read(bytes))!=-1)&#123; fos.write(bytes, 0, len); &#125; //通过客户端连接对象获取字节输出流 //上传成功写回客户端 socket.getOutputStream().write("上传成功".getBytes()); fos.close(); socket.close(); server.close(); &#125; &#125; 多线程上传案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*A:多线程上传案例 public class TCPThreadServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); while (true) &#123; // 获取到一个客户端,必须开启新线程,为这个客户端服务 Socket socket = server.accept(); new Thread(new Upload(socket)).start(); &#125; &#125; &#125; public class Upload implements Runnable &#123; private Socket socket; public Upload(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; try &#123; // 通过客户端连接对象,获取字节输入流,读取客户端图片 InputStream in = socket.getInputStream(); // 将目的文件夹封装到File对象 File upload = new File("d:\\upload"); if (!upload.exists()) upload.mkdirs(); // 防止文件同名被覆盖,从新定义文件名字 // 规则: 域名+毫秒值+6位随机数 String filename = "itcast" + System.currentTimeMillis() + new Random().nextInt(999999) + ".jpg"; // 创建字节输出流,将图片写入到目的文件夹中 FileOutputStream fos = new FileOutputStream(upload + File.separator + filename); // 读写字节数组 byte[] bytes = new byte[1024]; int len = 0; while ((len = in.read(bytes)) != -1) &#123; fos.write(bytes, 0, len); &#125; // 通过客户端连接对象获取字节输出流 // 上传成功写回客户端 socket.getOutputStream().write("上传成功".getBytes()); fos.close(); socket.close(); &#125; catch (Exception ex) &#123; &#125; &#125; &#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础29(数据库表项目基础练习)]]></title>
    <url>%2F2016%2F11%2F30%2Fday31%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、管家婆家庭记账项目2、熟练View层、Service层、Dao层之间的方法相互调用操作3、熟练dbutils操作数据库表完成增删改查 01项目训练目标 A: 项目训练目标 a: 项目目标 综合运用前面所学习的知识点 熟练View层、Service层、Dao层之间的方法相互调用操作、 熟练dbutils操作数据库表完成增删改查 了解公司项目开发的流程，充分的掌握项目需求分析、设计与功能的代码实现。提高同学们独立分析需求与功能实现的能力。 02项目中的功能模块 A: 项目中的功能模块 a: 五大模块 查询账务 多条件组合查询账务 添加账务 编辑账务 删除账务03技术的选择和相关jar包 A: 技术的选择和相关jar包 a: apache的commons组件：….. commons-dbutils-1.4.jar：封装并简化了JDBC；….. commons-dbcp-1.4.jar：apache commons提供的数据库连接池组件，命名为DBCP； b:….. commons.pool-1.3.jar：DBCP连接池依赖该jar包；….. mysql-connector-java-5.1.28-bin.jar：MySQL的JDBC驱动包，用JDBC连接MySQL数据库必须使用该JAR包。 04项目中的工具类 A: 项目中的工具类 a: 工具类的介绍 每个项目中都会有很多个工具类，不要求每个工具类对能独立写出来，但是要会使用工具类 JDBCUtils：用来创建数据库连接池对象 123456789101112131415161718192021222324252627282930public class JDBCUtils &#123; private static BasicDataSource datasource =new BasicDataSource(); static &#123; //1.注册驱动, 将驱动类加入到内容 String drivername="com.mysql.jdbc.Driver"; //2.获得数据库连接 DriverManager类中静态方法 //static Connection getConnection(String url, String user, String password) //返回值是Connection接口的实现类,在mysql驱动程序 //url: 数据库地址 jdbc:mysql://连接主机IP:端口号/数据库名字 String url="jdbc:mysql://localhost:3306/qjunbase"; String username = "root"; String password = "root"; datasource.setDriverClassName(drivername); datasource.setUrl(url); datasource.setUsername(username); datasource.setPassword(password); //对象连接池中的连接数量配置,可选的 datasource.setInitialSize(10); datasource.setMaxActive(8); datasource.setMaxIdle(5); datasource.setMinIdle(1); &#125; public static DataSource getDataSource()&#123; return datasource; &#125;&#125; 05数据表的设计 A: 数据表的设计 a: 数据表的设计 表与表之间是有关系的 主表和从表的关系 主表中的主键作为从表中的外键 06创建数据库数据表写入测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* A: 创建数据库数据表写入测试数据* a: 创建数据库数据表/*创建管家婆的数据库名字 gjp*/CREATE DATABASE gjp;USE gjp;/*创建数据表,表名账务字段,列主键分类名称 可变字符金额 double账户 可变字符 (支付,收入方法)创建日期 date账务描述 可变字符*/CREATE TABLE gjp_zhangwu(-- 主键zwid INT PRIMARY KEY AUTO_INCREMENT,-- 分类名称 flname VARCHAR(200),-- 金额money DOUBLE,-- 账户zhanghu VARCHAR(100),-- 创建日期createtime DATE,-- 账务描述description VARCHAR(1000));SELECT * FROM gjp_zhangwu;* b: 写入数据-- 写入测试的数据INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (1,'吃饭支出',247,'交通银行','2016-03-02','家庭聚餐');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (2,'工资收入',12345,'现金','2016-03-15','开工资了');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (3,'服装支出',1998,'现金','2016-04-02','买衣服');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (4,'吃饭支出',325,'现金','2016-06-18','朋友聚餐');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (5,'股票收入',8000,'工商银行','2016-10-28','股票大涨');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (6,'股票收入',5000,'工商银行','2016-10-28','股票又大涨');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (7,'工资收入',5000,'交通银行','2016-10-28','又开工资了');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (8,'礼金支出',5000,'现金','2016-10-28','朋友结婚');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (9,'其他支出',1560,'现金','2016-10-29','丢钱了');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (10,'交通支出',2300,'交通银行','2016-10-29','油价还在涨啊');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (11,'吃饭支出',1000,'工商银行','2016-10-29','又吃饭');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (12,'工资收入',1000,'现金','2016-10-30','开资');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (13,'交通支出',2000,'现金','2016-10-30','机票好贵');INSERT INTO gjp_zhangwu(zwid,flname,money,zhangHu,createtime,description) VALUES (14,'工资收入',5000,'现金','2016-10-30','又开资'); 07项目中的分层设计 A: 项目中的分层设计 a: 各层功能介绍….. view层作用: 视图层,即项目中的界面….. controller层作用: 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理….. service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理….. dao层作用: 数据访问层, 用来操作数据库表的数据 ……. database数据库: 这里指MySQL……. domain 实体包: 存放JavaBean……. tools工具包:存放项目中使用到的工具类……. test 测试包: 存放项目功能测试的代码 08创建项目_分层_导入jar包12345678910111213141516* A: 创建项目_分层_导入jar包* a: 创建工程包* cn.itcast.gjp.app: 存放main方法类；* cn.itcast.gjp.domain: 存放JavaBean；* cn.itcast.gjp.view: 存放界面，及表现层类；* cn.itcast.gjp.service: 存放业务层类；* cn.itcast.gjp.dao: 存放数据访问层类;* cn.itcast.gjp.tools:存放工具类* b: 导入jar包* 在项目根路径下建立文件夹lib* 导入以下jar包* mysql-connector-java-5.1.37-bin.jar：数据库驱动* commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作* commons-dbcp-1.4.jar：* commons-pool-1.5.6.jar：提供高效的数据库连接池技术 * 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path 首先，完成本项目中类的创建: 复制已编写好的工具类JDBCUtils.java 到 tools包中； 复制jar包mysql-connector-java-5.1.28-bin.jar、commons-dbutils-1.4.jar、commons-dbcp-1.4.jar、commons-pool-1.3.jar，到lib文件夹中，通过Build Path操作，添加到classPath路径中，提供给JDBCUtils使用; 在app包中，创建类MainApp.java，编写main主方法，用来完成本项目的启动 在domain包中，创建类ZhangWu.java，它是用来封装账务信息的JavaBean。 在dao包中，创建类ZhangWuDao.java，给ZhangWuDao类添加一个成员变量QueryRunner对象，因为我们使用dbutils来操作数据库。 在service包中，创建类ZhangWuService.java，给ZhangWuService类添加一个类型为ZhangWuDao的成员变量，因为service依赖dao。 在view包中，创建类MainView.java，给MainView类添加一个类型为ZhangWuService的成员变量，因为本项目中view依赖service。 09创建domain包中的类12345678910111213141516* A: 创建domain包中的类* a: 案例代码public class ZhangWu &#123; private int zwid; private String flname; private double money; private String zhanghu; private String createtime; private String description; //注意生成空参构造、有参构造、set和get方法、toString方法等&#125; 10创建JDBCUtils工具类1234567891011121314151617181920* A：创建JDBCUtils工具类* a: 案例代码public class JDBCUtils&#123;//创建BasicDataSource对象private static BasicDataSource datasource = new BasicDataSource();//静态代码块,实现必要参数设置static&#123; datasource.setDriverClassName("com.mysql.jdbc.Driver"); datasource.setUrl("jdbc:mysql://localhost:3306/gjp"); datasource.setUsername("root"); datasource.setPassword("123"); datasource.setMaxActive(10); datasource.setMaxIdle(5); datasource.setMinIdle(2); datasource.setInitialSize(10);&#125;public static DataSource getDataSource()&#123; return datasource;&#125;&#125; 11创建其他包中的类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* A: 创建其他包中的类* a: cn.itcast.gjp.dao包中"创建ZhangWuDao类""/** 实现对数据表 gjp_zhangwu 数据增删改查操作* dbuils工具类完成,类成员创建QueryRunner对象,指定数据源*/"public class ZhangWuDao &#123;private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());&#125;——————————————————————————————————————————————————————————————————————————————————————* b: cn.itcast.gjp.service包中"创建ZhangWuService类""/** 业务层类* 接收上一层,控制层controller的数据* 经过计算,传递给dao层,操作数据库* 调用dao层中的类,类成员位置,创建Dao类的对象*/"public class ZhangWuService &#123;private ZhangWuDao dao = new ZhangWuDao();&#125;——————————————————————————————————————————————————————————————————————————————————————* c: cn.itcast.gjp.controller包中"建立ZhangWuController类""/** 控制器层* 接收视图层的数据,数据传递给service层* 成员位置,创建service对象*/"public class ZhangWuController &#123;private ZhangWuService service = new ZhangWuService(); &#125;——————————————————————————————————————————————————————————————————————————————————————* d: cn.itcast.gjp.view包中"建立MainView类""/** 试图层,用户看到和操作的界面* 数据传递给controller层实现* 成员位置,创建controller对象*/"public class MainView &#123;private ZhangWuController controller = new ZhangWuController();&#125;——————————————————————————————————————————————————————————————————————————————————————* e: cn.itcast.gjp.app包中"建立MainApp类""/** 主程序类,作用,开启软件程序*/"public class MainApp &#123;public static void main(String[] args) &#123; new MainView().run();&#125;&#125; 12实现用户的界面菜单1234567891011121314151617181920212223242526272829303132333435363738* A: 实现用户的界面菜单* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类中添加run方法/** 实现界面效果* 接收用户的输入* 根据数据,调用不同的功能方法*/public void run()&#123;//创建Scanner类对象,反复键盘输入Scanner sc = new Scanner(System.in);while(true)&#123; System.out.println("---------------管家婆家庭记账软件---------------"); System.out.println("1.添加账务 2.编辑账务 3.删除账务 4.查询账务 5.退出系统"); System.out.println("请输入要操作的功能序号[1-5]:"); //接收用户的菜单选择 int choose = sc.nextInt(); //对选择的菜单判断,调用不同的功能 switch(choose)&#123; case 1: // 选择添加账务,调用添加账务的方法 break; case 2: // 选择的编辑账务,调用编辑账务方法 break; case 3: // 选择的删除账务,调用删除账务方法 break; case 4: // 选择的是查询账务,调用查询方法 //selectZhangWu(); break; case 5: System.exit(0); break; &#125;&#125;&#125; 13实现查询的界面菜单1234567891011121314151617181920212223242526272829303132333435363738394041* A: 实现查询的界面菜单* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类中添加selectZhangWu方法、selectAll方法、select方法/* * 定义方法 selectZhangWu() * 显示查询的方式 1 所有查询 2 条件查询 * 接收用户的选择 */ public void selectZhangWu()&#123; System.out.println("1. 查询所有 2. 条件查询"); Scanner sc = new Scanner(System.in); int selectChooser = sc.nextInt(); //判断根据用户的选择,调用不同的功能 switch(selectChooser)&#123; case 1: //选择的查询所有,调用查询所有的方法 selectAll(); break; case 2: //选的条件查询,调用带有查询条件的方法 select(); break; &#125; &#125; /* * 定义方法,实现查询所有的账务数据 */ public void selectAll()&#123; &#125; /* * 定义方法,实现条件查询账务数据 * 提供用户的输入日期,开始日期结束日期 * 就2个日期,传递到controller层 * 调用controller的方法,传递2个日期参数 * 获取到controller查询的结果集,打印出来 */ public void select()&#123; &#125; 14实现查询所有账务的控制,业务层的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556* A: 实现查询所有账务的控制,业务层的实现* a: 案例核心代码* a: cn.itcast.gjp.dao包中创建ZhangWuDao类/** 实现对数据表 gjp_zhangwu 数据增删改查操作* dbuils工具类完成,类成员创建QueryRunner对象,指定数据源*/public class ZhangWuDao &#123;private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());/* * 定义方法,查询数据库,获取所有的账务数据 * 方法,由业务层调用 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中 */public List&lt;ZhangWu&gt; selectAll()&#123; return null;&#125;&#125;————————————————————————————————————————————————————————————————————————————————————* b: cn.itcast.gjp.service包中创建ZhangWuService类/* * 业务层类 * 接收上一层,控制层controller的数据 * 经过计算,传递给dao层,操作数据库 * 调用dao层中的类,类成员位置,创建Dao类的对象 */public class ZhangWuService &#123; private ZhangWuDao dao = new ZhangWuDao(); /* * 定义方法,实现查询所有的账务数据 * 此方法,由控制层调用, 去调用dao层的方法 * 返回存储ZhangWu对象的List集合 */ public List&lt;ZhangWu&gt; selectAll()&#123; return dao.selectAll(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————* c: cn.itcast.gjp.controller包中建立ZhangWuController类/* * 控制器层 * 接收视图层的数据,数据传递给service层 * 成员位置,创建service对象 */public class ZhangWuController &#123; private ZhangWuService service = new ZhangWuService(); /* * 控制层类定义方法,实现查询所有的账务数据 * 本方法由视图层调用,本方法调用service层 */ public List&lt;ZhangWu&gt; selectAll()&#123; return service.selectAll(); &#125; &#125; 15实现查询所有账务的dao层的实现123456789101112131415161718192021222324252627* A: 实现查询所有账务的dao层的实现* a: 案例核心代码* a: cn.itcast.gjp.dao包中创建ZhangWuDao类selectAll方法/** 实现对数据表 gjp_zhangwu 数据增删改查操作* dbuils工具类完成,类成员创建QueryRunner对象,指定数据源*/public class ZhangWuDao &#123;private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());/* * 定义方法,查询数据库,获取所有的账务数据 * 方法,由业务层调用 * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中 */public List&lt;ZhangWu&gt; selectAll()&#123; try&#123; //查询账务数据的SQL语句 String sql = "SELECT * FROM gjp_zhangwu"; //调用qr对象的方法,query方法,结果集BeanListHandler List&lt;ZhangWu&gt; list = qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class)); return list; &#125;catch(SQLException ex)&#123; System.out.println(ex); throw new RuntimeException("查询所有账务失败"); &#125;&#125;&#125; 16实现查询所有账务的view层的实现1234567891011121314151617* A: 实现查询所有账务的view层的实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类selectAll方法/** 定义方法,实现查询所有的账务数据*/public void selectAll()&#123; //调用控制层中的方法,查询所有的账务数据 List&lt;ZhangWu&gt; list = controller.selectAll();//输出表头 System.out.println("ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明"); //遍历集合,结果输出控制台 for(ZhangWu zw : list)&#123; System.out.println(zw.getZwid()+"\t\t"+zw.getFlname()+"\t\t"+zw.getZhanghu()+"\t\t"+ zw.getMoney()+"\t\t"+zw.getCreatetime()+"\t"+zw.getDescription()); &#125;&#125; 17实现条件查询账务的菜单实现1234567891011121314151617181920* A: 实现条件查询账务的菜单实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类select方法/** 定义方法,实现条件查询账务数据* 提供用户的输入日期,开始日期结束日期* 就2个日期,传递到controller层* 调用controller的方法,传递2个日期参数* 获取到controller查询的结果集,打印出来*/public void select()&#123; System.out.println("选择条件查询,输入日期格式XXXX-XX-XX"); Scanner sc = new Scanner(System.in); System.out.print("请输入开始日期:"); String startDate = sc.nextLine(); System.out.print("请输入结果日期:"); String endDate = sc.nextLine(); //调用controller层的方法,传递日期,获取查询结果集 &#125; 18实现条件查询账务的控制层,业务层实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859* A: 实现条件查询账务的控制层,业务层实现* a: 案例核心代码* a: cn.itcast.gjp.dao包中创建ZhangWuDao类/* * 实现对数据表 gjp_zhangwu 数据增删改查操作 * dbuils工具类完成,类成员创建QueryRunner对象,指定数据源 */public class ZhangWuDao &#123; private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); /* * 定义方法,查询数据库,带有条件去查询账务表 * 由业务层调用,查询结果集存储到Bean对象,存储到List集合 * 调用者传递2个日期字符串 */ public List&lt;ZhangWu&gt; select(String startDate,String endDate)&#123; return null; &#125;&#125;————————————————————————————————————————————————————————————————————————————————————* b: cn.itcast.gjp.service包中创建ZhangWuService类/* * 业务层类 * 接收上一层,控制层controller的数据 * 经过计算,传递给dao层,操作数据库 * 调用dao层中的类,类成员位置,创建Dao类的对象 */public class ZhangWuService &#123; private ZhangWuDao dao = new ZhangWuDao(); /* * 定义方法,实现条件查询账务 * 方法由控制层调用,传递2个日期字符串 * 调用dao层的方法,传递2个日期字符串 * 获取到查询结果集 */ public List&lt;ZhangWu&gt; select(String startDate,String endDate)&#123; return dao.select(startDate, endDate); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————* c: cn.itcast.gjp.controller包中建立ZhangWuController类/* * 控制器层 * 接收视图层的数据,数据传递给service层 * 成员位置,创建service对象 */public class ZhangWuController &#123; private ZhangWuService service = new ZhangWuService(); /* * 定义方法,实现条件查询账务 * 方法由试图层调用,传递两个日期的字符串 * 调用service层的方法,传递两个日期字符串,获取结果集 * 结果集返回给试图 */ public List&lt;ZhangWu&gt; select(String startDate,String endDate)&#123; return service.select(startDate, endDate); &#125; &#125; 19实现条件查询账务的dao层实现12345678910111213141516171819202122232425262728* A: 实现条件查询账务的dao层实现* a: 案例核心代码* a: cn.itcast.gjp.dao包中创建ZhangWuDao类select方法/* * 实现对数据表 gjp_zhangwu 数据增删改查操作 * dbuils工具类完成,类成员创建QueryRunner对象,指定数据源 */public class ZhangWuDao &#123; private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); /* * 定义方法,查询数据库,带有条件去查询账务表 * 由业务层调用,查询结果集存储到Bean对象,存储到List集合 * 调用者传递2个日期字符串 */ public List&lt;ZhangWu&gt; select(String startDate,String endDate)&#123; try&#123; //拼写条件查询的SQL语句 String sql = "SELECT * FROM gjp_zhangwu WHERE createtime BETWEEN ? AND ?"; //定义对象数组,存储?占位符 Object[] params = &#123;startDate,endDate&#125;; //调用qr对象的方法query查询数据表,获取结果集 return qr.query(sql, new BeanListHandler&lt;&gt;(ZhangWu.class),params); &#125;catch(SQLException ex)&#123; System.out.println(ex); throw new RuntimeException("条件查询失败"); &#125; &#125;&#125; 20实现条件查询账务的view层实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* A: 实现条件查询账务的view层实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类selectAll方法优化、抽取print方法、select方法/** 定义方法,实现查询所有的账务数据*/public void selectAll()&#123; //调用控制层中的方法,查询所有的账务数据 List&lt;ZhangWu&gt; list = controller.selectAll(); if(list.size()!=0) print(list); else System.out.println("没有查询到数据");&#125;/** 定义方法,实现条件查询账务数据* 提供用户的输入日期,开始日期结束日期* 就2个日期,传递到controller层* 调用controller的方法,传递2个日期参数* 获取到controller查询的结果集,打印出来*/public void select()&#123; System.out.println("选择条件查询,输入日期格式XXXX-XX-XX"); Scanner sc = new Scanner(System.in); System.out.print("请输入开始日期:"); String startDate = sc.nextLine(); System.out.print("请输入结果日期:"); String endDate = sc.nextLine(); //调用controller层的方法,传递日期,获取查询结果集 List&lt;ZhangWu&gt; list = controller.select(startDate, endDate); if(list.size()!=0) print(list); else System.out.println("没有查询到数据");&#125;//输出账务数据方法,接收List集合,遍历集合,输出表格private void print(List&lt;ZhangWu&gt; list) &#123; //输出表头 System.out.println("ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明"); //遍历集合,结果输出控制台 for(ZhangWu zw : list)&#123; System.out.println(zw.getZwid()+"\t\t"+zw.getFlname()+"\t\t"+zw.getZhanghu()+"\t\t"+ zw.getMoney()+"\t\t"+zw.getCreatetime()+"\t"+zw.getDescription()); &#125;&#125; 21添加账务功能分析 A: 添加账务功能分析 a: 编写MainView类中addZhangWu方法….. 键盘输入新添加的账务信息….. 调用ZhangWuService类中addZhangWu方法，用来指定账务的添加…..* 添加完毕后，使用输出语句，提示“添加账务成功！” b: 编写ZhangWuService类中addZhangWu方法…..* 调用ZhangWuDao类中addZhangWu方法，用来指定账务的添加 c: 编写ZhangWuDao类中addZhangWu方法…..* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成指定账务添加到数据库表中 22添加账务功能菜单和输入功能实现12345678910111213141516171819202122232425* A: 添加账务功能菜单和输入功能实现 * a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类addZhangWu方法/** 定义方法addZhangWu* 添加账务的方法，用户在界面中选择菜单1的时候调用、* 实现思想：* 接收键盘输入，5项输入，调用controller层方法*/public void addZhangWu() &#123; System.out.println("选择的添加账务功能，请输入以下内容"); Scanner sc = new Scanner(System.in); System.out.println("输入分类名称"); String flname = sc.next(); System.out.println("输入金额"); double money = sc.nextDouble(); System.out.println("输入账户"); String zhanghu = sc.next(); System.out.println("输入日期：格式XXXX-XX-xx"); String createtime = sc.next(); System.out.println("输入具体描述"); String description = sc.next(); //将接收到的数据，调用controller层的方法，传递参数，实现数据添加&#125; 23添加账务功能控制层,业务层实现123456789101112131415161718192021222324252627282930313233* A: 添加账务功能控制层,业务层实现* a: 案例核心代码* cn.itcast.gjp.controller包中的ZhangWuController类addZhangWu方法/* * 定义方法，实现账务添加功能 * 由视图层调用，传递参数(传递过来的参数不能是5个数据，传递的是一个ZhangWu类型的对象) * 本方法调用service层的方法，传递ZhangWu对象，获取到添加后的结果集(添加成功影响的行数，int) * */public void addZhangWu(ZhangWu zw) &#123; service.addZhangWu(zw);&#125;——————————————————————————————————————————————————————————————————————————————————————* cn.itcast.gjp.service包中的ZhangWuService类addZhangWu方法/* * 定义方法，实现添加账务 * 是由控制层调用，传递ZhangWu对象 */public void addZhangWu(ZhangWu zw) &#123; dao.addZhangWu(zw);&#125;——————————————————————————————————————————————————————————————————————————————————————* cn.itcast.gjp.dao包中的ZhangWuDao类addZhangWu方法/* * 定义方法，实现添加账务功能 * 由业务层调用，传递ZhangWu对象 * 将ZhangWu对象中的数据，添加到数据库 */public void addZhangWu(ZhangWu zw) &#123; &#125; 24添加账务功能dao层实现1234567891011121314151617* A: 添加账务功能dao层实现* a: 案例核心代码 * cn.itcast.gjp.dao包中的ZhangWuDao类的addZhangWu方法public void addZhangWu(ZhangWu zw) &#123; try&#123; //拼接添加数据的sql String sql = "INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES(?,?,?,?,?)"; //创建对象数组，处处5个占位符的实际参数 //实际参数来源是传递过来的对象ZhangWu Object[] params = &#123;zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription()&#125;; //调用qr对象中的方法update执行添加 qr.update(sql, params); &#125;catch(SQLException ex) &#123; System.out.println(ex); throw new RuntimeException("账务添加失败"); &#125;&#125; 25添加账务功能view层实现12345678910111213141516171819202122* A: 添加账务功能view层实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类addZhangWu方法public void addZhangWu() &#123; System.out.println("选择的添加账务功能，请输入以下内容"); Scanner sc = new Scanner(System.in); System.out.println("输入分类名称"); String flname = sc.next(); System.out.println("输入金额"); double money = sc.nextDouble(); System.out.println("输入账户"); String zhanghu = sc.next(); System.out.println("输入日期：格式XXXX-XX-xx"); String createtime = sc.next(); System.out.println("输入具体描述"); String description = sc.next(); //将接收到的数据，调用controller层的方法，传递参数，实现数据添加 //将用户输入的所有参数，封装成ZhangWu对象 ZhangWu zw = new ZhangWu(0, flname, money, zhanghu, createtime, description); controller.addZhangWu(zw); System.out.println("恭喜添加账务成功");&#125; 26编辑账务功能分析 A: 编辑账务功能分析 a: 编写MainView类中editZhangWu方法….. 键盘输入要编辑的账务信息ID号….. 键盘输入要修改的账务信息内容….. 调用ZhangWuService类中editZhangWu方法，用来将指定的账务信息进行更新….. 更新完毕后，使用输出语句，提示 “编辑账务成功！” b: 编写ZhangWuService类中editZhangWu方法…..* 调用ZhangWuDao类中editZhangWu方法，用来将指定的账务信息进行更新 c: 编写ZhangWuDao类中editZhangWu方法…..* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务更新操作 27编辑账务功能功能之前实现查询所有1234567891011* A: 编辑账务功能功能之前实现查询所有* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类editZhangWu方法public void editZhangWu() &#123; //调用查询所有账务数据的功能，显示出来 //看到所有数据，从中选择一项，进行修改 selectAll(); System.out.println("选择的是编辑功能，请输入数据"); &#125; 28编辑账务功能菜单实现1234567891011121314151617181920212223242526* A: 编辑账务功能菜单实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类editZhangWu方法public void editZhangWu() &#123; //调用查询所有账务数据的功能，显示出来 //看到所有数据，从中选择一项，进行修改 selectAll(); System.out.println("选择的是编辑功能，请输入数据"); Scanner sc = new Scanner(System.in); System.out.print("请输入ID"); int zwid = sc.nextInt(); System.out.println("输入分类名称"); String flname = sc.next(); System.out.println("输入金额"); double money = sc.nextDouble(); System.out.println("输入账户"); String zhanghu = sc.next(); System.out.println("输入日期：格式XXXX-XX-xx"); String createtime = sc.next(); System.out.println("输入具体描述"); String description = sc.next(); //将用户输入的数据，封装到ZhangWu对象中 //用户输入的ID，必须封装到到对象中 ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description); //调用controller层中的方法，实现编辑账务&#125; 29编辑账务功能控制层,业务层实现12345678910111213141516171819202122232425* A: 编辑账务功能控制层,业务层实现* a: 案例核心代码* cn.itcast.gjp.controller包中的ZhangWuController类editZhangWu方法/* * 定义方法，实现编辑账务功能 * 由视图层调用，传递参数，也是ZhangWu对象 * 调用service层的方法，也是ZhangWu对象 */public void editZhangWu(ZhangWu zw) &#123; service.editZhangWu(zw);&#125;* cn.itcast.gjp.service包中的ZhangWuService类editZhangWu方法/* * 定义方法，实现编辑账务 * 由控制层调用，传递ZhangWu对象 * 调用dao层的方法，传递ZhangWu对象 */public void editZhangWu(ZhangWu zw) &#123; dao.editZhangWu(zw);&#125;* cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法public void editZhangWu(ZhangWu zw) &#123; // TODO Auto-generated method stub &#125; 30编辑账务功能dao层实现12345678910111213141516171819202122* A：编辑账务功能dao层实现* a: 案例核心代码* cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法/* * 定义方法，实现编辑功能 * 由业务层调用，传递ZhangWu对象 * 将对象中的数据，更新到数据表 */public void editZhangWu(ZhangWu zw) &#123; try &#123; //更新数据的SQL String sql = "UPDATE zhangwu SET flname=?,money=?,zhanghu=?,createtime=?,description=? WHERE zwid=?"; //定义对象数组，封装所有数据 Object[] params = &#123;zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription(),zw.getZwid()&#125;; //调用qr对象方法update执行更新 qr.update(sql, params); &#125; catch (SQLException ex) &#123; System.out.println(ex); throw new RuntimeException("编辑账务失败"); &#125; &#125; 31编辑账务功能view层实现123456789101112131415161718192021222324252627282930313233343536* A: 编辑账务功能view层实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类editZhangWu方法/* * 定义方法，实现对账务的编辑功能 * 实现思想： * 接收用户的输入的信息 * 封装成ZhangWu对象 * 调用控制层的方法，传递ZhangWu对象，实现编辑 * */public void editZhangWu() &#123; //调用查询所有账务数据的功能，显示出来 //看到所有数据，从中选择一项，进行修改 selectAll(); System.out.println("选择的是编辑功能，请输入数据"); Scanner sc = new Scanner(System.in); System.out.print("请输入ID"); int zwid = sc.nextInt(); System.out.println("输入分类名称"); String flname = sc.next(); System.out.println("输入金额"); double money = sc.nextDouble(); System.out.println("输入账户"); String zhanghu = sc.next(); System.out.println("输入日期：格式XXXX-XX-xx"); String createtime = sc.next(); System.out.println("输入具体描述"); String description = sc.next(); //将用户输入的数据，封装到ZhangWu对象中 //用户输入的ID，必须封装到到对象中 ZhangWu zw = new ZhangWu(zwid, flname, money, zhanghu, createtime, description); //调用controller层中的方法，实现编辑账务 controller.editZhangWu(zw); System.out.println("账务编辑成功");&#125; 32删除账务功能分析 A: 删除账务功能分析 a: 编写MainView类中deleteZhangWu方法….. 键盘输入要删除的账务信息ID号….. 调用ZhangWuService类中deleteZhangWu方法，用来将指定的账务信息删除…..* 删除完毕后，使用输出语句，提示 “删除账务成功！” b: 编写ZhangWuService类中deleteZhangWu方法…..* 调用ZhangWuDao类中deleteZhangWu方法，用来将指定的账务信息删除 c: 编写ZhangWuDao类中deleteZhangWu方法…..* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务删除操作 33删除账务功能菜单实现1234567891011121314151617* A: 删除账务功能菜单实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类deleteZhangWu方法/* * 定义方法，实现账务删除 * 实现思想： * 接收用户的输入，输入一个主键数据 * 调用控制层方法，传递一个主键 */public void deleteZhangWu() &#123; //调用查询所有账务数据的功能，显示出来 //看到所有数据，从中选择一项，进行修改 selectAll(); System.out.println("选择的是删除功能，请输入序号即可"); int zwid = new Scanner(System.in).nextInt(); //调用控制层方法，传递主键id即可&#125; 34删除账务功能控制层,业务层实现123456789101112131415161718192021222324* A: 删除账务功能控制层,业务层实现* a: 案例核心代码* cn.itcast.gjp.controller包中的ZhangWuController类deleteZhangWu方法/* * 定义方法，实现删除功能 * 视图层调用，传递int类型主键 * 调用service层方法，传递int主键 */public void deleteZhangWu(int zwid) &#123; service.deleteZhangWu(zwid);&#125;* cn.itcast.gjp.service包中的ZhangWuService类deleteZhangWu方法/* * 定义方法，实现删除账务功能 * 由控制层调用，传递主键id * 调用dao层方法，传递主键id */public void deleteZhangWu(int zwid) &#123; dao.deleteZhangWu(zwid);&#125;* cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法public void deleteZhangWu(int zwid) &#123;&#125; 35删除账务功能dao实现1234567891011121314151617* A: 删除账务功能dao实现* a: 案例核心代码* cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法/* * 定义方法，实现删除业务 * 业务层调用，传递主键id */public void deleteZhangWu(int zwid) &#123; try &#123; //拼写删除数据SQL String sql = "DELETE FROM gjp_zhangwu WHERE zwid=?"; qr.update(sql, zwid); &#125; catch (SQLException ex) &#123; System.out.println(ex); throw new RuntimeException("删除账务失败"); &#125;&#125; 36删除账务功能view层实现123456789101112131415161718* A: 删除账务功能view层实现* a: 案例核心代码* cn.itcast.gjp.view包中建立MainView类editZhangWu方法/* * 定义方法，实现账务删除 * 实现思想： * 接收用户的输入，输入一个主键数据 * 调用控制层方法，传递一个主键 */public void deleteZhangWu() &#123; //调用查询所有账务数据的功能，显示出来 //看到所有数据，从中选择一项，进行修改 selectAll(); System.out.println("选择的是删除功能，请输入序号即可"); int zwid = new Scanner(System.in).nextInt(); //调用控制层方法，传递主键id即可 controller.deleteZhangWu(zwid); System.out.println("删除账务成功"); 37总结…..view层的作用是“界面”，用来完成数据显示给用户。当前项目view层中，包含了Controller层代码。…..Controller层的作用是“调度”，调度的是表现层view和业务层Service，主要功能分为：一是把表现层的数据交给业务层处理；二是把业务层返回的数据交给表现层显示。 …..Service层的作用是“业务”，我们也可以把“业务”当成是“功能”。今后要写的大型项目代码量最大的就是Service层。…..DAO层是操作数据库，现在我们使用的是commons-dbutils工具来简化JDBC，所以我们发现代码不多，比较简单。最后我们还会学习其他DAO层的工具，例如：hibernate和mybatis，他们都是JDBC的封装，用来简化JDBC。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础28(DBUtils, DBCP连接池)]]></title>
    <url>%2F2016%2F11%2F29%2Fday30%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、DBUtils2、DBCP连接池 01DButils工具类的介绍个三个核心类 A: DButils工具类的介绍个三个核心类 a: 概述 DBUtils是java编程中的数据库操作实用工具，小巧简单实用。 DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。 DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-1.6.jar才能够正常使用DBUtils工具。 b: Dbutils三个核心功能介绍 QueryRunner中提供对sql语句操作的API.….. update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作….. query(Connection conn, String sql, ResultSetHandler rsh, Object… params) ，用来完成表数据的查询操作 ResultSetHandler接口，用于定义select操作后，怎样封装结果集. DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法 02事务的简单介绍(此知识点后续详细介绍) A: 事务的简单介绍 03QueryRunner类的update方法介绍 A：QueryRunner类的update方法介绍 a: 方法介绍 update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作 使用QueryRunner类,实现对数据表的insert delete update 调用QueryRunner类的方法 update (Connection con,String sql,Object…param) Object…param 可变参数,Object类型,SQL语句会出现?占位符 数据库连接对象,自定义的工具类传递 123456 int update(Connection conn, String sql, Object... params) ，用来完成表数据的增加、删除、更新操作返回：成功操作的行数：The number of rows updated. &lt;T&gt; T query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) ，用来完成表数据的查询操作 04QueryRunner类实现insert添加数据12345678910111213141516171819202122* A: QueryRunner类实现insert添加数据* a: 案例代码public class QueryRunnerDemo &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args)throws SQLException &#123; insert(); &#125; /* * 定义方法,使用QueryRunner类的方法update向数据表中,添加数据 */ public static void insert()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); String sql = "INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)"; //将三个?占位符的实际参数,写在数组中 Object[] params = &#123;"体育用品",289.32,"购买体育用品"&#125;; //调用QueryRunner类的方法update执行SQL语句 int row = qr.update(con, sql, params); System.out.println(row); DbUtils.closeQuietly(con); &#125;&#125; 05QueryRunner类实现update修改数据1234567891011121314151617181920212223* A: QueryRunner类实现update修改数据* a: 案例代码public class QueryRunnerDemo &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args)throws SQLException &#123; update(); &#125; /* * 定义方法,使用QueryRunner类的方法update将数据表的数据修改 */ public static void update()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); //写修改数据的SQL语句 String sql = "UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=?"; //定义Object数组,存储?中的参数 Object[] params = &#123;"花卉",100.88,"情人节玫瑰花",4&#125;; //调用QueryRunner方法update int row = qr.update(con, sql, params); System.out.println(row); DbUtils.closeQuietly(con); &#125; &#125; 06QueryRunner类实现delete删除数据123456789101112131415161718192021222324252627* A: QueryRunner类实现delete删除数据* a: 案例代码public class QueryRunnerDemo &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args)throws SQLException &#123; delete(); &#125; /* * 定义方法,使用QueryRunner类的方法delete将数据表的数据删除 */ public static void delete()throws SQLException&#123; //创建QueryRunner类对象 QueryRunner qr = new QueryRunner(); //写删除的SQL语句 String sql = "DELETE FROM sort WHERE sid=?"; //调用QueryRunner方法update int row = qr.update(con, sql, 8); System.out.println(row); /* * 判断insert,update,delete执行是否成功 * 对返回值row判断 * if(row&gt;0) 执行成功 */ DbUtils.closeQuietly(con); &#125; &#125; 07JavaBean类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* A: JavaBean类* a: 概念* JavaBean就是一个类，在开发中常用封装数据。具有如下特性 1. "需要实现接口：java.io.Serializable ，通常实现接口这步骤省略了，不会影响程序。" 2. 提供私有字段：private 类型 "字段名"; 3. "提供getter/setter方法：" 4. "提供无参构造"例如：/* * 账务类 */public class ZhangWu implements Serializable &#123; private int id; private String name; private double money; private String parent; public ZhangWu() &#123; super(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; public String getParent() &#123; return parent; &#125; public void setParent(String parent) &#123; this.parent = parent; &#125; @Override public String toString() &#123; //该方法可以省略 return "ZhangWu [id=" + id + ", name=" + name + ", money=" + money + ", parent=" + parent + "]"; &#125;&#125; 08DBUtils工具类结果集处理的方式12345678910111213141516171819202122232425262728293031* A: DBUtils工具类结果集处理的方式* * a: QueryRunner实现查询操作* &lt;T&gt; T query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) ，* 用来完成表数据的查询操作* b: ResultSetHandler结果集处理类* ArrayHandler * 将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值* * ArrayListHandler * 将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。* * BeanHandler * 将结果集中第一条记录封装到一个指定的javaBean中。* * BeanListHandler * 将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中* * ColumnListHandler * 将结果集中指定的列的字段值，封装到一个List集合中* * ScalarHandler * 它是用于单数据。例如select count(*) from 表操作。* * MapHandler * 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据* * MapListHandler * 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合 09QueryRunner类的方法query1234567891011* A: QueryRunner类的方法query* a: QueryRunner数据查询操作* 调用QueryRunner类方法：* &lt;T&gt; T query(Connection con,String sql,ResultSetHandler r, Object..params)* ResultSetHandler r 结果集的处理方式,传递ResultSetHandler接口实现类* Object..params SQL语句中的?占位符* 注意: query方法返回值,返回的是T 泛型, 具体返回值类型,跟随结果集处理方式变化;* b: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection();&#125; 10结果集处理ArrayHandler12345678910111213141516171819202122* A: 结果集处理ArrayHandler* 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; arrayHandler(); &#125; "/* * 结果集第一种处理方法, ArrayHandler * 将结果集的第一行存储到对象数组中 Object[] */" public static void arrayHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法query执行查询,传递连接对象,SQL语句,结果集处理方式的实现类 //返回对象数组 Object[] result = qr.query(con, sql, new ArrayHandler()); for(Object obj : result)&#123; System.out.print(obj); &#125; &#125; &#125; 11结果集处理ArrayListHandler1234567891011121314151617181920212223242526272829303132* A: 结果集处理ArrayListHandler* * "qr.query(con, sql, new ArrayListHandler());返回的是： "List&lt;Object[]&gt;" "* * a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; arrayListHandler(); &#125; "/* * 结果集第二种处理方法,ArrayListHandler * 将结果集的"每一行",封装到对象数组中, 出现很多对象数组 * 对象数组存储到List集合： "List&lt;Object[]&gt;" */" public static void arrayListHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用query方法,结果集处理的参数上,传递实现类ArrayListHandler //方法返回值 每行是一个对象数组,存储到List List&lt;Object[]&gt; result= qr.query(con, sql, new ArrayListHandler()); //集合的遍历 for( Object[] objs : result)&#123; //遍历对象数组 for(Object obj : objs)&#123; System.out.print(obj+" "); &#125; System.out.println(); &#125; &#125;&#125; 12结果集处理BeanHandler123456789101112131415161718192021* A: 结果集处理BeanHandler* a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; beanHandler(); &#125; "/* * 结果集第三种处理方法,BeanHandler * 将结果集的"一行数据"(默认第一行),封装成JavaBean对象 * 注意: 被封装成数据到JavaBean对象, Sort类"必须"有"空参数构造" */" public static void beanHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort "; //调用方法,传递结果集实现类BeanHandler //BeanHandler(Class&lt;T&gt; type) Sort s = qr.query(con, sql, new BeanHandler&lt;Sort&gt;(Sort.class)); System.out.println(s); &#125;&#125; 13结果集处理BeanListHandler123456789101112131415161718192021222324* A: 结果集处理BeanListHandler* a: 案例代码public class QueryRunnerDemo1 &#123;private static Connection con = JDBCUtilsConfig.getConnection();public static void main(String[] args) throws SQLException&#123; beanListHander();&#125;"/* * 结果集第四种处理方法, BeanListHandler * 结果集每一行数据,封装JavaBean对象 * 多个JavaBean对象,存储到List集合 * 返回的是： * "List&lt;T&gt;","具体而言是：List&lt;JavaBean类&gt;" */"public static void beanListHander()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort "; //调用方法query,传递结果集处理实现类BeanListHandler List&lt;Sort&gt; list = qr.query(con, sql, new BeanListHandler&lt;Sort&gt;(Sort.class)); for(Sort s : list)&#123; System.out.println(s); &#125;&#125;&#125; 14结果集处理ColumnListHandler123456789101112131415161718192021222324* A: 结果集处理ColumnListHandler* a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; columnListHandler(); &#125; "/* * 结果集第五种处理方法,ColumnListHandler * 结果集,指定列的数据,存储到List集合 * 返回的是： List&lt;Object&gt; 每个列数据类型不同 */" public static void columnListHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort "; //调用方法 query,传递结果集实现类ColumnListHandler //实现类构造方法中,使用字符串的列名 List&lt;Object&gt; list = qr.query(con, sql, new ColumnListHandler&lt;Object&gt;("sname")); for(Object obj : list)&#123; System.out.println(obj); &#125; &#125; &#125; 15结果集处理ScalarHandler12345678910111213141516171819* A: 结果集处理ScalarHandler* a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; scalarHandler(); &#125; "/* * 结果集第六种处理方法,ScalarHandler * 对于查询后,只有1个结果 */" public static void scalarHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT COUNT(*) FROM sort"; //调用方法query,传递结果集处理实现类ScalarHandler long count = qr.query(con, sql, new ScalarHandler&lt;Long&gt;()); System.out.println(count); &#125;&#125; 16结果集处理MapHandler123456789101112131415161718192021222324* A: 结果集处理MapHandler* a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; mapHandler(); &#125; "/* * 结果集第七种处理方法,MapHandler * 将结果集第一行数据,封装到Map集合中 * Map&lt;键,值&gt; 键:列名 值:这列的数据 */" public static void mapHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法query,传递结果集实现类MapHandler //返回值: Map集合,Map接口实现类, 泛型 Map&lt;String,Object&gt; map = qr.query(con, sql, new MapHandler()); //遍历Map集合 for(String key : map.keySet())&#123; System.out.println(key+".."+map.get(key)); &#125; &#125;&#125; 17结果集处理MapListHandler12345678910111213141516171819202122232425262728* A: 结果集处理MapListHandlerr* a: 案例代码public class QueryRunnerDemo1 &#123; private static Connection con = JDBCUtilsConfig.getConnection(); public static void main(String[] args) throws SQLException&#123; mapListHandler(); &#125; "/* * 结果集第八种处理方法,MapListHandler * 将结果集每一行存储到Map集合,键:列名,值:数据 * Map集合过多,存储到List集合 */" public static void mapListHandler()throws SQLException&#123; QueryRunner qr = new QueryRunner(); String sql = "SELECT * FROM sort"; //调用方法query,传递结果集实现类MapListHandler //返回值List集合, 存储的是Map集合 List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(con, sql, new MapListHandler()); //遍历集合list for( Map&lt;String,Object&gt; map : list )&#123; for(String key : map.keySet())&#123; System.out.print(key+"..."+map.get(key)); &#125; System.out.println(); &#125; &#125;&#125; 18连接池介绍 A: 连接池介绍 a: 连接池介绍* 实际上就是存放连接的池子(容器) 在开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程 为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。 这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池 19连接池概念规范和DataSource接口 A: 连接池概念规范和DataSource接口 a: 连接池概念规范 用池来管理Connection，这样可以重复使用Connection。 不用自己来创建Connection，而是通过池来获取Connection对象* 使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池 连接池技术可以完成Connection对象的再次利用 b: DataSource接口 Java为数据库连接池提供了公共的接口：javax.sql.DataSource 各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池 常见的连接池：DBCP、C3P0 20DBCP连接池介绍 A: DBCP连接池介绍 a: DBCP连接池介绍 DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池 tomcat服务器简单介绍 21导入jar包123456789* A: 导入jar包* a: jar包介绍 * mysql-connector-java-5.1.37-bin.jar：数据库驱动* commons-dbutils-1.6.jar：提供QueryRunner类方便进行增删改查操作* commons-dbcp-1.4.jar：* commons-pool-1.5.6.jar：提供高效的数据库连接池技术* b: 导入jar包* 在项目根路径下建立文件夹lib* 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path 22BasicDataSource类的使用12345678910111213141516171819202122232425262728* A: BasicDataSource类的使用* a: 案例代码/* * 连接池jar包中,定义好一个类 BasicDataSource * 实现类数据源的规范接口 javax.sql.DataSource */public class DataSoruceDemo &#123; public static void main(String[] args) &#123; //创建DataSource接口的实现类对象 //实现类, org.apache.commons.dbcp BasicDataSource dataSource = new BasicDataSource(); //连接数据库的4个最基本信息,通过对象方法setXXX设置进来 dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/mybase"); dataSource.setUsername("root"); dataSource.setPassword("123"); try&#123; //调用对象方法getConnection获取数据库的连接 Connection con = dataSource.getConnection(); System.out.println(con); &#125;catch(SQLException ex)&#123;// System.out.println(ex); ex.printStackTrace(); throw new RuntimeException("数据库连接失败"); &#125; &#125;&#125; 23BasicDataSource类的常见配置123456789101112131415* A: BasicDataSource类的常见配置* a: 常见配置分类 属性 描述必须项 driverClassName 数据库驱动名称 url 数据库的地址 username 用户名 password 密码基本项（扩展） maxActive 最大连接数量 minIdle 最小空闲连接 maxIdle 最大空闲连接 initialSize 初始化连接参考文档：http://commons.apache.org/proper/commons-dbcp/configuration.html 24实现数据库连接池工具类123456789101112131415161718192021222324252627282930313233343536* A: 实现数据库连接池工具类* a: 案例代码/* * 使用DBCP实现数据库的连接池 * 连接池配置,自定义类, * 最基本四项完整 * 对于数据库连接池其他配置,自定义 */import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSource;public class JDBCUtils&#123; //创建出BasicDataSource类对象 private static BasicDataSource datasource = new BasicDataSource(); //静态代码块,对象BasicDataSource对象中的配置,自定义 static&#123; //数据库连接信息,必须的 datasource.setDriverClassName("com.mysql.jdbc.Driver"); datasource.setUrl("jdbc:mysql://localhost:3306/day33_user"); datasource.setUsername("root"); datasource.setPassword("123"); //对象连接池中的连接数量配置,可选的 datasource.setInitialSize(10);//初始化的连接数 datasource.setMaxActive(8);//最大连接数量 datasource.setMaxIdle(5);//最大空闲数 datasource.setMinIdle(1);//最小空闲 &#125; //定义静态方法,返回BasicDataSource类的对象 public static DataSource getDataSource()&#123; return datasource; &#125;&#125; 25工具类的测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* A: 工具类的测试* a: 案例代码/* * 测试写好的工具类, * 提供的是一个DataSource接口的数据源 * QueryRunner类构造方法,接收DataSource接口的实现类 * 后面,调用方法update,query,无需传递他们Connection连接对象 */import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.ArrayListHandler;import cn.itcast.jdbcutils.JDBCUtils;public class QueryRunnerDemo&#123; public static void main(String[] args) &#123; select(); &#125; //定义2个方法,实现数据表的添加,数据表查询 //QueryRunner类对象,写在类成员位置 private static QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); //数据表查询 public static void select()&#123; String sql = "SELECT * FROM sort"; try&#123; List&lt;Object[]&gt; list = qr.query(sql, new ArrayListHandler()); for(Object[] objs : list)&#123; for(Object obj : objs)&#123; System.out.print(obj+"\t"); &#125; System.out.println(); &#125; &#125;catch(SQLException ex)&#123; throw new RuntimeException("数据查询失败"); &#125; &#125; //数据表添加数据 public static void insert()&#123; String sql = "INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)"; Object[] params = &#123;"坚果",100.12,"刚刚上市的核桃"&#125;; try&#123; int row = qr.update(sql, params); System.out.println(row); &#125;catch(SQLException ex)&#123; throw new RuntimeException("数据添加失败"); &#125; &#125; &#125; 26总结 把今天的知识点总结一遍。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础27(JDBC,DBUtils)]]></title>
    <url>%2F2016%2F11%2F28%2Fday29%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、JDBC2、DBUtils 01JDBC概念和数据库驱动程序 A: JDBC概念和数据库驱动程序 a: JDBC概述 JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范 JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。 我们使用的是mysql的驱动mysql-connector-java-5.1.39-bin.jar b: 总结 JDBC是java提供给开发人员的一套操作数据库的接口 数据库驱动就是实现该接口的实现类 02JDBC原理 A: JDBC原理 a: 描述 Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动 DBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。 03准备数据12345678910111213141516171819202122* A: 准备数据* a: 创建数据库和表结构 #创建数据库 create database mybase; #使用数据库 use mybase; ###创建分类表 create table sort( sid int PRIMARY KEY AUTO_INCREMENT, sname varchar(100), sprice DOUBLE, sdesc VARCHAR(500) ); * b: 向表中插入数据 #初始化数据 insert into sort(sname,sprice,sdesc) values('家电',2000, '优惠的促销'); insert into sort(sname,sprice,sdesc) values('家具',8900, '家具价格上调,原材料涨价'); insert into sort(sname,sprice,sdesc) values('儿童玩具',290, '赚家长的钱'); insert into sort(sname,sprice,sdesc) values('生鲜',500.99, '生鲜商品'); insert into sort(sname,sprice,sdesc) values('服装',24000, '换季销售'); insert into sort(sname,sprice,sdesc) values('洗涤',50, '洗发水促销'); 04JDBC的开发步骤 A: JDBC的开发步骤 a: 步骤介绍1.注册驱动告知JVM使用的是哪一个数据库的驱动2.获得连接使用JDBC中的类,完成对MySQL数据库的连接3.获得语句执行平台通过连接对象获取对SQL语句的执行者对象4.执行sql语句使用执行者对象,向数据库执行SQL语句获取到数据库的执行后的结果5.处理结果6.释放资源 一堆close() 05导入mysql数据库驱动程序jar包 A: 导入mysql数据库驱动程序jar包 a: 步骤 创建lib目录，用于存放当前项目需要的所有jar包 选择jar包，右键执行build path / Add to Build Path 06注册数据库驱动程序代码：Class.forName(“com.mysql.jdbc.Driver”);JDBC规范定义驱动接口：java.sql.Driver，MySql驱动包提供了实现类：com.mysql.jdbc.DriverDriverManager工具类，提供注册驱动的方法 registerDriver()，方法的参数是java.sql.Driver，所以我们可以通过如下语句进行注册:DriverManager.registerDriver(new com.mysql.jdbc.Driver());以上代码不推荐使用，存在两方面不足1. 硬编码，后期不易于程序扩展和维护2. 驱动被注册两次。 通常开发我们使用Class.forName() 加载一个使用字符串描述的驱动类。如果使用Class.forName()将类加载到内存，该类的静态代码将自动执行。通过查询com.mysql.jdbc.Driver源码，我们发现Driver类“主动”将自己进行注册 123456789101112* A: 注册数据库驱动程序* a: 案例代码public class JDBCDemo &#123; public static void main(String[] args)throws ClassNotFoundException,SQLException&#123; "//1.注册驱动 反射技术,将驱动类加入到内容" // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver) // Diver是一个接口,参数传递,MySQL驱动程序中的实现类 //DriverManager.registerDriver(new Driver()); //驱动类源代码,注册2次驱动程序 Class.forName("com.mysql.jdbc.Driver"); &#125;&#125; 07获取数据库的连接对象代码：Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydatabase”, ”root”, ”root”); 获取连接需要方法 DriverManager.getConnection(url,username,password)，三个参数分别表示，url 需要连接数据库的位置（网址） user用户名 password 密码 url比较复杂，下面是mysql的url：jdbc:mysql://localhost:3306/mydatabase JDBC规定url的格式由三部分组成，每个部分中间使用冒号分隔。 第一部分是jdbc，这是固定的； 第二部分是数据库名称，那么连接mysql数据库，第二部分当然是mysql了； 第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(mydatabase)组成。url: 数据库地址 &gt;&gt;&gt;&gt;&gt; jdbc:mysql://连接主机IP:端口号/数据库名字 1234567891011121314151617181920212223242526* A：获取数据库的连接对象* a: 案例代码public class JDBCDemo &#123; public static void main(String[] args)throws ClassNotFoundException,SQLException&#123; //1.注册驱动 反射技术,将驱动类加入到内容 // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver) // Diver是一个接口,参数传递,MySQL驱动程序中的实现类 //DriverManager.registerDriver(new Driver()); //驱动类源代码,注册2次驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库连接 DriverManager类中静态方法 "//static Connection getConnection(String url, String user, String password) " //返回值是Connection接口的实现类,在mysql驱动程序 "//url: 数据库地址 jdbc:mysql://连接主机IP:端口号/数据库名字" String url = "jdbc:mysql://localhost:3296/mybase"; //用户名和密码用自己的 String username="root"; String password="123"; "//Connection 接口在java.sql中" Connection con = DriverManager.getConnection(url, username, password); "//返回值是 Connection 接口的实现类对象,在mysql驱动程序中：com.mysql.jdbc.JDBC4Connection" System.out.println(con); &#125;&#125; 08获取SQL语句的执行对象对象123456789101112131415161718192021222324252627282930* A: 获取SQL语句的执行对象对象* String sql = "某SQL语句";"获取Statement语句执行平台：Statement stmt = con.createStatement();"* a: 案例代码public class JDBCDemo &#123; public static void main(String[] args)throws ClassNotFoundException,SQLException&#123; //1.注册驱动 反射技术,将驱动类加入到内容 // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver) // Diver是一个接口,参数传递,MySQL驱动程序中的实现类 //DriverManager.registerDriver(new Driver()); //驱动类源代码,注册2次驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库连接 DriverManager类中静态方法 //static Connection getConnection(String url, String user, String password) //返回值是Connection接口的实现类,在mysql驱动程序 //url: 数据库地址 jdbc:mysql://连接主机IP:端口号//数据库名字 String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; Connection con = DriverManager.getConnection(url, username, password); //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象 "// con对象调用方法 Statement createStatement() 获取Statement对象,将SQL语句发送到数据库 // 返回值是 Statement接口的实现类对象,,在mysql驱动程序中：com.mysql.jdbc.StatementImpl" Statement stat = con.createStatement(); System.out.println(stat);&#125;&#125; 09执行insert语句获取结果集1234567891011121314String sql = "某SQL语句";获取Statement语句执行平台：Statement stmt = con.createStatement(); 常用方法： int executeUpdate(String sql) --执行insert update delete语句.参数：sql - SQL 数据操作语言（Data Manipulation Language，DML）语句，如 INSERT、UPDATE 或 DELETE；或者不返回任何内容的 SQL 语句，如 DDL 语句。 返回：(1) 对于 SQL 数据操作语言 (DML) 语句，返回【行计数】:操作成功的数据表有多少行，(2) 对于什么都不返回的 SQL 语句，返回 0 ; ResultSet executeQuery(String sql); --执行select语句. boolean execute(String sql); --执行select返回true 执行其他的语句返回false. 1234567891011121314151617181920212223242526272829303132333435363738* A: 执行insert语句获取结果集* a: 案例代码public class JDBCDemo &#123; public static void main(String[] args)throws ClassNotFoundException,SQLException&#123; //1.注册驱动 反射技术,将驱动类加入到内容 // 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver) // Diver是一个接口,参数传递,MySQL驱动程序中的实现类 //DriverManager.registerDriver(new Driver()); //驱动类源代码,注册2次驱动程序 Class.forName("com.mysql.jdbc.Driver"); //2.获得数据库连接 DriverManager类中静态方法 //static Connection getConnection(String url, String user, String password) //返回值是Connection接口的实现类,在mysql驱动程序 //url: 数据库地址 jdbc:mysql://连接主机IP:端口号//数据库名字 String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; Connection con = DriverManager.getConnection(url, username, password); //3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象 // con对象调用方法 Statement createStatement() 获取Statement对象,将SQL语句发送到数据库 // 返回值是 Statement接口的实现类对象,,在mysql驱动程序 Statement stat = con.createStatement(); // 4.执行sql语句 // 通过执行者对象调用方法执行SQL语句,获取结果 &gt;&gt; int executeUpdate(String sql) 执行数据库中的SQL语句, insert delete update &lt;&lt; "// 返回值int,操作成功的数据表多少行" int row = stat.executeUpdate ("INSERT INTO sort(sname,sprice,sdesc) VALUES('汽车用品',50000,'疯狂涨价')"); System.out.println(row); //6.释放资源 一堆close() stat.close(); con.close();&#125;&#125; 10执行select语句获取结果集12345678910111213 ResultSet executeQuery(String sql); --执行select语句. boolean execute(String sql); --执行select返回true 执行其他的语句返回false.ResultSet实际上就是一张二维的表格，我们可以调用其boolean next()方法指向某行记录，当第一次调用next()方法时，便指向第一行记录的位置，这时就可以使用ResultSet提供的getXXX(int col)方法(与索引从0开始不同，列从1开始)来获取指定列的数据：rs.next();//指向第一行rs.getInt(1);//获取第一行第一列的数据常用方法： Object getObject(int index) / Object getObject(String name) 获得任意对象 String getString(int index) / Object getObject(String name) 获得字符串 int getInt(int index) / Object getObject(String name) 获得整形 double getDouble(int index) / Object getObject(String name) 获得双精度浮点型 1234567891011121314151617181920212223242526272829303132* A: 执行select语句获取结果集* a: 案例代码public class JDBCDemo1 &#123; public static void main(String[] args) throws Exception&#123; //1. 注册驱动 Class.forName("com.mysql.jdbc.Driver"); //2. 获取连接对象 String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; Connection con = DriverManager.getConnection(url, username, password); //3 .获取执行SQL 语句对象 Statement stat = con.createStatement(); // 拼写查询的SQL String sql = "SELECT * FROM sort"; //4. 调用执行者对象方法,执行SQL语句获取结果集 // ResultSet executeQuery(String sql) 执行SQL语句中的select查询 // 返回值ResultSet接口的实现类对象,实现类在mysql驱动中 ResultSet rs = stat.executeQuery(sql); //5 .处理结果集 // ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集 while(rs.next())&#123; //获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名 System.out.println(rs.getInt("sid")+" "+rs.getString("sname")+ " "+rs.getDouble("sprice")+" "+rs.getString("sdesc")); &#125; rs.close(); stat.close(); con.close();&#125;&#125; 11SQL注入攻击1234567891011121314151617181920212223242526* A: SQL注入攻击* a: 注入问题* 假设有登录案例SQL语句如下:* SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码;* 此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录。 但是当用户输入的账号为XXX 密码为：XXX’ OR ‘a’=’a时，则真正执行的代码变为： * SELECT * FROM 用户表 WHERE NAME = ‘XXX’ AND PASSWORD =’ XXX’ OR ’a’=’a’;* 此时，上述查询语句时永远可以查询出结果的。那么用户就直接登录成功了，显然我们不希望看到这样的结果，这便是SQL注入问题。* b: 案例演示CREATE TABLE users( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100), PASSWORD VARCHAR(100));INSERT INTO users (username,PASSWORD) VALUES ('a','1'),('b','2');SELECT * FROM users;-- 登录查询SELECT * FROM users WHERE username='dsfsdfd' AND PASSWORD='wrethiyu' OR 1=1SELECT * FROM users WHERE username='a' AND PASSWORD='1'OR'1=1'键盘录入：11'OR' 1=1 12SQL注入攻击用户登录案例1234567891011121314151617181920212223242526272829* A: SQL注入攻击用户登录案例* a: 案例代码public class JDBCDemo2 &#123; public static void main(String[] args)throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3296/mybase"; String username = "root"; String password = "123"; Connection con = DriverManager.getConnection(url, username, password); Statement stat = con.createStatement(); Scanner sc = new Scanner(System.in); String user = sc.nextLine(); String pass = sc.nextLine(); //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败// String sql = "SELECT * FROM users WHERE username='dsfsdfd' AND PASSWORD='wrethiyu' OR 1=1"; String sql = "SELECT * FROM users WHERE username='"+user+"' AND PASSWORD='"+pass+"'"; System.out.println(sql); ResultSet rs = stat.executeQuery(sql); while(rs.next())&#123; System.out.println(rs.getString("username")+" "+rs.getString("password")); &#125; rs.close(); stat.close(); con.close(); &#125;&#125; 13PrepareStatement接口预编译SQL语句123456789101112131415161718* A: PrepareStatement接口预编译SQL语句* a: 预处理对象 * 使用PreparedStatement预处理对象时，建议每条sql语句所有的实际参数，都使用逗号分隔。 * String sql = "insert into sort(sid,sname) values(?,?);"; * String sql ="SELECT * FROM test0120 where username=? and PASSWORD1=?;"; *"方法中参数,SQL语句中的参数全部采用问号？占位符" * PreparedStatement预处理对象代码： * "PreparedStatement psmt = conn.prepareStatement(sql)" * b: 执行SQL语句的方法介绍 * int executeUpdate(); --执行insert update delete语句. * ResultSet executeQuery(); --执行select语句. * boolean execute(); --执行select返回true 执行其他的语句返回false.* c: 设置实际参数 * void setXxx(int index, Xxx xx) &gt;&gt;&gt; void setObject(int index, Object object) * 将指定参数设置为给定Java的xx值。在将此值发送到数据库时，驱动程序将它转换成一个 SQL Xxx类型值。 * 例如： * setString(2, "家用电器") 把SQL语句中第2个位置的占位符？ 替换成实际参数 "家用电器" 1234567891011121314151617181920212223242526272829303132333435363738394041424344* d: 案例代码 /* * Java程序实现用户登录,用户名和密码,数据库检查 * 防止注入攻击 * Statement接口实现类,作用执行SQL语句,返回结果集 * 有一个子接口PreparedStatement (SQL预编译存储,多次高效的执行SQL) * PreparedStatement的实现类数据库的驱动中,如何获取接口的实现类 * * 是Connection数据库连接对象的方法 * PreparedStatement prepareStatement(String sql) */public class JDBCDemo3 &#123; public static void main(String[] args)throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3296/mybase"; String username = "root"; String password = "123"; Connection con = DriverManager.getConnection(url, username, password); Scanner sc = new Scanner(System.in); String user = sc.nextLine(); String pass = sc.nextLine(); //执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败 String sql = "SELECT * FROM users WHERE username=? AND PASSWORD=?"; //调用Connection接口的方法prepareStatement,获取PrepareStatement接口的实现类 //方法中参数,SQL语句中的参数全部采用问号占位符 PreparedStatement pst = con.prepareStatement(sql); System.out.println(pst); //调用pst对象set方法,设置问号占位符上的参数 pst.setObject(1, user); pst.setObject(2, pass); //调用方法,执行SQL,获取结果集 ResultSet rs = pst.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString("username")+" "+rs.getString("password")); &#125; rs.close(); pst.close(); con.close();&#125;&#125; 14PrepareStatement接口预编译SQL语句执行修改12345678910111213141516171819202122232425262728* A: PrepareStatement接口预编译SQL语句执行修改* 案例代码 /* * 使用PrepareStatement接口,实现数据表的更新操作 */public class JDBCDemo &#123; public static void main(String[] args) throws Exception&#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; Connection con = DriverManager.getConnection(url, username, password); //拼写修改的SQL语句,参数采用?占位 String sql = "UPDATE sort SET sname=?,sprice=? WHERE sid=?"; //调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象 PreparedStatement pst = con.prepareStatement(sql); //调用pst的方法setXXX设置?占位 pst.setObject(1, "汽车美容"); pst.setObject(2, 49988); pst.setObject(3, 7); //调用pst方法执行SQL语句 pst.executeUpdate(); pst.close(); con.close();&#125;&#125; 15PrepareStatement接口预编译SQL语句执行查询123456789101112131415161718192021222324252627* A: PrepareStatement接口预编译SQL语句执行查询* a: 案例代码 /* * PrepareStatement接口实现数据表的查询操作 */public class JDBCDemo1 &#123; public static void main(String[] args) throws Exception&#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; Connection con = DriverManager.getConnection(url, username, password); String sql = "SELECT * FROM sort"; PreparedStatement pst = con.prepareStatement(sql); //调用pst对象的方法,执行查询语句,Select ResultSet rs=pst.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString("sid")+" "+rs.getString("sname")+" "+rs.getString("sprice")+" "+rs.getString("sdesc")); &#125; rs.close(); pst.close(); con.close();&#125;&#125; 16JDBC的工具类和测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677* A: JDBC的工具类和测试* a: 案例代码//JDBCUtils工具类代码public class JDBCUtils &#123; private JDBCUtils()&#123;&#125; private static Connection con ; static&#123; try&#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3296/mybase"; String username="root"; String password="123"; con = DriverManager.getConnection(url, username, password); &#125;catch(Exception ex)&#123; throw new RuntimeException(ex+"数据库连接失败"); &#125; &#125; /* * 定义静态方法,返回数据库的连接对象 */ public static Connection getConnection()&#123; return con; &#125; public static void close(Connection con,Statement stat)&#123; if(stat!=null)&#123; try&#123; stat.close(); &#125;catch(SQLException ex)&#123;&#125; &#125; if(con!=null)&#123; try&#123; con.close(); &#125;catch(SQLException ex)&#123;&#125; &#125; &#125; public static void close(Connection con,Statement stat , ResultSet rs)&#123; if(rs!=null)&#123; try&#123; rs.close(); &#125;catch(SQLException ex)&#123;&#125; &#125; if(stat!=null)&#123; try&#123; stat.close(); &#125;catch(SQLException ex)&#123;&#125; &#125; if(con!=null)&#123; try&#123; con.close(); &#125;catch(SQLException ex)&#123;&#125; &#125; &#125;&#125;//测试JDBCUtils工具类的代码public class TestJDBCUtils &#123; public static void main(String[] args)throws Exception &#123; Connection con = JDBCUtils.getConnection(); PreparedStatement pst = con.prepareStatement("SELECT sname FROM sort"); ResultSet rs = pst.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString("sname")); &#125; JDBCUtils.close(con, pst, rs); &#125;&#125; 17数据表数据存储对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576* A: 数据表数据存储对象* a: 准备工作 * 导入jar包 * 拷贝day32定义的工具类JDBCUtils * b: 案例代码 //定义实体类Sortpublic class Sort &#123; private int sid; private String sname; private double sprice; private String sdesc; public Sort(int sid, String sname, double sprice, String sdesc) &#123; this.sid = sid; this.sname = sname; this.sprice = sprice; this.sdesc = sdesc; &#125; public Sort()&#123;&#125; public int getSid() &#123; return sid; &#125; public void setSid(int sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public double getSprice() &#123; return sprice; &#125; public void setSprice(double sprice) &#123; this.sprice = sprice; &#125; public String getSdesc() &#123; return sdesc; &#125; public void setSdesc(String sdesc) &#123; this.sdesc = sdesc; &#125; @Override public String toString() &#123; return "Sort [sid=" + sid + ", sname=" + sname + ", sprice=" + sprice + ", sdesc=" + sdesc + "]"; &#125; &#125; /* * JDBC读取数据表sort,每行数据封装到Sort类的对象中 * 很多个Sort类对象,存储到List集合中 */public class JDBCDemo &#123; public static void main(String[] args) throws Exception&#123; //使用JDBC工具类,直接获取数据库连接对象 Connection con = JDBCUtils.getConnection(); //连接获取数据库SQL语句执行者对象 PreparedStatement pst = con.prepareStatement("SELECT * FROM sort"); //调用查询方法,获取结果集 ResultSet rs = pst.executeQuery(); //创建集合对象 List&lt;Sort&gt; list = new ArrayList&lt;Sort&gt;(); while(rs.next())&#123; //获取到每个列数据,封装到Sort对象中 Sort s = new Sort(rs.getInt("sid"),rs.getString("sname"),rs.getDouble("sprice"),rs.getString("sdesc")); //封装的Sort对象,存储到集合中 list.add(s); &#125; JDBCUtils.close(con, pst, rs); //遍历List集合 for(Sort s : list)&#123; System.out.println(s); &#125; &#125;&#125; 18properties配置文件12345678910* A: properties配置文件 * a: 相关介绍* 开发中获得连接的4个参数（驱动、URL、用户名、密码）通常都存在配置文件中，"方便后期维护"，程序如果需要更换数据库， 只需要修改配置文件即可。* 通常情况下，我们习惯使用"properties文件"，此文件我们将做如下要求： 1. 文件位置：任意，"建议src下" 2. 文件名称：任意，"扩展名为properties" 3. 文件内容：一行一组数据，"格式是“key=value”". a) key命名自定义，"如果是多个单词，习惯使用点分隔。例如：jdbc.driver" b) value值不支持中文，如果"需要使用非英文字符"，"将进行unicode转换。" 19properties文件的创建和编写12345678* A: properties文件的创建和编写* a: properties文件的创建 * src路径下建立database.properties(其实就是一个文本文件)* b: properties文件的编写(内容如下) driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3296/mybase username=root password=123 20加载配置文件(使用类的加载器)1234567891011121314151617181920212223* A: 加载配置文件* a: 案例代码 /* * 加载properties配置文件 * IO读取文件,键值对存储到集合 * 从集合中以键值对方式获取数据库的连接信息,完成数据库的连接 */"//使用类的加载器InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream("database.properties");""从用来加载类的搜索路径中打开具有指定名称的资源，以读取该资源。"public class PropertiesDemo &#123; public static void main(String[] args) throws Exception&#123; FileInputStream fis = new FileInputStream("database.properties"); System.out.println(fis); "//使用类的加载器" InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream("database.properties"); System.out.println(in); Properties pro = new Properties(); pro.load(in); System.out.println(in); &#125;&#125; 21通过配置文件连接数据库123456789101112131415161718192021222324252627* A: 通过配置文件连接数据库* a: 案例代码 /* * 加载properties配置文件 * IO读取文件,键值对存储到集合 * 从集合中以键值对方式获取数据库的连接信息,完成数据库的连接 */public class PropertiesDemo &#123; public static void main(String[] args) throws Exception&#123; FileInputStream fis = new FileInputStream("database.properties"); System.out.println(fis); //使用类的加载器 InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream("database.properties"); System.out.println(in); Properties pro = new Properties(); pro.load(in); //获取集合中的键值对 String driverClass=pro.getProperty("driverClass"); String url = pro.getProperty("url"); String username = pro.getProperty("username"); String password = pro.getProperty("password"); Class.forName(driverClass); Connection con = DriverManager.getConnection(url, username, password); System.out.println(con); &#125;&#125; 22读取配置文件的工具类12345678910111213141516171819202122232425262728293031323334353637383940* A: 读取配置文件的工具类* a: 案例代码/* * 编写数据库连接的工具类,JDBC工具类 * 获取连接对象采用读取配置文件方式 * 读取文件获取连接,执行一次,static&#123;&#125; */public class JDBCUtilsConfig &#123; private static Connection con ; private static String driverClass; private static String url; private static String username; private static String password; static&#123; try&#123; readConfig(); Class.forName(driverClass); con = DriverManager.getConnection(url, username, password); &#125;catch(Exception ex)&#123; throw new RuntimeException("数据库连接失败"); &#125; &#125; private static void readConfig()throws Exception&#123; InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream("database.properties"); Properties pro = new Properties(); pro.load(in); driverClass=pro.getProperty("driverClass"); url = pro.getProperty("url"); username = pro.getProperty("username"); password = pro.getProperty("password"); &#125; public static Connection getConnection()&#123; return con; &#125; &#125; 23测试工具类123456789101112131415161718192021* A: 测试工具类* a: 案例代码public class TestJDBCUtils &#123; public static void main(String[] args) &#123; Connection con = JDBCUtilsConfig.getConnection(); System.out.println(con); String sql = "select * from supermaket;"; PreparedStatement pstat = con.prepareStatement(sql); ResultSet rs = pstat.executeQuery(); while(rs.next())&#123; System.out.println(rs.getObject("id")+" "+ rs.getObject("sname")+" "+ rs.getObject("sprice")+" "+ rs.getObject("smessage") ); &#125; con.close(); pstat.close(); rs.close(); &#125;&#125; 24总结 把今天的知识点总结一遍。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础26(MySQL数据库,SQL语句)]]></title>
    <url>%2F2016%2F11%2F27%2Fday28%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.MySQL数据库2.SQL语句 01数据库概念 A: 什么是数据库数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。 B: 什么是数据库管理系统数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。 02常见的数据库 A: 常见的数据库MYSQL ：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。Oracle ：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。DB2 ：IBM公司的数据库产品,收费的。常应用在银行系统中.SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。SyBase ：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。SQLite : 嵌入式的小型数据库，应用在手机端。Java相关的数据库：MYSQL，Oracle．这里使用MySQL数据库。MySQL中可以有多个数据库，数据库是真正存储数据的地方 03数据库和管理系统* A: 数据库管理系统 123456----数据库1 ----数据表1a ----数据表1b----数据库2 -----数据表2a -----数据表2b 04数据表和Java中类的对应关系* A:数据库中以表为组织单位存储数据。 12345表类似我们的Java类，每个字段都有对应的数据类型。 那么用我们熟悉的java程序来与关系型数据对比，就会发现以下对应关系。 "类"----------"表" "类中属性"----------"表中字段" "对象"----------"表中每条记录" 05数据表和Java中类的对应关系用户表举例* A:举例: 账务表 id name age 1 lisi 23 2 wang 24 每一条记录对应一个User的对象 [user1 id = 1 name = lisi age = 23] [user2 id = 2 name = wang age = 24] 06MySQL数据库安装A: 安装步骤参见 day28_source《MySQL安装图解.doc》B: 安装后，MySQL会以windows服务的方式为我们提供数据存储功能。开启和关闭服务的操作：右键点击我的电脑→管理→服务→可以找到MySQL服务开启或停止。 07数据库在系统服务 A：开启服务和关闭服务方式1: 我的电脑—–&gt; (右键)管理—-&gt;服务和应用程序—-&gt;服务—-找到MySQL服务右键启动或关闭方式2: 进入dos窗口 使用命令: net start mysql 开启MySQL服务; 命令:net stop mysql 关闭MySql服务 08MySQL的登录123456* A: MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录。格式1：cmd&gt; mysql –u用户名 –p密码例如：mysql -uroot –proot格式2：cmd&gt; mysql --host=ip地址 --user=用户名 --password=密码例如：mysql --host=127.0.0.1 --user=root --password=root 09SQLYog软件介绍* A: 具体参见 《SQLYog配置.doc》 10SQL语句介绍和分类 A:SQL介绍 前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。 举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？ 主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。 结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。创建数据库、创建数据表、向数据表中添加一条条数据信息均需要使用SQL语句 1234567891011* B: SQL分类 * 数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等 * "数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等"* 数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户。* "数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等"* C: SQL通用语法"SQL语句可以单行或多行书写，以分号结尾" 可使用空格和缩进来增强语句的可读性 MySQL数据库的SQL语句"不区分大小写"，"建议关键字使用大写"，例如：SELECT * FROM user。 同样可以"使用/**/的方式完成注释" 11数据表中的数据类型123456789101112131415161718192021222324252627* A:MySQL中的我们常使用的数据类型如下 详细的数据类型如下(不建议详细阅读！)分类 类型名称 说明 整数类型 tinyInt 很小的整数 smallint 小的整数 mediumint 中等大小的整数 int(integer) 普通大小的整数小数类型 float 单精度浮点数 double 双精度浮点数 decimal（m,d） 压缩严格的定点数日期类型 year YYYY 1901~2155 time HH:MM:SS -838:59:59~838:59:59 date YYYY-MM-DD 1000-01-01~9999-12-3 datetime YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 timestamp YYYY-MM-DD HH:MM:SS 1970~01~01 00:00:01 UTC~2038-01-19 03:14:07UTC文本、二进制类型 CHAR(M) M为0~255之间的整数 VARCHAR(M) M为0~65535之间的整数 TINYBLOB 允许长度0~255字节 BLOB 允许长度0~65535字节 MEDIUMBLOB 允许长度0~167772150字节 LONGBLOB 允许长度0~4294967295字节 TINYTEXT 允许长度0~255字节 TEXT 允许长度0~65535字节 MEDIUMTEXT 允许长度0~167772150字节 LONGTEXT 允许长度0~4294967295字节 VARBINARY(M)允许长度0~M个字节的变长字节字符串 BINARY(M) 允许长度0~M个字节的定长字节字符串 12创建数据库操作12345678910111213141516171819202122232425262728293031* A: 创建数据库 格式: * create database 数据库名; * create database 数据库名 character set 字符集; 例如： #创建数据库 数据库中数据的编码采用的是安装数据库时指定的默认编码 utf8 CREATE DATABASE day21_1; #创建数据库 并指定数据库中数据的编码 CREATE DATABASE day21_2 CHARACTER SET utf8; * B: 查看数据库 查看数据库MySQL服务器中的所有的数据库: show databases; 查看某个数据库的定义的信息: show create database 数据库名; 例如： show create database day21_1; * C: 删除数据库 drop database 数据库名称; 例如： drop database day21_2; * D: 其他的数据库操作命令 切换数据库： use 数据库名; 例如： use day21_1; * E: 查看正在使用的数据库: select database(); 13创建数据表格式1234567891011* A:格式： create table 表名( 字段名 类型(长度) 约束, 字段名 类型(长度) 约束 ); 例如： ###创建分类表 CREATE TABLE sort ( sid INT, #分类ID sname VARCHAR(100) #分类名称 ); 14约束123456789101112131415161718192021222324252627282930313233343536* A: 约束的作用: void test() create table 表名( 列名 类型(长度) 约束, 列名 类型(长度) 约束 ); 限制每一列能写什么数据,不能写什么数据。 * B: 哪些约束: 主键约束 非空约束 唯一约束 外键约束格式：1.在创建表时创建主键，在字段后面加上 primary key.create table tablename( id int primary key, .......) 2. 在创建表时创建主键，在表创建的最后来指定主键 create table tablename( id int， .......， primary key(id))3.删除主键：alter table 表名 drop primary key; alter table sort drop primary key;4.主键自动增长：一般主键是自增长的字段，不需要指定。实现添加自增长语句,主键字段后加auto_increment(只适用MySQL)例如：###创建分类表CREATE TABLE sort ( sid INT PRIMARY KEY auto_increment, #分类ID sname VARCHAR(100) #分类名称); 15SQL代码的保存12* A: 当sql语句执行了，就已经对数据库进行操作了，一般不用保存操作 在SQLyog 中Ctrl + S 保存的是写sql语句。 16创建用户表123456789* A: 创建用户表: 需求:创建用户表,用户编号,姓名,用户的地址 * B: SQL语句 CREAT TABLE users ( uid INT, uname VARCHAR(20), uaddress VARCHAR(200) ); 17主键约束123456789101112131415161718192021* A: 主键是用于标识当前记录的字段。它的特点是非空，唯一。 在开发中一般情况下主键是不具备任何含义，只是用于标识当前记录。 * B: 格式： 1.在创建表时创建主键，在字段后面加上 primary key. create table tablename( id int primary key, ....... ) 2. 在创建表时创建主键，在表创建的最后来指定主键 create table tablename( id int， .......， primary key(id) ) 3.删除主键：alter table 表名 drop primary key; alter table sort drop primary key; 4."主键自动增长"：一般主键是"自增长的字段"，不需要指定。 "实现添加自增长语句,主键字段后加auto_increment(只适用MySQL)" 18常见表的操作12345678910* A:"查看表":"查看数据库中的所有表"： "格式：show tables;" "查看表结构"： 格式：desc 表名; 例如：desc sort;* B:"删除表" * "格式：drop table 表名;" 例如：drop table sort; 19修改表结构1234567891011121314151617181920212223242526272829303132333435* A: "修改表添加列" "alter table 表名 add 列名 类型(长度) 约束;" 例如： #1，为分类表添加一个新的字段为 分类描述 varchar(20) ALTER TABLE sort ADD sdesc VARCHAR(20);* B: "修改表修改列的类型长度及约束" "alter table 表名 modify 列名 类型(长度) 约束; " 例如： #2, 为分类表的分类名称字段进行修改，类型varchar(50) 添加约束 not null ALTER TABLE sort MODIFY sname VARCHAR(50) NOT NULL;* C: "修改表修改列名" "alter table 表名 change 旧列名 新列名 类型(长度) 约束; " 例如： #3, 为分类表的分类名称字段进行更换 更换为 snamesname varchar(30) ALTER TABLE sort CHANGE sname snamename VARCHAR(30);* D: "修改表删除列" "alter table 表名 drop 列名;" 例如： #4, 删除分类表中snamename这列 ALTER TABLE sort DROP snamename;* E: "修改表名" "rename table 表名 to 新表名; " 例如： #5, 为分类表sort 改名成 category RENAME TABLE sort TO category;* F: "修改表的字符集" "salter table 表名 character set 字符集;" 例如： #6, 为分类表 category 的编码表进行修改，修改成 gbk ALTER TABLE category CHARACTER SET gbk; 20数据表添加数据_112345678910* A: -- "向表中插入某些列"* 语法：insert into 表 (列名1,列名2,列名3..) values (值1,值2,值3..); * 举例:INSERT INTO product (id,pname,price) VALUES (1,'笔记本',5555.99);INSERT INTO product (id,pname,price) VALUES (2,'智能手机',9999);* 注意:列表,表名问题对应问题,个数,数据类型 21数据表添加数据_212345678910111213141516171819* A: "添加数据格式,不考虑主键"insert into 表名 (列名) values (值)* 举例:INSERT INTO product (pname,price) VALUE('洗衣机',800);* B: "添加数据格式,所有值全给出"格式insert into 表名 values (值1,值2,值3..); --向表中插入所有列INSERT INOT product VALUES (4,'微波炉',300.25);* C: "添加数据格式,批量写入"格式:insert into 表名 (列名1,列名2,列名3) values (值1,值2,值3),(值1,值2,值3)举例:INSERT INTO product (pname,price) VALUES('智能机器人',25999.22),('彩色电视',1250.36),('沙发',58899.02) 22更新数据12345678910111213141516171819202122232425262728293031* A: "用来修改指定条件的数据，将满足条件的记录指定列修改为指定值" 语法： "update 表名 set 字段名=值,字段名=值;" "update 表名 set 字段名=值,字段名=值 where 条件;" * B: 注意： * " 列名的类型与修改的值要一致. 修改值得时候不能超过最大长度. 值如果是字符串或者日期需要加’’. " * C: 例如： #1，将指定的sname字段中的值 修改成 日用品 UPDATE sort SET sname='日用品'; #2, 将sid为s002的记录中的sname改成 日用品 UPDATE sort SET sname='日用品' WHERE sid='s002'; UPDATE sort SET sname='日用品' WHERE sid='s003';update users set username='欧珀手机 R19',userprice=5612 where userid =3;"修改2行"：update users set username='欧珀手机 R19',userprice=5612 where userid =3 or userid=6;"修改多行"：update users set username='欧珀手机 R19',userprice=8888 where userid in (3,4,6);与 AND或 OR非 NOT等于 =不等于 &lt;&gt;小于等于 &lt;= where userid in (3,4,6) 表示()里的数据都采用 23删除数据12345678910111213141516* A: 语法：1、"delete from 表名 where 条件;" 2、"truncate table 表名;" * B: 面试题： 删除表中所有记录使用delete from 表名; 还是用truncate table 表名; "删除方式：delete 一条一条删除，不清空auto_increment记录数。" " truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。" * C: 例如： DELETE FROM sort WHERE sname='日用品'; "#表数据清空" DELETE FROM sort; 24命令行乱码问题12345678910111213141516171819A: 问题 我们在dos命令行操作中文时，会报错 insert into user(username,password) values(‘张三’,’123’); ERROR 1366 (HY000): Incorrect string value: '\xD5\xC5\xC8\xFD' for column 'username' at row 1B: 原因:因为mysql的客户端编码的问题我们的是utf8,而系统的cmd窗口编码是gbk1、解决方案（临时解决方案）:修改mysql客户端编码。 show variables like 'character%'; 查看所有mysql的编码 client connetion result 和客户端相关 database server system 和服务器端相关 "将客户端编码修改为gbk". "set character_set_results=gbk; / set names gbk;" 以上操作，"只针对当前窗口有效果"，如果关闭了服务器便失效。2、如果想要永久修改，通过以下方式: "在mysql安装目录下有my.ini文件" "default-character-set=gbk 客户端编码设置 " "character-set-server=utf8 服务器端编码设置" 注意:修改完成配置文件，重启服务 25数据表和测试数据准备123456789101112131415* A: 查询语句，在开发中使用的次数最多，此处使用“zhangwu” 账务表。 创建账务表： CREATE TABLE zhangwu ( id INT PRIMARY KEY AUTO_INCREMENT, -- 账务ID zname VARCHAR(200), -- 账务名称 zmoney DOUBLE -- 金额 ); * B: 插入表记录： INSERT INTO zhangwu(id,name,money) VALUES (1,'吃饭支出',247); INSERT INTO zhangwu(id,name,money) VALUES (2,'工资收入',12345); INSERT INTO zhangwu(id,name,money) VALUES (3,'服装支出',1000); INSERT INTO zhangwu(id,name,money) VALUES (4,'吃饭支出',325); INSERT INTO zhangwu(id,name,money) VALUES (5,'股票收入',8000); INSERT INTO zhangwu(id,name,money) VALUES (6,'打麻将支出',8000); INSERT INTO zhangwu(id,name,money) VALUES (7,null,5000); 26数据的基本查询1234567891011121314151617181920212223242526272829303132333435363738394041* A: "查询指定字段信息" "select 字段1,字段2,...from 表名;" 例如： select id,name from zhangwu;* B: "查询表中所有字段" "select * from 表名; " 例如： select * from zhangwu; 注意:使用"*"在练习、学习过程中可以使用，"在实际开发中，不推荐使用"。 原因，要查询的字段信息不明确，若字段数量很多，会导致查询速度很慢。* C: "distinct用于去除重复记录" "select distinct 字段 from 表名;" 例如： select distinct money from zhangwu;* D: "别名查询，使用的as关键字，as可以省略的." 别名可以给表中的字段，表设置别名。 当查询语句复杂时，使用别名可以极大的简便操作。 "表别名格式": "select * from 表名 as 别名;" 或 "select * from 表名 别名;" "列别名格式"： "select 字段名 as 别名 from 表名;" 或 "select 字段名 别名 from 表名;" 例如 表别名： select * from zhangwu as zw; 列别名： select money as m from zhangwu; select zname as '重新命名列' from zhangwu; 或 select money m from zhangwu; 我们在sql语句的操作中，可以直接对列进行运算。 例如：将所有账务的金额+10000元进行显示. SELECT DISTINCT zmoney+1000 as '资金求和' FROM zhangwu; 27数据的条件查询_11234567891011121314151617181920212223242526272829303132333435363738394041424344 * A:条件查询 "where语句表条件过滤"。满足条件操作，不满足不操作，多用于数据的查询与修改。 * B : 格式 : "select 字段 from 表名 where 条件;" * C: while条件的种类如下： 比较运算符 &gt; &lt; &lt;= &gt;= = &lt;&gt; ---------- 大于、小于、大于(小于)等于、"不等于"————————————————————————————————————————————————————————————————————————BETWEEN ...AND... ----------- 显示在某一区间的值("含头含尾")————————————————————————————————————————————————————————————————————————IN(set) -----------"显示在in列表中的值"，例：in(100,200)————————————————————————————————————————————————————————————————————————"LIKE 通配符" -----------"模糊查询"，Like语句中有两个通配符："% 用来匹配多个字符"；例first_name like ‘a%’;"_ 用来匹配一个字符"。例first_name like ‘a_’;————————————————————————————————————————————————————————————————————————IS NULL ------------判断是否为空is null; 判断为空is not null; 判断不为空————————————————————————————————————————————————————————————————————————* D 逻辑运算符 and ------------ 多个条件同时成立or ------------ 多个条件任一成立not ------------ 不成立，例：where not(salary&gt;100);* E: 例如：查询所有吃饭支出记录SELECT * FROM zhangwu WHERE name = '吃饭支出';查询出金额大于1000的信息SELECT * FROM zhangwu WHERE money &gt;1000;查询出金额在2000-5000之间的账务信息SELECT * FROM zhangwu WHERE money &gt;=2000 AND money &lt;=5000;或SELECT * FROM zhangwu WHERE money BETWEEN 2000 AND 5000;查询出金额是1000或5000或3500的商品信息SELECT * FROM zhangwu WHERE money =1000 OR money =5000 OR money =3500;或SELECT * FROM zhangwu WHERE money IN(1000,5000,3500); 28数据的条件查询_212345678910 * A "模糊查询" "查询出账务名称包含”支出”的账务信息。" SELECT * FROM zhangwu WHERE name LIKE "%支出%"; * B "查询出账务名称中是五个字的账务信息" SELECT * FROM gjp_ledger WHERE ldesc LIKE "_____"; -- 五个下划线_* C "查询出账务名称不为null账务信息" SELECT * FROM zhangwu WHERE name IS NOT NULL; SELECT * FROM zhangwu WHERE NOT (name IS NULL); 29排序查询123456789101112131415161718192021222324* A: 排序查询 使用格式 * "通过order by语句，可以将查询出的结果进行排序"。"放置在select语句的""最后"。 * "SELECT * FROM 表名 ORDER BY 字段ASC;" * ASC 升序 (默认) * DESC 降序 * B: 案例代码 /* 查询,对结果集进行排序 升序,降序,对指定列排序 order by 列名 [desc][asc] desc 降序 asc 升序排列,可以不写 */ -- 查询账务表,价格进行升序 "SELECT * FROM zhangwu ORDER BY zmoney ASC" -- 查询账务表,价格进行降序 SELECT * FROM zhangwu ORDER BY zmoney DESC -- 查询账务表,查询所有的支出,对金额降序排列 -- "先过滤条件 where 查询的结果再排序" SELECT * FROM zhangwu WHERE zname LIKE'%支出%' ORDER BY zmoney DESC 30聚合函数1234567891011121314151617181920212223242526272829303132* A: 聚合函数 * B: 函数介绍 * 之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询， 它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。 * count：统计指定列不为NULL的记录行数； * sum：计算指定列的数值和，如果指定列； * max：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串类型不是数值类型，那么计算结果为0排0序运算； * min：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算； * avg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；* C: 案例代码 /* 使用聚合函数查询计算 */ -- count 求和,对表中的数据的个数求和 count(列名) -- 查询统计账务表中,一共有多少条数据 SELECT COUNT(*)AS'count' FROM zhangwu -- sum求和,对一列中数据进行求和计算 sum(列名) -- 对账务表查询,对所有的金额求和计算 SELECT SUM(zmoney) FROM zhangwu -- 求和,统计所有支出的总金额 SELECT SUM(zname) FROM zhangwu WHERE zname LIKE'%收入%' INSERT INTO zhangwu (zname) VALUES ('彩票收入') -- max 函数,对某列数据,获取最大值 SELECT MAX(zmoney) FROM zhangwu -- avg 函数,计算一个列所有数据的平均数 SELECT AVG(zmoney)FROM zhangwu 31分组查询12345678910111213141516171819202122232425262728293031323334353637383940* A: 分组查询 * a: 使用格式 * "分组查询是指使用group by字句对查询信息进行分组",例如：我们要统计出zhanguw表中所有分类账务的总数量,这时就需要使用group by 来对zhangwu表中的账务信息根据parent进行分组操作。 * "* SELECT 字段1,字段2… FROM 表名 GROUP BY 字段 HAVING 条件;" * "分组操作中的having子语句"，"是用于在分组后对数据进行过滤的，作用类似于where条件"。 * b: having与where的区别 *" having是在"【分组后】"对数据进行过滤". * "where是在"【分组前】"对数据进行过滤" * having后面可以使用分组函数(统计函数) * where后面不可以使用分组函数。 * B: 案例代码 /* 查询所有的数据 吃饭支出 共计多少 工资收入 共计多少 服装支出 共计多少 股票收入 共计多少 打麻将支出 共计多少钱 分组查询: group by 被分组的列名 必须跟随聚合函数 select 查询的时候,被分组的列,要出现在select 选择列的后面 */ SELECT SUM(zmoney),zname FROM zhangwu GROUP BY zname -- 对zname内容进行分组查询求和,但是只要支出 SELECT SUM(zmoney)AS 'getsum',zname FROM zhangwu WHERE zname LIKE'%支出%' GROUP BY zname ORDER BY getsum DESC -- 对zname内容进行分组查询求和,但是只要支出, 显示金额大于5000 -- 结果集是分组查询后,再次进行筛选,不能使用where, 分组后再次过滤,关键字 having SELECT SUM(zmoney)AS 'getsum',zname FROM zhangwu WHERE zname LIKE'%支出%' GROUP BY zname HAVING getsum&gt;5000 32总结]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础25(多线程安全问题(同步、死锁)、等待唤醒机制)]]></title>
    <url>%2F2016%2F11%2F26%2Fday27%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、多线程安全问题2、等待唤醒机制 01线程操作共享数据的安全问题*A:线程操作共享数据的安全问题如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 02售票的案例1234567891011121314151617181920212223242526272829303132333435363738394041424344*A:售票的案例 /* * 多线程并发访问同一个数据资源 * 3个线程,对一个票资源,出售 */public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类对象 Tickets t = new Tickets(); //创建3个Thread类对象,传递Runnable接口实现类 Thread t0 = new Thread(t); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t0.start(); t1.start(); t2.start(); &#125; &#125;public class Tickets implements Runnable&#123; //定义出售的票源 private int ticket = 100; private Object obj = new Object(); public void run()&#123; while(true)&#123; if( ticket &gt; 0)&#123; //模拟产生安全问题 try &#123; Thread.sleep(1); &#125; catch (Exception ex)&#123; ex.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+" 出售第 "+ticket--); &#125; &#125; &#125; &#125; 03线程安全问题引发123456789101112131415161718192021222324252627282930313233343536373839404142*A:线程安全问题引发/* * 多线程并发访问同一个数据资源 * 3个线程,对一个票资源,出售 */public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类对象 Tickets t = new Tickets(); //创建3个Thread类对象,传递Runnable接口实现类 Thread t0 = new Thread(t); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t0.start(); t1.start(); t2.start(); &#125;&#125;/* * 通过线程休眠,出现安全问题 */public class Tickets implements Runnable&#123; //定义出售的票源 private int ticket = 100; private Object obj = new Object(); public void run()&#123; while(true)&#123; //对票数判断,大于0,可以出售,变量--操作 if( ticket &gt; 0)&#123; try&#123; Thread.sleep(10); //加了休眠让其他线程有执行机会 &#125;catch(Exception ex)&#123;&#125; System.out.println(Thread.currentThread().getName()+" 出售第 "+ticket--); &#125; &#125; &#125;&#125; 04同步代码块解决线程安全问题线程同步的方式有两种： 方式1：同步代码块 方式2：同步方法 同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*A:同步代码块解决线程安全问题 *A:售票的案例 /* * 多线程并发访问同一个数据资源 * 3个线程,对一个票资源,出售 */public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类对象 Tickets t = new Tickets(); //创建3个Thread类对象,传递Runnable接口实现类 Thread t0 = new Thread(t); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t0.start(); t1.start(); t2.start(); &#125; &#125; "/* * 通过线程休眠,出现安全问题 * 解决安全问题,Java程序,提供技术,同步技术 * 公式: * synchronized(任意对象)&#123; * 线程要操作的共享数据 * &#125; * 同步代码块 */"public class Tickets implements Runnable&#123; //定义出售的票源 private int ticket = 100; private Object obj = new Object(); public void run()&#123; while(true)&#123; //线程共享数据,保证安全,加入同步代码块 synchronized(obj)&#123; //对票数判断,大于0,可以出售,变量--操作 if( ticket &gt; 0)&#123; try&#123; Thread.sleep(10); &#125;catch(Exception ex)&#123;&#125; System.out.println(Thread.currentThread().getName()+" 出售第 "+ticket--); &#125; &#125; &#125; &#125; &#125; 05同步代码块的执行原理A:同步代码块的执行原理同步代码块: 在代码块声明上 加上synchronizedsynchronized (锁对象) {可能会产生线程安全问题的代码} 同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。 06同步的上厕所原理*A:同步的上厕所原理a:不使用同步:线程在执行的过程中会被打扰线程比喻成人线程执行代码就是上一个厕所第一个人正在上厕所,上到一半,被另外一个人拉出来b:使用同步:线程比喻成人线程执行代码就是上一个厕所锁比喻成厕所门第一个人上厕所,会锁门第二个人上厕所,看到门锁上了,等待第一个人上完再去上厕所 07同步方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455*A:同步方法:/** 多线程并发访问同一个数据资源* 3个线程,对一个票资源,出售*/public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类对象 Tickets t = new Tickets(); //创建3个Thread类对象,传递Runnable接口实现类 Thread t0 = new Thread(t); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t0.start(); t1.start(); t2.start(); &#125;&#125;*A:同步方法 "/* * 采用同步方法形式,解决线程的安全问题 * 好处: 代码简洁 * 将线程共享数据,和同步,抽取到一个方法中 * 在方法的声明上,加入同步关键字 * * 问题: * 同步方法有锁吗,肯定有,同步方法中的对象锁,是本类对象引用 this * 如果方法是静态的呢,同步有锁吗,绝对不是this * 锁是本类自己.class 属性 * 静态方法,同步锁,是本类类名.class属性 */"public class Tickets implements Runnable&#123; //定义出售的票源 private int ticket = 100; public void run()&#123; while(true)&#123; payTicket(); &#125; &#125; public synchronized void payTicket()&#123; if( ticket &gt; 0)&#123; try&#123; Thread.sleep(10); &#125;catch(Exception ex)&#123;&#125; System.out.println(Thread.currentThread().getName()+" 出售第 "+ticket--); &#125; &#125; &#125; 08JDK1.5新特性Lock接口,实现类ReentrantLockLock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。 锁是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问。一次只能有一个线程获得锁，对共享资源的所有访问都需要首先获得锁。不过，某些锁可能允许对共享资源并发访问，如 ReadWriteLock 的读取锁。 synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。 虽然 synchronized 方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用 “hand-over-hand” 或 “chain locking”：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。 随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用 synchronized 方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句： 1234567Lock l = ...; l.lock(); try &#123; // access the resource protected by this lock &#125; finally &#123; l.unlock();//最后必须释放锁 &#125; 1234567*A:JDK1.5新特性Lock接口 查阅API，查阅Lock接口描述，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。  Lock接口中的常用方法 void lock() void unlock() Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。 我们使用Lock接口,以及其中的lock()方法和unlock()方法替代同步，对电影院卖票案例中Ticket 09利用Lock接口实现类ReentrantLock改进售票案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253*A:Lock接口改进售票案例 /* * 多线程并发访问同一个数据资源 * 3个线程,对一个票资源,出售 */public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类对象 Tickets t = new Tickets(); //创建3个Thread类对象,传递Runnable接口实现类 Thread t0 = new Thread(t); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t0.start(); t1.start(); t2.start(); &#125; &#125; "/* * 使用JDK1.5 的接口Lock,替换同步代码块,实现线程的安全性 * Lock接口方法: * lock() 获取锁 * unlock()释放锁 * 实现类ReentrantLock */" public class Tickets implements Runnable&#123; //定义出售的票源 private int ticket = 100; //在类的成员位置,创建Lock接口的实现类对象 private Lock lock = new ReentrantLock(); public void run()&#123; while(true)&#123; //调用Lock接口方法lock获取锁 lock.lock(); //对票数判断,大于0,可以出售,变量--操作 if( ticket &gt; 0)&#123; try&#123; Thread.sleep(10); System.out.println(Thread.currentThread().getName()+" 出售第 "+ticket--); &#125;catch(Exception ex)&#123; &#125;finally&#123; ////最后必须释放锁,调用Lock接口方法unlock lock.unlock(); &#125; &#125; &#125; &#125; &#125; 10线程的死锁原理*A:线程的死锁原理当线程任务中出现了多个同步(多个锁) 时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。 12345synchronzied(A锁)&#123; synchronized(B锁)&#123; &#125;&#125; 11线程的死锁代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*A:线程的死锁代码实现 public class LockA &#123; private LockA()&#123;&#125; public static final LockA locka = new LockA(); &#125; public class LockB &#123; private LockB()&#123;&#125; public static final LockB lockb = new LockB(); &#125; public class DeadLockDemo &#123; public static void main(String[] args) &#123; DeadLock dead = new DeadLock(); Thread t0 = new Thread(dead); Thread t1 = new Thread(dead); t0.start(); t1.start(); &#125; &#125;public class DeadLock implements Runnable&#123; private int i = 0; public void run()&#123; while(true)&#123; if(i%2==0)&#123; //先进入A同步,再进入B同步 synchronized(LockA.locka)&#123; System.out.println("if...locka"); synchronized(LockB.lockb)&#123; System.out.println("if...lockb"); &#125; &#125; &#125;else&#123; //先进入B同步,再进入A同步 synchronized(LockB.lockb)&#123; System.out.println("else...lockb"); synchronized(LockA.locka)&#123; System.out.println("else...locka"); &#125; &#125; &#125; i++; &#125; &#125; &#125; 打印效果之一：if … lockaif … lockbelse … lockbif … locka这是因为：Thread t0 = new Thread(dead);Thread t1 = new Thread(dead);2个线程都执行了DeadLock程序的内容，即2个线程可以共享DeadLock中同一锁对象LockA.locka，和LockB.lockb 在线程1执行完if语句后，进入else语句执行完B同步，正准备执行A同步时，这时线程2突然抢占了资源，执行了if语句中的A同步，准备执行B同步; 即这时线程1获得了B同步的锁对象LockB.lockb；而线程2获得了A同步的锁对象LockA.locka，导致线程1没有A同步的锁对象，无法执行A同步；线程2没有B同步的锁对象，无法执行B同步,陷入死锁 12线程等待与唤醒案例介绍线程之间的通信：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。*A:线程等待与唤醒案例介绍 等待唤醒机制所涉及到的方法：  wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。  notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。  notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。 其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。 13线程等待与唤醒案例资源类编写123456789101112*A:线程等待与唤醒案例资源类编写/* * 定义资源类,有2个成员变量 * name,sex * 同时有2个线程,对资源中的变量操作 * 1个对name,age赋值 * 2个对name,age做变量的输出打印 */public class Resource &#123; public String name; public String sex;&#125; 14线程等待与唤醒案例输入和输出线程123456789101112131415161718192021222324252627282930313233343536A:线程等待与唤醒案例输入和输出线程 /* * 输入的线程,对资源对象Resource中成员变量赋值 * 一次赋值 张三,男 * 下一次赋值 lisi,nv */ public class Input implements Runnable &#123; private Resource r=new Resource(); public void run() &#123; int i=0; while(true)&#123; if(i%2==0)&#123; r.name="张三"; r.sex="男"; &#125;else&#123; r.name="lisi"; r.sex="女"; &#125; i++; &#125; &#125; &#125; /* * 输出线程,对资源对象Resource中成员变量,输出值 */ public class Output implements Runnable &#123; private Resource r=new Resource() ; public void run() &#123; while(true)&#123; System.out.println(r.name+"..."+r.sex); &#125; &#125; &#125; 15线程等待与唤醒案例测试类12345678910111213141516171819A:线程等待与唤醒案例测试类 /* * 开启输入线程和输出线程,实现赋值和打印值 */ public class ThreadDemo&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Input in = new Input(); Output out = new Output(); Thread tin = new Thread(in); Thread tout = new Thread(out); tin.start(); tout.start(); &#125; &#125; 16线程等待与唤醒案例null值解决12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061A:线程等待与唤醒案例null值解决/** 输入的线程,对资源对象Resource中成员变量赋值* 一次赋值 张三,男* 下一次赋值 lisi,nv*/public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r=r; &#125; public void run() &#123; int i=0; while(true)&#123; if(i%2==0)&#123; r.name="张三"; r.sex="男"; &#125;else&#123; r.name="lisi" r.sex="女" &#125; i++; &#125; &#125;&#125;/** 输出线程,对资源对象Resource中成员变量,输出值*/ public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r=r; &#125; public void run() &#123; while(true)&#123; System.out.println(r.name+"..."+r.sex); &#125; &#125; &#125;&#125;/** 开启输入线程和输出线程,实现赋值和打印值*/public class ThreadDemo&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Input in = new Input(r); Output out = new Output(r); Thread tin = new Thread(in); Thread tout = new Thread(out); tin.start(); tout.start(); &#125;&#125; 17线程等待与唤醒案例数据安全解决1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465A:线程等待与唤醒案例数据安全解决/* * 输入的线程,对资源对象Resource中成员变量赋值 * 一次赋值 张三,男 * 下一次赋值 lisi,nv*/public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r=r; &#125; public void run() &#123; int i=0; while(true)&#123; synchronized(r)&#123; if(i%2==0)&#123; r.name="张三"; r.sex="男"; &#125;else&#123; r.name="lisi" r.sex="女" &#125; i++; &#125; &#125; &#125; /* * 输出线程,对资源对象Resource中成员变量,输出值 */ public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r=r; &#125; public void run() &#123; while(true)&#123; synchronized(r)&#123; System.out.println(r.name+"..."+r.sex); &#125; &#125; &#125; &#125; &#125; /* * 开启输入线程和输出线程,实现赋值和打印值 */public class ThreadDemo&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Input in = new Input(r); Output out = new Output(r); Thread tin = new Thread(in); Thread tout = new Thread(out); tin.start(); tout.start(); &#125; &#125; 18线程等待与唤醒案例通信的分析*A:线程等待与唤醒案例通信的分析输入: 赋值后,执行方法wait()永远等待输出: 变量值打印输出,在输出等待之前,唤醒【输入】的notify(),自己在wait()永远等待输入: 被唤醒后,重新对变量赋值,赋值后,必须唤醒【输出】的线程notify(),自己的wait() 19线程等待与唤醒案例的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697*A 线程等待与唤醒案例的实现 /* * 定义资源类,有2个成员变量 * name,sex * 同时有2个线程,对资源中的变量操作 * 1个对name,age赋值 * 2个对name,age做变量的输出打印 */public class Resource &#123; public String name; public String sex; public boolean flag = false; &#125; /* * 输入的线程,对资源对象Resource中成员变量赋值 * 一次赋值 张三,男 * 下一次赋值 lisi,nv */public class Input implements Runnable &#123; private Resource r ; public Input(Resource r)&#123; this.r = r; &#125; public void run() &#123; int i = 0 ; while(true)&#123; synchronized(r)&#123; //标记是true,等待 if(r.flag)&#123; try&#123;r.wait();&#125;catch(Exception ex)&#123;&#125; &#125; if(i%2==0)&#123; r.name = "张三"; r.sex = "男"; &#125;else&#123; r.name = "lisi"; r.sex = "nv"; &#125; //将对方线程唤醒,标记改为true r.flag = true; r.notify(); &#125; i++; &#125; &#125; &#125; /* * 输出线程,对资源对象Resource中成员变量,输出值 */public class Output implements Runnable &#123; private Resource r ; public Output(Resource r)&#123; this.r = r; &#125; public void run() &#123; while(true)&#123; synchronized(r)&#123; //判断标记,是false,等待 if(!r.flag)&#123; try&#123;r.wait();&#125;catch(Exception ex)&#123;&#125; &#125; System.out.println(r.name+".."+r.sex); //标记改成false,唤醒对方线程 r.flag = false; r.notify(); &#125; &#125; &#125; &#125; /* * 开启输入线程和输出线程,实现赋值和打印值 */public class ThreadDemo&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Input in = new Input(r); Output out = new Output(r); Thread tin = new Thread(in); Thread tout = new Thread(out); tin.start(); tout.start(); &#125; &#125; 20总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 同步锁"多个线程"想保证线程安全，必须要使用"同一个锁对象" 同步代码块 synchronized (锁对象)&#123; 可能产生线程安全问题的代码&#125;同步代码块的"锁对象"可以是"任意(Object)的对象" 同步方法 public synchronized void method()&#123; 可能产生线程安全问题的代码 &#125; 同步方法中的锁对象是 this 静态同步方法public synchronized void method()&#123; 可能产生线程安全问题的代码&#125;"静态同步方法中的锁对象"是 类名.class 多线程有几种实现方案，分别是哪几种?" a, 继承Thread类 b, 实现Runnable接口 c, 通过线程池，实现Callable接口" 同步有几种方式，分别是什么?" a,同步代码块 b,同步方法 静态同步方法" 启动一个线程是run()还是start()?它们的区别?" 启动一个线程是start() 区别： start： 启动线程，并调用线程中的run()方法 run : 执行该线程对象要执行的任务" void test()  sleep()和wait()方法的区别 sleep: 不释放锁对象, 释放CPU使用权 在休眠的时间内，不能唤醒 wait(): 释放锁对象, 释放CPU使用权 在等待的时间内，能唤醒 为什么wait(),notify(),notifyAll()等方法都定义在Object类中 锁对象可以是任意类型的对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础24(多线程及其创建方式、线程池)]]></title>
    <url>%2F2016%2F11%2F20%2Fday26%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、多线程(Thread线程类、Runnable接口)2、线程池(ExecutorService：线程池类) 01进程概念*A:进程概念 a:进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。 02线程的概念 *A:线程的概念 a:线程：线程是进程中的一个执行单元(执行路径)，负责当前进程中程序的执行， 一个进程中至少有一个线程。一个进程中是可以有多个线程的， 这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 03深入线程的概念A:深入线程的概念什么是多线程呢？ 即就是一个程序中有多个线程在同时执行。 一个核心的CPU在多个线程之间进行着随即切换动作,由于切换时间很短(毫秒甚至是纳秒级别),导致我们感觉不出来 单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如去网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。 04迅雷的多线程下载 A:迅雷的多线程下载 多线程,每个线程都读一个文件 05线程的运行模式A:线程的运行模式a:分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 b:抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。 比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。 此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。 对于CPU的一个核而言，某个时刻，只能执行一个线程， 而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 06main的主线程jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程 : thread “main”。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。1234567891011121314151617*A:main的主线程 /* * 程序中的主线程 */ public class Demo &#123; public static void main(String[] args) &#123; System.out.println(0/0); function(); System.out.println(Math.abs(-9)); &#125; public static void function()&#123; for(int i = 0 ; i &lt; 10000;i++)&#123; System.out.println(i); &#125; &#125; &#125; 07 Thread 类和Runnable 接口介绍A:Thread类介绍:Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。 发现创建新执行线程有两种方法。 a:一种方法是将类声明为 Thread 的子类。 该子类应重写 Thread 类的 run 方法。创建对象，开启线程。run方法相当于其他线程的main方法。 b:另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。 然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。 创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。例如，计算大于某一规定值的质数的线程可以写成： 1234567891011class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125; 然后，下列代码会创建并启动一个线程,必须用start()方法： 12PrimeThread p = new PrimeThread(143);p.start(); 创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。采用这种风格的同一个例子如下所示： 1234567891011class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125;&#125; 然后，下列代码会创建并启动一个线程： 12PrimeRun p = new PrimeRun(143);new Thread(p).start(); 08实现线程程序继承Thread线程对象调用 run方法和调用start方法区别？线程对象调用run方法不开启线程。仅是对象调用方法。线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。 1234567891011121314151617181920212223242526272829*A:实现线程程序继承Thread /* * 创建和启动一个线程 * 创建Thread子类对象 * 子类对象调用方法start() * 让线程程序执行,JVM调用线程中的run */ public class ThreadDemo &#123; public static void main(String[] args) &#123; SubThread st = new SubThread(); SubThread st1 = new SubThread(); st.start(); st1.start(); for(int i = 0; i &lt; 50;i++)&#123; System.out.println("main..."+i); &#125; &#125; &#125; /* * 定义子类,继承Thread * 重写方法run */ public class SubThread extends Thread&#123; public void run()&#123; for(int i = 0; i &lt; 50;i++)&#123; System.out.println("run..."+i); &#125; &#125; &#125; 09线程执行的随机性12345678910111213141516171819202122232425262728293031323334353637383940*A:线程执行的随机性 * 代码分析: 整个程序就只有三个线程, 一个是主线程 启动另外两个线程 st.start(); st1.start(); for(int i = 0; i &lt; 50;i++)&#123; System.out.println("main..."+i); &#125; 一个是st(Thread-0)线程 for(int i = 0; i &lt; 50;i++)&#123; System.out.println("run..."+i); &#125; 一个是st1(Thread-1)线程下 * public class ThreadDemo &#123; public static void main(String[] args) &#123; SubThread st = new SubThread(); SubThread st1 = new SubThread(); st.start(); st1.start(); for(int i = 0; i &lt; 50;i++)&#123; System.out.println("main..."+i); &#125; &#125; &#125; /* * 定义子类,继承Thread * 重写方法run */ public class SubThread extends Thread&#123; public void run()&#123; for(int i = 0; i &lt; 50;i++)&#123; System.out.println("run..."+i); &#125; &#125; &#125; 10为什么要继承Thread*A:什么要继承Threada:我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？ 继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？ 如下代码： Thread t1 = new Thread(); t1.start();//这样做没有错，但是该start调用的是Thread类中的run方法 //而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。Thread类run方法中的任务并不是我们所需要的，只有重写这个run方法。既然Thread类已经定义了线程任务的编写位置（run方法），那么只要在编写位置（run方法）中定义任务代码即可。所以进行了重写run方法动作 b:创建线程的目的是什么？ 是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。 对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。 11多线程内存图解*A:多线程内存图解 多线程执行时，到底在内存中是如何运行的呢？多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 12获取线程名字Thread类方法getName123456789101112131415161718192021222324252627282930313233*A:获取线程名字Thread类方法getName /* * 获取线程名字,父类Thread方法 * String getName() */ public class NameThread extends Thread&#123; public NameThread()&#123; super("小强"); &#125; public void run()&#123; System.out.println(getName()); &#125; &#125; "/* * 每个线程,都有自己的名字 * 运行方法main线程,名字就是"main" * 其他新键的线程也有名字,默认 "Thread-0","Thread-1" * * JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是 * Thread类对象 */" public class ThreadDemo &#123; public static void main(String[] args) &#123; NameThread nt = new NameThread(); nt.start(); &#125; &#125; 13获取线程名字Thread类方法currentThread12345678910111213141516171819202122232425262728293031323334*A:获取线程名字Thread类方法currentThread /* * 获取线程名字,父类Thread方法 * String getName() */ public class NameThread extends Thread&#123; public void run()&#123; System.out.println(getName()); &#125; &#125; * * 每个线程,都有自己的名字 * 运行方法main线程,名字就是"main" * 其他新键的线程也有名字,默认 "Thread-0","Thread-1" * * JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是 * Thread类对象 * Thread类中,静态方法 * static Thread currentThread()返回正在执行的线程对象 * public class ThreadDemo &#123; public static void main(String[] args) &#123; NameThread nt = new NameThread(); nt.start(); /*Thread t =Thread.currentThread(); System.out.println(t.getName());*/ System.out.println(Thread.currentThread().getName()); &#125; &#125; 14线程名字设置12345678910111213141516171819202122232425262728293031323334A:线程名字设置 "/* * 获取线程名字,父类Thread方法 * String getName() */" public class NameThread extends Thread&#123; public NameThread()&#123; super("小强"); &#125; public void run()&#123; System.out.println(getName()); &#125; &#125; "/* * 每个线程,都有自己的名字 * 运行方法main线程,名字就是"main" * 其他新键的线程也有名字,默认 "Thread-0","Thread-1" * * JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是 * Thread类对象 * Thread类中,静态方法 * static Thread currentThread()返回正在执行的线程对象 */" public class ThreadDemo &#123; public static void main(String[] args) &#123; NameThread nt = new NameThread(); nt.setName("旺财"); nt.start(); &#125; &#125; 15Thread类方法sleep123456789101112131415161718192021222324A:Thread类方法sleep public class ThreadDemo &#123; public static void main(String[] args) throws Exception&#123; /*for(int i = 0 ; i &lt; 5 ;i++)&#123; Thread.sleep(50); System.out.println(i); &#125;*/ new SleepThread().start(); &#125; &#125; public class SleepThread extends Thread&#123; public void run()&#123; for(int i = 0 ; i &lt; 5 ;i++)&#123; try&#123; Thread.sleep(500);//睡眠500ms,500ms已到并且cpu切换到该线程继续向下执行 &#125;catch(Exception ex)&#123; &#125; System.out.println(i); &#125; &#125; &#125; 16实现线程的另一种方式实现Runnable接口12345678910111213141516171819202122232425262728A:实现线程的另一种方式实现Runnable接口 "/* * 实现接口方式的线程 * 创建Thread类对象,构造方法中,传递Runnable接口实现类 * 调用Thread类方法start() */" public class ThreadDemo &#123; public static void main(String[] args) &#123; SubRunnable sr = new SubRunnable(); Thread t = new Thread(sr); t.start(); for(int i = 0 ; i &lt; 50; i++)&#123; System.out.println("main..."+i); &#125; &#125; &#125; "/* * 实现线程成功的另一个方式,接口实现 * 实现接口Runnable,重写run方法 */" public class SubRunnable implements Runnable&#123; public void run()&#123; for(int i = 0 ; i &lt; 50; i++)&#123; System.out.println("run..."+i); &#125; &#125; &#125; 17实现Runnable接口方式的原理和好处A:实现接口方式的原理为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？实现Runnable接口，避免了继承Thread类的单继承局限性。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务。 B:实现接口方式的好处 第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。 实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。 继承Thread类，线程对象和线程任务耦合在一起。 一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。 实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。 (降低紧密性或者依赖性,创建线程和执行任务不绑定) 18匿名内部类实现线程程序1234567891011121314151617181920212223242526272829303132333435*A:匿名内部类实现线程程序 /* * 使用匿名内部类,实现多线程程序 * 前提: 继承或者接口实现 * new 父类或者接口()&#123; * 重写抽象方法 * &#125; */public class ThreadDemo &#123; public static void main(String[] args) &#123; //继承方式 XXX extends Thread&#123; public void run()&#123;&#125;&#125; new Thread()&#123; public void run()&#123; System.out.println("!!!"); &#125; &#125;.start(); //实现接口方式 XXX implements Runnable&#123; public void run()&#123;&#125;&#125; Runnable r = new Runnable()&#123; public void run()&#123; System.out.println("###"); &#125; &#125;; new Thread(r).start(); new Thread(new Runnable()&#123; public void run()&#123; System.out.println("@@@"); &#125; &#125;).start(); &#125;&#125; 19线程的状态图 A:线程的状态图 20线程池的原理线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 A:线程池的原理 1.在java中，如果每个请求到达就创建一个新线程，开销是相当大的。 2.在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大， 甚至可能要比在处理实际的用户请求的时间和资源要多的多。 3.除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。 如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。 为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目， 尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。 线程池主要用来解决线程生命周期开销问题和资源不足问题。 通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在， 所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。 另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。 21JDK5实现线程池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。  Executors：线程池创建"工厂类" public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象 ExecutorService：线程池类 Future&lt;?&gt; submit(Runnable task)：获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用 使用线程池中线程对象的步骤： 创建线程池对象 创建Runnable接口子类对象 提交Runnable接口子类对象 关闭线程池 A:JDK5实现线程池public static ExecutorService newFixedThreadPool(int nThreads)创建一个可重用固定线程数的线程池，以共享的(无界队列方式)来运行这些线程。在任意点，在(大多数) nThreads 线程会处于(处理任务的活动状态)。如果在所有线程处于活动状态时提交附加任务，(则在有可用线程之前），（附加任务将在队列中等待）。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。（在某个线程被显式地关闭之前），（池中的线程将一直存在）。 参数：nThreads - （池中的线程数） 返回：新创建的线程池 * * JDK1.5新特性,实现线程池程序 * 使用工厂类 Executors中的静态方法创建线程对象,指定线程的个数 * static ExecutorService newFixedThreadPool(int 个数) 返回线程池对象 * 返回的是ExecutorService接口的实现类 (线程池对象) * * 接口实现类对象,调用方法submit (Ruunable r) 提交线程执行任务 * * public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; "//调用工厂类的静态方法,创建线程池对象" "//返回线程池对象,是返回的接口" ExecutorService es = Executors.newFixedThreadPool(2); "//调用接口实现类对象es中的方法submit提交线程任务" "//将Runnable接口实现类对象,传递" es.submit(new ThreadPoolRunnable()); es.submit(new ThreadPoolRunnable()); "//如果线程池大小为2，第3个线程则会等待在前2个线程结束之后才运行" es.submit(new ThreadPoolRunnable()); "注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中" //关闭线程池 //es.shutdown(); &#125; &#125; public class ThreadPoolRunnable implements Runnable &#123; public void run()&#123; System.out.println(Thread.currentThread().getName()+" 线程提交任务"); &#125; &#125; 22实现线程的Callable接口方式12345678910111213141516171819202122232425262728293031323334353637383940414243Callable接口：与Runnable接口功能相似，用来指定线程的任务。其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。ExecutorService：线程池类&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：获取线程池中的某一个线程对象，并执行线程中的call()方法Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用使用线程池中线程对象的步骤：创建线程池对象创建Callable接口子类对象提交Callable接口子类对象关闭线程池 A:实现线程的Callable接口方式 * * 实现线程程序的第三个方式,实现Callable接口方式 * 实现步骤 * 工厂类 Executors静态方法public static ExecutorService newFixedThreadPool(int nThreads)： * 利用newFixedThreadPool方法,创建线程池对象 * 线程池对象ExecutorService接口实现类,调用方法submit提交线程任务 * Future&lt;?&gt; submit(Callable c) * public class ThreadPoolDemo1 &#123; public static void main(String[] args)throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(2); "//提交线程任务的方法submit方法返回 Future接口的实现类" Future&lt;String&gt; f = es.submit(new ThreadPoolCallable()); String s = f.get(); System.out.println(s); &#125; &#125; /* * Callable 接口的实现类,作为线程提交任务出现 * 使用方法返回值 */ import java.util.concurrent.Callable; public class ThreadPoolCallable implements Callable&lt;String&gt;&#123; public String call()&#123; return "abc"; &#125; &#125; 23线程实现异步计算123456789101112131415161718192021222324252627282930313233A:线程实现异步计算 /* * 使用多线程技术,求和 * 两个线程,1个线程计算1+100,另一个线程计算1+200的和 * 多线程的异步计算 */ public class ThreadPoolDemo &#123; public static void main(String[] args)throws Exception &#123; ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;Integer&gt; f1 =es.submit(new GetSumCallable(100)); Future&lt;Integer&gt; f2 =es.submit(new GetSumCallable(200)); System.out.println(f1.get()); System.out.println(f2.get()); es.shutdown(); &#125; &#125; public class GetSumCallable implements Callable&lt;Integer&gt;&#123; private int a; public GetSumCallable(int a)&#123; this.a=a; &#125; public Integer call()&#123; int sum = 0 ; for(int i = 1 ; i &lt;=a ; i++)&#123; sum = sum + i ; &#125; return sum; &#125; &#125; 总结1234567891011121314151617181920212223242526272829303132333435363738394041创建线程的方式方式1，继承Thread线程类步骤 1， 自定义类继承Thread类 2， 在自定义类中重写Thread类的run方法 3， 创建自定义类对象(线程对象) 4， 调用start方法，启动线程，通过JVM，调用线程中的run方法方式2，实现Runnable接口步骤 1， 创建线程任务类 实现Runnable接口 2， 在线程任务类中 重写接口中的run方法 3， 创建线程任务类对象 4， 创建线程对象，把线程任务类对象作为Thread类构造方法的参数使用 5， 调用start方法，启动线程，通过JVM，调用线程任务类中的run方法方式3和4 线程池：&gt;&gt;&gt;&gt;1、通过Runnable接口，run()方法没有返回值通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。  Executors：线程池创建"工厂类" public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象 ExecutorService：线程池类 Future&lt;?&gt; submit(Runnable task)：获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用 使用线程池中线程对象的步骤： 创建线程池对象 创建Runnable接口子类对象 提交Runnable接口子类对象 关闭线程池&gt;&gt;&gt;&gt;2、通过Callable接口，call()方法有返回值ExecutorService：线程池类&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：获取线程池中的某一个线程对象，并执行线程中的call()方法Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用使用线程池中线程对象的步骤：创建线程池对象创建Callable接口子类对象提交Callable接口子类对象关闭线程池]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础23(Properties集合,序列化流与反序列化流,打印流)]]></title>
    <url>%2F2016%2F11%2F19%2Fday25%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Properties集合2、序列化流与反序列化流3、打印流4、commons-IO 01Properties集合的特点 A: Properties集合的特点 a: Properties类介绍 Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串 b: 特点 Hashtable的子类，map集合中的方法都可以用。 该集合没有泛型。键值都是字符串。 它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。 有和流技术相结合的方法。 c: 方法介绍 123456789101112 void test()* load(InputStream inputStream) * 把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中* load(Reader reader) * 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）* store(OutputStream outputStream,String commonts) * 把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息* stroe(Writer writer,String comments) * 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符 02Properties集合存储键值对123456789101112131415161718192021222324252627282930313233343536* A: Properties集合存储键值对 * a: 方法介绍 void test() * 集合对象Properties类,继承Hashtable,实现Map接口 * 可以和IO对象结合使用,实现数据的持久存储 * 使用Properties集合,存储键值对 * setProperty等同与Map接口中的put * setProperty(String key, String value) * 通过键获取值, getProperty(String key)* b: 案例代码public class PropertiesDemo &#123; public static void main(String[] args)throws IOException &#123; function_2(); &#125; /* * 使用Properties集合,存储键值对 * setProperty等同与Map接口中的put * setProperty(String key, String value) * 通过键获取值, getProperty(String key) */ public static void function()&#123; Properties pro = new Properties(); pro.setProperty("a", "1"); pro.setProperty("b", "2"); pro.setProperty("c", "3"); System.out.println(pro); String value = pro.getProperty("c"); System.out.println(value); //方法stringPropertyNames,将集合中的键存储到Set集合,类似于Map接口的方法keySet Set&lt;String&gt; set = pro.stringPropertyNames(); for(String key : set)&#123; System.out.println(key+"..."+pro.getProperty(key)); &#125; &#125;&#125; 03Properties集合的方法load123456789101112131415161718192021222324252627282930* A: Properties集合的方法load* a: 方法介绍 void test() * Properties集合特有方法 load * load(InputStream in)) * load(Reader r) * 传递任意的字节或者字符输入流 * 流对象读取文件中的键值对,保存到集合 * b: 案例代码 public class PropertiesDemo &#123; public static void main(String[] args)throws IOException &#123; function_1(); &#125; /* * Properties集合特有方法 load * load(InputStream in) * load(Reader r) * 传递任意的字节或者字符输入流 * 流对象读取文件中的键值对,保存到集合 */ public static void function_1()throws IOException&#123; Properties pro = new Properties(); FileReader fr = new FileReader("c:\\pro.properties"); //调用集合的方法load,传递字符输入流 pro.load(fr); fr.close(); System.out.println(pro); &#125; &#125; 04Properties集合的方法store12345678910111213141516171819202122232425262728* A: Properties集合的方法store* a: 方法介绍 void test() * Properties集合的特有方法store * store(OutputStream out,String comments) * store(Writer w,String comments) * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存* b: 案例代码 public class PropertiesDemo &#123; public static void main(String[] args)throws IOException &#123; function_2(); &#125; /* * Properties集合的特有方法store * store(OutputStream out) * store(Writer w) * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存 */ public static void function_2()throws IOException&#123; Properties pro = new Properties(); pro.setProperty("name", "zhangsan"); pro.setProperty("age", "31"); pro.setProperty("email", "123456789@163.com"); FileWriter fw = new FileWriter("c:\\pro.properties"); //键值对,存回文件,使用集合的方法store传递字符输出流 pro.store(fw, ""); fw.close(); &#125; &#125; 05对象的序列化与反序列化 A: 对象的序列化与反序列化 a: 基本概念 对象的序列化 对象中的数据，以流的形式，写入到文件中保存过程称为写出对象，对象的序列化 ObjectOutputStream将对象写道文件中，实现序列化 对象的反序列化 在文件中，以流的形式，将对象读出来，读取对象，对象的反序列化 ObjectInputStream 将文件对象读取出来，对象的反序列化 06ObjectOutputStream流写对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061* A: ObjectOutputStream流写对象* a: 简单介绍 void test() * IO流对象,实现对象Person序列化,和反序列化 * ObjectOutputStream 写对象,实现序列化 * ObjectInputStream 读取对象,实现反序列化 ObjectOutputStream流构造方法: ObjectOutputStream(OutputStream out) * final void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。* b: 案例代码 public class Person implements Serializable&#123; public String name; public int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; &#125; public class ObjectStreamDemo &#123; public static void main(String[] args)throws IOException, ClassNotFoundException &#123; // writeObject(); readObject(); &#125; /* * ObjectOutputStream * 构造方法: ObjectOutputStream(OutputSteam out) * 传递任意的字节输出流 * void writeObject(Object obj)写出对象的方法 */ public static void writeObject() throws IOException&#123; //创建字节输出流,封装文件 FileOutputStream fos = new FileOutputStream("c:\\person.txt"); //创建写出对象的序列化流的对象,构造方法传递字节输出流 ObjectOutputStream oos = new ObjectOutputStream(fos); Person p = new Person("lisi",25); //调用序列化流的方法writeObject,写出对象 oos.writeObject(p); oos.close(); &#125; &#125; 07ObjectInputStream流读取对象1234567891011121314151617181920212223242526272829303132* A: ObjectInputStream流读取对象* a: 简单介绍 void test() * ObjectInputStream * 构造方法:ObjectInputStream(InputStream in) * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件 * Object readObject() 读取对象* b: 案例代码 /* * IO流对象,实现对象Person序列化,和反序列化 * ObjectOutputStream 写对象,实现序列化 * ObjectInputStream 读取对象,实现反序列化 */ public class ObjectStreamDemo &#123; public static void main(String[] args)throws IOException, ClassNotFoundException &#123; readObject(); &#125; /* * ObjectInputStream * 构造方法:ObjectInputStream(InputStream in) * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件 * Object readObject() 读取对象 */ public static void readObject() throws IOException, ClassNotFoundException&#123; FileInputStream fis = new FileInputStream("c:\\person.txt"); //创建反序列化流,构造方法中,传递字节输入流 ObjectInputStream ois = new ObjectInputStream(fis); //调用反序列化流的方法 readObject()读取对象 Object obj =ois.readObject(); System.out.println(obj); ois.close(); &#125; &#125; 08静态不能序列化 A: 静态不能序列化 a: 原因 序列化是把对象数据进行持久化存储 静态不属于对象，而属于类 09transient 瞬态关键字 A: transient关键字 a: 作用 被transient修饰的属性不会被序列化 transient关键字只能修饰成员变量 10Serializable接口的含义 A：Serializable接口的含义 a: 作用 给需要序列化的类上加标记。该标记中没有任何抽象方法 只有实现了 Serializable接口的类的对象才能被序列化 11序列化中的序列号冲突问题 A: 序列化中的序列号冲突问题 a: 问题产生原因 当一个类实现Serializable接口后，创建对象并将对象写入文件，之后更改了源代码(比如：将成员变量的修饰符有private改成public)， 再次从文件中读取对象时会报异常 12序列化中自定义的序列号 A: 序列化中自定义的序列号 a: 定义方式 private static final long serialVersionUID = 1478652478456L; 这样每次编译类时生成的serialVersionUID值都是固定的 b: 案例代码 123456789101112131415161718192021222324252627282930public class Person implements Serializable&#123; public String name; public /*transient阻止成员变量序列化*/ int age; //类,自定义了序列号,编译器不会计算序列号 private static final long serialVersionUID = 1478652478456L; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; &#125; 13打印流和特性123456789101112131415161718192021* A: 打印流和特性* a: 概述 void test() * 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式. * 打印流根据流的分类： * 字节打印流 PrintStream * 字符打印流 PrintWriter * 方法： * void print(String str): 输出任意类型的数据， * void println(String str): 输出任意类型的数据，自动写入换行操作* b: 特点 * 此流不负责数据源,只负责数据目的 * 为其他输出流,添加功能 * 永远不会抛出IOException，但是可能抛出别的异常 * 两个打印流的方法,完全一致 * 构造方法,就是打印流的输出目的端——————————————————————————————————————————————————————————————————————————————————————————————— * PrintStream() 构造方法 * 接收File类型,接收字符串文件名,接收字节输出流OutputStream * PrintWriter() 构造方法 * (接收File类型,接收字符串文件名,接收字节输出流OutputStream, 接收字符输出流Writer)——————————————————————————————————————————————————————————————————————————————————————————————— 14打印流输出目的是File对象12345678910111213141516171819202122* A: 打印流输出目的是File对象* a: 案例代码 public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; function_3(); &#125; * * 打印流,向File对象的数据目的写入数据 * "方法print println 原样输出" * "write方法走码表" * public static void function() throws FileNotFoundException&#123; File file = new File("c:\\1.txt"); PrintWriter pw = new PrintWriter(file); pw.println(true);// true pw.println(100);// 100 pw.write(100);// d pw.close(); &#125; &#125; 15输出语句是char数组123456789101112131415161718* A: 输出语句是char数组* a: 案例代码 public class Demo &#123; public static void main(String[] args) &#123; int[] arr = &#123;1&#125;; System.out.println(arr); char[] ch = &#123;'a','b'&#125;; System.out.println(ch);//打印 ab byte[] b = &#123;&#125;; System.out.println(b); &#125; &#125;* b: 结果分析* println数组，只有打印字符数组时只有容，其余均打印数组的地址 * 因为api中"定义了打印字符数组"的方法，其底层是在"遍历数组中的元素" * 而其他打印数组的方法，都是将数组对象编程Object，其底层再将对象编程String，调用了String s = String.valueOf(x);方法 16打印流输出目的是String和流对象123456789101112131415161718192021222324252627282930* A: 打印流输出目的是String和流对象* a: 案例代码 public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; function_2(); &#125; /* * 打印流,输出目的,是流对象 * 可以是字节输出流,可以是字符的输出流 * OutputStream Writer */ public static void function_2() throws IOException&#123; // FileOutputStream fos = new FileOutputStream("c:\\3.txt"); FileWriter fw = new FileWriter("c:\\4.txt"); PrintWriter pw = new PrintWriter(fw); pw.println("打印流"); pw.close(); &#125; /* * 打印流,输出目的,String文件名 */ public static void function_1() throws FileNotFoundException&#123; PrintWriter pw = new PrintWriter("c:\\2.txt"); pw.println(3.5); pw.close(); &#125; &#125; 17打印流开启自动刷新123456789101112131415161718192021222324* A: 打印流开启自动刷新* 案例代码 public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; function_3(); &#125; "/* * 打印流,可以开启自动刷新功能 * 满足2个条件: * 1. 输出的数据目的必须是流对象 * OutputStream Writer * 2. 必须调用println,printf,format三个方法中的一个,启用自动刷新 */" public static void function_3()throws IOException&#123; //File f = new File("XXX.txt"); FileOutputStream fos = new FileOutputStream("c:\\5.txt"); PrintWriter pw = new PrintWriter(fos,true); pw.println("i"); pw.println("love"); pw.println("java"); pw.close(); &#125; &#125; 18打印流复制文本文件12345678910111213141516171819* A: 打印流复制文本文件* a: 案例代码 "/* * 打印流实现文本复制 * 读取数据源 BufferedReader+File 读取文本行 * 写入数据目的 PrintWriter+println 自动刷新 */" public class PrintWriterDemo1 &#123; public static void main(String[] args) throws IOException&#123; BufferedReader bfr = new BufferedReader(new FileReader("c:\\a.txt")); PrintWriter pw = new PrintWriter(new FileWriter("d:\\a.txt"),true); String line = null; while((line = bfr.readLine())!=null)&#123; pw.println(line); &#125; pw.close(); bfr.close(); &#125; &#125; 19commons-io工具类介绍 A: commons-io工具类介绍 a: 工具类介绍 解压缩commons-io-2.4.zip文件 commons-io-2.4.jar需要导入到项目中的jar包，里面存放的是class文件 commons-io-2.4-sources.jar工具类中原代码 docs是帮助文档 20使用工具类commons_io A: 使用工具类commons_io a: 导入jar包 加入classpath的第三方jar包内的class文件才能在项目中使用 创建lib文件夹 将commons-io.jar拷贝到lib文件夹 右键点击commons-io.jar，Build Path→Add to Build Pathidea 是 Add as Libirary b: 学会如何看源代码,需要添加source文件：commons-io-2.4-sources.jar 21IO工具类FilenameUtils123456789101112131415161718192021222324252627282930313233343536373839404142* A: IO工具类FilenameUtils* a: 方法介绍 void test() * getExtension(String path)：获取文件的扩展名； * getName()：获取文件名； * isExtension(String fileName,String ext)：判断fileName是否是ext后缀名；* b: 案例代码* public class Commons_IODemo &#123; public static void main(String[] args) &#123; function_2(); &#125; /* * FilenameUtils类的方法 * static boolean isExtension(String filename,String extension) * 判断文件名的后缀是不是extension */ public static void function_2()&#123; boolean b = FilenameUtils.isExtension("Demo.java", "java"); System.out.println(b); &#125; /* * FilenameUtils类的方法 * static String getName(String filename) * 获取文件名 */ public static void function_1()&#123; String name = FilenameUtils.getName("c:\\windows\\"); System.out.println(name); &#125; /* * FilenameUtils类的方法 * static String getExtension(String filename) * 获取文件名的扩展名 */ public static void function()&#123; String name = FilenameUtils.getExtension("c:\\windows"); System.out.println(name); &#125; &#125; 22IO工具类FileUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748* A: IO工具类FileUtils* a: 方法介绍 void test() * readFileToString(File file)：读取文件内容，并返回一个String； * writeStringToFile(File file，String content)：将内容content写入到file中； * copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制 * copyFile(File srcFile,File destFile);文件复制 * b: 案例代码public class Commons_IODemo1 &#123; public static void main(String[] args)throws IOException &#123; function_3(); &#125; /* * FileUtils工具类方法 * static void copyDirectoryToDirectory(File src,File desc) * 复制文件夹 */ public static void function_3() throws IOException&#123; FileUtils.copyDirectoryToDirectory(new File("d:\\demo"), new File("c:\\")); &#125; /* * FileUtils工具类的方法 * static void copyFile(File src,File desc) * 复制文件 */ public static void function_2() throws IOException&#123; FileUtils.copyFile(new File("c:\\k.jpg"),new File("d:\\k.jpg")); &#125; /* * FileUtils工具类的方法 * static void writeStringToFile(File src,String date) * 将字符串直接写到文件中 */ public static void function_1() throws IOException&#123; FileUtils.writeStringToFile(new File("c:\\b.txt"),"我爱Java编程"); &#125; /* * FileUtils工具类的方法 * static String readFileToString(File src)读取文本,返回字符串 */ public static void function() throws IOException&#123; String s = FileUtils.readFileToString(new File("c:\\a.txt")); System.out.println(s); &#125;&#125; 23总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 void test() 字节流  字节输入流 InputStream  FileInputStream() 操作文件的字节输入流  BufferedInputStream()高效的字节输入流  ObjectInputStream() 反序列化流  字节输出流 OutputStram  FileOutputStream() 操作文件的字节输出流  BufferedOutputStream() 高效的字节输出流  ObjectOuputStream() 序列化流  PrintStream() 字节打印流 字符流  字符输入流 Reader  FileReader()操作文件的字符输入流  BufferedReader() 高效的字符输入流  InputStreamReader() 输入操作的转换流(把字节流封装成字符流)  字符输出流 Writer  FileWriter()操作文件的字符输出流  BufferedWriter() 高效的字符输出流  OutputStreamWriter() 输出操作的转换流(把字节流封装成字符流)  PrintWriter() 字符打印流 方法： 读数据方法：  read() 一次读一个字节或字符的方法  read(byte[] char[]) 一次读一个数组数据的方法  readLine() 一次读一行字符串的方法(BufferedReader类特有方法)  readObject() 从流中读取对象(ObjectInputStream特有方法) 写数据方法：  write(int) 一次写一个字节或字符到文件中  write(byte[] char[]) 一次写一个数组数据到文件中  write(String) 一次写一个字符串内容到文件中  writeObject(Object ) 写对象到流中(ObjectOutputStream类特有方法)  newLine() 写一个换行符号(BufferedWriter类特有方法) 向文件中写入数据的过程 1，创建输出流对象 2，写数据到文件 3，关闭输出流 从文件中读数据的过程 1， 创建输入流对象 2， 从文件中读数据 3， 关闭输入流 文件复制的过程 1， 创建输入流（数据源） 2， 创建输出流（目的地） 3， 从输入流中读数据 4， 通过输出流，把数据写入目的地 5， 关闭流 File类 方法  获取文件名称 getName()  获取文件绝对路径 getAbsolutePath()  获取文件大小 length()  获取当前文件夹中所有File对象 File[] listFiles()  判断是否为文件 isFile()  判断是否为文件夹 isDirectory()  创建文件夹 mkdir() mkdirs()  创建文件 createNewFile() 异常  try..catch…finally捕获处理异常  throws 声明异常  throw 抛出异常对象 异常的分类  编译期异常 Exception |- 运行期异常 RuntimeException 注意： 编译期异常，必须处理，不然无法编译通过 运行期异常，程序运行过程中，产生的异常信息 Properties：Map集合的一种，它是Hashtable集合的子集合, 它键与值都是String类型,它是唯一能与IO流结合使用的集合 方法  load( InputStream in ) 从流所对应的文件中，读数据到集合中  load( Reader in ) 从流所对应的文件中，读数据到集合中  store( OutputStream out , String message ) 把集合中的数据，写入到流所对应的文件中  store( Writer out , String message) 把集合中的数据，写入到流所对应的文件中 实现文件内容的自动追加  构造方法  FileOutputStream(File file, boolean append)  FileOutputStream(String fileName, boolean append)  FileWriter(File, boolean append)  FileWriter(String fileName, boolean append) 实现文件内容的自动刷新  构造方法  PrintStream(OutputStream out, boolean autoFlush)  PrintWriter(OutputStream out, boolean autoFlush)  PrintWriter(Writer out, boolean autoFlush) Commons-IO 方法  readFileToString(File file)：读取文件内容，并返回一个String；  writeStringToFile(File file，String content)：将内容content写入到file中；  copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制  copyFileToDirectory (File srcFile,File destFile);文件复制]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础22(转换流,缓冲流)]]></title>
    <url>%2F2016%2F11%2F18%2Fday24%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、转换流2、缓冲流 01转换流概述 A: 转换流概述 a: 转换流概述 FileReader、FileWriter是在默认字符编码和默认字节缓冲区大小的情况下进行的，对于需要编码转换的情况不太方便。 OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节 将字符串按照指定的编码表转成字节，再使用字节流将这些字节写出去 02转换流_字符转字节的过程 OutputStreamWriter A: 转换流_字符转字节的过程 OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节。它的作用的就是，将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去。 03OutputStreamWriter写文本文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849* A: OutputStreamWriter写文本文件* a: OutputStreamWriter * java.io.OutputStreamWriter 继承Writer类 * 就是一个字符输出流，写文本文件 * write()字符，字符数组，字符串 * 字符通向字节的桥梁，将字符流转字节流 * OutputStreamWriter 使用方式 * void test() * 构造方法： * OutputStreamWriter(OuputStream out)接收所有的字节输出流 * 字节输出流： FileOutputStream * OutputStreamWriter(OutputStream out, String charsetName) * String charsetName 传递编码表名字 GBK UTF-8 * OutputStreamWriter 有个子类， FileWriter* b: 案例代码public class OutputStreamWriterDemo &#123; public static void main(String[] args)throws IOException &#123;// writeGBK(); writeUTF(); &#125; /* * 转换流对象OutputStreamWriter写文本 * 采用UTF-8编码表写入 */ public static void writeUTF()throws IOException&#123; //创建字节输出流，绑定文件 FileOutputStream fos = new FileOutputStream("c:\\utf.txt"); //创建转换流对象，构造方法保证字节输出流，并指定编码表是UTF-8 OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8"); osw.write("你好"); osw.close(); &#125; /* * 转换流对象 OutputStreamWriter写文本 * 文本采用GBK的形式写入 */ public static void writeGBK()throws IOException&#123; //创建字节输出流，绑定数据文件 FileOutputStream fos = new FileOutputStream("c:\\gbk.txt"); //创建转换流对象，构造方法，绑定字节输出流，使用GBK编码表 OutputStreamWriter osw = new OutputStreamWriter(fos); //转换流写数据 osw.write("你好"); osw.close(); &#125;&#125; 04转换流_字节转字符流过程 InputSteamReader1234567891011121314* A: 转换流_字节转字符流过程* a: InputStreamReader * java.io.InputStreamReader 继承 Reader * 字符输入流，读取文本文件 * 字节流向字符的敲了，将字节流转字符流 * 读取的方法: * read() 读取1个字符，读取字符数组 * 技巧 void test() * OuputStreamWriter写了文件 * InputStreamReader读取文件 * OutputStreamWriter(OutputStream out)所有字节输出流 * InputStreamReader(InputStream in) 接收所有的字节输入流 * 可以传递的字节输入流： FileInputStream * InputStreamReader(InputStream in,String charsetName) 传递编码表的名字 b: 图解 05InputSteamReader读取文本文件12345678910111213141516171819202122232425262728293031323334353637* A: InputSteamReader读取文本文件* a: 案例代码 public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // readGBK(); readUTF(); &#125; /* * 转换流,InputSteamReader读取文本 * 采用UTF-8编码表,读取文件utf */ public static void readUTF()throws IOException&#123; //创建自己输入流,传递文本文件 FileInputStream fis = new FileInputStream("c:\\utf.txt"); //创建转换流对象,构造方法中,包装字节输入流,同时写编码表名 InputStreamReader isr = new InputStreamReader(fis,"UTF-8"); char[] ch = new char[1024]; int len = isr.read(ch); System.out.println(new String(ch,0,len)); isr.close(); &#125; /* * 转换流,InputSteamReader读取文本 * 采用系统默认编码表,读取GBK文件 */ public static void readGBK()throws IOException&#123; //创建自己输入流,传递文本文件 FileInputStream fis = new FileInputStream("c:\\gbk.txt"); //创建转换流对象,构造方法,包装字节输入流 InputStreamReader isr = new InputStreamReader(fis); char[] ch = new char[1024]; int len = isr.read(ch); System.out.println(new String(ch,0,len)); isr.close(); &#125; &#125; 06转换流子类父类的区别123456789101112131415* A: 转换流子类父类的区别* a: 继承关系 OutputStreamWriter: |--FileWriter: InputStreamReader: |--FileReader;* b: 区别* OutputStreamWriter和InputStreamReader是"字符和字节"的桥梁：也可以称之为"字符转换流"。* "字符转换流原理：字节流+编码表"。* FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。 "当操作的字符文件，使用的是默认编码表时可以不用父类"，而直接用子类就完成操作了，简化了代码。* 以下三句话功能相同 * InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"));//默认字符集。 * InputStreamReader isr = new InputStreamReader(new FileInputStream("a.txt"),"GBK");//指定GBK字符集。 * FileReader fr = new FileReader("a.txt"); 07缓冲流概述 A: 缓冲流概述 a: 概述 可提高IO流的读写速度 分为字节缓冲流与字符缓冲流 08字节输出流缓冲流BufferedOutputStream123456789101112131415161718192021222324252627282930* A: 字节输出流缓冲流BufferedOutputStream* a: BufferedOutputStream * 字节输出流的缓冲流 void test() * java.io.BufferedOuputStream 作用: 提高原有输出流的写入效率 * BufferedOuputStream 继承 OutputStream * 方法,写入 write 字节,字节数组 * 构造方法: * BufferedOuputStream(OuputStream out) * 可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率 * b: 案例代码public class BufferedOutputStreamDemo &#123; public static void main(String[] args)throws IOException &#123; //创建字节输出流,绑定文件 //FileOutputStream fos = new FileOutputStream("c:\\buffer.txt"); //创建字节输出流缓冲流的对象,构造方法中,传递字节输出流 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("c:\\buffer.txt")); bos.write(55); byte[] bytes = "HelloWorld".getBytes(); bos.write(bytes); bos.write(bytes, 3, 2); bos.close(); &#125;&#125; 09字节输入流缓冲流BufferedInputStream1234567891011121314151617181920212223* A: 字节输入流缓冲流BufferedInputStream* a: BufferedInputStream * 字节输入流的缓冲流 void test() * 继承InputStream,标准的字节输入流 * 读取方法 read() 单个字节,字节数组 * 构造方法: * BufferedInputStream(InputStream in) * 可以传递任意的字节输入流,传递是谁,就提高谁的效率 * 可以传递的字节输入流 FileInputStream* b: 案例代码public class BufferedInputStreamDemo &#123; public static void main(String[] args) throws IOException&#123; //创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("c:\\buffer.txt")); byte[] bytes = new byte[10]; int len = 0 ; while((len = bis.read(bytes))!=-1)&#123; System.out.print(new String(bytes,0,len)); &#125; bis.close(); &#125;&#125; 10四种文件复制方式的效率比较 A：四种文件复制方式的效率比较 a: 四中复制方式 字节流读写单个字节 125250 毫秒 字节流读写字节数组 193 毫秒 OK 字节流缓冲区流读写单个字节 1210 毫秒 字节流缓冲区流读写字节数组 73 毫秒 OK b: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Copy &#123; public static void main(String[] args)throws IOException &#123; long s = System.currentTimeMillis(); copy_4(new File("c:\\q.exe"), new File("d:\\q.exe")); long e = System.currentTimeMillis(); System.out.println(e-s); &#125; "/* * 方法,实现文件复制 * 4. 字节流缓冲区流读写字节数组 */" public static void copy_4(File src,File desc)throws IOException&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc)); int len = 0 ; byte[] bytes = new byte[1024]; while((len = bis.read(bytes))!=-1)&#123; bos.write(bytes,0,len); &#125; bos.close(); bis.close(); &#125; /* * 方法,实现文件复制 * 3. 字节流缓冲区流读写单个字节 */ public static void copy_3(File src,File desc)throws IOException&#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(desc)); int len = 0 ; while((len = bis.read())!=-1)&#123; bos.write(len); &#125; bos.close(); bis.close(); &#125; /* * 方法,实现文件复制 * 2. 字节流读写字节数组 */ public static void copy_2(File src,File desc)throws IOException&#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(desc); int len = 0 ; byte[] bytes = new byte[1024]; while((len = fis.read(bytes))!=-1)&#123; fos.write(bytes,0,len); &#125; fos.close(); fis.close(); &#125; /* * 方法,实现文件复制 * 1. 字节流读写单个字节 */ public static void copy_1(File src,File desc)throws IOException&#123; FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(desc); int len = 0 ; while((len = fis.read())!=-1)&#123; fos.write(len); &#125; fos.close(); fis.close(); &#125;&#125; 11字符输出流缓冲流BufferedWriter123456789101112131415161718192021222324252627282930313233343536373839* A: 字符输出流缓冲流BufferedWriter* a: BufferedWriter * 字符输出流缓冲区流 * java.io.BufferedWriter 继承 Writer * 写入方法 write () 单个字符,字符数组,字符串 * 构造方法: * BufferedWriter(Writer w)传递任意字符输出流 * 传递谁,就高效谁 * 能传递的字符输出流 FileWriter, OutputStreamWriter* b: 案例代码 public class BufferedWrierDemo &#123; public static void main(String[] args) throws IOException&#123; //创建字符输出流,封装文件 FileWriter fw = new FileWriter("c:\\buffer.txt"); BufferedWriter bfw = new BufferedWriter(fw); bfw.write(100); bfw.flush(); bfw.write("你好".toCharArray()); bfw.flush(); bfw.write("你好"); bfw.flush(); bfw.write("我好好"); bfw.flush(); bfw.write("大家都好"); bfw.flush(); bfw.close(); &#125; &#125; 12字符输出流缓冲流BufferedWriter特有方法newLine12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849* A: 字符输出流缓冲流BufferedWriter特有方法newLine* a: 方法介绍 * void newLine() 写换行 * newLine()文本中换行, \r\n也是文本换行 * 方法具有平台无关性 * Windows \r\n * Linux \n * newLine()运行结果,和操作系统是相互关系 * JVM: 安装的是Windows版本,newLine()写的就是\r\n * 安装的是Linux版本,newLine()写的就是\n /* * 将数据源 c:\\a.txt * 复制到 d:\\a.txt 数据目的 * 字节输入流,绑定数据源 * 字节输出流,绑定数据目的 * * 输入,读取1个字节 * 输出,写1个字节 */* b: 案例代码 public class BufferedWrierDemo &#123; public static void main(String[] args) throws IOException&#123; //创建字符输出流,封装文件 FileWriter fw = new FileWriter("c:\\buffer.txt"); BufferedWriter bfw = new BufferedWriter(fw); bfw.write(100); bfw.flush(); bfw.write("你好".toCharArray()); bfw.flush(); bfw.write("你好"); bfw.newLine(); bfw.flush(); bfw.write("我好好"); bfw.newLine(); bfw.flush(); bfw.write("大家都好"); bfw.flush(); bfw.close(); &#125; &#125; 13字符输入流缓冲流BufferedReader A: 字符输入流缓冲流BufferedReader a: 概述 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取 public String readLine() 读取一个文本行，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null 14字符输入流缓冲流BufferedReader读取文本行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* A: 字符输入流缓冲流BufferedReader读取文本行* a: BufferedReader * 字符输入流缓冲流 * java.io.BufferedReader 继承 Reader * 读取功能 read() 单个字符,字符数组 * 构造方法: * BufferedReader(Reader r) * 可以任意的字符输入流 FileReader InputStreamReader * BufferedReader自己的功能 * String readLine() 读取文本行 \r\n * 方法读取到流末尾,返回null* b: 小特点 * 获取内容的方法一般都有返回值 * int 没有返回的都是负数 * 引用类型 找不到返回null * boolean 找不到返回false * c: 案例代码 public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; int lineNumber = 0; //创建字符输入流缓冲流对象,构造方法传递字符输入流,包装数据源文件 BufferedReader bfr = new BufferedReader(new FileReader("c:\\a.txt")); //调用缓冲流的方法 readLine()读取文本行 //循环读取文本行, 结束条件 readLine()返回null String line = null; while((line = bfr.readLine())!=null)&#123; lineNumber++; System.out.println(lineNumber+" "+line); &#125; bfr.close(); &#125; &#125; /* * String line = bfr.readLine(); System.out.println(line); line = bfr.readLine(); System.out.println(line); line = bfr.readLine(); System.out.println(line); line = bfr.readLine(); System.out.println(line); line = bfr.readLine(); System.out.println(line); */ 15字符流缓冲区流复制文本文件1234567891011121314151617181920212223* A: 字符流缓冲区流复制文本文件* a: 案例代码 /* * 使用缓冲区流对象,复制文本文件 * 数据源 BufferedReader+FileReader 读取 * 数据目的 BufferedWriter+FileWriter 写入 * 读取文本行, 读一行,写一行,写换行 */ public class Copy_1 &#123; public static void main(String[] args) throws IOException&#123; BufferedReader bfr = new BufferedReader(new FileReader("c:\\w.log")); BufferedWriter bfw = new BufferedWriter(new FileWriter("d:\\w.log")); //读取文本行, 读一行,写一行,写换行 String line = null; while((line = bfr.readLine())!=null)&#123; bfw.write(line); bfw.newLine(); bfw.flush(); &#125; bfw.close(); bfr.close(); &#125; &#125; 16IO流对象的操作规律123456789101112131415161718192021222324252627282930* A: IO流对象的操作规律* a: 明确一：要操作的数据是数据源还是数据目的。 * 源：InputStream Reader * 目的：OutputStream Writer * 先根据需求明确要读，还是要写。* b: 明确二：要操作的数据是字节还是文本呢？ * 源： * 字节：InputStream * 文本：Reader * 目的： * 字节：OutputStream * 文本：Writer* c: 明确三：明确数据所在的具体设备。 * 源设备： * 硬盘：文件 File开头。 * 内存：数组，字符串。 * 键盘：System.in; * 网络：Socket * 目的设备： * 硬盘：文件 File开头。 * 内存：数组，字符串。 * 屏幕：System.out * 网络：Socket * 完全可以明确具体要使用哪个流对象。* d: 明确四：是否需要额外功能呢？ * 额外功能： * 转换吗？转换流。InputStreamReader OutputStreamWriter * 高效吗？缓冲区对象。BufferedXXX * 已经明确到了具体的体系上。 17总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364InputStream FileInputStream BufferedInputStream OuputStream FileOutputStream BufferedOuputStreamWriter OutputStreamWriter FileWriter BufferedWriterReader InputStreamReader FileReader BufferedReader void test()字节流 字节输入流 InputStream FileInputStream() 操作文件的字节输入流 BufferedInputStream() 高效的字节输入流 字节输出流 OutputStream FileOutputStream() 操作文件的字节输出流 BufferedOutputStream() 高效的字节输出流字符流 字符输入流 Reader FileReader() 操作文件的字符输入流 BufferedReader() 高效的字符输入流 InputStreamReader() 输入操作的转换流(把字节流封装成字符流) 字符输出流 Writer FileWriter() 操作文件的字符输出流 BufferedWriter() 高效的字符输出流 OutputStreamWriter() 输出操作的转换流(把字节流封装成字符流)方法： 读数据方法： read() 一次读一个字节或字符的方法 read(byte[] char[]) 一次读一个数组数据的方法 readLine() 一次读一行字符串的方法(BufferedReader类特有方法) readObject() 从流中读取对象(ObjectInputStream特有方法)写数据方法： write(int) 一次写一个字节或字符到文件中 write(byte[] char[]) 一次写一个数组数据到文件中 write(String) 一次写一个字符串内容到文件中 writeObject(Object ) 写对象到流中(ObjectOutputStream类特有方法) newLine() 写一个换行符号(BufferedWriter类特有方法)向文件中写入数据的过程 1，创建输出流对象 2，写数据到文件 3，关闭输出流  从文件中读数据的过程 1， 创建输入流对象 2， 从文件中读数据 3， 关闭输入流 文件复制的过程 1， 创建输入流（数据源） 2， 创建输出流（目的地） 3， 从输入流中读数据 4， 通过输出流，把数据写入目的地 5， 关闭流]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础：编译时和运行时的区别]]></title>
    <url>%2F2016%2F11%2F18%2FNew%20Document%2F</url>
    <content type="text"><![CDATA[在java开发设计过程中，了解java运行时和编译时的区别是非常有必要的。如下从几个问题来描述两者的区别 Q1: 如下代码片段中，A行和B行的区别是什么 A行是在编译时计算值，B行是在运行时计算值，当该类编译后，如果使用一些反编译器(如jd-gui)反编译后可以看到，实际代码如下： java编译时会做一些优化操作，比如替换一些final的不可变更的参数，在这里，由于number1和number2都是final的，那么product1肯定是确定的，这里就会在编译时计算出product1的值。 除了如上的一些代码优化话，再什么其他的情况下查看编译后的class文件是非常有用的？ java中的泛型。泛型是编译时会做优化，通过编译文件可以非常方便的看到其对应的实际类型，如下例子： 实际编码如下： 反编译后的代码如下： 可以，在编译后的文件中，Parent类会显示的被实际类型取代。 重写，重载，泛型，分别是在运行时还是编译时执行的? 方法重载是在编译时执行的，因为，在编译的时候，如果调用了一个重载的方法，那么编译时必须确定他调用的方法是哪个。如： 当调用evaluate(“hello”)时候，我们在编译时就可以确定他调用的method #1. 方法的重写是在运行时进行的。这个也常被称为运行时多态的体现。编译器是没有办法知道它调用的到底是那个方法，相反的，只有在jvm执行过程中，才知晓到底是父子类中的哪个方法被调用了。如下： 试想，当有如下一个接口的时候，我们是无法确定到底是调用父类还是子类的方法 泛型(类型检测)，这个发生在编译时。编译器会在编译时对泛型类型进行检测，并吧他重写成实际的对象类型(非泛型代码)，这样就可以被JVM执行了。这个过程被称为”类型擦除”。 类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。类型擦除的主要过程如下： 1). 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 2). 移除所有的类型参数。 在编译后变成： 注解。注解即有可能是运行时也有可能是编译时。 如java中的@Override注解就是典型的编译时注解，他会在编译时会检查一些简单的如拼写的错误(与父类方法不相同)等 同样的@Test注解是junit框架的注解，他是一个运行时注解，他可以在运行时动态的配置相关信息如timeout等。 异常。异常即有可能是运行时异常，也有可能是编译时异常。 RuntimeException是一个用于指示编译器不需要检查的异常。RuntimeException 是在jvm运行过程中抛出异常的父类。对于运行时异常是不需要再方法中显示的捕获或者处理的，如NullPointerException,ArrayIndexOutOfBoundsException 已检查的异常是被编译器在编译时候已经检查过的异常，这些异常需要在try/catch块中处理的异常。 AOP. Aspects能够在编译时，预编译时以及运行时使用。 1). 编译时：当你拥有源码的时候，AOP编译器(AspectJ编译器)能够编译源码并生成编织后的class。这些编织进入的额外功能是在编译时放进去的。 2). 预编译时：织入过程有时候也叫二进制织入，它是用来织入到哪些已经存在的class文件或者jar中的。 3). 运行时：当被织入的对象已经被加载如jvm中后，可以动态的织入到这些类中一些信息。 继承：继承是编译时执行的，它是静态的。这个过程编译后就已经确定 代理(delegate)：也称动态代理，是在运行时执行。 你如何理解”组合优于继承”这句话 继承是一个多态的工具，而非重用工具。在没有多态关联关系的对象间，一些程序员倾向于使用继承来保持重用。但事实是，只有当子类和父类的关系为”is a”的关系时候，继承才会使用。 不要使用继承来实现代码的重用。如果两者之间没有”is a”的关系，那么使用组合来实现重用。当父类的某个方法修改后，子类的相关实现也有可能会被更改。 不要为了多态而使用继承。如果你只是为了实现多态而采用继承模式，那么实际上组合模式更加适合你，而且更加简洁和灵活。 这也就是为什么GoF设计模式中常说”组合优于继承”的原因。 你能区分编译时继承和运行时继承的区别吗？请列举例子说明 实际上在java中只支持编译时继承。java语言原生是不支持运行时时继承的。一般情况下所谓编译时继承如下： 如上有两个类，其中Child为Parent的子类。当我们创建一个Parent实例的时候(无论实际对象为Parent还是Child)，编译器在编译期间会将其替换成实际类型。所以继承实际上在编译时就已经确定了。 而在java中，可以设计通过组合模式来尝试模拟下所谓的运行时继承。 在Child类中，其中有一个Parent实例。通过这种方式，我们动态的child类中代理了parent的相关功能]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础20(IO,File类,递归)]]></title>
    <url>%2F2016%2F11%2F16%2Fday22%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、File2、递归 01IO技术概述 A:IO技术概述 a: Output 把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作 b: Input 把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作 c: IO操作 把上面的这种输入和输出动作称为IO操作 02File类的概述和作用 A:File类的概述和作用 a: File的概念 File类是文件和目录路径名的抽象表示形式 Java中把文件或者目录（文件夹）都封装成File对象 我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可 03File类静态的成员变量 A:File类静态的成员变量 a: pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串 windows中是一个分号； Linux中是冒号 : b: separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串 windows中向右 \ Linux / c: 案例代码 1234567891011121314151617181920212223/** java.io.File* 将操作系统中的,文件,目录(文件夹),路径,封装成File对象* 提供方法,操作系统中的内容* File与系统无关的类* 文件 file* 目录 directory* 路径 path*/&gt;public class FileDemo &#123;public static void main(String[] args) &#123;//File类静态成员变量//与系统有关的路径分隔符String separator = File.pathSeparator;System.out.println(separator);// windows中是一个分号,//目录的分割(window中环境变量配置各个路径用分号分割，表示一个完整的路径结束) Linux中是冒号 ://与系统有关的默认名称分隔符separator = File.separator;System.out.println(separator);// windows中向右 \ 目录名称分割 Linux / &#125;&#125; 04File类构造方法_11234567891011121314151617181920* A: File类构造方法_1* a: File(String pathname) * 通过将给定路径名字符串转换为一个File对象,之后可以使用File中的方法 * "windows中的路径或文件名不区分大小写"* d: 案例代码 public class FileDemo1 &#123; public static void main(String[] args) &#123; function(); &#125; /* * File(String pathname) * 传递路径名: 可以写到文件夹,可以写到一个文件 * c:\\abc c:\\abc\\Demo.java * 将路径封装File类型对象 */ public static void function()&#123; File file = new File("d:\\eclipse"); System.out.println(file); &#125; &#125; 05相对路径和绝对路径123456789101112131415161718* A: 相对路径和绝对路径* a: 绝对路径 * 绝对路径是一个固定的路径,从盘符开始* b: 相对路径 * 相对路径相对于某个位置,在eclipse下是指当前项目下 * c: 路径 绝对路径 在系统中具有唯一性 c:\\windows\\system32 相对路径 表示路径之间的关系 D:\\develop\\Java\\jdk1.7.0_72\\bin D:\\develop\\Java\\jre7 路径之间关系 Java 父目录是D:\\develop Java 子目录是：jdk1.7.0_72 父路径是 唯一性 子目录是可以多个 06File类的构造方法_21234567891011121314151617181920212223242526272829303132* A: File类的构造方法_2* a:File(String parent, String child) * 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 对象 * b: File(File parent, String child)* c: 案例代码public class FileDemo1 &#123; public static void main(String[] args) &#123; function_2(); &#125; * * File(File parent,String child) * "传递路径,传递File类型父路径,字符串子路径" * "好处: 父路径是File类型,父路径可以直接调用File类方法" */ public static void function_2()&#123; File parent = new File("d:"); File file = new File(parent,"eclipse"); System.out.println(file); &#125; * * File(String parent,String child) * "传递路径,传递字符串父路径,字符串子路径 * 好处: 单独操作父路径和子路径" */ public static void function_1()&#123; File file = new File("d:","eclipse"); System.out.println(file); &#125;&#125; 07File类创建文件功能123456789101112131415161718192021* A: File类创建文件功能* a: public boolean createNewFile() * 创建文件 如果存在这样的文件，就不创建了 * b: 案例代码 public class FileDemo2 &#123; public static void main(String[] args)throws IOException &#123; function(); &#125; "/* * File创建文件的功能 * boolean createNewFile() * 创建的文件路径和文件名,在File构造方法中给出 * 文件已经存在了,不再创建 */" public static void function()throws IOException&#123; File file = new File("c:\\a.txt"); boolean b = file.createNewFile(); System.out.println(b); &#125; &#125; 08File类创建目录功能123456789101112131415161718192021* A: File类创建目录功能* a: 创建目录 * public boolean mkdir():创建单层文件夹 如果存在这样的文件夹，就不创建了 * public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来* b: 案例代码 public class FileDemo2 &#123; public static void main(String[] args)throws IOException &#123; function_1(); &#125; "/* * File创建文件夹功能 * boolean mkdirs() 创建多层文件夹 * 创建的路径也在File构造方法中给出 * 文件夹已经存在了,不在创建 */" public static void function_1()&#123; File file = new File("c:\\abc"); boolean b = file.mkdirs(); System.out.println(b); &#125; &#125; 09File类删除功能12345678910111213141516171819202122* A: File类删除功能* a: 删除功能 * public boolean delete():删除文件或者文件夹* B: 案例代码public class FileDemo2 &#123; public static void main(String[] args)throws IOException &#123; function_2(); &#125; "/* * File类的删除功能 * boolean delete() * 删除的文件或者是文件夹,在File构造方法中给出 * 删除成功返回true,删除失败返回false * 删除方法,不走回收站,直接从硬盘中删除 * 删除有风险,运行需谨慎 */" public static void function_2()&#123; File file = new File("c:\\a.txt"); boolean b = file.delete(); System.out.println(b); &#125; &#125; 10File类获取功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869* A：File类获取功能* a: 方法介绍* String getName(): 返回路径中表示的文件或者文件夹名 * 获取路径中的最后部分的名字* long length(): 返回路径中表示的文件的字节数* String getAbsolutePath(): 获取绝对路径,返回String对象* File getAbsoluteFile() : 获取绝对路径,返回File对象 * eclipse环境中,写一个相对路径,绝对位置工程根目录* String getParent(): 获取父路径,返回String对象* File getParentFile(): 获取父路径,返回File对象 * b: 案例代码public class FileDemo3 &#123; public static void main(String[] args) &#123; function_3(); &#125; /* * File类的获取功能 * String getParent() 返回String对象 * File getParentFile()返回File对象 * 获取父路径 */ public static void function_3()&#123; File file = new File("d:\\eclipse\\eclipse.exe"); File parent = file.getParentFile(); System.out.println(parent); &#125; /* * File类获取功能 * String getAbsolutePath() 返回String对象 * File getAbsoluteFile() 返回File对象 * 获取绝对路径 * eclipse环境中,写的是一个相对路径,绝对位置工程根目录 */ public static void function_2()&#123; File file = new File("src"); File absolute = file.getAbsoluteFile(); System.out.println(absolute); &#125; /* * File类获取功能 * long length() * 返回路径中表示的文件的字节数 */ public static void function_1()&#123; File file = new File("d:\\eclipse\\eclipse.exe"); long length = file.length(); System.out.println(length); &#125; /* * File类的获取功能 * String getName() * 返回路径中表示的文件或者文件夹名 * 获取路径中的最后部分的名字 */ public static void function()&#123; File file = new File("d:\\eclipse\\eclipse.exe"); String name = file.getName(); System.out.println(name); /*String path = file.getPath(); System.out.println(path);*/// System.out.println(file); &#125;&#125; 11File类判断功能12345678910111213141516171819202122232425262728293031323334353637383940414243* A: File类判断功能* a: 方法介绍 * boolean exists(): 判断File构造方法中封装路径是否存在 * 存在返回true,不存在返回false * boolean isDirectory(): 判断File构造方法中封装的路径是不是文件夹 * 如果是文件夹,返回true,不是文件返回false * boolean isFile(): 判断File构造方法中封装的路径是不是文件 * 如果是文件,返回true,不是文件返回false* b: 案例代码 public class FileDemo4 &#123; public static void main(String[] args) &#123; function_1(); &#125; /* * File判断功能 * boolean isDirectory() * 判断File构造方法中封装的路径是不是文件夹 * 如果是文件夹,返回true,不是文件返回false * * boolean isFile() * 判断File构造方法中封装的路径是不是文件 */ public static void function_1()&#123; File file = new File("d:\\eclipse\\eclipse.exe"); if(file.exists())&#123; boolean b = file.isDirectory(); System.out.println(b); &#125; &#125; /* * File判断功能 * boolean exists() * 判断File构造方法中封装路径是否存在 * 存在返回true,不存在返回false */ public static void function()&#123; File file = new File("src"); boolean b = file.exists(); System.out.println(b); &#125; &#125; 12File类list获取功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* A: File类list获取功能* a: 方法介绍 * String[] list()：获取到File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录) * "返回只有名字" * File[] listFiles()：获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录) * 返回的是目录或者文件的"全路径" * static File[] listRoots(): 列出可用的文件系统根 * b: 案例代码 public class FileDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; public static void function_2()&#123; //获取系统中的所有根目录 File[] fileArr = File.listRoots(); for(File f : fileArr)&#123; System.out.println(f); &#125; &#125; /* * File类的获取功能 * File[] listFiles() * 获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录) * 返回的是目录或者文件的全路径 */ public static void function_1()&#123; File file = new File("d:\\eclipse"); File[] fileArr = file.listFiles(); for(File f : fileArr)&#123; System.out.println(f); &#125; &#125; /* * File类的获取功能 * String[] list() * 获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录) * 返回只有名字 */ public static void function()&#123; File file = new File("c:"); String[] strArr = file.list(); System.out.println(strArr.length); for(String str : strArr)&#123; System.out.println(str); &#125; &#125; &#125; 13文件过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445* A: 文件过滤器* a: 作用 * "过滤一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹" * b: 方法介绍 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter) * C: 案例代码 /* * 自定义过滤器 * 实现FileFilter接口,重写抽象方法 */ public class MyFilter implements FileFilter&#123; public boolean accept(File pathname) &#123; /* * pathname 接受到的也是文件的全路径 * c:\\demo\\1.txt * 对路径进行判断,如果是java文件,返回true,不是java文件,返回false * 文件的后缀结尾是.java */ //String name = pathname.getName(); return pathname.getName().endsWith(".java"); &#125; &#125; "/* * File类的获取,文件获取过滤器 * 遍历目录的时候,可以根据需要,只获取满足条件的文件 * 遍历目录方法 listFiles()重载形式 * listFiles(FileFilter filter)接口类型 * 传递FileFilter接口的实现类 * 自定义FileFilter接口实现类,重写抽象方法, * 接口实现类对象传递到遍历方法listFiles */" public class FileDemo1 &#123; public static void main(String[] args) &#123; File file = new File("c:\\demo"); File[] fileArr = file.listFiles(new MyFilter()); for(File f : fileArr)&#123; System.out.println(f); &#125; &#125; &#125; 14文件过滤器_原理分析1234567* A:文件过滤器_原理分析* "listFiles()遍历目录的同时，获取到了文件名全路径，调用过滤器的方法accept， 将获取到的路径传递给accept方法的参数pathname"* accept方法接收了参数pathname，参数是listFiles传递来的* 在accept方法中，进行判断，如果这个路径是Java文件，返回true，走着返回false* 一旦方法返回了true* listFiles将路径保存到File数组中 15递归遍历全目录12345678910111213141516171819202122232425262728293031* A: 递归遍历全目录* a: 案例代码 /* * 对一个目录的下的所有内容,进行完全的遍历 * 编程技巧,方法的递归调用,自己调用自己 */ public class FileDemo &#123; public static void main(String[] args) &#123; File dir = new File("d:\\eclipse"); getAllDir(dir); &#125; /* * 定义方法,实现目录的全遍历 */ public static void getAllDir(File dir)&#123; System.out.println(dir); //调用方法listFiles()对目录,dir进行遍历 File[] fileArr = dir.listFiles(); for(File f : fileArr)&#123; //判断变量f表示的路径是不是文件夹 if(f.isDirectory())&#123; //是一个目录,就要去遍历这个目录 //本方法,getAllDir,就是给个目录去遍历 //继续调用getAllDir,传递他目录 getAllDir(f); &#125;else&#123; System.out.println(f); &#125; &#125; &#125; &#125; 16递归概念和注意事项123456789* A:递归概念和注意事项* a: 递归概念 * 递归，指在当前方法内调用自己的这种现象 * 递归分为两种，直接递归和间接递归 * 直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法* b: 注意事项 * 递归一定要有出口, 必须可以让程序停下 * 递归次数不能过多 * 构造方法,禁止递归 17递归求和计算12345678910111213141516171819202122232425262728293031323334353637* A: 递归求和计算* a: 题目分析 * 1+2+3+...+(n-1)+n:求1到n的和 * 总结规律：1到n的和等于1到(n-1)的和再加n * getSum(n-1)+ n * 递归出口：getSum(1) return 1;* b: 案例代码 /* * 方法的递归调用 * 方法自己调用自己 * 适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化 * 注意: * 递归一定要有出口, 必须可以让程序停下 * 递归次数不能过多 * 构造方法,禁止递归 */ public class DiGuiDemo &#123; public static void main(String[] args) &#123; int sum = getSum(3); System.out.println(sum); &#125; /* * 计算 1+2+3+100和 = 5050 * 计算规律: * n+(n-1)+(n-2) * 100+(100-1)+(99-1)+...1 */ public static int getSum(int n)&#123; if( n == 1) return 1; return n + getSum(n-1); &#125; &#125; 18递归求阶乘123456789101112131415161718192021222324252627282930313233343536* A: 递归求和计算* a: 题目分析 * 5!=5*4*3*2*1 * =5*4! * 4!=4*3! * 3!=3*2! * 2!=2*1! * 1!=1 * n!=n*(n-1)! * 递归出口：n*getJieCheng(n-1): getJieCheng(1) return 1;* b: 案例代码 /* * 方法的递归调用 * 方法自己调用自己 * 适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化 * 注意: * 递归一定要有出口, 必须可以让程序停下 * 递归次数不能过多 * 构造方法,禁止递归 */ public class DiGuiDemo &#123; public static void main(String[] args) &#123; System.out.println(getJieCheng(5)); &#125; /* * 计算阶乘 5! * 5*4*3*2*1 */ public static int getJieCheng(int n)&#123; if ( n == 1) return 1; return n * getJieCheng(n-1); &#125; &#125; 19递归计算斐波那契数列123456789101112131415161718192021222324252627282930* A: 递归计算斐波那契数列* a：题目分析 * 1 1 2 3 5 8 13 21 * 从第三项开始，后面的每一项都等于前面两项的和，第一项和第二项的值为1，作为程序的出口* b: 案例代码 /* * 方法的递归调用 * 方法自己调用自己 * 适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化 * 注意: * 递归一定要有出口, 必须可以让程序停下 * 递归次数不能过多 * 构造方法,禁止递归 */ public class DiGuiDemo &#123; public static void main(String[] args) &#123; System.out.println(getFBNQ(12)); &#125; /* * 方法递归,计算斐波那契数列 * */ public static int getFBNQ(int month)&#123; if( month == 1) return 1; if( month == 2) return 1; return getFBNQ(month-1)+getFBNQ(month-2); &#125; &#125; 20遍历目录下的所有java文件123456789101112131415161718192021222324252627282930313233343536373839* A: 遍历目录下的所有java文件* a: 案例代码 public class MyJavaFilter implements FileFilter &#123; public boolean accept(File pathname) &#123; //判断获取的是目录,直接返回true if(pathname.isDirectory()) return true; return pathname.getName().toLowerCase().endsWith(".java"); &#125; &#125; /* * 遍历目录,获取目录下的所有.java文件 * 遍历多级目录,方法递归实现 * 遍历的过程中,使用过滤器 */ public class FileDemo1 &#123; public static void main(String[] args) &#123; getAllJava(new File("c:\\demo")); // new File("c:\\demo").delete(); &#125; /* * 定义方法,实现遍历指定目录 * 获取目录中所有的.java文件 */ public static void getAllJava(File dir)&#123; //调用File对象方法listFiles()获取,加入过滤器 File[] fileArr = dir.listFiles(new MyJavaFilter()); for(File f : fileArr)&#123; //对f路径,判断是不是文件夹 if(f.isDirectory())&#123; //递归进入文件夹遍历 getAllJava(f); &#125;else&#123; System.out.println(f); &#125; &#125; &#125; &#125; 21总结123456789101112131415161718192021222324252627282930313233343536373839404142434445 递归： 方法定义中调用方法本身的现象 直接递归 public void methodA()&#123; methodA(); &#125; 间接递归 public void metohdB()&#123; methodC(); &#125; public void methodC()&#123; methodB(); &#125; 递归注意实现 要有出口，否则就是死递归 次数不能太多，否则就内存溢出 File: 文件和目录路径名的抽象表示形式 构造方法：public File(String pathname) 通过给定的文件或文件夹的路径，来创建对应的File对象public File(String parent, String child) 通过给定的父文件夹路径，与给定的文件名称或目录名称来创建对应的File对象public File(File parent, String child)通过给定的File对象的目录路径，与给定的文件夹名称或文件名称来创建对应的File对象 路径的分类： 绝对路径, 带盘盘符 E:\Workspace\day20_File\abc.txt 相对路径， 不带盘符 day20_File\abc.txt 注意： 当指定一个文件路径的时候，如果采用的是相对路径，默认的目录为 项目的根目录 方法public boolean createNewFile()创建文件 返回值为true， 说明创建文件成功 返回值为false，说明文件已存在，创建文件失败public boolean mkdir() 创建单层文件夹 创建文件夹成功，返回 true 创建文件夹失败，返回 falsepublic boolean mkdirs() 创建多层文件夹public boolean delete() 删除此抽象路径名表示的文件或目录。 如果此路径名表示一个目录，则该目录必须为空才能删除public boolean isDirectory() 判断是否为文件夹public boolean isFile() 判断是否为文件public boolean exists() 判断File对象对应的文件或文件夹是否存在public String getAbsolutePath() 获取当前File的绝对路径public String getName() 获取当前File对象的文件或文件夹名称public long length() 获取当前File对象的文件或文件夹的大小（字节）public File[] listFiles() 获取File所代表目录中所有文件或文件夹的绝对路径]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础21(字节流,字符流)]]></title>
    <url>%2F2016%2F11%2F16%2Fday23%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、字节流2、字符流 01输入和输出 A:输入和输出 a: 参照物 到底是输入还是输出，都是以Java程序为参照 b: Output 把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作 程序到文件称为输出 c: Input 把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作 文件到程序称为输入 d: IO操作 把上面的这种输入和输出动作称为IO操作 02字节输出流OutputStream A: 字节输出流OutputStream a.概念 IO流用来处理设备之间的数据传输 Java对数据的操作是通过流的方式 Java用于操作流的类都在IO包中 流按流向分为两种：输入流，输出流。 流按操作类型分为两种： 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的 字符流 : 字符流只能操作纯字符数据，比较方便。 b.IO流常用父类 字节流的抽象父类： InputStream OutputStream 字符流的抽象父类： Reader Writer c.IO程序书写 使用前，导入IO包中的类 使用时，进行IO异常处理 使用后，释放资源 d: 方法介绍 1234* void close(): 关闭此输出流并释放与此流有关的所有系统资源。* void write(byte[] b)： 将 b.length 个字节从指定的 byte 数组写入此输出流* void write(byte[] b, int off, int len) ：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。* abstract void write(int b) ： 将指定的字节写入此输出流。 03字节输出流FileOutputStream写字节1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* A: 字节输出流FileOutputStream写字节* a: FileOutputStream * 写入数据文件,学习父类方法,使用子类对象 * void test() * b: FileOutputStream构造方法 * 作用：绑定输出的输出目的 * FileOutputStream(File file) * 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 * FileOutputStream(File file, boolean append) * 创建一个向指定 File 对象表示的文件中写入数据的文件输出流，以追加的方式写入。 * FileOutputStream(String name) * 创建一个向具有指定名称的文件中写入数据的输出文件流。 * FileOutputStream(String name, boolean append) * 创建一个向具有指定 name 的文件中写入数据的输出文件流，以追加的方式写入。* c: 流对象使用步骤 * 1. 创建流子类的对象,绑定数据目的 * 2. 调用流对象的方法write写 * 3. close释放资源* d: 注意事项 * 流对象的构造方法,可以创建文件,如果文件存在,直接覆盖 * e: 案例代码 * * FileOutputStream * 写入数据文件,学习父类方法,使用子类对象 * * 子类中的构造方法: 作用:绑定输出的输出目的 * 参数: * File 封装文件 * String 字符串的文件名 * * 流对象使用步骤 * 1. 创建流子类的对象,绑定数据目的 * 2. 调用流对象的方法write写 * 3. close释放资源 * * 流对象的构造方法,可以创建文件,如果文件存在,直接覆盖 * public class FileOutputStreamDemo &#123; public static void main(String[] args)throws IOException &#123; FileOutputStream fos = new FileOutputStream("c:\\a.txt"); //流对象的方法write写数据 //写1个字节 fos.write(97); //关闭资源 fos.close(); &#125; &#125; 04字节输出流FileOutputStream写字节数组1234567891011121314151617181920212223242526272829303132333435363738394041* A: 字节输出流FileOutputStream写字节数组* a: 方法介绍 * void write(byte[] b)： 将 b.length 个字节从指定的 byte 数组写入此输出流 * void write(byte[] b, int off, int len) ：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。* b: 案例代码 /* * FileOutputStream * 写入数据文件,学习父类方法,使用子类对象 * * 子类中的构造方法: 作用:绑定输出的输出目的 * 参数: * File 封装文件 * String 字符串的文件名 * * 流对象使用步骤 * 1. 创建流子类的对象,绑定数据目的 * 2. 调用流对象的方法write写 * 3. close释放资源 * * 流对象的构造方法,可以创建文件,如果文件存在,直接覆盖 */ public class FileOutputStreamDemo &#123; public static void main(String[] args)throws IOException &#123; FileOutputStream fos = new FileOutputStream("c:\\a.txt"); //流对象的方法write写数据 //写字节数组 byte[] bytes = &#123;65,66,67,68&#125;; fos.write(bytes); //写字节数组的一部分,开始索引,写几个 fos.write(bytes, 1, 2); //写入字节数组的简便方式 //写字符串 fos.write("hello".getBytes()); //关闭资源 fos.close(); &#125; &#125; 05文件的续写和换行符号12345678910111213141516171819202122* A: 文件的续写和换行符号* a: 文件的续写 * FileOutputStream构造方法, 的第二个参数中,加入true* b: 换行符号 * 在文件中,写入换行,符号换行 \r\n * \r\n 可以写在上一行的末尾, 也可以写在下一行的开头* c: 案例代码 /* * FileOutputStream 文件的续写和换行问题 * 续写: FileOutputStream构造方法, 的第二个参数中,加入true * 在文件中,写入换行,符号换行 \r\n * \r\n 可以写在上一行的末尾, 也可以写在下一行的开头 */ public class FileOutputStreamDemo1 &#123; public static void main(String[] args)throws IOException &#123; File file = new File("c:\\b.txt"); FileOutputStream fos = new FileOutputStream(file,true); fos.write("hello\r\n".getBytes()); fos.write("world".getBytes()); fos.close(); &#125; &#125; 06IO中的异常处理1234567891011121314151617181920212223242526272829303132333435* A: IO中的异常处理* a:IO流的异常处理 * try catch finally * b: 细节 * 1. 保证流对象变量,作用域足够 * 2. catch里面,怎么处理异常 * 输出异常的信息,目的看到哪里出现了问题 * 停下程序,从新尝试 * 3. 如果流对象建立失败了,需要关闭资源吗 * new 对象的时候,失败了,没有占用系统资源 * 释放资源的时候,对流对象判断null * 变量不是null,对象建立成功,需要关闭资源* c: 案例代码 public class FileOutputStreamDemo3 &#123; public static void main(String[] args) &#123; //try 外面声明变量,try 里面建立对象 FileOutputStream fos = null; try&#123; fos = new FileOutputStream("s:\\a.txt"); fos.write(100); &#125;catch(IOException ex)&#123; System.out.println(ex); throw new RuntimeException("文件写入失败,重试"); &#125;finally&#123; try&#123; if(fos!=null) fos.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("关闭资源失败"); &#125; &#125; &#125; &#125; 07字节输入流InputStream12345678910111213141516171819202122232425* A: 字节输入流InputStream* a: 方法介绍 * abstract int read() ： * 从输入流中读取数据的下一个字节。 * 下一个数据字节；如果已到达文件末尾，则返回 -1。 * int read(byte[] b) * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 * int read(byte[] b, int off, int len) * 将输入流中最多 len 个数据字节读入 byte 数组。 * void close() * 关闭此输入流并释放与该流关联的所有系统资源。 * b: 案例代码 /* * 字节输入流 * java.io.InputStream 所有字节输入流的超类 * 作用: 读取任意文件,每次只读取1个字节 * 读取的方法 read * int read() 读取1个字节 * int read(byte[] b) 读取一定量的字节,存储到数组中 */ public class InputStreamDemo &#123; &#125; 08字节输入流FileInputStream读取字节12345678910111213141516171819202122232425262728293031323334353637383940414243* A: 字节输入流FileInputStream读取字节* a: 方法介绍 * abstract int read() ： * 从输入流中读取数据的下一个字节，返回-1表示文件结束 * int read(byte[] b) * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 * 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。 * int read(byte[] b, int off, int len) * 将输入流中最多 len 个数据字节读入 byte 数组。 * void close() * 关闭此输入流并释放与该流关联的所有系统资源。* b: 案例代码 /* * FileInputStream读取文件 * * 构造方法: 为这个流对象绑定数据源 * * 参数: * File 类型对象 * String 对象 * 输入流读取文件的步骤 * 1. 创建字节输入流的子类对象 * 2. 调用读取方法read读取 * 3. 关闭资源 * * read()方法, * read()执行一次,就会自动读取下一个字节 * 返回值,返回的是读取到的字节, 读取到结尾返回-1 */ public class FileInputStreamDemo &#123; public static void main(String[] args) throws IOException&#123; FileInputStream fis = new FileInputStream("c:\\a.txt"); //读取一个字节,调用方法read 返回int //使用循环方式,读取文件, 循环结束的条件 read()方法返回-1 int len = 0;//接受read方法的返回值 while( (len = fis.read()) != -1)&#123; System.out.print((char)len); &#125; //关闭资源 fis.close(); &#125; &#125; 09字节输入流FileInputStream读取字节数组123456789101112131415161718192021222324252627282930313233343536373839* A: 字节输入流FileInputStream读取字节数组* a: 方法介绍 * int read(byte[] b) * 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。 * 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。 * int read(byte[] b, int off, int len) * 将输入流中最多 len 个数据字节读入 byte 数组。* b: 案例代码 /* * FileInputStream读取文件 * 读取方法 int read(byte[] b) 读取字节数组 * 数组作用: 缓冲的作用, 提高效率 * read返回的int,表示什么含义 读取到多少个有效的字节数 */ public class FileInputStreamDemo1 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\a.txt"); // 创建字节数组 byte[] b = new byte[2]; int len = fis.read(b); System.out.println(new String(b));// ab System.out.println(len);// 2 len = fis.read(b); System.out.println(new String(b));// cd System.out.println(len);// 2 len = fis.read(b); System.out.println(new String(b));// ed System.out.println(len);// 1 len = fis.read(b); System.out.println(new String(b));// ed System.out.println(len);// -1 fis.close(); &#125; &#125; 10字节输入流FileInputStream读取字节数组的实现原理 A：字节输入流FileInputStream读取字节数组的实现原理 a: 原理 123456789101112131415161718192021222324252627282930* b: 案例代码public class FileInputStreamDemo1 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream("aa.txt"); byte[] b = new byte[1024 * 10]; int value;//每次 fis.read(b) 读取字节的个数 while ((value = fis.read(b)) != -1) &#123; System.out.print(new String(b, 0, value, "GBK")); //每次只把value长度的byte类型数据 创建为字符串,"GBK"是国标编码 &#125; &#125; catch (IOException ex)&#123; ex.printStackTrace(); System.out.println("文件有误"); &#125; finally &#123; try &#123; if (fis != null) fis.close(); &#125; catch (IOException ex)&#123; ex.printStackTrace(); &#125; &#125; &#125;&#125; 11文件复制原理 A: 文件复制原理 12字节流复制文件读取单个字节123456789101112131415161718192021222324252627282930313233343536373839404142434445* A: 字节流复制文件读取单个字节* a: 案例代码/* * 将数据源 c:\\a.txt * 复制到 d:\\a.txt 数据目的 * 字节输入流,绑定数据源 * 字节输出流,绑定数据目的 * * 输入,读取1个字节 * 输出,写1个字节 */public class Copy &#123; public static void main(String[] args) &#123; //定义两个流的对象变量 FileInputStream fis = null; FileOutputStream fos = null; try&#123; //建立两个流的对象,绑定数据源和数据目的 fis = new FileInputStream("c:\\t.zip"); fos = new FileOutputStream("d:\\t.zip"); //字节输入流,读取1个字节,输出流写1个字节 int len = 0 ; while((len = fis.read())!=-1)&#123; fos.write(len); &#125; &#125;catch(IOException ex)&#123; System.out.println(ex); throw new RuntimeException("文件复制失败"); &#125;finally&#123; try&#123; if(fos!=null) fos.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125;finally&#123; try&#123; if(fis!=null) fis.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125; &#125;&#125; 13字节流复制文件读取字节数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546* A: 字节流复制文件读取字节数组* a: 案例代码/* * 字节流复制文件 * 采用数组缓冲提高效率 * 字节数组 * FileInputStream 读取字节数组 * FileOutputStream 写字节数组 */public class Copy_1 &#123; public static void main(String[] args) &#123; long s = System.currentTimeMillis(); FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream("c:\\t.zip"); fos = new FileOutputStream("d:\\t.zip"); //定义字节数组,缓冲 byte[] bytes = new byte[1024*10]; //读取数组,写入数组 int len = 0 ; while((len = fis.read(bytes))!=-1)&#123; fos.write(bytes, 0, len); &#125; &#125;catch(IOException ex)&#123; System.out.println(ex); throw new RuntimeException("文件复制失败"); &#125;finally&#123; try&#123; if(fos!=null) fos.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125;finally&#123; try&#123; if(fis!=null) fis.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125; long e = System.currentTimeMillis(); System.out.println(e-s); &#125;&#125; 14编码表1234567891011121314151617* A: 编码表* a: 定义： * 生活中字符和计算机二进制的对应关系表,就是编码表* b: 分类* 1、ascii： 一个字节中的7位就可以表示。对应的字节都是正数。0-xxxxxxx* 2、"iso-8859-1:拉丁码表" latin，用了一个字节用的8位。1-xxxxxxx 负数。* 3、GB2312:简体中文码表。包含6000-7000中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数 * "GBK:目前最常用的中文码表"，2万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是1，第二字节开头是0 * GB18030：最新的中文码表，目前还没有正式使用。* 4、unicode：国际标准码表:无论是什么文字，都用两个字节存储。 * Java中的char类型用的就是这个码表。char c = 'a';占两个字节。 * Java中的字符串是按照系统默认码表来解析的。简体中文版 字符串默认的码表是GBK。* 5、UTF-8:基于unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化，在每一个字节头加入了编码信息(后期到api中查找)。* 6、"能识别中文的码表：GBK、UTF-8 "；正因为识别中文码表不唯一，涉及到了编码解码问题。 * 对于我们开发而言；常见的编码 GBK UTF-8 ISO-8859-1 * 文字---&gt;(数字) ：编码。 “abc”.getBytes() byte[] * (数字)---&gt;文字 : 解码。 byte[] b=&#123;97,98,99&#125; new String(b) 15字符输出流写文本FileWriter类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657* A: 字符输出流写文本FileWriter类,只能写"文本文件"* a: 方法介绍 * void write(int c) * 写入单个字符 * void write(String str) * 写入字符串 * void write(String str, int off, int len) * 写入字符串的某一部分 * void write(char[] cbuf) * 写入字符数组 * abstract void write(char[] cbuf, int off, int len) * 写入字符数组的某一部分* b: 案例代码 * * 字符输出流 * java.io.Writer 所有字符输出流的超类 * 写文件,写文本文件 * * 写的方法 write * write(int c) 写1个字符 * write(char[] c)写字符数组 * write(char[] c,int,int)字符数组一部分,开始索引,写几个 * write(String s) 写入字符串 * * Writer类的子类对象 FileWriter * * 构造方法: 写入的数据目的 * File 类型对象 * String 文件名 * * 字符输出流写数据的时候,必须要运行一个功能,刷新功能 * flush() */ public class WriterDemo &#123; public static void main(String[] args) throws IOException&#123; FileWriter fw = new FileWriter("c:\\1.txt"); //写1个字符 fw.write(100); fw.flush(); //写1个字符数组 char[] c = &#123;'a','b','c','d','e'&#125;; fw.write(c); fw.flush(); //写字符数组一部分 fw.write(c, 2, 2); fw.flush(); //写如字符串 fw.write("hello"); fw.flush(); fw.close(); &#125; &#125; 16字符输入流读取文本FileReader类123456789101112131415161718192021222324252627282930313233343536373839404142* A: 字符输入流读取文本FileReader类* a: 方法介绍 * int read() * 读取单个字符 * int read(char[] cbuf) * 将字符读入数组 * abstract int read(char[] cbuf, int off, int len) * 将字符读入数组的某一部分。* b: 案例代码 * * 字符输入流读取文本文件,所有字符输入流的超类 * java.io.Reader * 专门读取文本文件 * * 读取的方法 : read() * int read() 读取1个字符 * int read(char[] c) 读取字符数组 * * Reader类是抽象类,找到子类对象 FileReader * * 构造方法: 绑定数据源 * 参数: * File 类型对象 * String文件名 */ public class ReaderDemo &#123; public static void main(String[] args) throws IOException&#123; ** 要求文件的默认编码为GBK或者UTF-8，不然会有中文乱码 ** FileReader fr = new FileReader("c:\\1.txt"); /*int len = 0 ; while((len = fr.read())!=-1)&#123; System.out.print((char)len); &#125;*/ char[] ch = new char[1024]; int len = 0 ; while((len = fr.read(ch))!=-1)&#123; System.out.print(new String(ch,0,len)); &#125; fr.close(); &#125; &#125; 17flush方法和close方法区别 A: flush方法和close方法区别*a: flush()方法 用来刷新缓冲区的,刷新后可以再次写出,流还可以继续使用,只有字符流FileWriter类才需要刷新*b: close()方法 用来关闭流释放资源的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 18字符流复制文本文件123456789101112131415161718192021222324252627282930313233343536373839404142* A: 字符流复制文本文件* a: 案例代码 /* * 字符流复制文本文件,必须文本文件 * 字符流查询本机默认的编码表,简体中文GBK * FileReader读取数据源 * FileWriter写入到数据目的 */ public class Copy_2 &#123; public static void main(String[] args) &#123; FileReader fr = null; FileWriter fw = null; try&#123; fr = new FileReader("c:\\1.txt"); fw = new FileWriter("d:\\1.txt"); char[] cbuf = new char[1024]; int len = 0 ; while(( len = fr.read(cbuf))!=-1)&#123; fw.write(cbuf, 0, len); fw.flush(); &#125; &#125;catch(IOException ex)&#123; System.out.println(ex); throw new RuntimeException("复制失败"); &#125;finally&#123; try&#123; if(fw!=null) fw.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125;finally&#123; try&#123; if(fr!=null) fr.close(); &#125;catch(IOException ex)&#123; throw new RuntimeException("释放资源失败"); &#125; &#125; &#125; &#125; &#125; 19总结 IO流的分类123456789101112*- 字节流 *- 字节输入流 InputStream 抽象类 *- FileInputStream 操作文件的字节输入流 *- 字节输出流 OuputStream抽象类 *- FileOutputStream 操作文件的字节输出流*- 字符流 *- 字符输入流 Reader抽象类 *- InputStreamReader 输入操作的转换流 *- FileReader 用来操作文件的字符输入流（简便的流） *- 字符输出流 Writer抽象类 *- OutputStreamWriter 输出操作的转换流 *- FileWriter 用来操作文件的字符输出流（简便的流）]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础19(异常、throw、try...catch、finally、Throwable类))]]></title>
    <url>%2F2016%2F11%2F01%2Fday21%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、异常概述和继承体系2、异常原因以及处理方式3、运行时期异常4、方法重写的异常处理5、Throwable类常见方法6、自定义异常 01异常的概述1234567* A: 异常的概述* a:什么是异常 * Java代码在运行时期发生的问题就是异常。* b:异常类 * 在Java中，把异常信息封装成了一个类。 * 当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。* c：我们见过的异常：数组角标越界异常ArrayIndexOutOfBoundsException,空指针异常NullPointerException 02异常的继续体系和错误的区别1234567891011121314151617181920212223242526272829* A: 异常的继承体系 Throwable: 它是所有错误与异常的超类（祖宗类） |- Error 错误 |- Exception 编译期异常,进行编译JAVA程序时出现的问题 |- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题* B：异常与错误的区别* a："异常Exception" * 指程序在"编译、运行期间"发生了某种"异常(XxxException)"，我们可以对异常进行具体的处理。 * 若不处理异常，程序将会结束运行。 * 案例演示： public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr[0]); System.out.println(arr[3]); // 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException， // 由于没有处理异常，导致程序无法继续执行，程序结束。 System.out.println("over"); // 由于上面代码发生了异常，此句代码不会执行 &#125; * b："错误Error" * 指程序在"运行期间"发生了某种"错误(XxxError)"，Error错误通常"没有具体的处理方式"，程序将会结束运行。 * Error错误的发生往往都是"系统级别"的问题，都是"jvm所在系统"发生的，并反馈给jvm的。 * 我们无法针对处理，"只能修正代码"。 * 案例演示： public static void main(String[] args) &#123; int[] arr = new int[1024*1024*100]; //该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间， //导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。 &#125; 03异常对象的产生原因和处理方式1234567891011121314151617181920212223242526272829303132333435* A: 异常对象的产生原因* 案例代码： * 工具类 class ArrayTools&#123; //对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr,int index) &#123; int element = arr[index]; return element; &#125; &#125; * 测试类 class ExceptionDemo2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;34,12,67&#125;; int num = ArrayTools.getElement(arr,4) System.out.println("num="+num); System.out.println("over"); &#125; &#125;* 原因分析： * a: 由于没找到4索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。 这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。 java将这些信息直接封装到异常对象中。new ArrayIndexOutOfBoundsException(4); * b：throw new ArrayIndexOutOfBoundsException(4);产生异常对象。JVM将产生的异常抛给调用者main()方法。 * c：main()方法接收到了数组索引越界异常对象。 由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。 当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。* B：异常的处理方式* a：JVM的默认处理方式 * 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。 * 一旦有异常发生，其后来的代码不能继续执行。* b：解决程序中异常的手动方式 * a)：编写处理代码 try...catch...finally * b)：抛出 throws * 04方法内部抛出对象throw关键字1234567891011121314151617在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。* A: 什么时候使用throw关键字？ * 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断， 数据若不合法，就应该告诉调用者，传递合法的数据进来。 这时需要使用抛出异常的方式来告诉调用者。* B: 使用throw关键字具体操作 * a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 * b: 通过关键字throw将这个异常对象告知给调用者。throw 异常对象； throw 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。* C: throw关键字使用格式 * throw new 异常类名(参数); * 例如： throw new NullPointerException("要访问的arr数组不存在"); throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");* D：案例演示 * throw的使用 * 05方法声明异常关键字throws123456789101112131415161718192021222324252627282930313233* A: 声明 * 将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常， 而"没有捕获处理"（稍后讲解该方式），那么"必须通过"throws进行声明，让"调用者去处理"。* B: 声明异常格式 * 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… &#123; &#125;* C：注意事项： * throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。* D：代码演示： * 多个异常的处理"//方法声明异常关键字" throwspublic class ExceptionDemoTest &#123; public static void main(String[] args) throws Exception &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;;// func(arr); func(trt); &#125; private static int func(int [] arr) throws Exception&#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 06try…catch异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344* A: 捕获 * Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理* B: 捕获异常格式 try &#123; "//需要被检测的语句。" &#125; catch(异常类 变量) &#123; //参数。 "//异常的处理语句。" &#125; finally &#123; "//一定会被执行的语句。" &#125;* C: 格式说明 * a: try * 该代码块中编写可能产生异常的代码。 * b: catch * 用来进行某种异常的捕获，实现对捕获到的异常进行处理。 * c: finally： * "有一些特定的代码无论异常是否发生，都需要执行"。 * 另外，因为"异常会引发程序【跳转】到"catch语句处，"导致有些语句执行不到"。 * 而finally就是解决这个问题的，在finally代码块中存放的"代码都是【一定】会被执行"的。 * d：try...catch..."处理掉异常后，程序可以继续执行"* D：案例演示 * 捕获异常格式"//try…catch异常处理"public class TryCatchDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere); int result = func(arr);"//异常发生后后，程序将发生跳转到catch处执行" System.out.println("ano: "+ ano);"//try异常后面的语句不会执行" System.out.println("result: "+ result); &#125;catch(Exception ex)&#123; System.out.println(ex); &#125; System.out.println("程序继续执行..."); &#125; 07多catch处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* A：一个try 多个catch组合 * 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。* B：多catch处理的格式 void show()&#123; //不用throws try&#123; throw new Exception();//产生异常，直接捕获处理 &#125;catch(XxxException e)&#123; //处理方式 &#125;catch(YyyException e)&#123; //处理方式 &#125;catch(ZzzException e)&#123; //处理方式 &#125; &#125; 注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个catch中异常变量名为e。"//多catch处理"public class TryCatchDemo_1 &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere); int result = func(arr);//异常发生后后，程序将发生跳转到catch出执行 System.out.println("ano: "+ ano);//try异常后面的语句不会执行// System.out.println("result: "+ result); &#125; catch(NullPointerException nullex)&#123; System.out.println(nullex); &#125; catch(ArrayIndexOutOfBoundsException outboundex)&#123; System.out.println(outboundex); &#125; System.out.println("程序继续执行..."); &#125; private static int func(int [] arr) throws NullPointerException,ArrayIndexOutOfBoundsException &#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 08多catch处理细节12345678910* A：细节：多个catch小括号中，写的是异常类的类名，有没有顺序的概念？ * 有顺序关系。* B："平级异常"： * 抛出的"异常类之间","没有""继承关系","没有顺序" NullPointerException extends RuntimeException NoSuchElementException extends RuntimeException ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException* C："上下级关系(继承关系)的异常" * 越高级的"父类",越"写在下面"，《考虑多态的影响》 NullPointerException extends RuntimeException extends Exception 09finally代码块123456789101112131415161718192021222324252627282930313233343536373839404142* A: finally的特点 * "无论"try...catch语句"有没有异常出现"，被finally控制的"语句体"一定"会执行"， * "除非"发生"异常时"在catch语句中 有 "System.exit(0)" 或者 try语句外部"前面""有异常"出现;* B：finally的作用 * finally,无论程序是否有异常出现,程序必须执行释放资源在 如：IO流操作和数据库操作中会见到public class FinallyDemo &#123; public static void main(String[] args) &#123; int [] arr = &#123;&#125;; int [] trt = null; int [] ere = &#123;1,2&#125;; try&#123; int ano = func(ere);// int result = func(arr);//异常发生后后，程序将发生跳转到catch处执行 System.out.println("ano: "+ ano);//try异常后面的语句不会执行 &#125;catch(Exception ex)&#123; System.out.println(ex); &#125; finally&#123; System.out.println("无论有无异常，这里的代码均会执行..."); &#125; &#125; private static int func(int [] arr) throws Exception&#123; if(arr == null)&#123; throw new NullPointerException("数组对象是空指针"); &#125; if(arr.length ==0)&#123; throw new ArrayIndexOutOfBoundsException("数组元素为空"); &#125; int result = arr[arr.length-1]; return result*2; &#125;&#125; 09finally代码块中有return语句123456789101112131415161718192021警告： 当 finally 子句包含 return 语句时， 将会出现一种意想不到的结果。假设利用 return语句从 try语句块中退出。在"方法返回前"，finally 子句的内容"将【先被】执行"。如果 finally 子句中也有一个 return 语句， 这个"返回值"将会"【覆盖】""原始的返回值"。例子： public static int f(int n) &#123; try &#123; int r = n * n; return r; &#125; finally &#123; if (n == 2) return 0; &#125; &#125;如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值 4 10try…catch…finally代码块详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class TryCatchFinallyDemo &#123; public static void main(String[] args) &#123; InputStream in = new FileInputStream(. . .); try &#123; "//1" "code that might throw exceptions" "//2" &#125; catch (IOException e) &#123; "// 3" "show error message" "// 4" &#125; finally &#123; "// 5" in.close()； &#125; "//6" &#125;&#125;在上面这段代码中，有下列 3 种情况会执行 finally 子句：1 ) "代码【没有】抛出异常"。 在这种情况下， 程序首先执行 try 语句块中的"全部代码"，然后执行 finally 子句中的代码 。随后， 继续执行 try...finally 语句块之"后的"第一条"语句"。也就是说，执行标注的 1、 2、 5、 6 处。2 ) "抛出"一个在 catch 子句中"捕获的异常"。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，"直到发生异常为止"。此时，将"跳过" try语句块中的"剩余代码"， 转去"执行与该异常匹配"的 catch 子句中的代码， 最后执行 finally 子句中的代码。【分为以下2种情况】： A:如果 catch 子句"没有抛出异常"， 程序将执行 try 语句块之后的第一条语句。 在这里，执行标注 1、 3、 4、5、 6 处的语句。 B:如果 catch 子句"抛出了一个异常"， "异常"将被"抛回"这个方法的"调用者"。 在这里， 执行标注1、 3、 5 处的语句，"注意"语句6"将不再执行"。3 ) 代码"抛出了一个异常"， "但这个异常【不是】"由 catch 子句"捕获"的。在这种情况下， 程序将执行 try 语句块中的所有语句，"直到有异常被抛出为止"。此时， 将"跳过" try 语句块中的"剩余代码"， 然后执行 finally子句中的语句， 并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。"注意"语句6"将不再执行"。即：try语句"抛出异常"，但是catch"没有捕获"的"异常"或者 catch语句"自身出现异常"，6处的代码"不会执行"try 语句"可以只有" finally 子句，而"没有"catch 子句。例如，下面这条 try 语句： InputStream in = ...； try &#123; code that might throw exceptions &#125; finally &#123; in.close()； &#125; 10调用抛出异常方法try和throws处理方式123456789101112131415161718192021222324* A: 在实际开发中使用哪种异常处理方式呢，* 继续向上throws Exception 还是用 try...catch...finally处理异常 ？ * 能自己处理的尽量自己处理。(建议用try...catch)例如：public Date parse(String source) throws ParseException从给定字符串的开始解析文本，以生成一个日期。该方法不使用给定字符串的整个文本。 该方法本身会 throws ParseException (声明可能抛出的异常)public class TryCatch_ThowsDemo &#123; public static void main(String[] args) &#123; try&#123; func(); &#125; catch(ParseException ex)&#123; System.out.println(ex); &#125; &#125; public static void func() throws ParseException &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date dd = sdf.parse("2088-8-8"); System.out.println(dd); &#125;&#125; 11运行时期异常RuntimeException的特点1234567891011121314151617* A: 运行时期异常的概述: * RuntimeException和"他的所有子类异常",都属于"运行时期异常"。 如常见的 NullPointerException,ArrayIndexOutOfBoundsException 等都属于运行时期异常.* B：运行时期异常的特点 * a：方法中"抛出运行时期异常",方法定义中"无需"throws"声明",调用者也"无需处理此异常"。 * b："运行时期异常一旦发生,【一定】是源代码发生了错误，需要程序人员【修改】【源代码】"。 设计原因: 运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码 运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义(1) 抛出"Exception"，"必须要"throws"声明"，一声明就"告知""调用者"进行"捕获"，一旦"问题处理了"调用者的"程序会继续执行"。(2) 抛出"RuntimeExcpetion","不需要"throws"声明"的，这时调用是"不需要编写捕获代码"的，因为调用者根本就不知道有问题。一旦发生RuntimeException，"调用者程序会停掉"，并有jvm将信息显示到屏幕，让调用者看到问题，"修正代码"。 12运行异常的案例12345678910111213141516171819202122232425262728293031323334353637* A: 计算圆的面积案例 定义方法,计算圆形的面积 传递参数0,或者负数,计算的时候没有问题 但是,违反了真实情况 参数小于=0, 停止程序,不要在计算了* B：数组索引越界案例 使用数组中不存在的索引public class RuntimeExceptionDemo &#123; public static void main(String[] args) &#123; double d = getArea(1); System.out.println(d); &#125; /* * 定义方法,计算圆形的面积 * 传递参数0,或者负数,计算的时候没有问题 * 但是,违反了真实情况 * 参数小于=0, 停止程序,不要在计算了 * */ 方法中"抛出运行时期异常",方法定义中"无需"throws"声明",调用者也"无需处理此异常" public static double getArea(double r)&#123; if(r &lt;= 0) throw new RuntimeException("圆形不存在"); return r*r*Math.PI; &#125; public static void function()&#123; int[] arr = &#123;1,2,3&#125;; //对数组的5索引进行判断,如果5索引大于100,请将3索引上的数据/2,否则除以3 //索引根本就没有 if(arr[3] &gt; 100)&#123; arr[3] = arr[3]/2; &#125;else&#123; arr[3] = arr[3]/3; &#125;&#125; 13方法重写时候异常的处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657* A：方法重写时候异常的处理* a："子类"覆盖"父类"方法时，* 如果"父类"的"方法""声明异常"，"子类""只能"声明"父类异常"或者"父类异常的子类"，或者"不声明"。 例如： class Fu &#123; public void method () throws RuntimeException &#123; &#125; &#125; class Zi extends Fu &#123; public void method() throws RuntimeException &#123; &#125; "//抛出父类一样的异常" public void method() throws NullPointerException&#123; &#125; "//抛出父类异常的子类" public void method()&#123;&#125; "//不声明异常" &#125;* b：当"父类方法"声明"多个异常"时，"子类""覆盖"时"只能"声明"多个异常"的"子集"(注意是"子集")。 例如： class Fu &#123; public void method () throws NullPointerException, ClassCastException&#123; &#125; &#125; class Zi extends Fu &#123; public void method()throws NullPointerException, ClassCastException &#123; &#125; public void method() throws NullPointerException&#123; &#125; "//抛出父类异常中的一部分" public void method() throws ClassCastException &#123; &#125; "//抛出父类异常中的一部分" &#125;* c：当"父类"被覆盖的"方法""没有""异常声明"时，"子类"覆盖时"不能""声明异常"。 例如： class Fu &#123; public void method ()&#123; &#125; &#125; class Zi extends Fu &#123; public void method() throws Exception &#123; &#125; ！！！error /"错误的方式" &#125;* B：问题：父类中会存在下列这种情况，接口也有这种情况。 接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？回答：无法进行throws声明，只能catch的捕获。 万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。interface Inter &#123; public abstract void method();&#125;class Zi implements Inter &#123; public void method()&#123; //无法声明 throws Exception int[] arr = null; if (arr == null) &#123; //只能捕获处理 try&#123; throw new Exception("哥们，你定义的数组arr是空的!"); &#125; catch(Exception e)&#123; System.out.println("父方法中没有异常抛出，子类中不能抛出Exception异常"); //我们把异常对象e，采用RuntimeException异常方式抛出 throw new RuntimeException(e); &#125; &#125; &#125;&#125; 14Throwable类方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556* A: 常见方法 * a："getMessage()方法" 返回该异常的详细信息字符串，即"异常提示信息" * b："toString()方法" 返回该"异常的名称"与"详细信息字符串" * c："printStackTrace()方法" 在控制台输出"该异常的名称"与"详细信息字符串"、"异常出现的代码【位置】"* B：案例演示 异常的常用方法代码演示 try &#123; Person p= null; if (p==null) &#123; throw new NullPointerException(“出现空指针异常了，请检查对象是否为null”); &#125; &#125; catch (NullPointerException e) &#123; String message = e.getMesage(); System.out.println(message ); String result = e.toString(); System.out.println(result); e.printStackTrace(); &#125;public class ThrowableDemo &#123; public static void main(String[] args) &#123; try&#123; func(); &#125; catch(Exception ex)&#123; System.out.println(ex); System.out.println("--------------------------------------------1"); System.out.println(ex.getMessage()); System.out.println("--------------------------------------------2"); System.out.println(ex.toString()); System.out.println("---------------------------------------------3"); ex.printStackTrace(); &#125; &#125; private static void func() throws Exception&#123; int[] arr =&#123;1,2,3&#125;; for(int i=0;i&lt;5;i++)&#123; if(i&gt;=arr.length)&#123; throw new ArrayIndexOutOfBoundsException("数组长度是"+ arr.length +", 数组越界了..."); &#125; System.out.println(arr[i]); &#125; &#125;&#125; 15自定义异常类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113* A: 自定义异常的定义例如NullPointerException异常类源代码：public class NullPointerException extends RuntimeException &#123; public NullPointerException() &#123; super();"//调用父类构造方法" &#125; public NullPointerException(String s) &#123; super(s);"//调用父类具有异常信息的构造方法" &#125;&#125;* a：通过阅读源码，发现规律： 每个异常中都"调用了父类的构造方法"，把"异常描述信息""传递"给了"父类"， 让"父类"帮我们"进行异常信息的封装"。* b："格式"： Class 异常名 extends Exception&#123; "//或继承RuntimeException" public 异常名()&#123; &#125; public 异常名(String s)&#123; super(s); &#125; &#125; * c：自定义异常"继承Exception"演示class MyException extends Exception&#123; /* 为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。 */ public MyException()&#123; super(); &#125; public MyException(String message) &#123; // 如果自定义异常需要异常信息， //可以通过调用父类的带有字符串参数的构造函数即可。 super(message); &#125;&#125;* d：自定义异常"继承RuntimeException"演示* class MyException extends RuntimeException&#123; /* 为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。 */ MyException()&#123; super(); &#125; MyException(String message) &#123; // 如果自定义异常需要异常信息， //可以通过调用父类的带有字符串参数的构造函数即可。 super(message); &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————* B：自定义异常的练习 在Person类的有参数构造方法中，进行年龄范围的判断， 若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。 要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。"//自定义异常类"public class AgeException extends Exception &#123; public AgeException()&#123; &#125; public AgeException(String message)&#123; super(message); &#125;&#125;"//Person类"public class Person &#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) throws AgeException&#123; if(age &lt;0 || age&gt;200)&#123; throw new AgeException("年龄输入有误:" + age); &#125; this.name =name; this.age =age; &#125; @Override public String toString()&#123; return "姓名： "+ name + " |年龄: "+ age; &#125;&#125;"//测试类"public class ExceptionTestDemo &#123; public static void main(String[] args) &#123; try &#123; Person p= new Person("张楠", 209); System.out.println(p.toString()); &#125; catch(AgeException aex)&#123; aex.printStackTrace(); &#125; &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————* C：关于构造方法"抛出异常总结"(1) 抛出"Exception"，"必须要"throws"声明"，一声明就"告知""调用者"进行"捕获"，一旦"问题处理了"调用者的"程序会继续执行"。(2) 抛出"RuntimeExcpetion","不需要"throws"声明"的，这时调用是"不需要编写捕获代码"的，因为调用者根本就不知道有问题。一旦发生RuntimeException，"调用者程序会停掉"，并有jvm将信息显示到屏幕，让调用者看到问题，"修正代码"。 16总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 异常：就是程序中出现的不正常的现象(错误与异常) 异常的继承体系: Throwable: 它是所有错误与异常的超类（祖宗类） |- Error 错误，修改java源代码 |- Exception 编译期异常, javac.exe进行编译的时候报错 |- RuntimeException 运行期异常, java出现运行过程中出现的问题 异常处理的两种方式： 1，出现问题，自己解决 try…catch…finally try&#123; 可能出现异常的代码 &#125; catch(异常类名 对象名)&#123; 异常处理代码 &#125; finally &#123; 异常操作中一定要执行的代码 &#125; 2，出现问题，别人解决 throws 格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2,...&#123;&#125; public void method() throws Exception&#123;&#125;—————————————————————————————————————————————————————————————————————————————————————————— 异常分类异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。 严重错误Error，无法通过处理的错误 编译时异常Exception，编译时无法编译通过。如日期格式化异常 运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如空指针异常 异常基本操作 创建异常对象 抛出异常 处理异常： 捕获处理，将异常获取，使用try/catch做分支处理 try&#123; 需要检测的异常；&#125; catch(异常对象) &#123; 通常我们只使用一个方法：printStackTrace打印异常信息&#125; "声明抛出处理"，"出现异常后不处理"，"声明抛出给调用者处理"。 方法声明上加throws 异常类名 "注意"：异常的处理，指处理"异常"的"一种可能性"，即有了异常处理的代码，"不一定"会"产生异常"。如果没有产生异常，则代码正常执行，如果产生了异常，则中断当前执行代码，执行异常处理代码。—————————————————————————————————————————————————————————————————————————————————————————— 异常注意事项 多异常处理捕获处理： 1多个异常可以分别处理 2多个异常一次捕获多次处理 3多个异常一次捕获，采用同一种方式处理声明抛出异常： 声明上使用,一次声明多个异常 —————————————————————————————————————————————————————————————————————————————————————————— "运行时异常"被抛出可以"不处理"。"即不捕获""也不声明抛出" 如果"父类"抛出了"多个异常","子类覆盖父类方法"时,"只能"抛出相同的异常或者是他的"子集" "父类"方法"没有"抛出异常，"子类覆盖父类该方法"时也"不可抛出异常"。 此时子类产生该异常，只能捕获处理，不能声明抛出 当"多"catch异常处理时，捕获处理，"前边的类""不能"是"后边类"的"父类" 自定义异常如果Java没有提供你需要的异常，则可以自定义异常类。定义方法：编译时异常继承Exception，运行时异常继承RuntimeException。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础18(Map接口、HashMap集合、LinkedHashMap集合、集合嵌套))]]></title>
    <url>%2F2016%2F10%2F29%2Fday20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Map接口2、HashMap集合、LinkedHashMap集合3、集合的嵌套4、集合应用举例 01Map集合概述12345678910111213A:Map集合概述:我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同 a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 "Collection中的集合称为【单列集合】，Map中的集合称为【双列集合】"。需要注意的是，"Map中的集合【不能】包含【重复的键】"，【"值】可以重复"；"每个【键】只能对应一个【值】"。"如果添加【重复的键】，会把之前的【键值】【覆盖】掉"Map |--HashMap |--LinkedHashMap 02Map接口中的常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687A:Map接口中的常用方法 /* * Map接口中的常用方法 * 使用Map接口的实现类 HashMap */ public class MapDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* * 移除集合中的键值对,【返回】被【移除】之前的【值】 * V remove(K) * 如果集合中【没有】这个【键】,【返回null】，不移除任何元素 */" public static void function_2()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "a"); map.put(2, "b"); map.put(3, "c"); System.out.println(map); String value = map.remove(33);//null System.out.println(value); System.out.println(map); &#125; "/* * 通过键对象,获取值对象 * V get(K) * 如果集合中【没有】这个【键】,【返回null】 */" public static void function_1()&#123; //创建集合对象,作为键的对象整数,值的对象存储字符串 Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "a"); map.put(2, "b"); map.put(3, "c"); System.out.println(map); String value = map.get(4);//null System.out.println(value); &#125; "/* * 将键值对存储到集合中 * V put(K,V) K 作为键的对象, V作为值的对象 * 返回值：以前与 key 关联的值，如果没有针对 key 的映射关系，则返回 null。 * 存储的是重复的键,将原有的值,覆盖 * 返回值一般情况下返回null, * 存储重复键的时候,返回被覆盖之前的值 */" public static void function()&#123; //创建集合对象,HashMap,存储对象,键是字符串,值是整数 Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put("a", 1); map.put("b", 2); map.put("c", 3); System.out.println(map); &#125; &#125;————————————————————————————————————————————————————————————————————————————————————————Java 8 为 Map 新增的方法&gt; void forEach(BiConsumer action): 该方法是 Java 8 为 Map 新增的 一个遍历 key-value 对的方法 ，通过该方法可以更简洁地遍历 Map 的 key-value 对 。&gt; Object replace(Object key, Object value) : 将 Map 中指定 key 对应的 value 替换成新value。与传统put()方法不同的是，该方法【不可能添加新的 key-value 对】 。 如果尝试替换的 key 在原 Map 中不存在，该方法不会添加 key-value 对 ， 而是返回 null 。&gt; Object computelfAbsent(Object key, Function mappingFunction): 如 果传给该方法的 key 参数在Map 中对应的 value 为 null ，则使用 mappingFunction 根据 key 计算一个新的结果，如果计算结果不为 null ，则用计算结果覆盖原有的 value。如果原 Map 原来不包括该 key，那么该方法可能会添加一组 key-value 对。&gt; Object computelfPresent(Object key, BiFunction remappingFunction): 如果传给该方法的 key 参数在 Map 中对应的 value 不为 null ， 该方法将使用 remappingFunction 根据原 key、 value 计算一个新的结果 ，如果计算结果不为 null ，则使用该结果覆盖原来的 value; 如果计算结果为 null ，则删除原 key-value 对 。 03Map集合遍历方式keySet方法1234567891011121314151617181920212223242526272829303132333435363738394041424344A:Map集合遍历方式"keySet方法" 1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键 2.遍历键的Set集合，得到每一个键 3.根据键利用get(key)去Map找所对应的值 "/* * Map集合的遍历 * 利用键获取值 * Map接口中定义方法keySet * 所有的键,存储到Set集合 */" public class MapDemo1 &#123; public static void main(String[] args) &#123; "/* * 1. 调用map集合的方法keySet,所有的键存储到Set集合中 * 2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键) * 3. 调用map集合方法get,通过键获取到值 */" Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put("a", 11); map.put("b", 12); map.put("c", 13); map.put("d", 14); "//1. 调用map集合的方法keySet,所有的键存储到Set集合中" Set&lt;String&gt; set = map.keySet(); "//2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)" Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; "//it.next返回是Set集合元素,也就是Map中的键 //3. 调用map集合方法get,通过键获取到值" String key = it.next(); Integer value = map.get(key); System.out.println(key+"...."+value); &#125; System.out.println("======================="); // for Each方法更简便 for(String key : map.keySet())&#123; Integer value = map.get(key); System.out.println(key+"...."+value); &#125; &#125; &#125; 04Map集合Entry对象12345678910111213141516171819202122232425在Map类设计时，提供了一个"嵌套接口"："Entry"。Entry将"【键值对】的【对应关系】""封装成了对象"，即"键值对对象"。这样我们在遍历Map集合时，就可以从每一个"键值对（Entry）对象"中获取对应的"键"与对应的"值"。"entrySet()方法"：用于"返回"Map集合中所有的"键值对(Entry)对象"，以"Set集合"形式返回。A:Map集合Entry对象 interface Map&#123; interface Entry&#123;"//Entry是Map的一个【内部接口】，是static的" //由Map的子类的内部类实现 &#125; &#125; class HashMap&#123; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry对象指的就是该类的对象 final K key; V value; &#125; &#125; 在Map类设计时，提供了一个"嵌套接口：Entry"。 Entry将键值对的对应关系封装成了对象。 即"键值对对象"，这样我们在遍历Map集合时，就可以"从每一个键值对（Entry）对象中获取对应的键与对应的值"。 a:Entry是Map接口中提供的一个"静态内部嵌套接口"。 b:相关方法  "getKey()方法"：获取Entry对象中的"键"  "getValue()方法"：获取Entry对象中的"值"  "entrySet()方法"：用于"返回"Map集合中所有的"键值对(Entry)对象"，以"Set集合形式返回"。 05Map集合遍历方式entrySet方法123456789101112131415161718192021222324252627282930313233343536A:Map集合遍历方式"entrySet方法"* * Map集合获取方式 * entrySet方法,"键值对映射关系"获取 * 实现步骤: * 1. 调用map集合方法entrySet()将集合中的"映射关系对象","存储"到"Set集合" *" Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); *" 2." 迭代Set集合" * 3. 获取出的"Set集合的元素",是"映射关系对象Map.Entry&lt;K, V&gt;" * 4. 通过映射关系对象的方法" getKet(), getValue()"获取"键值对" * * 创建内部类对象 外部类.内部类 = new */public class MapDemo2 &#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "abc"); map.put(2, "bcd"); map.put(3, "cde"); "//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合" Set&lt;Map.Entry &lt;Integer,String&gt; &gt; set = map.entrySet(); "//2. 迭代Set集合" Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator(); while(it.hasNext())&#123; "// 3. 获取出的Set集合的元素,是映射关系对象 // it.next 获取的是Map.Entry对象" Map.Entry&lt;Integer, String&gt; entry = it.next(); "//4. 通过映射关系对象方法 getKet, getValue获取键值对" Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"...."+value); &#125; &#125;&#125; 06Map集合遍历方式增强for循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748A:Map集合遍历方式"增强for循环" A:Map集合遍历方式"entrySet方法"* * Map集合获取方式 * entrySet方法,"键值对映射关系"获取 * 实现步骤: * 1. 调用map集合方法entrySet()将集合中的"映射关系对象","存储"到"Set集合" *" Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); *" 2." 迭代Set集合" * 3. 获取出的"Set集合的元素",是"映射关系对象Map.Entry&lt;K, V&gt;" * 4. 通过映射关系对象的方法" getKet(), getValue()"获取"键值对" * * 创建内部类对象 外部类.内部类 = new */—————————————————————————————————————————————————————————————————————————————————————— "注意"：Map接口"没有"继承自"Iterable&lt;E&gt;接口"， "【不能】"直接使用"迭代器或者foreach"进行遍历。"转成Set之后"才可以使用。—————————————————————————————————————————————————————————————————————————————————————— public class MapDemo2 &#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "abc"); map.put(2, "bcd"); map.put(3, "cde"); //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合 Set&lt;Map.Entry &lt;Integer,String&gt; &gt; set = map.entrySet(); //2. 迭代Set集合 Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator(); while(it.hasNext())&#123; // 3. 获取出的Set集合的元素,是映射关系对象 // it.next 获取的是什么对象,也是Map.Entry对象 Map.Entry&lt;Integer, String&gt; entry = it.next(); //4. 通过映射关系对象方法 getKet, getValue获取键值对 Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"...."+value); &#125; System.out.println("========================="); for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125; &#125;—————————————————————————————————————————————————————————————————————————————————————— "注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。"—————————————————————————————————————————————————————————————————————————————————————— 07HashMap集合存储和遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110A:HashMap集合存储和遍历 "/* * 使用HashMap集合,存储自定义的对象 * 自定义对象,作为键,出现,作为值出现 */" public class HashMapDemo &#123; public static void main(String[] args) &#123; function_1(); &#125; "/* * HashMap 存储自定义对象Person,作为键出现 * 键的对象,是Person类型,值是字符串 * 保证键的唯一性,存储到键的对象,【【重写hashCode equals】】，见下面的Person类 */" public static void function_1()&#123; HashMap&lt;Person, String&gt; map = new HashMap&lt;Person, String&gt;(); map.put(new Person("a",20), "里约热内卢"); map.put(new Person("b",18), "索马里"); map.put(new Person("b",18), "索马里"); map.put(new Person("c",19), "百慕大"); for(Person key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"..."+value); &#125; System.out.println("==================="); for(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125; "/* * HashMap 存储自定义的对象Person,作为值出现 * 【【键的对象,是字符串,可以保证唯一性】】 */" public static void function()&#123; HashMap&lt;String, Person&gt; map = new HashMap&lt;String, Person&gt;(); map.put("beijing", new Person("a",20)); map.put("tianjin", new Person("b",18)); map.put("shanghai", new Person("c",19)); for(String key : map.keySet())&#123; Person value = map.get(key); System.out.println(key+"..."+value); &#125; System.out.println("================="); for(Map.Entry&lt;String, Person&gt; entry : map.entrySet())&#123; String key = entry.getKey(); Person value = entry.getValue(); System.out.println(key+"..."+value); &#125; &#125; &#125;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; //重写方法hashCode和equals @Override public int hashCode()&#123; return this.name.hashCode()+this.age*31; &#125; @Override public boolean equals(Object obj)&#123; if(this == obj)&#123; return true; &#125; if(obj == null)&#123; return false; &#125; if(obj instanceof Person)&#123; Person p = (Person) obj; return Objects.equals(this.name,p.name) &amp;&amp; this.age==p.age;// return this.name.equals(p.name) &amp;&amp; this.age==p.age; &#125; return false; &#125;&#125; 08LinkedHashMap的特点12345678910111213141516*A:LinkedHashMap的特点 "/* * LinkedHashMap继承HashMap * 保证迭代的顺序,有序的HashMap */" public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;(); link.put("1", "a"); link.put("13", "a"); link.put("15", "a"); link.put("17", "a"); System.out.println(link); &#125; &#125; 09Hashtable的特点123456789101112131415161718192021*A:Hashtable的特点 * * "Map接口实现类 Hashtable" * 底层数据结果哈希表,特点和HashMap是一样的 * "Hashtable" "线程安全"集合,运行"速度慢" * "HashMap" "线程不安全"的集合,运行"速度快" * * Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代 * * "HashMap" "允许存储""null值,null键" * "Hashtable" "不允许存储""null值,null键" * * Hashtable他的孩子,"子类 Properties 依然活跃"在开发舞台 * public class HashtableDemo &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new Hashtable&lt;String,String&gt;(); map.put(null, null); System.out.println(map); &#125; &#125; 10静态导入1234567891011121314151617181920212223242526272829303132333435363738394041*A:静态导入:如果"本类"中有和"静态导入"的"同名方法"会"优先使用""本类"的 如果还想使用静态导入的,依然需要类名来调用 "/* * JDK1.5新特性,静态导入 * 减少开发的代码量 * 标准的写法,【导入包】的时候才能使用 * * import static java.lang.System.out;【最末尾】,【必须】是一个【静态成员】 */" import static java.lang.System.out; import static java.util.Arrays.sort; public class StaticImportDemo &#123; public static void main(String[] args) &#123; out.println("hello"); int[] arr = &#123;1,4,2&#125;; sort(arr); &#125; &#125;例如：Map.Entry的访问，简化后为Entryimport static java.util.Map.Entry;public class HashMapTest &#123; public static void main(String[] args) &#123; "//1,创建hashmap集合对象。" Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); "//取出元素。键值对方式" //Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); Set&lt;Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();//静态导入后，直接用Entry //for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; for (Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key.toString()+"....."+value); &#125; &#125;&#125; 11方法的可变参数12345678910111213141516171819202122232425262728293031323334353637*A:方法的可变参数 * * JDK1.5新的特性,"方法的可变参数" * 前提: 方法参数数据类型确定,"参数的个数""任意" * 可变参数语法: "数据类型...变量名" * "可变参数","本质"就是一个"数组" */ public class VarArgumentsDemo &#123; public static void main(String[] args) &#123; //调用一个带有可变参数的方法,传递参数,可以任意 // getSum(); int sum = getSum(5,34,3,56,7,8,0); System.out.println(sum); &#125; /* * 定义方法,计算10个整数和 * 方法的可变参数实现 */ public static int getSum(int...a)&#123; int sum = 0 ; for(int i : a)&#123; sum = sum + i; &#125; return sum; &#125; "可变参数","本质"就是一个"数组" private static void func(int ... arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; arr[i] *= 2; System.out.println(arr[i]); &#125; &#125; &#125; 12可变参数的注意事项123456789*A:可变参数的注意事项 * * 可变参数的注意事项 * 1. "一个方法中,【可变参数】"只能"有【一个】" * 2. 方法的"参数列表"中"可变参数"和"普通参数""都有"时,"必须"写在参数列表的"末尾位置（最后）" */ private static void funb(int a,int b,int ... arr)&#123; &#125; 13Collections工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132A:Collections工具类 * * 集合操作的工具类 * "Collections" * 均为"静态方法"，通过"Collections.方法名"进行调用 */public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T...elements)将所有指定的元素添加到指定的集合。 要添加的元素【可以单独指定】或【作为数组指定】。 这种方便方法的行为与c.addAll(Arrays.asList(elements)) 相同 ，但是在大多数实现中，【这种方法可能会显着加快】。【单独指定元素】时，此方法为现有集合添加一些元素提供了一种便捷的方法：Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 参数类型T - 要添加和收集的元素的类参数c - 要插入 elements的集合elements - 要插入到 c的元素结果true如果集合由于调用而更改—————————————————————————————————————————————————————————————————————————————————————————Element[] array = &#123;new Element(1),new Element(2),new Element(3)&#125;;"将数组转化成List":(1)"利用ArrayList的构造方法"ArrayList&lt;Element&gt; arrayList = new ArrayList&lt;Element&gt;(Arrays.asList(array));ArrayList(Collection &lt; ? extends E &gt; c) : 构造一个包含特定容器的元素的列表ArrayList，并且根据容器迭代器的顺序返回。 所以"构造方法"所做的事情如下： 1.将"容器c转换为一个数组" 2.将"数组拷贝到ArrayList中称为”elementData”的数组"中 ArrayList的构造方法的源码如下：public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125;—————————————————————————————————————————————————————————————————————————————————————————(2)"Arrays.asList(array)方法"List&lt;Element&gt; list1 = Arrays.asList(array);"asList()返回的列表的大小是固定的"。事实上，返回的列表"不是java.util.ArrayList"，而是定义在java.util.Arrays中一个"私有静态类"。我们知道ArrayList的实现本质上是一个数组，而asList()返回的列表是由原始数组支持的固定大小的列表。这种情况下，如果"添加或删除列表中的元素，程序会抛出异常"UnsupportedOperationException。—————————————————————————————————————————————————————————————————————————————————————————(3)(java.util.Collections包),"Collections.addAll(list2, array)方法"；List&lt;element&gt; list2 = new ArrayList&lt;element&gt;();Collections.addAll(list2, array);"这种方便方法的行为与c.addAll(Arrays.asList(elements)) 相同 ，但是在大多数实现中，这种方法可能会显着加快"。————————————————————————————————————————————————————————————————————————————————————————— public class CollectionsDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* * Collections.shuffle方法 * 对List集合中的元素,进行随机排列 */" public static void function_2()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(5); list.add(9); list.add(11); list.add(8); list.add(10); list.add(15); list.add(20); System.out.println(list); //调用工具类方法shuffle对集合随机排列 Collections.shuffle(list); System.out.println(list); &#125; "/* * Collections.binarySearch静态方法 * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素 * ！！！注意：使用该方法前，"必须"先进行"排序" */" public static void function_1()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(5); list.add(8); list.add(10); list.add(15); list.add(20); //调用工具类静态方法binarySearch int index = Collections.binarySearch(list, 16); System.out.println(index); &#125; "/* * Collections.sort静态方法 * 对于List集合,进行"升序排列" */" public static void function()&#123; //创建List集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("ewrew"); list.add("qwesd"); list.add("Qwesd"); list.add("bv"); list.add("wer"); System.out.println(list); //调用集合工具类的方法sort Collections.sort(list); System.out.println(list); &#125; &#125; 14集合的嵌套123456789101112131415161718192021222324252627282930313233343536373839404142A:集合的嵌套/* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); keySet(czbk); &#125; 15集合的嵌套keySet遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980A:集合的嵌套keySet遍历 /* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); keySet(czbk); &#125; "//keySet() Iterator 遍历"public static void keySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)&#123;"//调用czbk集合方法keySet将键存储到Set集合"Set&lt;String&gt; classNameSet = czbk.keySet();"//迭代Set集合"Iterator&lt;String&gt; classNameIt = classNameSet.iterator();while(classNameIt.hasNext())&#123; "//classNameIt.next获取出来的是Set集合元素,czbk集合的键" String classNameKey = classNameIt.next(); "//czbk集合的方法get获取值,值是一个HashMap集合" HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey); "//调用classMap集合方法keySet,键存储到Set集合" Set&lt;String&gt; studentNum = classMap.keySet(); Iterator&lt;String&gt; studentIt = studentNum.iterator(); while(studentIt.hasNext())&#123; "//studentIt.next获取出来的是classMap的键,学号" String numKey = studentIt.next(); "//调用classMap集合中的get方法获取值" String nameValue = classMap.get(numKey); System.out.println(classNameKey+".."+numKey+".."+nameValue); &#125;&#125;System.out.println("==================================");"//keySet() forEach 遍历"for(String className: czbk.keySet())&#123; HashMap&lt;String, String&gt; hashMap = czbk.get(className); for(String numKey : hashMap.keySet())&#123; String nameValue = hashMap.get(numKey); System.out.println(className+".."+numKey+".."+nameValue); &#125;&#125;&#125;&#125; 16集合的嵌套entrySet遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384A:集合的嵌套entrySet遍历/* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); entrySet(czbk);&#125;"//entrySet() Iterator 遍历"public static void entrySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)&#123;"//调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合"Set&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameSet = czbk.entrySet();"//迭代器迭代Set集合"Iterator&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameIt = classNameSet.iterator();while(classNameIt.hasNext())&#123; "//classNameIt.next方法,取出的是czbk集合的键值对关系对象" Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classNameEntry = classNameIt.next(); //classNameEntry方法 getKey,getValue String classNameKey = classNameEntry.getKey(); "//获取值,值是一个Map集合" HashMap&lt;String,String&gt; classMap = classNameEntry.getValue(); "//调用班级集合classMap方法entrySet,键值对关系对象存储Set集合" Set&lt;Map.Entry&lt;String, String&gt;&gt; studentSet = classMap.entrySet(); "//迭代Set集合" Iterator&lt;Map.Entry&lt;String, String&gt;&gt; studentIt = studentSet.iterator(); while(studentIt.hasNext())&#123; "//studentIt方法next获取出的是班级集合的键值对关系对象" Map.Entry&lt;String, String&gt; studentEntry = studentIt.next(); //studentEntry方法 getKey getValue String numKey = studentEntry.getKey(); String nameValue = studentEntry.getValue(); System.out.println(classNameKey+".."+numKey+".."+nameValue); &#125;&#125; System.out.println("==================================");"//entrySet() Iterator 遍历"for (Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; me : czbk.entrySet()) &#123; String classNameKey = me.getKey(); HashMap&lt;String, String&gt; numNameMapValue = me.getValue(); for (Map.Entry&lt;String, String&gt; nameMapEntry : numNameMapValue.entrySet()) &#123; String numKey = nameMapEntry.getKey(); String nameValue = nameMapEntry.getValue(); System.out.println(classNameKey + ".." + numKey + ".." + nameValue); &#125;&#125;&#125;&#125; 17集合应用举例：斗地主的功能分析12345678910111213141516171819A:斗地主的功能分析 a:具体规则： 1. 组装54张扑克牌 2. 将54张牌顺序打乱 3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4. 查看三人各自手中的牌（按照牌的大小排序）、底牌 b:分析: 1.准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 2.洗牌： 通过数字完成洗牌发牌 3.发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 4.看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 18斗地主的准备牌123456789101112131415161718192021222324252627282930313233343536A:斗地主的准备牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */ public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王,索引是从0~54,对应大王,小王,...3(牌的顺序从大到小) pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); &#125; 19斗地主的洗牌123456789101112131415161718192021222324252627282930313233343536373839404142A:斗地主的洗牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */ public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); &#125; &#125; 20斗地主的发牌123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566A:斗地主的发牌/* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); //发牌功能,将牌编号,发给玩家集合,底牌集合 ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;(); //发牌采用的是集合索引%3 for(int i = 0 ; i &lt; pookerNumber.size() ; i++)&#123; //先将底牌做好 if(i &lt; 3)&#123; //存到底牌去 bottom.add( pookerNumber.get(i)); //对索引%3判断 &#125;else if(i % 3 == 0)&#123; //索引上的编号,发给玩家1 player1.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 1)&#123; //索引上的编号,发给玩家2 player2.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 2)&#123; //索引上的编号,发给玩家3 player3.add( pookerNumber.get(i) ); &#125; &#125; &#125; &#125; 21斗地主的看牌1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283A:斗地主的看牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); //发牌功能,将牌编号,发给玩家集合,底牌集合 ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;(); //发牌采用的是集合索引%3 for(int i = 0 ; i &lt; pookerNumber.size() ; i++)&#123; //先将底牌做好 if(i &lt; 3)&#123; //存到底牌去 bottom.add( pookerNumber.get(i)); //对索引%3判断 &#125;else if(i % 3 == 0)&#123; //索引上的编号,发给玩家1 player1.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 1)&#123; //索引上的编号,发给玩家2 player2.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 2)&#123; //索引上的编号,发给玩家3 player3.add( pookerNumber.get(i) ); &#125; &#125; //对玩家手中的编号排序 Collections.sort(player1); Collections.sort(player2); Collections.sort(player3); //看牌,将玩家手中的编号,到Map集合中查找,根据键找值 //定义方法实现 look("刘德华",player1,pooker); look("张曼玉",player2,pooker); look("林青霞",player3,pooker); look("底牌",bottom,pooker);&#125; public static void look(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; pooker)&#123; //遍历ArrayList集合,获取元素,作为键,到集合Map中找值 System.out.print(name+" "); for(Integer key : player)&#123; String value = pooker.get(key); System.out.print(value+" "); &#125; System.out.println();&#125;&#125; 小结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 Map集合: map集合中的元素都是成对出现，成对存储的 map集合中的元素都是以一对键和值的形式组成存在的，称为键值对 map集合中的键不能重复存储，值可以重复 map集合中的每一个键 对应着一个值 方法：V put(K key, V value) 把指定的键与指定的值添加到Map集合中V remove(Object key) 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取到Map集合中所有的键值对对象的集合(Set集合)V get(Object key) 根据指定的键，在Map集合中获取对应的值Set&lt;K&gt; keySet() 获取Map集合中所有的键，存储到Set集合中——————————————————————————————————————————————————————————————————————————————————————  Map集合遍历的两种方式 方式1：根据键找值的方式 //a, 获取到Map集合中所有的键，返回对应的Set集合 //b, 遍历键的集合，获取到每一个键 //c, 通过键，找到对应的值 //获取到Map集合中所有的键，返回对应的Set集合 Set&lt;String&gt; keys = map.keySet(); //遍历键的集合，获取到每一个键 for (String key : keys) &#123; //通过键，找到对应的值 Student s = map.get(key); System.out.println( key + "..." + s.getName() + "..." + s.getAge() ); &#125;—————————————————————————————————————————————————————————— 方式2：根据键值对对象找键和值的方式 //a, 获取Map集合中所有的键值对元素,返回对应的Set集合 //b, 遍历键值对元素集合，获取到每一个键值对元素对象 //c, 通过键值对元素对象，获取对应的键，和对应的值 //获取Map集合中所有的键值对元素,返回对应的Set集合 Set&lt; Map.Entry&lt;String, Student&gt;&gt; entrySet = map.entrySet(); //遍历键值对元素集合，获取到每一个键值对元素对象 for (Map.Entry&lt;String, Student&gt; entry : entrySet) &#123; //通过键值对元素对象，获取对应的键，和对应的值 //找键 String key = entry.getKey(); //找值 Student s = entry.getValue(); //打印 System.out.println( key+"..."+s.getName()+"..."+s.getAge() ); &#125;——————————————————————————————————————————————————————————————————————————————————————  HashMap: 特点： "是Map集合的子集合 底层采用【哈希表】结构 HashMap集合中的key不能重复，通过【重写】hashCode() 与 equals()方法来保证【键的唯一】。 【不能保证】元素存与取的【顺序】完全一致"——————————————————————————————————————————————————————————————————————————————————————  LinkedHashMap: 特点： "是HashMap集合的子集合 底层采用【哈希表+链表】结构 LinkedHashMap集合中的key【不能重复】，通过【重写】hashCode() 与 equals()方法来保证【键的唯一】"。——————————————————————————————————————————————————————————————————————————————————————  Collections中的方法： public static &lt;T&gt; void sort(List&lt;T&gt; list) 排序 public static void shuffle(List&lt;?&gt; list) 集合中的元素存储位置随机打乱]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础17(List接口、Set接口以及其实现的集合类，哈希表(Hash table)，Queue接口(队列),Deque 接口(双端队列))]]></title>
    <url>%2F2016%2F10%2F28%2Fday19%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、List接口2、ArrayList集合、LinkedList集合3、Set接口4、哈希表(Hash table)5、HashSet集合、LinkedHashSet集合、TreeSet集合6、判断集合唯一性原理7、Queue接口(队列)8、PrioritQueue 优先级队列9、Deque 接口(双端队列)、ArrayDeque 实现类 01List接口的特点12345678910A:List接口的特点:a:"它是一个元素【存取有序】的集合。" 例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。b:"它是一个【带有索引】的集合"，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 c:"集合中【可以有重复】的元素"，通过元素的equals方法，来比较是否为重复的元素。 d:List接口的常用子类有： ArrayList集合 LinkedList集合 02List接口的特有方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576A:List接口的特有方法(带索引的方法)a:增加元素方法 add(Object e)："向集合末尾处，添加指定的元素"  add(int index, Object e) "向集合指定索引处，添加指定的元素，原有元素依次后移" /* * add(int index, E) * 将元素插入到列表的指定索引上 * 带有索引的操作,防止越界问题 * java.lang.IndexOutOfBoundsException * ArrayIndexOutOfBoundsException * StringIndexOutOfBoundsException */ public static void function()&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); list.add("abc4"); System.out.println(list); list.add(1, "itcast"); System.out.println(list); &#125;——————————————————————————————————————————————————————————————————————————————————————————b:删除元素删除 remove(Object e)："将指定元素对象，从集合中删除，返回值为被删除的元素" remove(int index)："将指定索引处的元素，从集合中删除，返回值为被删除的元素" /* * E remove(int index) * 移除指定索引上的元素 * 返回被删除之前的元素 */ public static void function_1()&#123; List&lt;Double&gt; list = new ArrayList&lt;Double&gt;(); list.add(1.1); list.add(1.2); list.add(1.3); list.add(1.4); Double d = list.remove(0); System.out.println(d); System.out.println(list); &#125;——————————————————————————————————————————————————————————————————————————————————————————c:替换元素方法 set(int index, Object e)："将指定索引处的元素，替换成指定的元素，返回值为替换前的元素"注意："指定的索引【必须】是List集合的有效索引"、例如集合长度是4，就不能指定替换索引为4处的元素。也就是说，set(int index, Object element)方法"【不会改变】List集合的【长度】" " /* * E set(int index, E) * 修改指定索引上的元素 * 返回【被修改之前】的元素 */" public static void function_2()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); Integer i = list.set(0, 5); System.out.println(i); System.out.println(list); &#125;d:查询元素方法 get(int index)：获取指定索引处的元素，并返回该元素——————————————————————————————————————————————————————————————————————————————————————————e:指定元素的索引 indexOf int indexOf(Object o)"返回此列表中第一次出现的【指定元素的索引】；如果此列表不包含该元素，则返回 -1。"更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的"最低索引 i"；如果没有这样的索引，则返回 -1。 03迭代器的并发修改异常123456789101112131415161718192021222324252627282930313233343536373839A:迭代器的并发修改异常 "/* * 迭代器的并发修改异常 java.util.ConcurrentModificationException (并发修改异常) * 就是在遍历的过程中,使用了集合方法【修改】了【集合的长度】,不允许的 */" public class ListDemo1 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); list.add("abc4"); //对集合使用迭代器进行获取,获取时候判断集合中是否存在 "abc3"对象 //如果有,添加一个元素 "ABC3" Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); //对获取出的元素s,进行判断,是不是有"abc3" if(s.equals("abc3"))&#123; "添加一个元素 "ABC3",造成集合长度变化，抛出异常" list.add("ABC3");//error "修改指定索引的元素为"ABC3",【没有】造成集合长度变化，正常运行" list.set(list.indexOf("abc3"),"ABC3");//正常运行 &#125; System.out.println(s); &#125; &#125; &#125;运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？在迭代过程中，使用了集合的方法对元素进行操作。"导致迭代器并不知道集合中的变化，容易引发数据的不确定性"。"并发修改异常解决办法"："在迭代时，【不要使用】集合的方法操作元素"。或者"通过ListIterator迭代器操作元素是可以"的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。 04数据的存储结构12345678910A:数据的存储结构 a:栈结构:"后进先出/先进后出"(手枪弹夹) FILO (first in last out) b:队列结构:"先进先出/后进后出"(银行排队) FIFO(first in first out) c:数组结构: "【查询快】:通过索引快速找到元素" "【增删慢】:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中" " 开辟新数组耗费资源" d:链表结构 " 【查询慢】:每次都需要从链头或者链尾找起" "【增删快】:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素" 05ArrayList集合的自身特点1234567891011A:ArrayList集合的自身特点 底层采用的是数组结构 ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组 al.add("abc");"//底层会创建一个长度为10的Object数组 "Object[] obj=new Object[10] //obj[0]="abc" "//如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组" "//把原数组中的元素【拷贝】(Arrays.copyOf)到新数组,再把最后一个元素添加到新数组中"原数组: a b c d e f g h k l添加m: a b c d e f g h k l m null null null null 06LinkedList集合的自身特点123456789101112131415161718A:LinkedList集合的自身特点LinkedList 类是 "List 接口 "的 实现类,LinkedList 还实现了 "Deque 接口",可以被当成"双端队列"来使用 ， 因此既可以被当成"栈"来使用，也可以 当成"队列"使用 。"底层采用链表结构,每次查询都要从【链头】或【链尾】找起,【查询】相对数组【较慢】""但是【删除元素】直接【修改元素记录的地址值】即可,不需要大量移动元素，【增删】相对数组【较快】"LinkedList的"索引"决定是从"链头"开始找还是从"链尾"开始找"如果该元素【小于】元素长度一半,从【链头】开始找起；如果【大于】元素长度的一半,则从【链尾】找起"实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在"列表的开头及结尾" get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将"链接列表"用作"堆栈、队列"或双端队列。LinkedList集合数据存储的结构是链表结构。"方便元素添加、删除的集合"。实际开发中对一个集合元素的添加与删除经常涉及到"首尾操作"，而LinkedList提供了大量"首尾操作"的方法 07LinkedList特有方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132具体查看 ："25 Deque 接口(双端队列)与 ArrayDeque 实现类、LinkedList 实现类"public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; lds = new LinkedList&lt;&gt;(); "//将元素加入队列的尾部" lds.offer(23); "//将一个元素加入【栈】的顶部" lds.push(111); "//将元素加入【队列】的尾部" lds.offer(407); "//将元素添加到【队列】的头部(相当于【栈】的顶部〉" lds.addFirst(56); "//输出：[56, 111, 23, 407]" System.out.println(lds); "//以 List 的方式(按【索引访问】的方式〉来遍历集合元素" for(int ee:lds)&#123; System.out.println(ee); &#125; //访问并不删除顶的元素:56 System.out.println(lds.peekFirst()) ; //访问并不删除队列的最后一个元素:407 System.out.println(lds.peekLast()) ; "//将【栈】顶的元素弹出 ,输出 56" System.out.println(lds.pop()); //输出：[111, 23, 407] System.out.println(lds); //访问并删除【队列】的最后一个元素: 407 System.out.println(lds.pollLast()); //输出：[111, 23] System.out.println(lds); &#125;&#125;———————————————————————————————————————————————————————————————————————————————————— *A:LinkedList特有方法:获取,添加,删除 * * LinkedList 链表集合的特有功能 * "自身特点: 链表底层实现,查询慢,增删快" * "* 子类的特有功能,不能多态调用，只能向下强制转换" * public class LinkedListDemo &#123; public static void main(String[] args) &#123; function_3(); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * E removeFirst() 移除并返回链表的开头 * E removeLast() 移除并返回链表的结尾 */ public static void function_3()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.add("1"); link.add("2"); link.add("3"); link.add("4"); String first = link.removeFirst(); String last = link.removeLast(); System.out.println(first); System.out.println(last); System.out.println(link); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * E getFirst() 获取链表的开头 * E getLast() 获取链表的结尾 */ public static void function_2()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.add("1"); link.add("2"); link.add("3"); link.add("4"); if(!link.isEmpty())&#123; String first = link.getFirst(); String last = link.getLast(); System.out.println(first); System.out.println(last); &#125; &#125; public static void function_1()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.addLast("a"); link.addLast("b"); link.addLast("c"); link.addLast("d"); link.addFirst("1"); link.addFirst("2"); link.addFirst("3"); System.out.println(link); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * addFirst(E) 添加到链表的开头 * addLast(E) 添加到链表的结尾 */ public static void function()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.addLast("heima"); link.add("abc"); link.add("bcd"); link.addFirst("itcast"); System.out.println(link); &#125; &#125; 08 各List实现类的性能分析，集合Vector类的特点,1234567891011121314151617181920212223242526272829303132Java 提供的 List 就是一个线性表接口，而ArrayList 、 LinkedList 又是线性表的两种典型实现 : "ArrayList是基于数组的线性表"，"LinkedList是基于链的线性表"。 "Queue 代表了队列"，" Deque 代表了双端队列(既可作为【队列】使用，也可作为【栈】使用)" ，"LinkedList 集合"不仅提供了 "List 的功能"，还提供了"双端队列"、"栈"的功能。接下来对各种实现类的性能进行分析。"总体来说"， "ArrayList "的性能"比" "LinkedList" 的性能要"好""数组"在"随机访问"时"性能""最好" ，所有的内部以数组作为底层实现的集合在随机访问时性能都比较好 ;而内部以"链表"作为底层实现的集合在"执行插入、删除操作"时有"较好"的性能 。》如果需要"遍历 List 集合元素" ： 对于 ArrayList、 Vector 集合 ， 应该使用"随机访问方法 (get) "来"遍历"集合元素，这样性能更好 ; 对于" LinkedList 集合"，则应该采用"迭代器 （Iterator) "来"遍历"集合元素 。》如果需要经常"执行插入、删除操作"来改变包含大量数据的 List 集合的大小：可考虑"使用LinkedList 集合"。使用 "ArrayList 、 Vector 集合"可能需要经常"重新分配内部数组的大小"，效果可能"较差"。》如果有"多个线程"需要"同时访问" List 集合中的元素，开发者可考虑使用 "Collections "将集合"包装"成"线程安全"的集合。————————————————————————————————————————————————————————————————————————————————————*B:Vector类的特点 Vector集合数据存储的结构是数组结构，为JDK中"最早"提供的"集合",它是"线程同步"的 Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。 此接口Enumeration的功能与 Iterator 接口的功能是类似的。 " Vector集合已被 ArrayList【替代】。枚举Enumeration 已被 迭代器Iterator【替代】"。 09Set接口的特点12345678910Set接口类似于个"罐子"，"程序可以依次把多个对象“丢进”Set集合"，集合通常"不能"记住"元索的添加顺序"。"Set集合与Collection基本相同"，"【没有】提供【任何】【额外的方法】"。实际上Set就是Collection，只是行为略有不同("Set不允许包含重复元素")。A:Set接口的特点 a:它是个"【不包含】重复元素"的集合。 b:Set集合取出元素的方式可以采用："【迭代器】、【增强for】"。"不能通过索引进行取值"。 HashSet"没有提供get()方法"，同HashMap一样，"Set内部是无序的"，只能通过迭代的方式获得 c:Set集合有多个子类，这里我们介绍其中的"HashSet、LinkedHashSet"这两个集合。 10Set集合存储和迭代(以HashSet为例)12345678910111213141516171819202122232425262728293031A:Set集合存储和迭代"HashSet类(散列集) 实现 Set 接口，由哈希表Hash table（实际上是一个 HashMap 实例）支持"。它"【不保证】 set 的迭代顺序"；"特别是它【不保证】该顺序恒久不变"。此类允许"使用 null 元素" "/* * Set接口,特点不重复元素,没索引 * * Set接口的实现类,HashSet * 特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素 * 代码的编写上,和ArrayList完全一致 */" public class HashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("cn"); set.add("heima"); set.add("java"); set.add("java"); set.add("itcast"); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; System.out.println("=============="); for(String s : set)&#123; System.out.println(s); &#125; &#125; &#125; 11哈希表的数据结构1234567891011A:哈希表的数据结构:(参见图解)"加载因子:表中填入的记录数 / 哈希表的长度"例如:加载因子是0.75 代表: 数组中的16个位置,其中存入16*0.75=12个元素如果在存入第13个(&gt;12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会"扩充哈希表(再哈希 Rehash)",底层会"开辟一个长度为原长度2倍的数组",把老元素拷贝到新数组中,再把新元素添加数组中 当存入"元素数量" &gt; "哈希表长度*加载因子",就要"扩容",因此"加载因子决定扩容时机" 12字符串对象的哈希值(HashCode)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354A:字符串对象的哈希值"/** 对象的哈希值,普通的十进制整数* 父类Object,方法 public int hashCode() 计算结果int整数*/"举例：StringBuilder sb = new StringBuilder("abc");StringBuilder tb = new StringBuilder("abc");int s = sb.hashCode();int t = tb.hashCode();System.out.println("s: " + s);"//StringBuilder没有重写HashCode方法，返回对象的内存地址值"System.out.println("t: " + t);//StringBuilder没有重写HashCode方法，返回对象的内存地址值System.out.println(sb.equals(tb));"//比较的是对象的内存地址值"System.out.println("————————————————————————————————————————1");String ss= new String("abc");"//String重写HashCode方法，根据内容的值进行计算"String st = "abc";System.out.println("ss.hashCode(): " + ss.hashCode());System.out.println("st.hashCode(): " + st.hashCode());System.out.println(ss.equals(st));"//比较的是对象的内容是否完全相同"——————————————————————————————————————————————————————————————————————————————————————————public class HashDemo &#123; public static void main(String[] args) &#123; Person p = new Person(); int i = p.hashCode(); System.out.println(i); String s1 = new String("abc"); String s2 = new String("abc"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354 "两个【不同】字符串的hashCode值完全可能【相同】" System.out.println("重地".hashCode());//1179395 System.out.println("通话".hashCode());//1179395 &#125;&#125;//String类重写hashCode()方法//字符串都会存储在底层的value数组中&#123;'a','b','c'&#125;public int hashCode() &#123; int h = hash;//hash初值为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; 13哈希表的存储过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657A:哈希表的存储原理当向哈希表中"存放元素"时，需要根据元素的"特有数据结合相应的算法"，这个算法其实就是"Object类中的【hashCode方法】"。由于任何对象都是Object类的子类，所以"任何对象都拥有这个方法"。即就是"在给哈希表中【存放对象】时，会【调用】对象的【hashCode方法】"，这里需要注意：算出对象在表中的存放位置，如果"两个对象hashCode方法算出【结果一样】"，这样现象称为"哈希冲突"，这时会调用对象的"equals方法"，比较这"两个对象【是不是】同一个对象"，(1)如果"equals方法返回的是true"，那么就"不会"把第二个对象存放在哈希表中，(2)如果"返回的是false"，就会"把这个值存放在哈希表中"。总结："保证HashSet集合元素的唯一"，其实就是根据"对象的 hashCode和 equals 方法"来决定的。！！！如果我们往集合中存放"自定义的对象"，那么保证其唯一，就"必须""重写hashCode和equals方法"建立属于当前对象的比较方式。——————————————————————————————————————————————————————————————————————————————————————————B:哈希表的存储过程 public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(new String("abc")); set.add(new String("abc")); set.add(new String("bbc")); set.add(new String("bbc")); System.out.println(set); &#125;存取原理:每存入一个新的元素都要走以下三步:1.首先调用"本类的hashCode()方法"算出哈希值2."在容器中找是否与【新元素】【哈希值相同】的【老元素】", "如果没有直接存入" 如果有转到第三步3."新元素会与该索引位置下的老元素利用equals方法"一一对比 一旦"新元素.equals(老元素)"返回true,停止对比,"说明重复","不再存入" 如果与该索引位置下的老元素都通过equals方法对比返回false,说明"没有重复","存入"——————————————————————————————————————————————————————————————————————————————————————————举例：HashSet&lt;String&gt; hset = new HashSet&lt;&gt;(); hset.add("abc");"//hashCode: 96354" hset.add("abc"); hset.add("ad%");"//hashCode: 96354" hset.add("yut"); System.out.println(hset);上述代码：第1行： "abc"的hashCode 为 96354第2行： "abc"的hashCode 为 96354，调用新元素.equals(老元素)，即"abc".equals("abc")结果为true,说明"元素重复，不添加到HashSet中";第3行： "ad%"的hashCode 也为 96354，调用新元素.equals(老元素)，即"ad%".equals("abc")结果为false，"没有元素重复，添加到HashSet中"; —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— 14HashSet存储自定义的对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152A:HashSet存储自定义的对象 "/* * HashSet集合的自身特点: * 底层数据结构,哈希表 * 存储,取出都比较快 * 线程不安全,运行速度快 */" public class HashSetDemo1 &#123; public static void main(String[] args) &#123; //将Person对象中的姓名,年龄,相同数据,看作同一个对象 "//判断对象是否重复,依赖对象自己的方法 hashCode(),equals()" HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;(); setPerson.add(new Person("a",11)); setPerson.add(new Person("b",10));"hashCode方法返回对象的地址值，地址值不同，会存入HashSet" setPerson.add(new Person("b",10));"hashCode方法返回对象的地址值，地址值不同，会存入HashSet" setPerson.add(new Person("c",25)); setPerson.add(new Person("d",19)); setPerson.add(new Person("e",17));"//每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】,【直接存入】" System.out.println(setPerson); &#125; &#125;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String toString()&#123; return name+".."+age; &#125; &#125; 15自定义对象重写hashCode和equals方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 A:自定义对象重写hashCode和equals方法"给HashSet中存放【自定义类型元素】时，需要【重写】对象中的hashCode和equals方法，建立【自己的比较方式】，才能【保证】HashSet集合中的【对象唯一】"也就是说，HashSet集合"判断两个元素相等的标准"是：两个对象通过"equals()方法"比较"相等"，返回true，"并且"两个对象的"hashCode()方法"返回值"也相等"。"则 HashSet集合中的 两个元素【相同】，【不予添加】" "/* * HashSet集合的自身特点: * 底层数据结构,哈希表 * 存储,取出都比较快 * 线程不安全,运行速度快 */" public class HashSetDemo1 &#123; public static void main(String[] args) &#123; //将Person对象中的姓名,年龄,相同数据,看作同一个对象 "//判断对象是否重复,依赖【对象自己】的方法 hashCode,equals" HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;(); setPerson.add(new Person("a",11)); setPerson.add(new Person("b",10)); setPerson.add(new Person("b",10)); setPerson.add(new Person("c",25)); setPerson.add(new Person("d",19)); setPerson.add(new Person("e",17)); System.out.println(setPerson); &#125; &#125; public class Person &#123; private String name; private int age;"/** 没有做重写父类(Obejct类)的hashCode和equals方法,每次运行结果都是不同整数， 因为每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】* 如果子类重写父类hashCode和equals方法,将会得到自定义的哈希值* 存储到HashSet集合的依据：用hashCode和equals方法进行判断* * 尽可能让不同的属性值产生不同的哈希值(优化hashCode的产生方法),这样就不用再调用equals方法去比较属性**/" public int hashCode()&#123; return name.hashCode()+age*55; &#125; //方法equals重写父类,保证和父类相同 //public boolean equals(Object obj)&#123;&#125; public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj == null) return false; if(obj instanceof Person)&#123; Person p = (Person)obj; return name.equals(p.name) &amp;&amp; age==p.age; &#125; return false; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String toString()&#123; return name+".."+age; &#125; &#125; 16LinkedHashSet集合123456789101112131415161718192021A:LinkedHashSet集合 " /* * LinkedHashSet 基于【链表】的【哈希表】实现 * 继承自HashSet："有序"的hashSet * * LinkedHashSet 自身特性,"具有顺序",存储和取出的顺序相同 * 线程不安全的集合,"运行速度块" */" public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; LinkedHashSet&lt;Integer&gt; link = new LinkedHashSet&lt;Integer&gt;(); link.add(123); link.add(44); link.add(33); link.add(33); link.add(66); link.add(11); System.out.println(link); &#125; &#125; 17ArrayList,HashSet判断对象是否重复的原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115ArrayList,HashSet判断对象是否重复的原理1： "ArrayList的【contains方法】判断元素是否重复"a:"ArrayList的【contains方法】原理:【底层依赖于】【equals方法】"ArrayList的【contains方法】会使用调用方法时， "传入的元素的equals方法依次与集合中的旧元素所比较"， 从而根据返回的布尔值判断是否有重复元素。b:"当ArrayList存放【自定义类型】时"，由于自定义类型在"未重写equals方法"之前， "判断是否重复的依据是内存地址值"，"所以如果想根据【内容】判断是否为重复元素，需要【重写】元素的equals方法"。——————————————————————————————————————————————————————————————————————————————————————————2: "HashSet的add/contains等方法判断元素是否重复""HashSet的【add()方法和contains方法()】【底层】都【依赖】 hashCode()方法与equals方法()"HashSet集合"判断两个元素相等的标准"是：两个对象通过"equals()方法"比较"相等"，返回true，"并且"两个对象的"hashCode()方法"返回值"也相等"。"则 HashSet集合中的 两个元素【相同】，【不予添加】"Set集合"不能"存放重复元素，"其add()方法在添加时会判断是否有重复元素，"有重复【不】添加"，"没重复则添加""。HashSet集合由于是"无序"的，其判断唯一的依据是元素类型的"hashCode与equals方法的返回结果"。规则如下：先判断新元素与集合内已经有的旧元素的"HashCode值"1): 如果"不同"，说明是"不同元"素，"添加到集合"。2): 如果"相同"，再"判断equals比较结果"。返回true则"相同元素"，"不予添加"； 返回false则"不同元素"，"添加到集合"。即：两个对象通过"equals()方法"比较"相等"，并且两个对象的"hashCode()方法"返回值"也相等"。则"不予添加"。——————————————————————————————————————————————————————————————————————————————————————————总结：使用"HashSet""存储【自定义类型】"时，如果"没有重写"该类的hashCode与equals方法，则判断重复时，使用的是"内存地址值"，如果想通过"【内容】比较元素是否相同"，"需要重写"该元素类的hashcode与equals方法。——————————————————————————————————————————————————————————————————————————————————————————！！！！！！！！！！！！！！"注意"：如果向HashSet中添加一个"可变对象"后，后面程序修改了该"可变对象"的"实例变量"，则可能导致它与集合中"其他对象"的"元素相同"。(即两个对象通过equals()方法比较返回true，两个对象的 hashCode 值也相等)，这就可能导致HashSet 中包含"两个相同的对象"。public class Example &#123; int count; public Example(int count) &#123; this.count = count; &#125; public Example() &#123; &#125; @Override public int hashCode() &#123; return this.count; &#125; @Override public boolean equals(Object obj) &#123; if(this == obj)&#123; return true; &#125; if(obj != null &amp;&amp; obj.getClass()==Example.class)&#123; Example ex = (Example) obj; return this.count ==ex.count; &#125; return false; &#125; @Override public String toString()&#123; return "Example[count: "+ this.count + "]"; &#125;&#125;public class ExampleTest &#123; public static void main(String[] args) &#123; HashSet&lt;Example&gt; hs = new HashSet&lt;&gt;(); hs.add(new Example(5)); hs.add(new Example(-3)); hs.add(new Example(9)); hs.add(new Example(-2)); //打印HashSet集合，集合元素没有重复 System.out.println(hs); Iterator&lt;Example&gt; it = hs.iterator(); it.next().count = -3; //为第一个元素的count实例变量赋值 System.out.println(hs); //删除值为-3的Example对象 hs.remove(new Example(-3)); System.out.println(hs); System.out.println("hs是否包含count为-3的Example对象? "+ hs.contains(new Example(-3))); System.out.println("hs是否包含count为-2的Example对象? "+ hs.contains(new Example(-2))); &#125;&#125;结果：[Example[count: -2], Example[count: -3], Example[count: 5], Example[count: 9]][Example[count: -3], Example[count: -3], Example[count: 5], Example[count: 9]][Example[count: -3], Example[count: 5], Example[count: 9]]hs是否包含count为-3的Example对象? falsehs是否包含count为-2的Example对象? false分析：正如结果所见到的，HashSet集合的第1个元素和第2个元素"完全相同"，这表明两个元素"已经重复"。此时HashSet会比较混乱:当试图删除count为-3的Example对象时，HashSet会计算出该对象的hashCode值，从而找出该对象在集合中的保存位置，然后把此处的对象与count为-3的Example对象时通过equals()方法进行比较，如果相等则删除该对象：HashSet"只有"第2个元素才满足该条件(第1个元素"实际"上保存在count为-2的Example对象对应的位置)，所以"第2个元素被删除"。至于第一个count为-3的Example对象，它保存在count为-2的Example对象对应的位置，但使用equals()方法拿它和count为-2的R对象比较时又返回false—这将导致HashSet"不能""准确"访问该"元素"。 18hashCode和equals方法的面试题12345678910111213141516171819202122232425262728293031 A:hashCode和equals的面试题 两个对象 Person p1 p2 问题: (1)"如果两个对象的哈希值相同" p1.hashCode()==p2.hashCode() 两个对象的equals一定返回true吗 p1.equals(p2) 一定是true吗 正确答案:"p1.equals(p2)不一定"是true (2)"如果两个对象的equals方法返回true",p1.equals(p2)==true 两个对象的"哈希值一定相同"吗 正确答案: "哈希值一定相同"——————————————————————————————————————————————————————————————————————————————————————————在 Java 应用程序执行期间，"规定"：1."如果根据 equals(Object) 方法"，"两个对象是相等"的，那么对这两个对象中的每个对象调用 "hashCode 方法"都"必须生成相同的整数结果"。 2.如果根据 equals(java.lang.Object) 方法，"两个对象【不相等】"，那么对这两个对象中的任一对象上调用" hashCode 方法" "不要求"一定"生成不同的整数结果"。此时，hashCode值(可以"相同"也"可以不同") 2.1 两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法"哈希值""可相同"两个对象调用hashCode()方法哈希值不同=====&gt;equals返回true2.2 两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法"哈希值""可不同"两个对象调用hashCode()方法哈希值相同=====&gt;equals返回true"所以说两个对象【哈希值】无论【相同】还是【不同】,equals都可能返回"true 19TreeSet类123456789101112131415161718192021222324252627282930313233343536373839404142434445TreeSet 类与散列集HashSet十分类似， 不过， 它比HashSet有所改进。TreeSet是一个"有序集合"( sorted collection) 。可以以任意顺序将元素插入到集合中。在对集合进行遍历时， 每个值将"自动地按照排序后"的"顺序"呈现。TreeSet是SortedSet接口的实现类。与"HashSet集合"采用"hash算法"来决定元索的"存储位置"不同，"TreeSet"采用"红黑树"的数据结构来存储集合元素。TreeSet支持两种排序方法:"自然排序"和"定制排序"。public Comparator&lt;? super E&gt; comparator():如果TreeSet采用了"定制排序"，则该方法返回定制排序所使用的如果TreeSet采用了"自然排序"，则返回nullpublic E first(): 返回集合中的第一个元素。public E last(): 返回集合中的最后一个元素。public E lower(E e):返回集合中位于指定元素之前的元素(即小于指定元素的最大元素，参考元素不需要是TreeSet集合里的元素)。public E higher(E e):返回集合中位于指定元素之后的元素(即大于指定元素的最小元素，参考元素不需要是TreeSet集合里的元素)。public SortedSet&lt;E&gt; subSet(E fromElement,E toElement):返回此Set的子集合，范围从fromElement (包含)到toElement(不包含)。public SortedSet&lt;E&gt; headSet(E toElement):返回此Set的子集，由小于toElement的元素组成。public SortedSet&lt;E&gt; tailSet(E fromElement):返回此Set的子集，由大于或等于fromElement的元素组成。TreeSet并【不是】根据元素的【插入顺序】进行排序的，而是根据元素【实际值的大小】来进行排序的。public class TreeSetDemol &#123; public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; tset = new TreeSet&lt;&gt;(); tset.add(12); tset.add(-9); tset.add(19); tset.add(78); tset.add(3); System.out.println(tset);//[-9, 3, 12, 19, 78] System.out.println(tset.first());//-9 System.out.println(tset.last());//78 System.out.println(tset.lower(5));//3 System.out.println(tset.higher(7));//12 System.out.println(tset.headSet(4));//[-9, 3] System.out.println(tset.tailSet(8));//[12, 19, 78] System.out.println(tset.subSet(2,13));//[3, 12] &#125;&#125; 20TreeSet类的自然排序和定制排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778791. 自然排序TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。如果试图把个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序将会抛出异常。例如：class Err&#123;&#125;public class TreeSetErrorTest&#123; public static void main (String「1args) &#123; TreeSet ts=new TreeSet(); //向TreeSet集合中添加两个Err对象 ts.add(aew Err()); ts.add (nest Err());//(1) &#125;&#125;上面的程序试图向TreeSet集合中添加两个Err对象，添加第一个对象时，TreeSet里没有任何元素，所以不会出现任何问题;但是添加第二个Err对象时，TreeSet就会调用该对象的compareTo(Object obj)方法与集合中的其他元素进行比较：如果其对应的类没有实现Comparable接口，则会引发CIassCastException异常。因此，上面的程序会在(1)处引发该异常。此外："如果希望TreeSet能正常运作，TreeSet【只能】添加【同一种类型】的对象"。对于TreeSet集合，判断两个对象是否相等的唯一标准是：两个对象通过"compareTo(Object obj)方法"比较"是否返回0"：如果通过compareTo(Object obj)方法比较"返回0"，TreeSet则会认为它们"相等";否则就认为它们不相等—————————————————————————————————————————————————————————————————————————————————————————————2. 定制排序TreeSet 的 自然排序是根据集合元素的大小， TreeSet将它们以升序排列。 如果需要实现定制排序 ，例如以降序排列 ，则可以通过" Comparator 接口 "的帮助 。 该接 口 里包含一个 int compare(T 01, T 02)方法 ，该方法用于 比较 01 和 02 的大小:如果该方法返回正整数，则表 明 01 大于 02； 如果该方法返回 0，则表 明 0 1 等于 02；如果该方法返回负整数，则表 明 01 小于 02 ;如果需要实现"定制排序" ，则需要在创建 TreeSet 集合对象时，提供一个 "Comparator 对象"与该 "TreeSet集合""关联" ，由该" Comparator 对象""负责"集合元素的"排序逻辑" 。 由于 Comparator 是一个函数式接口 ， 因此可使用 Lambda 表达式来代替 Comparator 对象 。//TreeSet定制排序class M&#123; int age; public M(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "M&#123;" + "age=" + age + '&#125;'; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; //此处 Lambda 表达式的目标类型是 Comparator TreeSet ts = new TreeSet((t1, t2) -&gt; &#123; M m1 = (M) t1; M m2 = (M) t2; //根据"对象的 a归属性来决定大小， ag. 越大， M 对象反而越小 return m1.age&gt; m2.age ? -1 : m1.age&lt;m2.age ? 1 : 0; &#125;); ts.add(new M(5)); ts.add(new M(-3)); ts.add(new M(9)); System.out.println(ts); &#125;&#125;结果：降序排列： [M&#123;age=9&#125;, M&#123;age=5&#125;, M&#123;age=-3&#125;] 21TreeSet类判断对象是否重复的原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061对于TreeSet集合，判断"两个对象是否相等"的"唯一标准"是:两个对象通过"compareTo(Object obj)方法""比较"是否返回0：如果通过compareTo(Object obj)方法比较"返回0"，TreeSet则会认为它们"相等";"否则"就认为它们"不相等"。只和"compareTo(Object obj)方法""结果有关"举例：public class Exampale implements Comparable &#123; int age; public Exampale()&#123; &#125; public Exampale(int age)&#123; this.age =age; &#125; @Override public boolean equals(Object obj)&#123; return true; "equals()方法总是返回 true" &#125; public int compareTo(Object obj)&#123; return 1; "compareTo(Object obj)方法总是返回 1" &#125;&#125;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Exampale&gt; ts= new TreeSet&lt;&gt;(); Exampale e1 = new Exampale(10); ts.add(e1); (1) //第二次添加同一个对象 ， 输出 true ， 表明添加成功 boolean bb = ts.add(e1); (1) //下面输出 set 集合，将看到有两个元素 System.out.println(ts); //修改 set 集合的第一个元素的 age 变量 ts.first().age = 88; //输出 set 集合的最后一个元素的 age 变量，将看到也变成了88 System.out.println(ts.last().age);//88 &#125;&#125;结果：[demo10.Exampale@4554617c, demo10.Exampale@4554617c]88分析：程序中(1)代码行把同一个对象再次添加到 TreeSet 集合中 ，"因为 e1 对象的compareTo(Object obj)方法总是返回 1 "， "不返回0 "，虽然它的 equals()方法总是返回 true ，但 "TreeSet "会认为 " e1 对象 "和 "它自己 "也 "不相等 " ， 因此,TreeSet 可以添加两个e1对象。从图可以看到 TreeSet 对象保存的两个元素(集合里的元素总是"引用"，但习惯上把被引用的对象称为集合元素) ， 实际上是同一个元素("同一个引用") 。所以当"修改" TreeSet 集合里"第一个元素"的 age 变量后，该 TreeSet 集合里"最后一个元素"的 age 变量也"随之改变"。由此应该注意一个问题 :当需要把一个对象放入 TreeSet 中，重写该对象对应类的" equals方法"时 ，应保证该方法与 "compareTo(Object obj)方法"有"一致"的"结果".其规则是 : 如果两个对象通过" equals()方法"比较返回 true 时，这两个对象通过 "compareTo(Object obj)方法 "比较应"返回 0 "。 22各Set实现类的性能分析123456789HashSet 和 TreeSet 是 Set 的两个典型实现 ，到底如何选择HashSet 和 TreeSet 呢? "HashSet "的性能总是"比" "TreeSet" "好"(特别是最常用的"添加、查询元素等操作" ) ，因为 TreeSet 需要额外的"红黑树算法"来维护集合元素的"次序"。只有当需要一个保持"排序"的 Set 时，才应该使用 TreeSet ， "否则都应该使用 HashSet"。LinkedHashSet，对于普通的"插入、删除操作"， LinkedHashSet 比 HashSet要"略微慢一点" ，这是由"维护链表"所带来的额外开销造成的 ，但"由于有了链表"，"遍历" LinkedHashSet 会"比"HashSet"更快" 。 23 Queue(队列)集合12345678910111213Queue 用于模拟队列这种数据结构 ， 队列通常是指"先进先出" (FIFO ) 的容器 。 队列的头部保存在队列中存放时间最长的元素 ，队列的尾部保存在队列中存放时间最短的元素。新元素插入 (offer ) 到队列的尾部，访问元素 (poll) 操作会返回队列头部的元素 。通常 ，队列不允许随机访问队列中的元素。Queue 接口中定义了如下儿个方法。~ void add(Object e): 将指定元素加入此队列的【尾部】 。~ Object element(): 获取队列【头部】 的元素，但是不删除该元素 。~ boolean offer(Object e): 将指定元素加入此队列的【尾部】。当使用有容量 限制的队列时，此方法通常比 add(Object e)方法更好 。~ Object peek(): 获取队列【头部】的元素，但是【不删除】该元素。如果此队列为空，则返回 null 。~ Object poll(): 获取队列【头部】的元素 ， 并【删除】该元素 。如果此队列为 空 ，则返回 null 。~ Object remove(): 获取 队列【头部】的元素，并删除该元素 。 24 Priority Queue 优先级队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152"PriorityQueue" 是一个比较标准的队列实现类 ，但"不是绝对标准"的"队列"实现，是因为 PriorityQueue 保存队列元素的顺序并"不是"按"加入队列"的"顺序"，而是按"队列元素"的"大小"进行"重新排序"（堆结构）。因此当调用 "peek()方法或者 poll()方法"取出队列中的元素时，并"不是取出""最先进入队列的元素"，"而是"取出队列中"最小的元素" 。 从这个意义上来看 ， PriorityQueue 已经违反了队列的最基本规则 : 先进先出 (FIFO )优先级队列使用的是"堆（heap)数据结构"。堆是一个可以"自我调整的二叉树"，对树执行"添加（add) "和"删除（remore) "操作， 可以让"最小的元素（优先级最高）""移动到根"，都将"优先级最高"的任务从"队列"中"删除"（由于"习惯上将1设为最高优先级"，所以会将"最小的元素删除" )而不必花费时间对元素进行排序。优先级队列（priority queue) 中的元素可以"按照任意的顺序插人"，却总是"按照排序的顺序进行检索"。也就是说，无论何时调用 remove 方法，"总会获得"当前"优先级队列"中"最小的元素（优先级最高的元素）"。然而，优先级队列并没有对所有的元素进行排序public class QueueDemo &#123; public static void main(String[] args) &#123; Queue&lt;Integer&gt; pq =new PriorityQueue&lt;&gt;(); pq.offer(12); pq.offer(-10); pq.offer(118); pq.offer(5); pq.offer(120); System.out.println(pq);//[-10, 5, 118, 12, 120] System.out.println(pq.poll());//-10 System.out.println(pq);//[5, 12, 118, 120] System.out.println(pq.poll());//5 System.out.println(pq.poll());//12 System.out.println(pq.poll());//118 System.out.println(pq.poll());//120 &#125;&#125;运行上面程序"直接输出" PriorityQueue 集合时，可能看到该队列里的元素"并没有"很好地"按大小进行排序"，但这只是受到 PriorityQueue 的 toString()方法的返回值的影响 。实际上 ，程序"多次调用" PriorityQueue集合对象的" poll()方法"，即可看到元素"按从小到大"的顺序"移出队列"。PriorityQueue "不允许插入" null 元素，它还"需要"对"队列元素"进行"排序" ，PriorityQueue 的元素有两种排序方式。》"自然排序" : 采用自然顺序的 PriorityQueue 集合中的元素必须实现了 "Comparable 接口"，而且应该是"同一个类的多个实例"，否则可能导致 ClassCastException 异常 。》"定制排序":创建 PriorityQueue 队列时，传入一个 "Comparator 对象"，该对象负责对队列中的所有元素进行排序 。采用定制排序时不要求队列元素实现 Comparable 接口 。PriorityQueue 队列对元素的要求与 TreeSet 对元素的要求基本 一致 25 Deque 接口(双端队列)与 ArrayDeque 实现类、LinkedList 实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147~ void addFirst(Object e): 将指定元素插入该双端队列的开头。~ void addLast(Object e): 将指定元素插入该双端队列的末尾。~ Iterator descendingIterator(): 返回该双端队列对应的迭代器，该迭代器将以逆向顺序来法代队列中的元素。~ Object getFirst(): 获取但不删除双端队列的第一个元素。~ Object getLast() : 获取但不删除双端队列的最后 一个元素 。~ boolean offerFirst(Object e): 将指定元素插入该双端队列的开头 。~ boolean offerLast(Object e): 将指定元素插入该双端队列的末尾 。~ Object peekFirst(): 获取但不删除该双端队列的第一个元素;如果此双端队列为空，则返回 null 。~ Object peekLast(): 获取但不删除该双端队列的最后 一个元素;如果此双端队列为空，则返回 null 。~ Object pollFirst(): 获取并删除该双端队列的第一个元素 :如果此双端队列为 空 ，则返回 null o~ Object pollLast(): 获取并删除该双端队列的最后一个元素 ; 如果此双端队列为空，则返回 null 。~ Object pop() (栈方法) : pop 出该双端队列所表示的栈的栈顶元素 。 相当于 removeFirst() 。~ void push(Object e) (栈方法) : 将 一个元素 push 进该双端队列所表 示 的栈的栈顶 。 相当于addFirst(e) 。~ Object removeFirst(): 获取并删除该双端队列的第一个元素 。~ Object removeFirstOccurrence(Object 0): 删 除该双端队列的第一次出现的元素 。 。~ Object removeLast(): 获取并删除该双端队列的最后一个元素 。~ boolean removeLastOccurrence(Object 0): 删除该双端队列的最后一次出现的元素。;从上面方法中可以看出，" Deque" 不仅可以 当成"双端队列"使用，而且可以被当成"栈"来使用 ， 因为 该类里还包含了 pop (出栈〉、 push (入栈)两个方法。————————————————————————————————————————————————————————————————————————————————————Deque 接口提供了 一个典型的实现类: "ArrayDeque" ，从该名称就可以看出，它是一个"基于数组实现的双端队列"，创建 Deque 时同样可指定一个 numElements 参数 ，该参数用于指定 Object[]数组的长度:如果不指定 numElements 参数， Deque 底层数组的长度为 16 。"————————————————————————————————————————————————————————————————————————————————————Queue 方法 等效 Deque 方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() ————————————————————————————————————————————————————————————————————————————————————堆栈方法 等效 Deque 方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() ————————————————————————————————————————————————————————————————————————————————————"当然 "ArrayDeque" 也可以 当成"队列使用"，此处 ArrayDeque 将按"先进先出"的方式操作集合元素public class ArrayDequeDemo1 &#123; public static void main(String[] args) &#123; ArrayDeque&lt;Integer&gt; ad = new ArrayDeque&lt;&gt;(); ad.offer(23); ad.offer(1); ad.offer(56); ad.offer(-70); ad.offer(8); "//输出 :[23, 1, 56, -70, 8]" System.out.println(ad); ////访问队列头部的元素，但并不将其 poll 出队列"钱 "， 输出 : 23 System.out.println(ad.peek()); // poll 出第一个元素，输出 23 System.out.println(ad.poll()); //输出 :[1, 56, -70, 8] System.out.println(ad); &#125;&#125;展示 "ArrayDeque" 作为"栈"的行为 ，"后进先出",因此当程序中需要使用"栈" 这种数据结构时，推荐使用 ArrayDequepublic class ArrayDequeDemo &#123; public static void main(String[] args) &#123; ArrayDeque&lt;Integer&gt; ad = new ArrayDeque&lt;&gt;(); ad.push(42); ad.push(205); ad.push(-30); ad.push(78); ad.push(3); ad.push(11); "//输出 :[11, 3, 78, -30, 205, 42]" System.out.println(ad); //访问第一个元素，但并不将其 pop 出"栈,输出 :11 System.out.println(ad.peek()); //输出 :[11, 3, 78, -30, 205, 42] System.out.println(ad); //第一个元素将其 pop 出"栈,输出 :11 System.out.println(ad.pop()); //输出 :[ 3, 78, -30, 205, 42] System.out.println(ad); System.out.println(ad.peekLast()); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————LinkedList 类是 "List 接口 "的 实现类,LinkedList 还实现了 "Deque 接口",可以被当成"双端队列"来使用 ， 因此既可以被当成"栈"来使用，也可以 当成"队列"使用 。public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; lds = new LinkedList&lt;&gt;(); "//将元素加入队列的尾部" lds.offer(23); "//将一个元素加入【栈】的顶部" lds.push(111); "//将元素加入【队列】的尾部" lds.offer(407); "//将元素添加到【队列】的头部(相当于【栈】的顶部〉" lds.addFirst(56); "//输出：[56, 111, 23, 407]" System.out.println(lds); "//以 List 的方式(按【索引访问】的方式〉来遍历集合元素" for(int ee:lds)&#123; System.out.println(ee); &#125; //访问并不删除顶的元素:56 System.out.println(lds.peekFirst()) ; //访问并不删除队列的最后一个元素:407 System.out.println(lds.peekLast()) ; "//将【栈】顶的元素弹出 ,输出 56" System.out.println(lds.pop()); //输出：[111, 23, 407] System.out.println(lds); //访问并删除【队列】的最后一个元素: 407 System.out.println(lds.pollLast()); //输出：[111, 23] System.out.println(lds); &#125;&#125; 小结123456789101112131415161718192021222324252627282930 List与Set集合的区别？List: 它是一个有序的集合(元素存与取的顺序相同) 它可以存储重复的元素 Set: 它是一个无序的集合(元素存与取的顺序可能不同) 它不能存储重复的元素 List集合中的特有方法 void add(int index, Object element) 将指定的元素，添加到该集合中的指定位置上 Object get(int index)返回集合中指定位置的元素。 Object remove(int index) 移除列表中指定位置的元素, 返回的是被移除的元素 Object set(int index, Object element)用指定元素替换集合中指定位置的元素,返回值的更新前的元素 ArrayList: 底层数据结构是数组，查询快，增删慢 LinkedList: 底层数据结构是链表，查询慢，增删快 HashSet: 元素唯一，不能重复 底层结构是 哈希表结构 元素的存与取的顺序不能保证一致 如何保证元素的唯一的？ 重写hashCode() 与 equals()方法 LinkedHashSet: 元素唯一不能重复 底层结构是 哈希表结构 + 链表结构 元素的存与取的顺序一致]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础16(集合Collecton,Iterator迭代器,增强for循环,泛型)]]></title>
    <url>%2F2016%2F10%2F26%2Fday18%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、集合2、Iterator迭代器3、增强for循环4、泛型 01集合使用的回顾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 *A:集合使用的回顾 *a.ArrayList集合存储5个int类型元素 public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(111); list.add(222); list.add(333); list.add(444); list.add(555); for(int i=0; i&lt;list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125; *b.ArrayList集合存储5个Person类型元素public class Person &#123; private String name; private int age; public Person()&#123; super(); &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写toString()方法 @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;public class ArraryListDemo &#123; public static void main(String[] args) &#123; ArrayList &lt;Person&gt; aa = new ArrayList&lt;Person&gt;(); aa.add(new Person("a",23)); aa.add(new Person("b",52)); aa.add(new Person("c",36)); for(Person p : aa)&#123; System.out.println(p);//默认调用toString()方法 &#125; &#125;&#125; 02集合的学习目标12345 集合，集合是java中提供的一种容器，可以用来存储多个数据。 在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？  "数组的长度是固定的。【集合】的【长度】是【可变】的。"  " 集合中存储的元素【必须】是【引用类型数据】" 03集合继承关系图123456789101112131415161718192021222324252627A:集合继承关系图 a:ArrayList的继承关系: 查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口 "Collection接口为【最顶层】【集合接口】了"。 源代码： interface List extends Collection &#123; &#125; public class ArrayList extends AbstractList implements List&#123; &#125;b:集合继承体系 "这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。  Collecton接口常用的子接口有：List接口、Set接口  List接口常用的子类有：ArrayList类、LinkedList类  Set接口常用的子类有：HashSet类、LinkedHashSet类 Collection 接口 | ---------------------------------------------------------------- | | List接口 Set接口 | | ---------------- ------------- | | | |ArrayList类 LinkedList类 HashSet类 LinkedHashSet类" 04集合Collection的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879A:集合Collection的方法 "/* * Collection接口中的方法 * 是集合中所有实现类必须拥有的方法 * 使用Collection接口的实现类,程序的演示 * ArrayList implements List * List extends Collection * 方法的执行,都是实现的重写 */" public class CollectionDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* Collection接口方法 * Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组 * 返回是一个存储对象的数组, 数组存储的数据类型是Object */" private static void function_2() &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); Object[] objs = coll.toArray(); for(int i = 0 ; i &lt; objs.length ; i++)&#123; System.out.println(objs[i]); &#125; &#125; "/* * 学习Java中三种长度表现形式 * —————————————————————————————————— * 数组.length 属性 返回值 int * —————————————————————————————————— * 字符串.length() 方法,返回值int * —————————————————————————————————— * 集合.size()方法, 返回值int */" "/* * Collection接口方法 * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true * 如果此 collection 包含【指定的元素】，则返回 true * 方法参数是Object类型 */" private static void function_1() &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); boolean b = coll.contains("itcast"); System.out.println(b); &#125; "/* * Collection接口的方法 * void clear() 清空集合中的所有元素 * 集合容器本身依然存在 */" public static void function()&#123; //接口多态的方式调用 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("bcd"); System.out.println(coll); coll.clear(); System.out.println(coll); &#125; &#125; 05集合Collection的remove方法1234567891011121314151617181920212223242526A:05集合Collection的remove方法 "/* * Collection接口方法 * boolean remove(Object o)移除集合中指定的元素 * 如果集合中包含多个相同的元素，remove方法只删除出现的第一个元素。 * * * 另外： * boolean removeAll(Collection&lt;?&gt; c) * 移除此 collection 中那些也包含在【指定 collection 】中的【所有元素】（可选操作）。 * 此调用返回后，collection 中将不包含任何与指定 collection 相同的元素。 */" private static void function_3()&#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("money"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); System.out.println(coll); boolean b = coll.remove("money"); System.out.println(b); System.out.println(coll); &#125; 06迭代器的概述1234567891011A:迭代器概述:a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种"通用的获取方式"来完成。b:"Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为【迭代】。"c:"每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素以及取出里面的元素的动作,那么Java为我们提供一个【迭代器】定义了【统一的判断元素和取元素的方法】" 07迭代器的实现原理123456789101112131415161718 *A:迭代器的实现原理" /* * 集合中的迭代器: * 获取集合中元素方式 * 接口 Iterator : 两个抽象方法 * boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true * next() 取出集合中的下一个元素 * ———————————————————————————————————————————————————————————————————— * Iterator接口,找实现类. * Collection接口定义了iterator方法： * Iterator&lt;E&gt; iterator() * 返回在此 collection 的元素上进行迭代的迭代器 *———————————————————————————————————————————————————————————————————— * ArrayList类 重写方法 iterator(),返回了Iterator接口的实现类的对象 * 使用ArrayList集合的对象 * Iterator it =array.iterator(),运行结果就是Iterator接口的实现类ArrayList的对象 * it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代 */" 08迭代器的代码实现1234567891011121314151617181920212223242526*A:迭代器的代码实现 public class IteratorDemo &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); coll.add("abc4"); //迭代器,对集合ArrayList中的元素进行取出 //调用集合的方法iterator()获取出,Iterator接口的实现类的对象 Iterator&lt;String&gt; it = coll.iterator(); //接口实现类对象,调用方法hasNext()判断集合中是否有元素 //boolean b = it.hasNext(); //System.out.println(b); //接口的实现类对象,调用方法next()取出集合中的元素 //String s = it.next(); //System.out.println(s); //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; &#125; &#125; 09迭代器的执行过程12345678910111213141516171819202122232425A:迭代器的执行过程 a:迭代器的原理: while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //cursor记录的索引值不等于集合的长度返回true,否则返回false public boolean hasNext() &#123; return cursor != size; //cursor初值为0 &#125; //next()方法作用: //①返回cursor指向的当前元素 //②cursor++ public Object next() &#123; int i = cursor; cursor = i + 1; return elementData[lastRet = i]; &#125; b:for循环迭代写法: for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext(); ) &#123; System.out.println(it2.next()); &#125; 10集合迭代中的转型12345678910111213141516171819202122232425262728293031323334A:集合迭代中的转型 a:在使用集合时，我们需要注意以下几点：  "集合中存储其实都是【对象的地址】"。  "集合中可以存储基本数值"：jdk1.5版本以后可以存储了。 "因为出现了【基本类型】的【包装类】，它提供了【自动装箱】操作（基本类型对象）"， 这样，"集合中的元素就是【基本数值】的【包装类】对象"。b:"存储时提升了Object。取出时要使用元素的【特有内容】，必须【向下转型】"。 "可以【不指定】【集合的存储类型】，即可以添加 Object 对象(任意对象)"，如下所示： Collection coll = new ArrayList(); coll.add("abc"); coll.add("aabbcc"); coll.add("shitcast"); Iterator it = coll.iterator(); while (it.hasNext()) &#123; //由于元素被存放进集合后全部被提升为Object类型 //当需要使用子类对象特有方法时，需要向下转型 String str = (String) it.next(); System.out.println(str.length()); &#125;" 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。"c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下： Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("aabbcc"); coll.add("shitcast"); Iterator&lt;String&gt; it = coll.iterator(); while (it.hasNext()) &#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; 11增强for循环遍历数组123456789101112131415161718192021222324252627282930313233*A:增强for循环遍历数组 a:格式: "/* * JDK1.5新特性,增强for循环 * JDK1.5版本后,出现新的接口 java.lang.Iterable * Collection开是继承Iterable * Iterable作用,实现增强for循环 * * 格式: * for( 数据类型 变量名 : 数组或者集合 )&#123; * sop(变量); * &#125; */" public static void function_1()&#123; "for each对于对象数组遍历的时候,可以【调用】【对象的方法】" String[] str = &#123;"abc","itcast","cn"&#125;; for(String s : str)&#123; System.out.println(s.length()); &#125; &#125; "/* * 实现for循环,遍历数组 * 好处: 代码少了,方便对容器遍历 * 弊端: 没有索引,不能操作容器里面的元素 */" public static void function()&#123; int[] arr = &#123;3,1,9,0&#125;; for(int i : arr)&#123; System.out.println(i+1); &#125; System.out.println(arr[0]); &#125; 12增强for循环遍历集合12345678910111213A:增强for循环遍历集合 " /* * 增强for循环遍历集合 * 存储自定义Person类型 */" public static void function_2()&#123; ArrayList&lt;Person&gt; array = new ArrayList&lt;Person&gt;(); array.add(new Person("a",20)); array.add(new Person("b",10)); for(Person p : array)&#123; System.out.println(p);// System.out.println(p.toString()); &#125; &#125; 13泛型的引入12345678910111213141516171819202122232425A:泛型的引入"在前面学习集合时，我们都知道集合中是可以【存放任意对象】的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用【类型转换】。"比如下面程序：public class GenericDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add("abc"); list.add("itcast"); list.add(5);"//由于集合没有做任何限定，任何类型都可以存放" "//自动装箱:Object obj=new Integer(5);" Iterator it = list.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next();//String str=(String)obj; "//编译时期仅检查语法错误,String是Object的子类可以向下转型 //运行时期String str=(String)(new Integer(5)) //String与Integer没有父子关系所以转换失败 //程序在运行时发生了问题java.lang.ClassCastException" System.out.println(str.length()); &#125; &#125;&#125; 14泛型的定义和使用12345678910111213141516171819202122232425A:泛型的定义和使用"/* * JDK1.5 出现新的安全机制,保证程序的安全性 * 泛型: 指明了【集合】中【存储数据的类型】 &lt;类型变量&gt; */"public class GenericDemo &#123; public static void main(String[] args) &#123; function(); &#125; public static void function()&#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("rtyg"); coll.add("43rt5yhju");// coll.add(1); Iterator&lt;String&gt; it = coll.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s.length()); &#125; &#125;&#125; 15Java中的伪泛型1234567891011121314151617181920212223242526272829303132333435363738A:Java中的【伪泛型】："泛型【只在】【编译时】存在,【编译后】就被【擦除】,在编译之前我们就可以限制集合的类型,起到安全作用""编译后得到的Class文件是【没有】【泛型】的，实际并不存在泛型类，【系统】【不会】生成泛型类"例如: ArrayList&lt;String&gt; al=new ArrayList&lt;String&gt;();"编译后": ArrayList al=new ArrayList();————————————————————————————————————————————————————————————————————————————————————————B："运行时类查询(getClass方法)【只适用】于【原始类型】"。可以理解为ArrayList&lt;String&gt;类是ArrayList的子类，事实上，ArrayList&lt;String&gt;类也确实像一种特殊的ArrayList类:"该ArrayList&lt;String&gt;对象【只能】添加【String对象】作为【集合元素】"。但实际上，"系统【并没有】为ArrayList&lt;String&gt;生成【新的class文件】， 而且也【不会】把ArrayList&lt;String&gt;当成【新类】来处理"例如:List&lt;String&gt; l1 =new ArrayList&lt;&gt;();List&lt;Integer&gt; ii = new ArrayList&lt;&gt;();System.out.println(l1.getClass());"//class java.util.ArrayList"System.out.println(ii.getClass());"//class java.util.ArrayList"System.out.println(l1.getClass() == ii.getClass());"true"————————————————————————————————————————————————————————————————————————————————————————C： "不管为泛型的【类型形参】传入哪一种一【类型实参】，对于Java来说，它们依然被当成【同一个类处理】，在内存中也【只占用一块内存空间】"，"因此在【静态方法】、【静态初始化块】或者【静态变量】的【声明和初始化】中【不允许】使用【类型形参】"。下面程序演示了这种"【错误】"。public class Apple&lt;T&gt; &#123; private static T age; "【error】" public static void bar(T mm)&#123; "【error】" &#125;————————————————————————————————————————————————————————————————————————————————————————D："由于系统中并不会真正生成泛型类，所以【instanceof运算符】后【不能】使用【泛型类】"List&lt;Integer&gt; ii = new ArrayList&lt;Integer&gt;();if(ii instanceof ArrayList)&#123;//true &#125;if(ii instanceof ArrayList&lt;Integer&gt;)&#123;"【error】" &#125; 16泛型类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697A:泛型类:a:定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; &#125;注意："泛型类的【静态方法】、【静态初始化块】或者【静态变量】的 【声明和初始化】中【不允许】使用【类型形参】T"private static T age;"【error】"public static void bar(T mm)&#123;"【error】"&#125;static&#123; T gr = 1;"【error】"&#125;————————————————————————————————————————————————————————————————————————————————————————b:使用格式： "创建对象时，确定泛型的类型" 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型 class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; &#125; 例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型 class ArrayList&lt;Integer&gt;&#123; public boolean add(Integer e)&#123; &#125; public Integer get(int index)&#123; &#125; &#125;————————————————————————————————————————————————————————————————————————————————————————c:"可以为【任何类，接口】【增加泛型声明】(【井不是】【只有】集合类才可以使用泛型声明，虽然集合类是泛型的重要使用场所)"例如：public class Apple&lt;T&gt; &#123; private T info; private String id; public Apple()&#123; super(); &#125; public Apple(T info)&#123; this.info = info; &#125; public Apple(T info, String id)&#123; this.info = info; this.id =id; &#125; public void setInfo(T info)&#123; this.info =info; &#125; public T getInfo()&#123; return this.info; &#125; public void setId(String id)&#123; this.id =id; &#125; public String getId()&#123; return this.id; &#125; @Override public String toString()&#123; return "&#123;"+ "id=: " +this.id+ "|"+" info=: "+ this.info +"&#125;"; &#125;&#125;public class AppleTest &#123; public static void main(String[] args) &#123; new Apple&lt;Double&gt;(); Apple&lt;Double&gt; a1= new Apple&lt;&gt;(25008.8,"刘鹏001"); Apple&lt;Integer&gt; b2 = new Apple&lt;&gt;(26000,"周莉002"); System.out.println(a1); System.out.println(b2); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————d: "当创建带泛型声明的自定义类，为该类定义【构造器】时， 【构造器名】还是【原来的类名】，【不能】【增加泛型声明】。例如，为Apple&lt;T&gt;类定义构造器，其【构造器名依然是Apple】，而【不是】Apple&lt;T&gt;!【调用】（new对象时）该构造器时却可以使用Apple&lt;T&gt;的形式，当然应该为T形参传入实际的类型参数"。如：public Apple(T info)&#123; this.info = info; &#125;public Apple(T info, String id)&#123; this.info = info; this.id =id; &#125; 17 泛型类派生子类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849A:当创建了带泛型声明的接口、父类之后，可以为该接创建实现类，或从该父类派生子类，"需要指出的是，当使用这些接口、父类时【不能】再【包含】【类型形参】。例如，下而代码就是【错误】的"public class SubApple extends Apple&lt;T&gt;&#123;&#125;"//error""除非：子类也是泛型类"，即：SubApple&lt;T&gt;public class SubApple&lt;T&gt; extends Apple&lt;T&gt;&#123;&#125;————————————————————————————————————————————————————————————————————————————————————————B:定义方法时可以声明数据形参，调用方法(使用方法)时必须为这些数据形参传入实际的数据:与此类似的是，"定义类、接口、方法时可以声明类型形参，使用类、接口、方法时应该为【类型形参】传入【实际的类型】"。public class SubApple11 extends Apple&lt;Integer&gt;&#123;&#125;public class SubApple11 extends Apple&lt;Integer&gt;&#123; public SubApple11()&#123; super(); &#125; public SubApple11(Integer d,String s)&#123; super(d,s); &#125; @Override public Integer getInfo()&#123; "//父类是Apple&lt;Integer&gt;" "返回值类型必须与Apple&lt;Integer&gt;的返回值类型完全相同" return super.getInfo() +5000; &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————C: 调用方法时必须为所有的数据形参传入参数值，"与调用方法不同的是"，"使用类、接口时【可以】【不为】类型形参传入【实际的类型参数】，即下面代码也是【正确】的"。"此时，系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理"。public class SubApple extends Apple&#123;&#125;举例：public class SubApple extends Apple&#123;//系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理public SubApple()&#123; super();&#125;public SubApple(Double d,String s)&#123; super(d,s);&#125;@Overridepublic Double getInfo()&#123; "//super.getInfo()是Object类型" return (Double) super.getInfo() +1000;&#125;&#125; 18泛型的方法123456789101112131415161718192021222324A:泛型的方法a:"定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125;"b:泛型方法的使用: 1:例如，API中的ArrayList集合中的方法： public &lt;T&gt; T[] toArray(T[] a)&#123; &#125; //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组"使用格式：调用方法时，确定泛型的类型"例如: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); String[] arr = new String[100]; String[] result = list.toArray(arr); "此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同" public &lt;String&gt; String[] toArray(String[] a)&#123; &#125;  例如: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); Integer[] arr = new Integer[100]; Integer [] result = list.toArray(arr); "此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同" public &lt;Integer&gt; Integer[] toArray(Integer[] a)&#123; &#125; 19泛型的接口12345678910111213141516171819202122A:泛型的接口: "/* * 带有泛型的接口 * * public interface List &lt;E&gt;&#123; * abstract boolean add(E e); * &#125; * ———————————————————————————————————————————————————————————————————— *A: 实现类,先实现接口,不理会泛型 * public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; * &#125; * 调用者 : new ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型 * * ———————————————————————————————————————————————————————————————————— *B: 实现类,实现接口的同时,也指定了数据类型 * public class XXX implements List&lt;String&gt;&#123; * &#125; * new XXX() */" public class GenericDemo2 &#123; &#125; 20泛型的好处1234567891011121314151617181920A:泛型的好处a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。b:避免了类型强转的麻烦。演示下列代码：public class GenericDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); System.out.println(str.length()); //当使用Iterator&lt;String&gt; //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 &#125; &#125; &#125; 21泛型的继承规则12345678910111213A："Manager类 是 Employee类 的【子类】。 但 Pair&lt;Manager&gt; 【不是】Pair&lt;Employee&gt; 的【子类】" ，"即 Pair&lt;Manager&gt; 与 Pair&lt;Employee&gt; 【没有】【继承关系】""无论 S 与 T 有什么联系，通常， Pair&lt;S&gt; 与 Pair&lt;T&gt; 没有联系"如：Integer是Number的子类List&lt;Integer&gt; ss = new ArrayList&lt;&gt;();List&lt;Number&gt; nn= ss; "// Error"B："数组和泛型有所不同：，假设Foo是Bar的一个子类型(子类或者子接口)，那么 Foo[]【依然是】Bar[] 的子类型;但 G&lt;Foo&gt; 【不是】 G&lt;Bar&gt; 的子类型"。Manager[] managerBuddies = &#123; ceo, cfo &#125;;Employee[] employeeBuddies = managerBuddies; // OK 22泛型的通配符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179A:泛型的通配符"为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号(?)，将一个问号作为类型实参传给List集合，写作:List&lt;?&gt; 意思是元素类型未知的List 。这个问号(?)被称为【通配符】，它的元素类型可以【匹配任何类型】(Object 类型)"注意："这种带通配符的List仅表示它是【各种泛型List】的【父类】， 【不能】把【元素】加入到其中，因为其类型是无法确定的" 但是程序【可以调用】get() 方法来返回List&lt;?&gt;集合指定索引处的元素， 其返回值是一个未知类型，但可以肯定的是，它总是一个【Object类型】如：List&lt;?&gt; c = new ArrayList&lt;&gt;();"//下面程序引起编译错误"c.add(new Object());"//error"—————————————————————————————————————————————————————————————————————————————————————————— /** 泛型的通配符*/public class GenericDemo &#123;public static void main(String[] args) &#123; ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); array.add("123"); array.add("456"); set.add(789); set.add(890); iterator(array); iterator(set);&#125;"/* * 定义方法,可以同时迭代2个集合 * 参数: 怎么实现 , 不能写ArrayList,也不能写HashSet * 参数: 或者共同实现的接口 * 泛型的通配,匹配所有的数据类型 ? */"public static void iterator(Collection&lt;?&gt; coll)&#123; Iterator&lt;?&gt; it = coll.iterator(); while(it.hasNext())&#123; //it.next()获取的对象是什么类型,就得到什么类型 System.out.println(it.next()); &#125;&#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————B：设定类型通配符的上限" List&lt;? extends Shape&gt; 是受限制通配符的例子，此处的问号(?)代表一个未知的类型，就像前面看到的通配符一样。但是此处的这个未知类型【必须】是【Shape的子类型(也可以是Shape本身)】，因此可以把Shape称为这个【通配符的上限】（upper bound）"类似地，"由于程序【无法确定】这个受限制的通配符的【具体类型】，所以【不能】把【Employee对象或其子类的对象】加入这个泛型集合中。例如，下面代码就是【错误】的。"public static void iterator_func(ArrayList&lt;? extends Employee&gt; list)&#123; list.add(new Manager());"//error"&#125;"————————————————————————————————extends通配符的缺陷————————————————————————————————""当使用 extends 通配符时，我们【无法】向其中【添加】【任何对象】。【只能】从中【取出】对象"例如：Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;();plate.add(new Apple()); "//Compile Error"plate.get(); // Compile Success因为编译时只看父类，运行时看子类，在我们还【未具体运行】时，1）进行"添加操作"时："JVM 并不知道我们要往plate里【添加】什么对象，只知道添加的是Fruit的【子类】，【无法确定】"。2）而执行"取出操作"时，JVM 知道结果"一定是父类Fruit的子类，可以做自动【向上转型】，用【父类的变量】接收【子类对象】"即：Fruit apple = plate.get();//多态的向上转型当然：如果考虑" Fruit类继承自 Food类"，还可以"继续向上转型"：即:Food food = plate.get();//多态的向上转型同样：Object food = plate.get(); 上述3种 赋值 都是"正确"的。举例："方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象" public static void iterator_func(ArrayList&lt;? extends Employee&gt; list)&#123; Iterator&lt;? extends Employee&gt; it = list.iterator(); while(it.hasNext())&#123; Employee e = it.next(); e.work(); &#125; &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————C：设定类型形参的上限Java泛型不仅允许在使用通配符形参时设定上限，"而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。"下面程序示范了这种用法。public class GenericDemo2&lt;T extends Number&gt; &#123; T nn; public static void main(String[] args) &#123; GenericDemo2&lt;Integer&gt; ii= new GenericDemo2&lt;&gt;(); GenericDemo2&lt;Double&gt; dd = new GenericDemo2&lt;&gt;(); "//下面代码将引发编译异常，下面代码试图把String类型传给T形参 //但String不是Number的子类型，所以引起编译错误" GenericDemo2&lt;String&gt; ss = new GenericDemo2&lt;&gt;();//error &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————D：设定类型形参的下限" List&lt;? super Type&gt;表示传入的未知类型【必须】是【Type本身，或者Type的父类型】"例如：Apple 类 和 Orange 类 继承自 Fruit类，Plate&lt;? super Apple&gt; plate = new Plate&lt;Fruit&gt;();Plate&lt;? super Apple&gt; plate = new Plate&lt;Object&gt;();上面的声明都是对的，因为 Object 是任何一个类的父类，而 Fruit类 是 Apple类 的父类。"————————————————————————————————super通配符的缺陷————————————————————————————————"&lt;? super T&gt;对于使用了 super 通配符的情况，我们"只能【存入】【 T 类型】及【 T 类型的子类】对象"。"【取出】的时候【必须】用【 Object 类型】的属性指向取出的对象"。例如：Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类Plate&lt;? super Fruit&gt; plate = new Plate&lt;&gt;();plate.add(new Fruit());plate.add(new Apple());plate.add(new Food()); "//Compile Error"plate 指向的具体类型可以是任何 "Fruit类及其父类"，JVM 在编译的时候肯定"无法判断具体是哪个类型"。但 JVM 能确定的是，"任何 Fruit 的子类【都可以】自动【向上转型】为 Fruit 类型"，"但任何 Fruit 的父类都【无法直接】转为 Fruit 类型，【只能】【向下强转】"。所以 "只能存入 T 类型及 T 类型的【子类】对象"，"T 类型的子类对象 能自动 【向上转型】为T 类型"Object object = plate.get();Fruit fruit = plate.get(); "//Error"Food food = plate.get(); "//Error"plate 指向的具体类型可以是任何 "Fruit类及其父类",接收类型是不确定的，"只能用Object 类型才能正确接收"。——————————————————————————————————————————————————————————————————————————————————————————总结：PECS(Producer Extends, Consumer Super)原则extends 和 super 通配符的使用和限制：对于 "extends 通配符"，我们"【无法】向其中【加入】任何对象"，但是"我们可以进行正常的取出"。对于 super 通配符，我们"可以存入 【T 类型】对象或 【T 类型的子类】对象"，但是我们取出的时候"【只能】用【 Object 类】变量指向取出的对象"。从上面的总结可以看出，"extends 通配符""偏向于内容的获取"，而 super 通配符更"偏向于内容的存入"。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。Producer Extends 说的是当你的情景是"生产者类型"，需要"获取资源"以供生产时，我们建议使用" extends 通配符"，因为使用了 extends 通配符的类型更适合获取资源。Consumer Super 说的是当你的场景是"消费者类型"，需要"存入资源"以供消费时，我们建议使用 "super 通配符"，因为使用 super 通配符的类型更适合存入资源。但如果你"既想存入，又想取出"，那么你最好还是不要使用 extends 或 super 通配符。 23泛型的限定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051A:泛型的限定" /** 将的酒店员工,厨师,服务员,经理,分别存储到3个集合中* 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法*/"import java.util.ArrayList;import java.util.Iterator;public class GenericTest &#123;public static void main(String[] args) &#123; //创建3个集合对象 ArrayList&lt;ChuShi&gt; cs = new ArrayList&lt;ChuShi&gt;(); ArrayList&lt;FuWuYuan&gt; fwy = new ArrayList&lt;FuWuYuan&gt;(); ArrayList&lt;JingLi&gt; jl = new ArrayList&lt;JingLi&gt;(); //每个集合存储自己的元素 cs.add(new ChuShi("张三", "后厨001")); cs.add(new ChuShi("李四", "后厨002")); fwy.add(new FuWuYuan("翠花", "服务部001")); fwy.add(new FuWuYuan("酸菜", "服务部002")); jl.add(new JingLi("小名", "董事会001", 123456789.32)); jl.add(new JingLi("小强", "董事会002", 123456789.33)); // ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;(); iterator(jl); iterator(fwy); iterator(cs);&#125;"/* * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法 * 强制转换: it.next()=Object o ==&gt; Employee * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象 * 【泛型的限定】 本案例,父类固定Employee,但是子类可以无限? * ———————————————————————————————————————————————————————————————————— * ? extends Employee 限制的是【父类】, 【上限限定】, 可以传递Employee,传递他的【子类】对象 * ———————————————————————————————————————————————————————————————————— * ? super Employee 限制的是【子类】, 【下限限定】, 可以传递Employee,传递他的【父类】对象 */"public static void iterator(ArrayList&lt;? extends Employee&gt; array)&#123; Iterator&lt;? extends Employee&gt; it = array.iterator(); while(it.hasNext())&#123; //获取出的next() 数据类型,是什么Employee Employee e = it.next(); e.work(); &#125;&#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础15(包装类,System类,Math类,Arrays类)]]></title>
    <url>%2F2016%2F10%2F25%2Fday17%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、基本类型包装类2、System类3、Math类4、Arrays类5、大数据运算 01基本数据类型对象包装类概述123456789101112*A:基本数据类型对象包装类概述 *a.基本类型包装类的产生 在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等 *b.八种基本类型对应的包装类 char Character int Integer byte Byte short Short long Long float Float double Double boolean Boolean 02Integer类parseInt方法123456789101112131415161718 *A:Integer类parseInt方法: *a:parseInt() int i = Integer.parseInt("12"); System.out.println(i/2);//6 *b:parseInt(String s, int radix) /* * Integer类静态方法parseInt(String s, int radix) * radix基数,进制 * "110",2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制 * 指定进制的字符串转换为十进制的整数 */ public static void function_1()&#123; int i = Integer.parseInt("110", 2); System.out.println(i); int a = Integer.parseInt("f",16); System.out.println(a); &#125; 03Integer类int转成字符串123456789*A:Integer类int转成字符串: *a:使用+与字符串拼接 int i = 3; String s = i+""; System.out.println(s+1);//"31" *b:toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解) String s1 = Integer.toString(5,2); System.out.println(s1); 04Integer类构造方法12345678910111213*A:Integer类构造方法 "/* * Integer类构造方法 * Integer (String s) * 将数字格式的字符串,传递到Integer类的构造方法中 * 创建Integer对象,包装的是一个字符串 * 将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue() */" public static void function_3()&#123; Integer in = new Integer("100"); int i = in.intValue(); System.out.println(--i);//99 &#125; 05Integer类其他方法12345678910111213141516171819202122232425*A:Integer类其他方法 "/** Integer类的3个静态方法* 做进制的转换* 十进制转成二进制 toBinarString(int)* 十进制转成八进制 toOctalString(int)* 十进制转成十六进制 toHexString(int)* 三个方法,返回值都是以String形式出现*/" a:十进制转二,八,十六进制 public static void function_1()&#123; System.out.println(Integer.toBinaryString(99)); System.out.println(Integer.toOctalString(99)); System.out.println(Integer.toHexString(999)); &#125; b:获取int的最大值和最小值 /* * Integer类的静态成员变量 * MAX_VALUE * MIN_VALUE */ public static void function()&#123; System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); &#125; 06自动装箱和自动拆箱,valueOf12345678910111213141516171819 *A:自动装箱与自动拆箱: "//JDK1.5新特性//自动装箱,拆箱的 好处: 基本类型和引用类直接运算 //自动装箱:使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象 //自动拆箱:使用Integer对象.intValue()返回Integer对象中封装的整数值"public static void function()&#123; //引用类型 , 引用变量一定指向对象 //自动装箱, 基本数据类型1, 直接变成了对象 Integer in = 1; // Integer in = new Integer(1) //in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型 //in+1 ==&gt; in.inValue()+1 = 2 //in = 2 自动装箱 in = in + 1; System.out.println(in); &#125; valueOf() 方法继承自Java Number类 valueOf() 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。 该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。 语法该方法有以下几种语法格式：123static Integer valueOf(int i)static Integer valueOf(String s)static Integer valueOf(String s, int radix) 参数i – Integer 对象的整数。 s – Integer 对象的字符串。 radix –在解析字符串 s 时使用的基数，用于指定使用的进制数。 返回值Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。 Integer valueOf(String s):返回保存指定的 String 的值的 Integer 对象。 Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。 实例1234567891011121314public class Test&#123; public static void main(String args[])&#123; Integer x =Integer.valueOf(9); Double c = Double.valueOf(5); Float a = Float.valueOf("80"); Integer b = Integer.valueOf("789",16); // 使用 16 进制 System.out.println(x); System.out.println(c); System.out.println(a); System.out.println(b); &#125;&#125; 编译以上程序，输出结果为： 95.080.01929 前言今天在做题时，碰到了一道选择题，就是关于Integer.valueOf()的知识，题目如下：Integer i01=59int i02=59Integer i03 =Integer.valueOf(59)Integer i04 = new Integer(59) 判断对错：A.System.out.println(i01== i02);B.System.out.println(i01== i03);C.System.out.println(i03== i04);D.System.out.println(i02== i04); 分析 选项A 选项A中比较的是i01和i02，Integer i01=59这里涉及到自动装箱过程，59是整型常量，经包装使其产生一个引用并存在栈中指向这个整型常量所占的内存，这时i01就是Integer 的引用。 而int i02=59由于int是基本类型，所以不存在引用问题，直接由编译器将其存放在栈中，换一句话说，i02本身就是59。那么System.out.println(i01== i02)结果任何呢？这里涉及到了拆箱的过程，因为等号一边存在基本类型所以编译器后会把另一边的Integer对象拆箱成int型，这时等号两边比较的就是数值大小，所以是true。 好了，到了这里，你有没有想到这样一个问题：如果是Integer i01=59；Integer i02=59；然后System.out.println(i01== i02)的结果是？可能你会说比较数值大小所以相等啊，也有可能说等号两边对象引用，所以比较的是引用，又因为开辟了不同的内存空间，所以引用不同所以返回false。可是正确答案是：true.再来看这个问题：：如果是Integer i01=300；Integer i02=300；然后System.out.println(i01== i02)的结果是？ 这次的答案是false。 解析：当靠想象无法解决问题的时候，这是就要看源代码了！！很重要！我们可以在Integer类中找到这样的嵌套内部类IntegerCache：12345678910111213141516171819202122232425private static class IntegerCache &#123;//静态缓存类 static final int low = -128; static final int high; static final Integer cache[]; static &#123; //静态代码块 // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125; 这个类就是在Integer类装入内存中时，会执行其内部类中静态代码块进行其初始化工作，做的主要工作就是把一字节的整型数据（-128-127）包装成Integer类并把其对应的引用存入到cache数组中，这样在方法区中开辟空间存放这些静态Integer变量，同时静态cache数组也存放在这里，供线程享用，这也称静态缓存。 所以当用Integer 声明初始化变量时，会先判断所赋值的大小是否在-128到127之间，若在，则利用静态缓存中的空间并且返回对应cache数组中对应引用，存放到运行栈中，而不再重新开辟内存。 所以对于Integer i01=59；Integer i02=59；i01 和 i02是引用并且相等都指向缓存中的数据，所以返回true。而对于Integer i01=300；Integer i02=300；因为其数据大于127，所以虚拟机会在堆中重新new （开辟新空间）一个 Integer 对象存放300，创建2个对象就会产生2个这样的空间，空间的地址肯定不同导致返回到栈中的引用的只不同。所以System.out.println打印出false。 补充：为什么1个字节的数据范围是-128到127呢，因为Java中数据的表示都是带符号数，所以最高位是用来表示数据的正负，0表示正数，1表示负数，所以正数最大的情况对应的二进制数为：01111111，负数最小对应的二进制数为：10000000. B选项 从上面的分析，我们已经知道Integer i01=59返回的是指向缓存数据的引用。那么Integer.valueOf(59)返回的是什么或者操作是什么呢？ 这个函数的功能就是把int 型转换成Integer，简单说就是装包，那他是新创建一个对象吗？还是像之前利用缓存的呢？有了之前的经验，肯定想到的是利用缓存，这样做既提高程序速度，又节约内存，何乐而不为？来看一下源代码：123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 很明显跟之前的思想一致，若在-128到127范围，直接返回该对象的引用，否则在堆中重新new 一个。 到这，System.out.println(i01== i03)的结果毋庸置疑就是true. 选项C Integer.valueOf(59)返回的是已缓存的对象的引用，而Integer i04 = new Integer(59)是在堆中新开辟的空间，所以二者的引用的值必然不同，返回false,这道题呢就选C 选项D System.out.println(i02== i04) i02是整型变量，i04是引用，这里又用到了解包，虚拟机会把i04指向的数据拆箱为整型变量再与之比较，所以比较的是数值，59==59，返回true. 思考 不得不服，Java这的设计真是巧妙，以后应多注意看看源码，其思想使我受益匪浅。出一道题：12345System.out.println(Integer.valueOf("127")==Integer.valueOf("127"));//trueSystem.out.println(Integer.valueOf("128")==Integer.valueOf("128"));//falseSystem.out.println(Integer.parseInt("128")==Integer.valueOf("128"));//true"//parseInt返回的是10进制整数，Integer.valueOf("128")的Integer对象拆箱成int型， 这时等号两边比较的就是数值大小，所以是true" 07自动装箱和自动拆箱练习题12345678910111213141516171819202122*A:自动装箱与自动拆箱: Integer i = new Integer(1);Integer j = new Integer(1);System.out.println(i==j);// false 对象地址System.out.println(i.equals(j));// true 继承Object重写equals,比较的对象数据System.out.println("===================");Integer a = 500;//Integer integer=Integer.valueOf(500) //integer=new Integer(500);Integer b = 500;System.out.println(a==b);//falseSystem.out.println(a.equals(b));//trueSystem.out.println("===================");"数据在byte(-128~127)范围内,JVM不会从新new对象"Integer aa = 127; // Integer aa = new Integer(127)Integer bb = 127; // Integer bb = aa;System.out.println(aa==bb); //trueSystem.out.println(aa.equals(bb));//true 08System类方法currentTimeMillis123456789101112131415161718192021在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息，和系统操作。System类"不能手动创建对象"，因为"构造方法"被private修饰，"阻止外界创建对象"。System类中的"都是"static方法，"类名访问即可"。在JDK中，有许多这样的类。*A:System类方法currentTimeMillis():用于计算程序的执行时间 /* * 获取系统当前毫秒值 * static long currentTimeMillis() * 对程序执行时间测试 */ public static void function()&#123; long start = System.currentTimeMillis();//当前时间x-1970年1月1日零时零分零秒 for(int i = 0 ; i &lt; 10000; i++)&#123; System.out.println(i); &#125; long end = System.currentTimeMillis();//当前时间y-1970年1月1日零时零分零秒 System.out.println(end - start);//当前时间y-当前时间x &#125; 09System类方法exit1234567891011 *A:System类方法exit()方法 /* * 退出虚拟机,所有程序全停止 * static void exit(0) */public static void function_1()&#123; while(true)&#123; System.out.println("hello"); System.exit(0);//该方法会在以后的finally代码块中使用(讲到再说) &#125;&#125; 10System类方法gc123456789101112131415161718192021222324A:System类方法gc public class Person &#123; public void finalize()&#123; System.out.println("垃圾收取了"); &#125; &#125; "* * JVM在内存中,收取对象的垃圾 * 当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象 * 同时调用回收对象所属类的 【finalize方法() * static void gc() *" public static void function_2()&#123; new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); System.gc(); &#125; 11System类方法getProperties12345678A:System类方法getProperties(了解) /* * 获取当前操作系统的属性:例如操作系统名称, * static Properties getProperties() */ public static void function_3()&#123; System.out.println( System.getProperties() ); &#125; 12System类方法arraycopy1234567891011121314151617181920212223242526272829303132333435 " /* * System类方法,复制数组,这是一个本地方法 * arraycopy(Object src, int srcPos, Object dest, int destPos, int length) * Object src, 要复制的源数组 * int srcPos, 数组源的起始索引 * Object dest,复制后的目标数组 * int destPos,目标数组起始索引 * int length, 复制几个 */""从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的【源数组】到 dest 引用的【目标数组】，数组组件的一个【子序列】被复制下来。被复制的组件的编号等于 length 参数。【源数组】中位置在【 srcPos 】到【 srcPos+length-1 】之间的组件被分别复制到【目标数组】中的【 destPos 】到【 destPos+length-1 】位置。" A:System类方法arraycopy： /* * System类方法,复制数组 * arraycopy(Object src, int srcPos, Object dest, int destPos, int length) * Object src, 要复制的源数组 * int srcPos, 数组源的起始索引 * Object dest,复制后的目标数组 * int destPos,目标数组起始索引 * int length, 复制几个 */ public static void function_4()&#123; int[] src = &#123;11,22,33,44,55,66&#125;; int[] desc = &#123;77,88,99,0&#125;; System.arraycopy(src, 1, desc, 1, 2);//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上 for(int i = 0 ; i &lt; desc.length ; i++)&#123; System.out.println(desc[i]); &#125; &#125; 13Math类的方法_1123456789101112131415161718192021222324252627282930313233343536373839404142434445A:Math类中的方法/* * static double sqrt(double d) * 返回参数的平方根 */ public static void function_4()&#123; double d = Math.sqrt(-2); System.out.println(d); &#125; /*0 * static double pow(double a, double b) * a的b次方 */ public static void function_3()&#123; double d = Math.pow(2, 3); System.out.println(d); &#125; /* * static double floor(double d) * 返回小于或者等于参数d的最大整数 */ public static void function_2()&#123; double d = Math.floor(1.5); System.out.println(d); &#125; /* * static double ceil(double d) * 返回大于或者等于参数d的最小整数 */ public static void function_1()&#123; double d = Math.ceil(5.1); System.out.println(d); &#125; /* * static int abs(int i) * 获取参数的绝对值 */ public static void function()&#123; int i = Math.abs(0); System.out.println(i); &#125; 14Math类的方法_21234567891011121314151617181920A:Math类的方法_2 /* * static double round(doubl d) * 获取参数的四舍五入,取整数 */ public static void function_6()&#123; double d = Math.round(5.4195); System.out.println(d); &#125; /* * static double random() 返回随机数 0.0-1.0之间 * 来源,也是Random类 */ public static void function_5()&#123; for(int i = 0 ; i &lt; 10 ;i++)&#123; double d = Math.random(); System.out.println(d); &#125; &#125; 15Arrays工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859A:Arrays工具类: public class ArraysDemo &#123; public static void main(String[] args) &#123; function_2(); int[] arr = &#123;56,65,11,98,57,43,16,18,100,200&#125;; int[] newArray = test(arr); System.out.println(Arrays.toString(newArray)); &#125; "/* * 定义方法,接收输入,存储的是10个人考试成绩 * 将最后三个人的成绩,存储到新的数组中,返回新的数组 */" public static int[] test(int[] arr)&#123; //对数组排序 Arrays.sort(arr); //将最后三个成绩存储到新的数组中 int[] result = new int[3]; //成绩数组的最后三个元素,复制到新数组中 // System.arraycopy(arr, 0, result, 0, 3); for(int i = 0 ; i &lt; 3 ;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; "/* * static String toString(数组) * 将数组变成字符串 */" public static void function_2()&#123; int[] arr = &#123;5,1,4,6,8,9,0&#125;; String s = Arrays.toString(arr); System.out.println(s); &#125; "/* * static int binarySearch(数组, 被查找的元素) * 数组的二分搜索法 * 返回元素在数组中出现的索引 * 元素不存在, 返回的是 (-插入点-1) */" public static void function_1()&#123; int[] arr = &#123;1,4,7,9,11,15,18&#125;; int index = Arrays.binarySearch(arr, 10); System.out.println(index); &#125; "/* * static void sort(数组) * 对数组升序排列 */" public static void function()&#123; int[] arr = &#123;5,1,4,6,8,9,0&#125;; Arrays.sort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125; 16数组复制练习12345678910111213141516171819202122*A:数组复制练习: public static void main(String[] args) &#123; int[] arr = &#123;56,65,11,98,57,43,16,18,100,200&#125;; int[] newArray = test(arr); System.out.println(Arrays.toString(newArray)); &#125; /* * 定义方法,接收输入,存储的是10个人考试成绩 * 将最后三个人的成绩,存储到新的数组中,返回新的数组 */ public static int[] test(int[] arr)&#123; //对数组排序 Arrays.sort(arr); //将最后三个成绩存储到新的数组中 int[] result = new int[3]; //成绩数组的最后三个元素,复制到新数组中 //System.arraycopy(arr, 0, result, 0, 3); for(int i = 0 ; i &lt; 3 ;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; 17BigInteger类概述和构造方法1234567891011121314A:BigInteger类概述和构造方法public static void main(String[] args) &#123; function(); &#125;/* * BigInteger类的构造方法 * 传递字符串,要求数字格式,没有长度限制 */ public static void function()&#123; BigInteger b = new BigInteger("8465846668464684562385634168451684568645684564564"); System.out.println(b); BigInteger b1 = new BigInteger("5861694569514568465846668464684562385634168451684568645684564564"); System.out.println(b1); &#125; 18BigInteger类四则运算12345678910111213141516171819202122232425262728A:BigInteger类四则运算 public static void main(String[] args) &#123; function_1(); &#125;/* * BigInteger对象的四则运算 * 调用方法计算,计算结果也只能是BigInteger对象 */ public static void function_1()&#123; BigInteger b1 = new BigInteger("5665464516451051581613661405146"); BigInteger b2 = new BigInteger("965855861461465516451051581613661405146"); //计算 b1+b2对象的和,调用方法 add BigInteger bigAdd = b1.add(b2);//965855867126930032902103163227322810292 System.out.println(bigAdd); //计算b1-b2对象的差,调用方法subtract BigInteger bigSub = b1.subtract(b2); System.out.println(bigSub); //计算b1*b2对象的乘积,调用方法multiply BigInteger bigMul = b1.multiply(b2); System.out.println(bigMul); //计算b2/b1对象商,调用方法divied BigInteger bigDiv = b2.divide(b1); System.out.println(bigDiv); &#125; 19员工案例的子类的编写1234567891011A:BigDecimal类概述 " /* * 计算结果,未知 * 原因: 计算机二进制中,表示浮点数不精确造成 * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal System.out.println(0.09 + 0.01);//0.09999999999999999 System.out.println(1.0 - 0.32);//0.6799999999999999 System.out.println(1.015 * 100);//101.49999999999999 System.out.println(1.301 / 100);//0.013009999999999999 */" 20BigDecimal类实现加法减法乘法123456789101112131415161718192021222324A:BigDecimal类实现加法减法乘法 /* * BigDecimal实现三则运算 * + - * */ public static void function()&#123; BigDecimal b1 = new BigDecimal("0.09"); BigDecimal b2 = new BigDecimal("0.01"); //计算b1+b2的和,调用方法add BigDecimal bigAdd = b1.add(b2); System.out.println(bigAdd); BigDecimal b3 = new BigDecimal("1"); BigDecimal b4 = new BigDecimal("0.32"); //计算b3-b2的差,调用方法subtract BigDecimal bigSub = b3.subtract(b4); System.out.println(bigSub); BigDecimal b5 = new BigDecimal("1.015"); BigDecimal b6 = new BigDecimal("100"); //计算b5*b6的成绩,调用方法 multiply BigDecimal bigMul = b5.multiply(b6); System.out.println(bigMul); &#125; 21BigDecimal类实现除法12345678910111213141516171819A:BigDecimal类实现除法/* * BigDecimal实现除法运算 * divide(BigDecimal divisor, int scale, int roundingMode) * int scale : 保留几位小数 * int roundingMode : 保留模式 * 保留模式 阅读API文档 * static int ROUND_UP 向上+1 * static int ROUND_DOWN 直接舍去 * static int ROUND_HALF_UP &gt;= 0.5 向上+1 * static int ROUND_HALF_DOWN &gt; 0.5 向上+1 ,否则直接舍去 */public static void function_1()&#123; BigDecimal b1 = new BigDecimal("1.0301"); BigDecimal b2 = new BigDecimal("100"); //计算b1/b2的商,调用方法divied BigDecimal bigDiv = b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//0.01301 System.out.println(bigDiv);&#125; 22小结12345678910111213141516171819202122232425262728293031323334353637383940 基本类型包装类 8种基本类型对应的包装类基本类型 包装类byte Byteshort Shortint " Integer "long Longfloat Floatdouble Doublechar " Character "boolean Boolean 自动装箱、自动拆箱 自动装箱：基本数值转成对象（int &gt;&gt; Integer） 自动拆箱：对象转成基本数值（Integer &gt;&gt; int） 常用方法public int parseInt(String str):把字符串转成基本类型intpublic static String toString(int x):把基本类型int转成字符串public static Integer valueOf(int x):返回一个表示指定的 int 值的 Integer 实例。如果不需要新的 Integer 实例，则通常应优先使用该方法。public int intValue():以 int类型返回该包装类对象的值 System类: 系统属性信息工具类 public static long currentTimeMillis()：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 public static void exit(int status)：用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态 public static void gc()：用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。 public static String getProperties()：用来获取指系统属性信息 Arrays类：数组操作工具类 public static void sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序） public static String toString方法，用来返回指定数组元素内容的字符串形式 public static void binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-插入点-1。要求该数组必须是个有序的数组 Math类：数学运算工具类 abs方法,结果都为正数 ceil方法，结果为比参数值大的最小整数的double值 floor方法，结果为比参数值小的最大整数的double值 max方法，返回两个参数值中较大的值 min方法，返回两个参数值中较小的值 pow方法，返回第一个参数的第二个参数次幂的值 round方法，返回参数值四舍五入的结果 random方法，产生一个大于等于0.0且小于1.0的double小数]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础14(正则表达式,Date类,Calendar类)]]></title>
    <url>%2F2016%2F10%2F20%2Fday16%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、正则表达式的定义及使用2、Date类的用法3、Calendar类的用法 01正则表达式的概念和作用* A: 正则表达式的概念和作用 123456* a: 正则表达式的概述 * "正则表达式也是一个【字符串】，用来定义匹配规则，在Pattern类中有简单的规则定义"。 "可以结合【字符串类】的【方法】使用"。 * 简单记：正则表达式是具有特殊含义的字符串。* b: 正则表达式的作用* 比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的 02正则表达式语法规则* A: 正则表达式语法规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* a: 字符 * x 代表的是字符x * \\ 代表的是反斜线字符'\' * \t 代表的是制表符 * \n 代表的是换行符 * \r 代表的是回车符——————————————————————————————————————————————————————————————————————————————————————* b: 字符类 * [abc] a、b 或 c（简单类） * [^abc] 任何字符，【除了】 a、b 或 c（否定） * [a-zA-Z] a到 z 或 A到 Z，【两头】的字母【包括在内（范围）】 * [0-9] 0到9的字符都包括 * [a-zA-Z_0-9] 代表的【字母】或者【数字】或者【下划线(即单词字符)】——————————————————————————————————————————————————————————————————————————————————————* c: 预定义字符类 * . : . 【任何字符】。 * \d ： [\\d] 数字：[0-9] ,相反地，[\\D]: 匹配字符不是数字 * \w ： [\\w] 单词字符：[a-zA-Z_0-9]如"com.itheima.tests"/finish——————————————————————————————————————————————————————————————————————————————————————* d: 边界匹配器 * ^ 代表的是行的开头 * $ 代表的是行的结尾 * \b 代表的是单词边界——————————————————————————————————————————————————————————————————————————————————————* e: 数量词 * X? X，一次或一次也没有 * X* X，零次或多次 * X+ X，一次或多次 * X&#123;n&#125; X，恰好 n 次 * X&#123;n,&#125; X，至少 n 次 * X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————举例：请写出满足如下匹配规则的字符串:规则："[0-9]&#123;6,12&#125;"该规则需要匹配的内容是：长度为6位到12位的数字。如：使用数据"123456789"进行匹配结果为true；使用数据"12345"进行匹配结果为false。规则："1[34578][0-9]&#123;9&#125;"该规则需要匹配的内容是：11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。如：使用数据"12345678901"进行匹配结果为false；使用数据"13312345678"进行匹配结果为true。规则："a*b"该规则需要匹配的内容是：在多个a或零个a后面有个b；b必须为最后一个字符。如：使用数据"aaaaab"进行匹配结果为true；使用数据"abc"进行匹配结果为false。 03正则表达式练习和相关的String类方法* A: 正则表达式练习和相关的String类方法 12345678910111213* a: boolean matches(String 正则的规则) ：告知此字符串是否匹配给定的正则表达式。 * "abc".matches("[a]") ：根据给定正则表达式的匹配拆分此字符串。 * 匹配成功返回true* b: String[] split(String 正则的规则) * "abc".split("a") * 使用规则将字符串进行切割 * String [] rr = "abc".split(""); // 按每个字符切割，得到:[a,b,c] * 返回：String [] 字符串数组，它是根据给定正则表达式的匹配拆分此字符串确定的 * c: String replaceAll( String 正则规则,String 字符串)：* 使用给定的字符串替换此字符串所有匹配给定的正则表达式的子字符串。 * "abc0123".repalceAll("[\\d]","#") * 按照正则的规则,替换字符串 04正则表达式匹配练习* A: 正则表达式匹配练习 12345678910111213141516171819202122232425262728293031* a: 案例代码public class RegexDemo &#123; public static void main(String[] args) &#123; checkTel(); &#125; /* * 检查手机号码是否合法 * 1开头 可以是34578 0-9 位数固定11位 */ public static void checkTel()&#123; String telNumber = "1335128005"; //String类的方法matches boolean b = telNumber.matches("1[34857][\\d]&#123;9&#125;"); System.out.println(b); &#125; /* * 检查QQ号码是否合法 * 0不能开头,全数字, 位数5,10位 * 123456 * \\d \\D匹配不是数字 */ public static void checkQQ()&#123; String QQ = "123456"; //检查QQ号码和规则是否匹配,String类的方法matches boolean b = QQ.matches("[1-9][\\d]&#123;4,9&#125;"); System.out.println(b); &#125;&#125; 05正则表达式切割练习* A: 正则表达式切割练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* a: 案例代码public class RegexDemo1 &#123; public static void main(String[] args) &#123; split_1(); split_2(); split_3(); &#125; /* * String类方法split对字符串进行切割 * 192.168.105.27 按照 点切割字符串 * 注意： * "\\."使用转义字符，因为"."表示【任何字符】 */ public static void split_3()&#123; String ip = "192.168.105.27"; String[] strArr = ip.split("\\."); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125; /* * String类方法split对字符串进行切割 * 18 22 40 65 按照空格切割字符串 */ public static void split_2()&#123; String str = "18 22 40 65"; String[] strArr = str.split(" +"); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125; /* * String类方法split对字符串进行切割 * 12-25-36-98 按照-对字符串进行切割 */ public static void split_1()&#123; String str = "12-25-36-98"; //按照-对字符串进行切割,String类方法split String[] strArr = str.split("-"); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125;&#125; 06正则表达式替换练习* A: 正则表达式替换练习 1234567891011121314151617 * a: 案例代码public class RegexDemo1 &#123; public static void main(String[] args) &#123; replaceAll_1(); &#125; /* * "Hello12345World6789012"将所有数字替换掉 * String类方法replaceAll(正则规则,替换后的新字符串) */ public static void replaceAll_1()&#123; String str = "Hello12345World6789012"; str = str.replaceAll("[\\d]+", "#"); System.out.println(str); &#125;&#125; 07正则表达式邮箱地址验证* A: 正则表达式邮箱地址验证 12345678910111213141516171819202122232425262728293031323334353637383940414243 匹配正确的数字匹配规则： 匹配正整数："\\d+" 匹配正小数："\\d+\\.\\d+" 匹配负整数："-\\d+" 匹配负小数："-\\d+\\.\\d+" 匹配保留两位小数的正数："\\d+\\.\\d&#123;2&#125;" 匹配保留1-3位小数的正数："\\d+\\.\\d&#123;1,3&#125;" 匹配合法的邮箱匹配规则： "[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\.[a-zA-Z_0-9]+)+" "\\w+@\\w+(\\.\\w+)+" 注意；用() 表示多个相同的匹配规则 获取IP地址(192.168.1.100)中的每段数字匹配规则： "\\."* a: 案例代码public class RegexDemo2 &#123; public static void main(String[] args) &#123; checkMail(); &#125; /* * 检查邮件地址是否合法 * 规则: * 1234567@qq.com * mym_ail@sina.com * nimail@163.com * wodemail@yahoo.com.cn * * @: 前 数字字母_ 个数不能少于1个 * @: 后 数字字母 个数不能少于1个 * .: 后面 字母 * */ public static void checkMail()&#123; String email ="abc123@sina.com"; boolean b = email.matches("[a-zA-Z0-9_]+@[0-9a-z]+(\\.[a-z]+)+"); System.out.println(b); &#125;&#125; 08毫秒值概念* A: 毫秒值概念 12345678910* a: 时间和日期类 * java.util.Date* b: 毫秒概念 * 1000毫秒=1秒* c: 毫秒的0点 * System.currentTimeMillis() 返回值long类型参数 * 获取当前日期的毫秒值 3742769374405 * 时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治 毫秒值就是0 * 时间2088年8月8日 * 时间和日期的计算，必须依赖毫秒值 09Date类的构造方法* A: Date类的构造方法 1234* a: 空参构造 * public Date()* b: 带参构造 * public Date(long times) 10Date类的get和set方法* A：Date类的get和set方法 1234* public long getTime() * 将当前的日期对象，转为对应的毫秒值* public void setTime(long times); * 根据给定的毫秒值，生成对应的日期对象 11日期格式化SimpleDateFormat* A: 日期格式化SimpleDateFormat 12345678910111213141516* a: 对日期进行格式化(自定义) * 对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法 * 实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法* b: 对日期进行格式化的步骤 * 1: 创建SimpleDateFormat对象 * 在类构造方法中,写入字符串的日期格式 (自己定义) * 2: SimpleDateFormat调用方法format对日期进行格式化 * public String format(Date date) 传递日期对象,返回字符串 * 日期模式: * yyyy 年份 * MM 月份 * dd 月中的天数 * HH 0-23小时 * mm 小时中的分钟 * ss 秒 * yyyy年MM月dd日 HH点mm分钟ss秒 汉字修改,: - 字母表示的每个字段不可以随便写 12字符串转成日期对象* A: 字符串转成日期对象 12345678* a: 使用步骤 * 1: 创建SimpleDateFormat的对象 * 构造方法中,指定日期模式 * 2: 子类对象,调用方法 parse 传递String,返回Date * 注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配 *西方星期的开始为周日，中国为周一。 在Calendar类中，"月份的表示是以0-11代表1-12月"。 日期是有大小关系的，时间靠后，时间越大。 13Calendar类_1* A: Calendar类_1 12345* a: 日历类(抽象类) * java.util.Calendar* b: 创建对象 * "Calendar类写了【静态方法】 getInstance() 【直接】返回了【子类的对象】" * "【不需要】直接new子类的对象,通过【静态方法】直接获取" 14Calendar类_2* A: Calendar类_2 123456789101112* a: 成员方法 * getTime() 把日历对象,转成Date日期对象 * get(日历字段) 获取指定日历字段的值* b: 代码演示 Calendar c = Calendar.getInstance(); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); 15Calendar类_3* A: Calendar类_3 12345678910111213141516171819202122232425* a: 成员方法 * set(int field,int value) 设置指定的时间* b: 代码演示 /* * Calendar类的set方法 设置日历 set(int field,int value) field 设置的是哪个日历字段 value * 设置后的具体数值 * * set(int year,int month,int day) 传递3个整数的年,月,日 */ public static void function_1() &#123; Calendar c = Calendar.getInstance(); // 设置,月份,设置到10月分 // c.set(Calendar.MONTH, 9); // 设置年,月,日 c.set(2099, 4, 1); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); &#125; 16Calendar类_4* A: Calendar类_4 12345678910111213141516171819202122* a: 成员方法 * add(int field, int value) 进行整数的偏移 * int get(int field) 获取指定字段的值* b: 案例演示 /* * Calendar类方法add 日历的偏移量, * 可以指定一个日历中的字段, * 进行整数的偏移 add(int field, int value) */ public static void function_2() &#123; Calendar c = Calendar.getInstance(); // 让日历中的天数,向后偏移280天 c.add(Calendar.DAY_OF_MONTH, -280); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); &#125; 17日期练习_活了多少天* A: 日期练习_活了多少天 1234567891011121314151617181920212223242526272829303132* a: 案例代码 /* * 计算活了多少天 * 生日 今天的日期 * 两个日期变成毫秒值,减法 */ public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); //获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); //将字符串日期,转成Date对象 //创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); //获取今天的日期对象 Date todayDate = new Date(); //将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if(secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else&#123; System.out.println(secone/1000/60/60/24); &#125; &#125; 18日期练习_闰年计算* A: 日期练习_闰年计算 12345678910111213141516* a: 案例代码 /* * 闰年计算 * 2000 3000 * 高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,获取天数,29闰年 */ public static void function_1()&#123; Calendar c = Calendar.getInstance(); //将日历,设置到指定年的3月1日 c.set(2088, 2, 1); //日历add方法,向前偏移1天 c.add(Calendar.DAY_OF_MONTH, -1); //get方法获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(day); &#125; 19总结12345678910111213141516171819202122232425262728293031323334353637383940 正则表达式：用来定义匹配规则，匹配一系列符合某个句法规则的字符串。正则表达式的匹配规则请参见1.2 正则表达式的匹配规则正则表达式的常用方法：public boolean matches(String regex) //判断字符串是否匹配给定的规则public String[] split(String regex) //根据给定正则表达式的匹配规则，拆分此字符串public String replaceAll(String regex,String replacement) //将符合规则的字符串内容，全部替换为新字符串———————————————————————————————————————————————————————————————————————————————————————— Date: 日期/时间类构造方法：public Date()// 系统当前日期时间public Date(long date) 得到一个1970年1月1日 0点这个时间基础上，加上参数date 毫秒值对应的日期时间方法： public long getTime() 获取日期所对应的毫秒值 public void setTime(long times); * 根据给定的毫秒值，生成对应的日期对象———————————————————————————————————————————————————————————————————————————————————————— DateFormat:是日期/时间格式化子类的抽象类, 使用其子类SimpleDateFormat 实例化构造方法：public SimpleDateFormat() 默认的格式化操作 public SimpleDateFormat(String pattern) 按照指定的格式，进行日期格式化 日期和时间模式 y 年 M 年中的月份 d 月份中的天数 H 一天中的小时数（0-23） m 小时中的分钟数 s 分钟中的秒数 S 毫秒数 方法： public final String format(Date date) 把日期 格式化成字符串 public Date parse(String source) 把日期字符串 转换成 日期对象———————————————————————————————————————————————————————————————————————————————————————— Calendar:日历类，可获取日期中指定字段的值方法：public static Calendar getInstance() //获取日期对象public int get(int field) //获取时间字段值public void add(int field,int amount) //指定字段增加某值public final void set(int field,int value)//设置指定字段的值public final Date getTime() //获取该日历对象转成的日期对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础13(Object,String,StringBuilder)]]></title>
    <url>%2F2016%2F10%2F18%2Fday15%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Object2、String3、StringBuilder 01API概念123456* A:API(Application Programming Interface) * 应用程序编程接口* B:Java API * 就是Java提供给我们使用的类，这些类将底层的实现封装了起来， * 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。* C: 演示查看Object类中的相关方法 02Object类概述123456789* A:Object类概述 * "类层次结构的【根类】 * 【所有类】都【直接】或者【间接】的【继承】自该类 * Object中描述的【所有方法】【子类】【都可以使用】 * 所有类在创建对象的时候，最终找的父类就是Object"。* B:构造方法 * public Object() * 回想面向对象中为什么说： * 子类的构造方法默认访问的是父类的无参构造方法 03equals方法比较内存地址* A:equals方法比较内存地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* a: Object类中的equals方法 * 用于比较两个对象是否相同，Object类中就是使用两个对象的内存地址在比较。 * Object类中的equals方法内部使用的就是==比较运算符。 * b: 案例代码 public class Person extends Object&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* * 将父类的equals方法写过来,重写父类的方法 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址 * */ public boolean equals(Object obj)&#123; return this == obj; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; //测试代码 public class TestEquals &#123; public static void main(String[] args) &#123; //Person类继承Object类,继承下来了父类的方法equals Person p1 = new Person("李四",20); Person p2 = new Person("张三",20); //Person对象p1,调用父类的方法equals,进行对象的比较 boolean b = p1.equals(p1); System.out.println(b); &#125; &#125; 04重写equals方法* A: 重写equals方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788* a: 开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较 * b: 在开发经常需要子类重写equals方法根据对象的属性值进行比较。 * c: ==号和equals方法的区别* "==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,* 基本数据类型比较的是值,引用数据类型比较的是地址值"* "equals方法是一个方法,【只能】【比较】【引用数据类型】,所有的对象都会继承Object类中的方法,如果【没有】重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性"* d: 案例代码public class Person extends Object&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* * 重写父类的方法toString() * 没有必要让调用者看到内存地址 * 要求: 方法中,返回类中所有成员变量的值 */ public String toString()&#123; return name + age; &#125; /* * 将父类的equals方法写过来,重写父类的方法 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址 * * 两个对象,比较地址,没有意义 * 比较两个对象的成员变量,age * 两个对象变量age相同,返回true,不同返回false * * 重写父类的equals,自己定义自己对象的比较方式 */ public boolean equals(Object obj)&#123; if( this == obj)&#123; return true; &#125; //对参数obj,非null判断 if( obj == null)&#123; return false; &#125; if( obj instanceof Person)&#123; // 参数obj接受到是Person对象,才能转型 "由于多态【编译】看父类，【父类】Object 没有成员变量age, 必须【向下转型】为 Person 类型，才能调用成员变量 age" // 对obj参数进行类型的向下转型,obj转成Person类型 Person p = (Person)obj; return this.age == p.age; &#125; return false; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;//测试代码public class TestEquals &#123; public static void main(String[] args) &#123; //Person类继承Object类,继承下来了父类的方法equals Person p1 = new Person("李四",20); Person p2 = new Person("张三",20); //Person对象p1,调用父类的方法equals,进行对象的比较 boolean b = p1.equals(p1); System.out.println(b); &#125;&#125; 05重写toString方法* A: 重写toString方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445* a: 为什么要重写toString方法 * "toString方法返回该对象的【字符串】表示"， * 其实该字符串内容就是"【对象的类型】+ @ + 【内存地址值】"。 * 由于toString方法返回的结果是内存地址， * 而在"开发"中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要"重写"它。 * "Object类中的toString的核心代码" " getClass().getName() + @ + Integer.toHexString(hashCode()) " * 由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。* b: 案例核心代码(重写Person类中的toString方法) /* * 重写父类的方法toString() * 没有必要让调用者看到内存地址 * 要求: 方法中,返回类中所有成员变量的值 */ public String toString()&#123; return name + age; &#125; //Eclipse中自动生成的toString @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; //测试代码 public class TestToString &#123; public static void main(String[] args) &#123; //调用Person类的方法toString() //输出语句中,写的是一个对象,默认调用对象的toString方法 Person p = new Person("张三",20); String s = p.toString(); System.out.println(p); System.out.println(s); /* * System.out.println(p); * System.out.println(p.toString()); */ /*Random r = new Random(); System.out.println(r.toString()); Scanner sc = new Scanner(System.in); System.out.println(sc.toString());*/ &#125; &#125; 06String类的概念和不变性* A: String类的概念和不变性 12345678910111213141516171819202122232425262728293031323334353637383940* a:String类* API中的String类的描述，发现String 类代表字符串* Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。* ———————————————————————————————————————————————————————————————————————————————————————* "【字符串】是【常量】,在创建之后不能更改"* ———————————————————————————————————————————————————————————————————————————————————————* "其实就是说一旦这个字符串确定了，那么就会【在内存区域中】就【生成】了【这个字符串】。"* ———————————————————————————————————————————————————————————————————————————————————————*" 【字符串】【本身】【不能改变】，但str变量中记录的【地址值】是【可以改变】的。"* ———————————————————————————————————————————————————————————————————————————————————————* 源码分析,String类底层采用的是"【字符数组】": private final char value[] private 修饰说明"value只能在【String类内部】使用,而且又没有提供get方法, 所以【外部无法获取value数组】,就无法改变数组中元素的值" final修饰说明"value是常量,【一旦创建】,就【不能被改变】, value一旦被初始化成某个数组,将永远指向这个数组,不可能再指向其它的数组了" * b: 案例代码" /* * String类特点: * 一切都是对象,字符串事物 "" 也是对象 * 类是描述事物,String类,描述字符串对象的类 * 所有的 "" 都是String类的对象 * * 字符串是一个常量,一旦创建,不能改变 * 字符串本质是 【字符数组】 */" public class StringDemo &#123; public static void main(String[] args) &#123; //引用变量str指向内存变化 //定义好的字符串对象,不变 String str = "itcast"; System.out.println(str); str = "itheima"; System.out.println(str); &#125; &#125; 07String类创建方式和比较* A: String类创建方式和比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103* a: "创建对象的【数量】比较" * String s3 = "abc"; * "在内存中【只有一个对象】。这个对象在【字符串常量池】中"——————————————————————————————————————————————————————————————————————————————————————— * String s4 = new String("abc"); * "在内存中有【两个对象】。一个new的对象在【堆】中，另一个是字符串本身对象，在【字符串常量池】中"———————————————————————————————————————————————————————————————————————————————————————"String重写了equals方法，建立了字符串自己的判断相同的依据（通过【字符串对象】中的【字符】进行判断）"，"即【字符】相同" ，返回true；否则，返回false。———————————————————————————————————————————————————————————————————————————————————————"引用数据类型,比较对象的地址""如果String常量池内【存在】与其【指定值】【【相同】】的String对象，那么此时虚拟机将【不】为此创建【新】的String对象】，而直接返回【已存在】的String对象的【引用】。"String s1 = "java";String s2 = "java";System.out.println(s1==s2); //true"如果String常量池内【【不存在】】与其指定值相同的String对象，那么此时虚拟机将为此【【创建新】】的String对象，并存放在String常量池内。"———————————————————————————————————————————————————————————————————————————————————————* b: 案例代码public class StringDemo2 &#123; public static void main(String[] args) &#123; //字符串定义方式2个, 直接= 使用String类的构造方法 String str1 = new String("abc"); String str2 = "abc"; System.out.println(str1); System.out.println(str2); //str1==str2 "引用数据类型,比较对象的地址" System.out.println(str1==str2);//引用数据类型,比较对象的地址 false //str1.equals(str2) "因为String重写了equals方法， 建立了字符串自己的判断相同的依据（通过【字符串对象】中的【字符】进行判断）" System.out.println(str1.equals(str2));//true ///// String s1 = "java"; String s2 = "java"; "引用数据类型,比较对象的地址" "如果String常量池内存在与其【指定值】【相同】的String对象， 那么此时虚拟机将【不】为此创建【新】的String对象】， 而直接返回【已存在】的String对象的【引用】。" System.out.println(s1==s2); //true System.out.println(s1.equals(s2)); //true &#125;&#125;———————————————————————————————————————————————————————————————————————————————————————public class StringDemo2 &#123; public static void main(String[] args) &#123; String a = "hello2"; final String b ="hello"; String d = "hello"; String c =b+2; "//相当于：JVM会优化成 String c ="hello"+2 结果是变成编译期就是已知的， 指向常量池中的hello2字符串，也就是a;" String e =d+2; // System.out.println(a==c);"//true" System.out.println(a==e);"//false" "//b是final修饰，表示在编译成.class文件的时候，所有引用到b变量的地方都被直接编译成"hello"" "// c= "hello"+2,即c="hello2",指向常量池中的hello2字符串，也就是a" "// 当比较a==c的时候,是同一个地址，都指向常量池中的hello2字符串" "// d 是指向存在于堆内存中的地址，当比较a==e的时候，比较的是a和e指向堆内存的地址。" "// 编译的时候，由于d对象的值是未知的，从而c对象的值也是未知的， //JVM会为e对象在堆内存中开辟新的内存空间"， "//运行时，d 指向字符串常量池中创建的字符串"hello"，" &#125;&#125;———————————————————————————————————————————————————————————————————————————————————————public class StringDemo3 &#123; public static void main(String[] args) &#123; String a = "hello2"; final String b = getStr(); String c = b + 2; System.out.println((a == c));//false "/* 因为这里的b虽然是常量，但是在编译期是不能获得值的， 只有在运行的时候才会调用函数，初始化赋值， 所以这时的String c = b+2是运行期间计算出来的， 所以编译的时候，JVM会为c对象在堆内存中开辟新的内存空间 而加号连接运算符，内部则是调用的StringBuilder，然后toString， 所以c相当于是new出来的String，即c是指向堆内存的地址， c内部的char数组才指向常量池中的字符串，所以明显a ！= c */" &#125; public static String getStr() &#123; return "hello"; &#125;&#125; 08String类构造方法* A: String类构造方法 12345678910111213141516171819202122232425262728293031323334353637* a: 常见构造方法 * public String():空构造 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(String original):把字符串常量值转成字符串* b: 案例代码 public class StringDemo3 &#123; public static void main(String[] args) &#123; function_1(); &#125; /* * 定义方法,String类的构造方法 * String(byte[] bytes) 传递字节数组 * 字节数组转成字符串 * 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 * 平台 : 机器操作系统 * 默认字符集: 操作系统中的默认编码表, 默认编码表GBK * 将字节数组中的每个字节,查询了编码表,得到的结果 * 字节是负数,汉字的字节编码就是负数, 默认编码表 ,一个汉字采用2个字节表示 * * String(byte[] bytes, int offset, int length) 传递字节数组 * 字节数组的一部分转成字符串 * offset 数组的起始的索引 * length 个数,转几个 , 不是结束的索引 */ public static void function()&#123; byte[] bytes = &#123;97,98,99,100&#125;; //调用String类的构造方法,传递字节数组 String s = new String(bytes); System.out.println(s); byte[] bytes1 =&#123;65,66,67,68,69&#125;; //调用String构造方法,传递数组,传递2个int值 String s1 = new String(bytes1,1,3); System.out.println(s1); &#125; &#125; 09String类构造方法_2* A: String类构造方法 1234567891011121314151617181920212223242526272829303132* a: 常见构造方法 * public String(char[] value):把字符数组转成字符串 * public String(char[] value,int index,int count):把字符数组的一部分转成字符串* B: 案例代码 /* * String类构造方法 * String类的构造方法,重载形式 * */public class StringDemo3 &#123; public static void main(String[] args) &#123; function_1(); &#125; /* * String(char[] value) 传递字符数组 * 将字符数组,转成字符串, 字符数组的参数,不查询编码表 * * String(char[] value, int offset, int count) 传递字符数组 * 将字符数组的一部分转成字符串 * offset 数组开始索引 * count 个数 */ public static void function_1()&#123; char[] ch = &#123;'a','b','c','d','e','f'&#125;; //调用String构造方法,传递字符数组 String s = new String(ch); System.out.println(s); String s1 = new String(ch,1,4); System.out.println(s1); &#125;&#125; 10String类的其他方法* A：String类的其他方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143* a: 方法介绍* char charAt(int index):返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。* int length(): 返回字符串的长度* String substring(int beginIndex,int endIndex): 获取字符串的一部分* String substring(int beginIndex): 获取字符串的一部分* boolean startsWith(String prefix): 判断一个字符串是不是另一个字符串的前缀,开头* boolean endsWith(String prefix): 判断一个字符串是不是另一个字符串的后缀,结尾* boolean contains (String s): 判断一个字符串中,是否包含另一个字符串* int indexOf(char ch): 查找一个字符,在字符串中第一次出现的索引,被查找的字符不存在,返回-1* byte[] getBytes(): 将字符串转成字节数组,此功能和String构造方法相反,byte数组相关的功能,查询编码表* char[] toCharArray(): 将字符串转成字符数组,功能和构造方法相反* boolean equals(Object obj): 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true* boolean equalsIgnoreCase(String s): 传递字符串,判断字符串中的字符是否相同,忽略大小写 * b: 案例代码 public class StringDemo4 &#123; public static void main(String[] args) &#123; function_9(); &#125; /* * boolean equals(Object obj) * 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true * * boolean equalsIgnoreCase(String s) * 传递字符串,判断字符串中的字符是否相同,忽略大小写 */ public static void function_9()&#123; String str1 = "Abc"; String str2 = "abc"; //分别调用equals和equalsIgnoreCase boolean b1 = str1.equals(str2); boolean b2 = str1.equalsIgnoreCase(str2); System.out.println(b1); System.out.println(b2); &#125; /* * char[] toCharArray() 将字符串转成字符数组 * 功能和构造方法相反 */ public static void function_8()&#123; String str = "itcast"; //调用String类的方法toCharArray() char[] ch = str.toCharArray(); for(int i = 0 ; i &lt; ch.length ; i++)&#123; System.out.println(ch[i]); &#125; &#125; /* * byte[] getBytes() 将字符串转成字节数组 * 此功能和String构造方法相反 * byte数组相关的功能,查询编码表 */ public static void function_7()&#123; String str = "abc"; //调用String类方法getBytes字符串转成字节数组 byte[] bytes = str.getBytes(); for(int i = 0 ; i &lt; bytes.length ; i++)&#123; System.out.println(bytes[i]); &#125; &#125; /* * int indexOf(char ch) * 查找一个字符,在字符串中第一次出现的索引 * 被查找的字符不存在,返回-1 */ public static void function_6()&#123; String str = "itcast.cn"; //调用String类的方法indexOf int index = str.indexOf('x'); System.out.println(index); &#125; /* * boolean contains (String s) * 判断一个字符串中,是否包含另一个字符串 */ public static void function_5()&#123; String str = "itcast.cn"; //调用String类的方法contains boolean b =str.contains("ac"); System.out.println(b); &#125; /* * boolean endsWith(String prefix) * 判断一个字符串是不是另一个字符串的后缀,结尾 * Demo.java * .java */ public static void function_4()&#123; String str = "Demo.java"; //调用String类方法endsWith boolean b = str.endsWith(".java"); System.out.println(b); &#125; /* * boolean startsWith(String prefix) * 判断一个字符串是不是另一个字符串的前缀,开头 * howareyou * hOw */ public static void function_3()&#123; String str = "howareyou"; //调用String类的方法startsWith boolean b = str.startsWith("hOw"); System.out.println(b); &#125; /* * String substring(int beginIndex,int endIndex) 获取字符串的一部分 * 返回新的字符串 * 包含头,不包含尾巴 * * String substring(int beginIndex)获取字符串的一部分 * 包含头,后面的字符全要 */ public static void function_2()&#123; String str = "howareyou"; //调用String类方法substring获取字符串一部分 str= str.substring(1, 5); System.out.println(str); String str2 = "HelloWorld"; str2 = str2.substring(1); System.out.println(str2); &#125; /* * int length() 返回字符串的长度 * 包含多少个字符 */ public static void function()&#123; String str = "cfxdf#$REFewfrt54GT"; //调用String类方法length,获取字符串长度 int length = str.length(); System.out.println(length); &#125; &#125; 11String类练习* A: 获取指定字符串中，大写字母、小写字母、数字的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445* a: 题目分析 * 为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。 * 为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。 * 对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1； * 如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。 * 显示大写字母、小写字母、数字的个数* b: 解题步骤 * 略* 案例代码public class StringTest &#123; public static void main(String[] args) &#123; getCount("A%A3eBr1FFy"); &#125; /* * 获取指定字符串中，大写字母、小写字母、数字的个数。 * 思想: * 1. 计数器,就是int变量,满足一个条件 ++ * 2. 遍历字符串, 长度方法length() + charAt() 遍历 * 3. 字符判断是大写,是小写,还是数字 */ public static void getCount(String str)&#123; //定义三个变量,计数 int upper = 0; int lower = 0; int digit = 0; //对字符串遍历 for(int i = 0 ; i &lt; str.length() ; i++)&#123; //String方法charAt,索引,获取字符 char c = str.charAt(i); //利用编码表 65('A')-90('Z') 97('a')-122('z') 48('0')-57('9') if(c &gt;='A' &amp;&amp; c &lt;='Z')&#123; upper++; &#125;else if( c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123; lower++; &#125;else if( c &gt;= '0' &amp;&amp; c &lt;='9')&#123; digit++; &#125; &#125; System.out.println(upper); System.out.println(lower); System.out.println(digit); &#125;&#125; 12String类练习_2* A: 将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。 12345678910111213141516171819202122232425262728293031323334* a: 题目分析* String toUpperCase(): 返回要转换为大写的 String。* String toLowerCase(): 返回要转换为小写的 String。 * 把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。 * 把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母 * 把两部分字符串连接在一起，得到一个完整的字符串* b: 解题步骤 * 略* C: 案例代码 public class StringTest &#123; public static void main(String[] args) &#123; System.out.println(toConvert("aBc5%4dEF")); &#125; /* * 将字符串的首字母转成大写,其他内容转成小写 * 思想: * 获取首字母, charAt(0) substring(0,1) * 转成大写 toUpperCase() * * 获取剩余字符串, substring(1) toLowerCase() */ public static String toConvert(String str)&#123; //定义变量,保存首字母,和剩余字符 String first = str.substring(0,1); String after = str.substring(1); //调用String类方法,大写,小写转换 first = first.toUpperCase(); after = after.toLowerCase(); return first+after; &#125; &#125; 13String类练习_3* A: 查询大字符串中，出现指定小字符串的次数 * 如&quot;hellojava,nihaojava,javazhenbang&quot;中查询出现&quot;java&quot;的次数。 12345678910111213141516171819202122232425262728293031323334353637*利用：* int indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引。* String substring(int beginIndex) :返回一个新的字符串，它是此字符串的一个子字符串。* a: 题目分析 * 在大串中，查找小串出现的位置，出现了就次数+1 * 在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。 * 回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止* b: 解题步骤 * 略* C: 案例代码 package cn.itcast.demo02;public class StringTest &#123; public static void main(String[] args) &#123; System.out.println(getStringCount("hellojava,nijavahaojava,javazhenbang", "java")); &#125; /* * 获取一个字符串中,另一个字符串出现的次数 * 思想: * 1. indexOf到字符串中到第一次出现的索引 * 2. 找到的索引+被找字符串长度,截取字符串 * 3. 计数器++ */ public static int getStringCount(String str, String key)&#123; //定义计数器 int count = 0; //定义变量,保存indexOf查找后的索引的结果 int index = 0; "开始循环找,条件,indexOf==-1 字符串没有了" while(( index = str.indexOf(key) )!= -1)&#123; count++; //获取到的索引,和字符串长度求和,截取字符串 str = str.substring(index+key.length()); &#125; return count; &#125;&#125; 14StringBuffer特点可变字符数组* A:StringBuffer类概述 1234567 *"StringBuffe：可变字符数组" * 通过JDK提供的API，查看StringBuffer类的说明 * "【线程安全】的【可变字符序列】 " * "底层采用【字符数组】实现,初始容量为【16】"* B:StringBuffer和String的区别 * "String是一个【不可变】的字符序列" * "StringBuffer是一个【可变】的字符序列" 15StringBuffer类的方法* A: StringBuffer类的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697* a: 方法介绍* StringBuffer append(), 将任意类型的数据,添加缓冲区 * append 返回值,写return this * 调用者是谁,返回值就是谁* delete(int start,int end): 删除缓冲区中字符 * 开始索引包含,结尾索引不包含* insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上* replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串* reverse(): 将缓冲区中的字符反转* String toString(): 继承Object,重写toString() * 将缓冲区中的所有字符,变成字符串* b: 案例代码 public class StringBufferDemo &#123; public static void main(String[] args) &#123; function_5(); &#125; /* * StringBuffer类的方法 * String toString() 继承Object,重写toString() * 将缓冲区中的所有字符,变成字符串 */ public static void function_5()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.append(12345); //将可变的字符串缓冲区对象,变成了不可变String对象 String s = buffer.toString(); System.out.println(s); &#125; /* * StringBuffer类的方法 * reverse() 将缓冲区中的字符反转 */ public static void function_4()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.reverse(); System.out.println(buffer); &#125; /* * StringBuffer类方法 * replace(int start,int end, String str) * 将指定的索引范围内的所有字符,替换成新的字符串 */ public static void function_3()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.replace(1, 4, "Q"); System.out.println(buffer); &#125; /* * StringBuffer类方法 insert * insert(int index, 任意类型) * 将任意类型数据,插入到缓冲区的指定索引上 */ public static void function_2()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.insert(3, 9.5); System.out.println(buffer); &#125; /* * StringBuffer类方法 * delete(int start,int end) 删除缓冲区中字符 * 开始索引包含,结尾索引不包含 */ public static void function_1()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.delete(1,5); System.out.println(buffer); &#125; /* * StringBuffer类方法 * StringBuffer append, 将任意类型的数据,添加缓冲区 * append 返回值,写return this * 调用者是谁,返回值就是谁 */ public static void function()&#123; StringBuffer buffer = new StringBuffer(); //调用StringBuffer方法append向缓冲区追加内容 buffer.append(6).append(false).append('a').append(1.5); System.out.println(buffer); &#125; &#125; 16StringBuilder类* A:StringBuilder的概述 1234567891011* 通过查看API了解一下StringBuilder类* B:面试题* "String,StringBuffer,StringBuilder的区别"——————————————————————————————————————————————————————————————————————————————————————* StringBuffer和StringBuilder的区别 * "【StringBuffer】是jdk1.0版本的,是【线程安全】的,【效率低】 " * "【StringBuilder】是jdk1.5版本的,【不保证同步】，是【线程不安全】的,【效率高】 "——————————————————————————————————————————————————————————————————————————————————————* String和StringBuffer,StringBuilder的区别 * "【String】是一个【不可变】的【字符序列】 " * "StringBuffer,StringBuilder是【可变】的【字符序列】 " 17StringBuffer类案例拼接数组* A: StringBuffer类案例拼接数组 12345678910111213141516171819202122232425262728293031323334353637* a: 题目分析 * 定义StringBuffer对象 * 遍历数组,按照格式要求拼接处新的字符串,追加到StringBuffer容器中 * 将StringBuffer中的内容以String的形式返回* b: 解题步骤 * 略* C: 案例代码 public class StringBufferTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,1,4,56,7,8,76&#125;; System.out.println(toString(arr)); &#125; /* * int[] arr = &#123;34,12,89,68&#125;;将一个int[]中元素转成字符串 * 格式 [34,12,89,68] * String s = "[" * 数组遍历 * s+= arr[i]; * s+"]" * StringBuffer实现,节约内存空间, String + 在缓冲区中,append方法 */ public static String toString(int[] arr)&#123; //创建字符串缓冲区 StringBuffer buffer = new StringBuffer(); buffer.append("["); //数组遍历 for(int i = 0 ; i &lt; arr.length;i++)&#123; //判断是不是数组的最后一个元素 if(i == arr.length-1)&#123; buffer.append(arr[i]).append("]"); &#125;else&#123; buffer.append(arr[i]).append(","); &#125; &#125; return buffer.toString(); &#125; &#125; 18总结1234567891011121314151617181920212223242526272829303132333435363738394041424344 Object: 它是所有类的超类，祖宗类。java中所有的类都直接或间接的继承这个类 方法public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的对象的类型+@+内存地址值public boolean equals(Object obj) 比较两个对象内容是否相同，对于Object类默认操作来说,比较的是地址值—————————————————————————————————————————————————————————————————————————————————————— String: 字符串类，字符串是常量；它们的值在创建之后不能更改 方法boolean equals(Object obj) 判断两个字符串中的内容是否相同boolean equalsIgnoreCase(String str) 判断两个字符串中的内容是否相同, 忽略大小写boolean contains(String str) 判断该字符串中 是否包含给定的字符串boolean startsWith(String str) 判断该字符串 是否以给定的字符串开头boolean endsWith(String str) 判断该字符串 是否以给定的字符串结尾boolean isEmpty() 判断该字符串的内容是否为空的字符串 ""int length() 获取该字符串的长度char charAt(int index) 获取该字符串中指定位置上的字符 String substring(int start) 从指定位置开始，到末尾结束，截取该字符串，返回新字符串String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串，返回新字符串 int indexOf(int ch ) 获取给定的字符，在该字符串中第一次出现的位置int indexOf(String str) 获取给定的字符串，在该字符串中第一次出现的位置int indexOf(int ch,int fromIndex) 从指定位置开始，获取给定的字符，在该字符byte[] getBytes() 把该字符串 转换成 字节数组char[] toCharArray() 把该字符串 转换成 字符数组String replace(char old,char new) 在该字符串中，将给定的旧字符，用新字符替换String replace(String old,String new) 在该字符串中， 将给定的旧字符串，用新字符串替换String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串String toLowerCase() 把该字符串转换成 小写字符串 String toUpperCase() 把该字符串转换成 大写字符串int indexOf(String str,int fromIndex) 从指定位置开始，获取给定的字符串，在该字符串中第一次出现的位置—————————————————————————————————————————————————————————————————————————————————————— StringBuffer/StringBuilder: 方法public StringBuffer append(String str) 在原有字符串缓冲区内容基础上，在末尾追加新数据public StringBuffer insert(int offset,String str) 在原有字符串缓冲区内容基础上，在指定位置插入新数据public StringBuffer deleteCharAt(int index) 在原有字符串缓冲区内容基础上，删除指定位置上的字符public StringBuffer delete(int start,int end) 在原有字符串缓冲区内容基础上，删除指定范围内的多个字符public StringBuffer replace(int start,int end,String str)在原有字符串缓冲区内容基础上， 将指定范围内的多个字符 用给定的字符串替换public StringBuffer reverse() 将字符串缓冲区的内容 反转 "abc"----"cba"public String substring(int start) 从指定位置开始，到末尾结束，截取该字符串缓冲区，返回新字符串public String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串缓冲区，返回新字符串]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础12(修饰符,“变参”方法,Comparable、Comparator接口,lambda表达式)]]></title>
    <url>%2F2016%2F10%2F16%2Fday14%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、不同修饰符混合使用细节2、辨析何时定义变量为成员变量3、类、抽象类、接口作为方法参数4、类、抽象类、接口作为方法返回值5、参数数量可变的方法（“变参”方法）6、Comparable 接口 &amp;&amp; Comparator 接口7、lambda表达式 不同修饰符使用细节A: 常用来修饰类、方法、变量的修饰符如下：12345678910111213 public 权限修饰符，【公共访问】, "类,方法,成员变量"————————————————————————————————————————————————————————— protected 权限修饰符，【受保护访问】, "方法,成员变量"，"注意【不能】修饰类"————————————————————————————————————————————————————————— 【默认什么也不写】 也是一种权限修饰符，【默认访问】, "类,方法,成员变量"————————————————————————————————————————————————————————— private 权限修饰符，【私有访问】, "方法,成员变量"———————————————————————————————————————————————————————————————————————————————————————— static 静态修饰符 "方法,成员变量,静态内部类"————————————————————————————————————————————————————————— final 最终修饰符 "类,方法,成员变量,局部变量"————————————————————————————————————————————————————————— abstract 抽象修饰符 "类 ,方法" B: 不能同时使用的修饰符12345678910111213141516171819202122232425262728同时，abstract 与 private "不能"同时使用；(私有abstract不能继承，无意义)同时，abstract 与 static "不能"同时使用；(abstract没有方法体，静态通过类名调用，无意义)同时，abstract 与 final "不能"同时使用。(abstract没有方法体，final不能重写，无意义)————————————————————————————————————————————————————————————————————————————————————————小结：1.抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量。抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。抽象类中有构造函数用于给子类对象进行初始化，同时"抽象类中【可以】含有非抽象方法"。—————————————————————————————————————————————————————————abstract关键字"不可以"与final，private,static关键字共存，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。如果static和abstract共同修饰父类中的方法，static表示是"静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现"，这与abstract关键字矛盾。————————————————————————————————————————————————————————————————————————————————————————2.static用于修饰成员变量和成员函数，想要"实现对象中的【共性数据】的【对象共享】"，可以将这个数据进行静态修饰，"被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在"。"静态方法只能访问静态成员（静态方法和静态变量），不可以【直接】用【成员名】访问非静态成员，需要new（创建对象）访问。这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员"。静态方法中"不能"使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。————————————————————————————————————————————————————————————————————————————————————————3.final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。被final修饰的变量只能是一个常量，只能赋值一次。内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。  C: 修饰类能够使用的修饰符：123456789修饰类【只能】使用public、默认的、final、abstract关键字静态内部类：static使用最多的是 public关键字a:代码案例 public class Demo &#123;&#125; //最常用的方式 class Demo2&#123;&#125; public final class Demo3&#123;&#125; public abstract class Demo4&#123;&#125; D:修饰成员变量能够使用的修饰符：1234567891011121314151617181920public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————final : 最终的static : 静态的使用最多的是 private修饰【成员变量】,【除了】 abstract 都可以————————————————————————————————————————————————————————————————————————————————————————a: 代码案例 public int count = 100; protected int count2 = 100; int count3 = 100; private int count4 = 100; //最常用的方式 public final int count5 = 100; public static int count6 = 100;  E:修饰构造方法能够使用的修饰符： 1234567891011121314public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————使用最多的是 publica:代码案例 public Demo()&#123;&#125; //最常用的方式 protected Demo()&#123;&#125; Demo()&#123;&#125; private Demo()&#123;&#125;  F:修饰成员方法能够使用的修饰符：123456789101112131415161718192021222324public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————final : 最终的static : 静态的abstract : 抽象的————————————————————————————————————————————————————————————————————————————————————————使用最多的是 publica:代码案例 public void method1()&#123;&#125;//最常用的方式 protected void method2()&#123;&#125; void method3()&#123;&#125; private void method4()&#123;&#125; public final void method5()&#123;&#125; public static void method6()&#123;&#125;//最常用的方式 public abstract void method7();//最常用的方式 局部变量和成员变量解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 定义长方形类，包含求周长与求面积的方法 定义数学工具类，包含求两个数和的二倍与求两个数积的方法【思考】：这两个类的计算方法均需要两个数参与计算，请问两个数定义在【成员位置】还是【形参位置】更好，为什么？"如果变量是【该类的一部分】时，定义成【成员变量】。 ""如果变量【不应该是类的一部分】，而仅仅是【功能】当中需要【参与计算的数】，则定义为【形参变量】。"* A：程序编译 数学工具类public class MathTool &#123; //求两个数的和的二倍 public double sum2times(int number,int number2) &#123; return (number+number2)*2; &#125; //求两个数的积 public double area(int number,int number2) &#123; return number*number2; &#125;&#125; 长方形类public class CFX &#123; //因为长与宽，在现实事物中属于事物的一部分，所以定义成员变量 private int chang; private int kuan; public CFX(int chang, int kuan) &#123; this.chang = chang; this.kuan = kuan; &#125; //求长与宽的周长 public double zhouChang() &#123; return (chang+kuan)*2; &#125; //求长与宽的面积 public double mianJi() &#123; return chang*kuan; &#125; public int getChang() &#123; return chang; &#125; public void setChang(int chang) &#123; this.chang = chang; &#125; public int getKuan() &#123; return kuan; &#125; public void setKuan(int kuan) &#123; this.kuan = kuan; &#125;&#125; 类作为方法的参数与返回值* A： 类作为方法参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647在编写程序中，会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象。如下代码演示： class Person&#123; public void show()&#123; System.out.println("show方法执行了"); &#125; &#125; //测试类 public class Test &#123; public static void main(String[] args) &#123; //创建Person对象 Person p = new Person(); //调用method方法 method(p); &#125; //定义一个方法method，用来接收一个Person对象，在方法中调用Person对象的show方法 public static void method(Person p)&#123; p.show(); &#125;———————————————————————————————————————————————————————————————————————————————————————— B：类作为方法返回值写程序调用方法时，我们以后会经常碰到"【返回】一个【类】类型的【返回值】"，那么这时，该方法要"返回"（return）一个"【该类的对象】"。如下代码演示：class Person&#123; public void show()&#123; System.out.println("show方法执行了"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的Person对象 Person p = method(); //调用p对象中的show方法 p.show(); &#125; //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建 public static Person method()&#123; Person p = new Person(); //返回的是 【类的对象】 return p; &#125;&#125; 抽象类作为方法参数与返回值* A: 抽象类作为方法参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667今后开发中，【抽象类】作为【方法参数】的情况也很多见。"当遇到【方法参数】为【抽象类】类型时，要传入一个【实现】【抽象类】【所有抽象方法】的【子类对象】"。"抽象类【没有对象】，只能通过【多态】的方式，传递【抽象类】的【子类】的【对象】"如下代码演示：//抽象类abstract class Person&#123; public abstract void show();&#125;class Student extends Person&#123; @Override public void show() &#123; System.out.println("重写了show方法"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //通过多态的方式，创建一个Person类型的变量，而这个对象实际是Student Person p = new Student(); //调用method方法 method(p); &#125; //定义一个方法method，用来接收一个Person类型对象，在方法中调用Person对象的show方法 public static void method(Person p)&#123;//抽象类作为参数 //抽象类【没有对象】，只能通过【多态】的方式，传递【抽象类】的【子类】的【对象】 //通过p变量调用show方法,这时实际调用的是Student对象中的show方法 p.show(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————* B: 抽象类作为方法返回值"【抽象类】作为【方法返回值】的情况，这时需要【返回】一个实现抽象类【所有抽象方法】的【子类对象】。""抽象类【没有对象】，只能通过【多态】的方式，返回的是【抽象类】的【子类】的【对象】"如下代码演示：//抽象类abstract class Person&#123; public abstract void show();&#125;class Student extends Person&#123; @Override public void show() &#123; System.out.println("重写了show方法"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的Person对象 Person p = method(); //通过p变量调用show方法,这时实际调用的是Student对象中的show方法 p.show(); &#125; //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建 public static Person method()&#123; Person p = new Student(); //抽象类【没有对象】，只能通过【多态】的方式，返回的是【抽象类】的【子类】的【对象】 return p; &#125;&#125; 接口作为方法参数与返回值* A: 接口作为方法参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465【接口】作为【方法参数】的情况是很常见的，经常会碰到。当遇到方法参数为【接口类型】时，那么该方法要传入一个"【接口实现类】【对象】"。"【接口】【没有对象】，只能通过【多态】的方式，【传入】的是【接口】的【实现类】的【对象】"如下代码演示。//接口interface Smoke&#123; public abstract void smoking();&#125;class Student implements Smoke&#123; @Override public void smoking() &#123; System.out.println("no smoking"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student Smoke s = new Student(); //调用method方法 method(s); &#125; //定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法 public static void method(Smoke sm)&#123;//接口作为参数 //通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法 sm.smoking(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————* B: 接口作为方法返回值接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个"【接口实现类对象】"。"【接口】【没有对象】，只能通过【多态】的方式，【返回】的是【接口】的【实现类】的【对象】"如下代码演示。//接口interface Smoke&#123; public abstract void smoking();&#125;class Student implements Smoke&#123; @Override public void smoking() &#123; System.out.println("no smoking"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的会吸烟的对象 Smoke s = method(); //通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法 s.smoking(); &#125; //定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建 public static Smoke method()&#123; Smoke sm = new Student(); return sm; &#125;&#125; 星级酒店案例* A:  根据“某五星级酒店，资金雄厚……都有自己的工作要做。”分析出，该题 目中包含酒店，可以把它封装成类，多名员工）。 1234567891011121314151617181920212223242526272829class 员工 &#123; 属性：姓名属性：工号方法：工作&#125;class 厨师 extends 员工&#123;&#125;class 服务员 extends 员工&#123;&#125;class 经理 extends 员工 &#123; 属性：奖金&#125;员工的类型有经理、厨师、服务员，它们有共同的属性（姓名、工号、），经理额外属性（奖金）。 根据“向酒店中，增加多名员工（其中包含1名经理，1名厨师、2名服务员）”。分析出，要创建一个酒店对象，并添加4名员工到酒店对象的员工集合中。酒店员工集合添加新员工： 经理对象酒店员工集合添加新员工： 厨师对象酒店员工集合添加新员工： 服务员对象酒店员工集合添加新员工： 服务员对象 根据“获取酒店幸运员工”。分析出，从酒店员工集合随机得到一名员工对象。1. 从酒店员工集合长度范围内，随机产生一个随机数2. 使用该随机数作为集合的索引，返回该索引处对应的员工对象 根据“酒店开设VIP服务，酒店的厨师与服务员可以提供VIP服务。（厨师做菜加量、服务员给顾客倒酒）”。分析出，这是要增加一个VIP的接口，接口中提供个VIP服务的方法。让厨师与服务员实现该接口。interface VIP服务&#123; 抽象方法：服务&#125;class 厨师 extends 员工 implements VIP服务&#123; 重写服务方法 &#125;class 服务员 extends 员工 implements VIP服务&#123; 重写服务方法 &#125; B:  VIP服务 public interface VIP { public abstract void server(); //服务 }  员工 1234567891011121314151617181920212223242526272829303132333435363738/** 员工：姓名 String工号 String*/public abstract class YuanGong &#123; // 成员变量 private String xingMing; private String gongHao; // 构造方法 public YuanGong() &#123; super(); &#125; public YuanGong(String xingMing, String gongHao) &#123; super(); this.xingMing = xingMing; this.gongHao = gongHao; &#125; // 抽象方法 public abstract void work(); // getters与setters public String getXingMing() &#123; return xingMing; &#125; public void setXingMing(String xingMing) &#123; this.xingMing = xingMing; &#125; public String getGongHao() &#123; return gongHao; &#125; public void setGongHao(String gongHao) &#123; this.gongHao = gongHao; &#125; &#125;  服务员 1234567891011121314151617181920/** 定义员工的子类 服务员类*/public class FuWuYuan extends YuanGong implements VIP &#123; public FuWuYuan() &#123; super(); &#125; public FuWuYuan(String xingMing, String gongHao) &#123; super(xingMing, gongHao); &#125; @Override public void work() &#123; System.out.println("亲，全身心为您服务，记得给好评哦"); &#125; @Override public void server() &#123; System.out.println("给顾客倒酒"); &#125;&#125;  经理 1234567891011121314151617181920212223242526/** 经理在员工的基础上，添加了奖金成员*/public class JingLi extends YuanGong &#123; private double jiangJin; public JingLi() &#123; super(); &#125; public JingLi(String xingMing, String gongHao, double jiangJin) &#123; super(xingMing, gongHao); this.jiangJin = jiangJin; &#125; public double getJiangJin() &#123; return jiangJin; &#125; public void setJiangJin(double jiangJin) &#123; this.jiangJin = jiangJin; &#125; @Override public void work() &#123; System.out.println("哪个员工让顾客不满意，我扣谁钱"); &#125;;&#125;  厨师 1234567891011121314151617181920/** 定义员工的子类 厨师类*/public class ChuShi extends YuanGong implements VIP&#123; public ChuShi() &#123; super(); &#125; public ChuShi(String xingMing, String gongHao) &#123; super(xingMing, gongHao); &#125; @Override public void work() &#123; System.out.println("我做饭，放心吃吧，包您满意"); &#125; @Override public void server() &#123; System.out.println("做菜加量加料"); &#125;&#125; 参数数量可变的方法（“变参”方法）1234567891011121314151617181920212223242526272829303132333435现在的版本提供了可以用可变的参数数量调用的方法（有时称为“ 变参” 方法。)printf方法是这样定义的：public class PrintStream&#123; public PrintStream printf(String fmt , Object ... args) &#123; return format(fmt, args); &#125;&#125;这里的省略号 . . . 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 format参数之外。)———————————————————————————————————————————————————————————————————————————————————————————实际上，printf 方法接收"两个参数"， 一个是"格式字符串"， 另一个是 "Object [] 数组"， "Object [] 数组" 保存着所有的参数（"如果调用者提供的是【整型数组或者其他基本类型】的值， 【自动装箱】功能将【把它们】【转换成对象】 )。现在将扫描format 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来"=&gt;&gt; "Object… 参数类型与 Object[ ] 完全一样"———————————————————————————————————————————————————————————————————————————————————————————编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上， 并在必要的时候进行自动装箱：System.out.printf("%d %s", new Object [] &#123; new Integer(n), "widgets" &#125; );"用户自己也可以定义可变参数的方法， 并将参数指定为【任意类型】， 【甚至】是【基本类型】"———————————————————————————————————————————————————————————————————————————————————————————public class Demo &#123; public static void main(String[] args) &#123; func("How ","are ","you"); &#125; public static void func(String ... args)&#123;//等效于 args -&gt; new String []&#123;"How ","are ","you"&#125;; for(String value : args)&#123; System.out.println(value); &#125; &#125;&#125;编译器将 new String []&#123;"How ","are ","you"&#125; 传递给 args甚至可以将 main 方法声明为下列形式：public static void main(String... args) Comparable 接口 &amp;&amp; Comparator 接口123456789101112131415### 总结``` java不同修饰符的使用类，最常使用public修饰成员变量，最常使用private修饰成员方法，最常使用public修饰自定义数据类型的使用"【类】作为【方法参数】时，说明要向方法中传入【该类的对象】""【类】作为【方法返回值】时，说明该方法要返回一个【该类的对象】。""【抽象类】作为【方法参数】时，说明要传入一个实现【抽象类】【所有抽象方法】的【子类对象】。""【抽象类】作为【方法返回值】时，说明需要返回一个实现【抽象类】【所有抽象方法】的【子类对象】。""【接口】作为【方法参数】时，说明该方法要传入一个【接口】【实现类对象】。""【接口】作为【方法返回值】时，说明该方法需要返回一个【接口】【实现类对象】。"]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础11(final、static，内部类，包，代码块)]]></title>
    <url>%2F2016%2F10%2F15%2Fday13%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、final 关键字2、static 关键字3、匿名对象4、内部类5、包的声明与访问6、访问修饰符7、代码块 01final关键字概念* A: 概述 12345继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。 02final修饰类义* A: final 修饰类 12345 final修饰类"【不可以】【被继承】，但是【可以继承】其他类"。* B: 案例 class Yy &#123;&#125; final class Fu extends Yy&#123;&#125; //可以继承Yy类 class Zi extends Fu&#123;&#125; //不能继承Fu类 03final修饰方法* A: final修饰方法 1234567891011  final修饰的方法"不可以被覆盖","但如果父类中【没有】被final修饰方法，子类【覆盖】"后可以加final。* B: 案例 class Fu &#123; // final修饰的方法，不可以被覆盖，但可以继承使用 public final void method1()&#123;&#125; public void method2()&#123;&#125; &#125; class Zi extends Fu &#123; //重写method2方法 public final void method2()&#123;&#125; &#125; 04final修饰局部变量* A:修饰基本数据类型变量 1234567891011121314151617final修饰的变量称为常量，这些变量只能赋值一次 * B:案例1 final int i = 20; i = 30; //赋值报错，final修饰的变量只能赋值一次 * C: 修饰引用数据类型 "【引用类型】的变量值为【对象地址值】，地址值【不能更改】， 但是【地址内的对象属性值可以修改】"* D: 修饰引用数据类型 final Person p = new Person(); Person p2 = new Person(); p = p2; //final修饰的变量p，所记录的地址值不能改变 p.name = "小明";//可以更改p对象中name属性值 p不能为别的对象，而p对象中的name或age属性值可更改。 05final修饰成员变量* A: 修饰成员变量 123456789101112131415 "修饰成员变量，需要在【创建对象】前赋值，否则报错。(当没有显式赋值时，如有多个构造方法，则均需要为其赋值。)"* B: 案例 class Demo &#123; //直接赋值 final int m = 100; //final修饰的成员变量，需要在创建对象前赋值，否则报错。 final int n; public Demo()&#123; //可以在创建对象时所调用的构造方法中，为变量n赋值 n = 2016; &#125; &#125; 06static的概念* A：概念 1234当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。"当在调用对象的某个方法时，但是这个方法【没有】访问到对象的【特有数据】时，方法创建这个对象有些多余。"可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？"可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。" 07static修饰的对象特有数据* A：特点1: 12345678910111213141516171819202122被 static "修饰的成员变量" "【属于类】"，"【不属于】这个类的某个对象"。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即"多个对象共享同一个" static 成员变量）" 被静态修饰的成员，可以被 【类名】 【直接调用】""对象的【特有数据】： （非静态修饰）=&gt; 【调用者只能是New 对象】对象的【共享数据】： （静态修饰） =&gt; 【调用者是类名，也可以是New 对象(不建议这样用)】"* B: 代码演示 class Demo &#123; public static int num = 100; &#125; class Test &#123; public static void main(String[] args) &#123; Demo d1 = new Demo(); Demo d2 = new Demo(); d1.num = 200; System.out.println(d1.num); //结果为200 System.out.println(d2.num); //结果为200 &#125; &#125; 08static的内存图 09static注意事项_【静态不能直接调用非静态】* A: 注意事项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 被static修饰的成员可以并且"建议通过类名直接访问"。 * B: 访问静态成员的格式：" 类名.静态成员变量名 类名.静态成员方法名(参数)" 对象名.静态成员变量名 ------不建议使用该方式，会出现警告 对象名.静态成员方法名(参数) ------不建议使用该方式，会出现警告 * C: 代码演示 class Demo &#123; //静态成员变量 public static int num = 100; //静态方法 public static void method()&#123; System.out.println("静态方法"); &#125; &#125; class Test &#123; public static void main(String[] args) &#123; System.out.println(Demo.num); Demo.method(); &#125; &#125;————————————————————————————————————————————————————————————————————————————————————————*"【静态内容】是优先于【对象】存在，【只能访问静态】"，"不能"使用this/super。"静态修饰的内容存于静态区"。class Demo &#123; //成员变量 public int num = 100; //静态方法 public static void method()&#123; //this.num; 不能使用this/super。 System.out.println(this.num); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"同一个类中，静态成员【只能】访问静态成员"class Demo &#123; //成员变量 public int num = 100; //静态成员变量 public static int count = 200; //静态方法 public static void method()&#123; //System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法 System.out.println(count); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"【非静态内容】 【只能】 通过 创建【本类对象】，再通过【 对象.成员变量 】 OR 【 对象.成员方法(参数) 】的方式调用"class Demo &#123; //成员变量 public int num = 100; //静态成员变量 public static int count = 200; //非静态方法 public void function()&#123; System.out.println("这是非静态方法 function"); &#125; //静态方法 public static void method()&#123; //System.out.println(num); // 静态方法中，只能访问静态成员变量或静态成员方法 System.out.println(count); //【非静态内容】 【只能】 通过 创建【本类对象】， // 再通过【 对象.成员变量 】 OR 【 对象.成员方法(参数) 】的方式调用 Demo d = new Demo(); System.out.println(d.num); d.function(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"main方法为静态方法仅仅为程序执行入口，它【不属于任何一个对象】，可以定义在任意类中。"————————————————————————————————————————————————————————————————————————————————————————举例：class Test&#123; public static void hello()&#123; System.out.println("hello"); &#125; &#125;public class TTTss &#123; public static void main(String[] args) &#123; Test tt = null; tt.hello(); &#125;&#125;运行结果：能编译通过，并能正常运行，打印：hello。注意：Test类中的方法 hello() 是静态static 的，因此，"hello()方法归类所有，与对象无关。当实例化Test类的时候，【静态成员】会被【优先加载】而且【只加载一次】，所以【不受】【实例化对象】 new Test();影响"，"只要是用到了Test类，都会加载静态 hello()方法。"此外，在【其他类】的【静态方法】中也能调用public的静态hello()方法。—————————————————————————————————————————————————————————总结： "静态方法【不受】实例化对象的影响"，即使Test tt = null; 这是只要调用了Test类，就会加载静态方法，tt中包含了Test类的初始化数据。 此外，如果hello()是【非静态的方法】，那就会报NullPointerException异常。 10static静态的使用场景* A: 使用场景 1234567static可以修饰"【成员变量】"和"【成员方法】"。 什么时候使用static修饰"成员变量"？ 加static修饰成员的时候，"这个成员会被类的所有对象所共享。一般我们把【共性数据】定义为静态的变量。"————————————————————————————————————————————————————————————————————————————————————————什么时候使用static修饰"成员方法"？ "静态的方法【只能】访问静态的成员"，" 如果静态方法中引用到了静态的其他成员，那么这个方法需要声明为静态的方法。" "方法中【没有】调用【非静态成员变量】，则将方法定义为【静态】" 11对象中的静态调用* A: 对象的静态调用 123456789101112131415"在多态中，无论是【静态成员变量】 还是【非静态成员变量】，【都看父类】"————————————————————————————————————————————————————————————————————————————————————————" 在多态中，【非静态成员方法】【编译】【看父类】，【运行】【看子类】，【父类没有】则编译失败。"————————————————————————————————————————————————————————————————————————————————————————" 但多态中的【静态成员方法】,【编译看父类】,【运行仍然看父类】。因为【静态和对象没有关系】，属于【静态绑定】。"————————————————————————————————————————————————————————————————————————————————————————即："【只有】【非静态成员方法】 运行看 【子类】,其他看父类"————————————————————————————————————————————————————————————————————————————————————————* B: 举例public class Test&#123; public static void main(String[] args)&#123; Fu f = new Zi(); f.show(); //父类的引用和父类的方法绑定,和对象无关,不会在运行时动态的执行子类特有的方法。 &#125;&#125; 12定义静态常量* A: 静态常量 123456789101112131415161718192021222324252627开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。"此时变量名用【全部大写】，多个单词使用下划线连接。"* B: 定义格式： public static final 数据类型 变量名 = 值; * C: 如下演示： class Company &#123; public static final String COMPANY_NAME = "传智播客"; public static void method()&#123; System.out.println("一个静态方法"); &#125; &#125; "当我们想使用类的静态成员时，【不需要创建对象】，【直接使用类名】来访问即可。" System.out.println(Company.COMPANY_NAME); //打印传智播客 Company.method(); // 调用一个静态方法* D: 注意： "接口中的每个【成员变量】都默认使用" public static final修饰。 "所有【接口】中的【成员变量】【必须是静态常量】，由于【接口】【没有】【构造方法】， 所以【必须显示赋值】。可以【直接】用【接口名】访问" interface Inter &#123; public static final int COUNT = 100; &#125; " 访问接口中的静态变量 ": Inter.COUNT&#125; 13匿名对象* A:匿名对象的概述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。* B:案例public class Person&#123; public void eat()&#123; System.out.println();&#125;&#125;创建一个普通对象Person p = new Person();"创建一个匿名对象"new Person();* C: 匿名对象的特点a:"创建匿名对象【直接使用】，【没有变量名】"。 new Person().eat() //"eat方法被一个没有名字的Person对象调用了"。b:"【匿名对象】在【没有指定】其【引用变量】时，【只能】【使用一次】，第二次使用则【重新】创建了【新的匿名对象】"。 new Person().eat(); 创建一个匿名对象，调用eat方法 new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象 c:"【匿名对象】可以作为【方法接收的参数】、【方法返回值】使用" class Demo &#123; public static Person getPerson()&#123; //普通方式 //Person p = new Person(); //return p; //匿名对象作为方法返回值 return new Person(); &#125; public static void method(Person p)&#123;&#125; &#125; class Test &#123; public static void main(String[] args) &#123; //调用getPerson方法，得到一个Person对象 Person person = Demo.getPerson(); //调用method方法 Demo.method(person); //匿名对象作为方法接收的参数 Demo.method(new Person()); &#125; &#125; 14内部类及其特点12345678910111213141516171819202122232425262728293031323334353637383940" 将类写在其他类的【内部】，可以写在其他类的【成员位置】和【局部位置】，这时写在其他类内部的类就称为【内部类】。其他类也称为外部类 "。* B: 什么时候使用内部类 在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机， 这时发动机就可以使用内部类来描述。 class 汽车 &#123; //外部类 class 发动机 &#123; //内部类 &#125; &#125;* C: 内部类的分类 注意：(1) "外部类 修饰符 【只能】使用 public 和 【省略访问控制符】" —————————————————————————————————————————————— "内部类 修饰符 可以使用：public protected private static 和 【省略访问控制符】"解释： 外部类的上一级程序单元是包，所以它只有2个作用域:"同一个包内和任何位置"。因此只需2种访问权限:"包访问权限和公开访问权限"，正好对应"省略访问控制符和public访问控制符"。省略访问控制符是包访问权限，即同一包中的其他类可以访问省略访问控制符的成员。因此，如果一个外部类不使用任何访问控制符修饰，则只能被同一个包中其他类访问。而内部类的上一级程序单元是外部类，它就具有4个作用域:同一个类、同一个包、父子类和任何位置，因此可以使用4种访问控制权限————————————————————————————————————————————————————————————————————————————————————————(2) "【非静态成员内部类】【不能】拥有【静态成员】" 根据静态成员不能直接访非静态成员的规则， "外部类的【静态方法】、静态代码块【不能直接】访问【非静态内部类】， 包括不能直接使用非静态内部类定义变量、创建实例等。" 总之，【不允许】在外部类的【静态成员】中直接使用【非静 态内部类】 —————————————————————————————————————————————— 《 非静态方法可以调用静态成员方法和静态成员变量 》———————————————————————————————————————————————————————————————————————————————————————— "内部类分为【成员内部类】与【局部内部类】"。———————————————————————————————————————————————————————————————————————————————————————— "我们【定义】【内部类】时，就是一个【正常定义类】的过程， 【同样】【包含】各种【修饰符】、【继承】与【实现关系】等"。———————————————————————————————————————————————————————————————————————————————————————— "在【内部类】中可以【直接】访问【外部类】的【所有成员】"。 15成员内部类的调用格式* A: 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102"【成员内部类】，定义在【外部类】中的【成员位置】。与类中的成员变量【相似】，可通过【外部类】【对象】进行访问"* B: 定义格式class 外部类 &#123; 修饰符 class 内部类 &#123; //其他代码 &#125;&#125;* C: 访问方式————————————————————————————————————————————————————————————————————————————————————————外部类名.内部类名 变量名 = new 外部类名().new 内部类名();Outer.this.成员 &gt;&gt;&gt; "表示内部类对外部类的成员引用"this.成员 &gt;&gt;&gt; "表示内部类对自己成员的调用"————————————————————————————————————————————————————————————————————————————————————————注：其他类调用内部类的成员：（一）访问"【非静态成员内部类】"："——————————————————————————————————————————————————————————"外部类名.内部类名 变量名 = new 外部类名().new 内部类名();"——————————————————————————————————————————————————————————"*************************************************************************************************"【非静态内部类】【不能】 定义【 静态方法、静态成员变量、静态初始化块】"*************************************************************************************************"需要在外部类中创建 内部类对象 ==&gt;&gt;&gt;调用方法"： 根据静态成员不能直接访非静态成员的规则， "外部类的【静态方法】、静态代码块【不能直接】访问【非静态内部类】， 包括不能直接使用非静态内部类定义变量、创建实例等。" 总之，【不允许】在中直接使用【非静 态内部类】举例：public class Outer_0 &#123; //非静态内部类 public class Inner_0&#123; &#125; //外部类的【静态方法】 public static void static_method()&#123; new Inner_0();//error,不允许在外部类的【静态成员】中【直接使用】非静态静内部类 "正确调用方式" new Outer_0().new Inner_0(); &#125;&#125;访问"【非静态成员内部类】"：（1）在【外部类】的"【非静态方法】"中访问： "【new 内部类名()" OR "【 new 外部类名().new 内部类名() 】" （2）在【外部类以外】的"【非静态方法】"中访问： "【只能】【 new 外部类名().new 内部类名() 】"（3）在【外部类】及 【外部类以外】的"【静态方法】"中访问：" 【只能】通过【 new 外部类名().new 内部类名() 】" 方式访问————————————————————————————————————————————————————————————————————————————————————————（二）访问"【静态成员内部类】"："——————————————————————————————————————————————————————————"（1）在【外部类】中使用静态内部类new 静态内部类名();调用静态内部类的"【非静态方法】"：new 外部类名.静态内部类名()调用静态内部类的"【静态方法】"： 静态内部类名.静态方法名(); （2）在【外部类以外】使用静态内部类 因为【静态内部类】是外部类"类相关"的，"因此创建静态内部类对象时【无须】创建外部类对象"。在【外部类以外】的地方创建静态内部类实例的语法："***************************************************************************************"外部类名.内部类名 变量名 = new 外部类名.静态内部类名();"***************************************************************************************" A:【调用非静态方法】： 变量名.静态方法名() OR new 外部类名.静态内部类名().静态方法名()"——————————————————————————————————————————————————————————" B:【调用静态方法】："在【外部类以外】：访问方式无需创建对象，利用 【 外部类名.静态内部类名.内部类静态方法 】访问内部类【静态方法】"————————————————————————————————————————————————————————————————————————————————————————* D: 成员内部类代码演示class Body &#123;//外部类，身体 private boolean life= true; //生命状态 public class Heart &#123; //内部类，心脏 public void jump() &#123; System.out.println("心脏噗通噗通的跳") System.out.println("生命状态" + life); //访问外部类成员变量 &#125; &#125;&#125;访问内部类public static void main(String[] args) &#123; //创建内部类对象 Body.Heart bh = new Body().new Heart(); //调用内部类中的方法 bh.jump();&#125; 16成员内部类的同名变量调用* A: 代码实现 1234567891011121314151617181920212223242526272829当在"【非静态内部类】"的"方法内"访问某个变量时，(1)系统优先在该"方法内"查找是否存在该名字的"局部变量"，如果存在就使用该变量;"方法内"的"局部变量"：直接用变量名 调用(2)如果不存在，则到该方法所在的"内部类"中查找是否存在该名字的成员变量，如果存在则使用该"成员变量";"内部类"中的"成员变量"：this.成员变量名 调用(3)如果不存在，则到该内部类所在的"外部类"中查找是否存在该名字的"成员变量"，如果存在则使用该成员变量;"外部类"中的"成员变量"：外部类名.this.成员变量名 调用如果依然不存在，系统将出现编译错误:提示找不到该变量。public class Outer &#123; int num = 1; class Inner &#123; int num = 2; public void inner()&#123; int num = 3; //18,就近原则 System.out.println("成员内部类 Inner 的方法 func &gt;&gt; num: "+ num); //视为 访问 内部类对象（this）的成员变量，用this System.out.println("成员内部类 Inner 的方法 func &gt;&gt; this.num: "+ this.num); //视为 访问 外部类对象(Outer.this)的成员变量，用Outer.this System.out.println("成员内部类 Inner 的方法 func &gt;&gt; Outer.this.num: "+ Outer.this.num); &#125; &#125;&#125; 17 局部内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687* A "局部内部类"，定义在"【外部类方法】"中的"局部位置"。"与访问方法中的【局部变量】【相似】，* 可通过【调用方法】【进行访问】".* 局部类 "【不能】" 用 public或 private "修饰符进行声明，它的作用域被限定在所声明的【局部类的块】中。"* B 定义格式 class 【外部类】 &#123; 修饰符 返回值类型 【方法名(参数)】 &#123; class 【内部类】 &#123; //其他代码 &#125; &#125; &#125;* C 访问方式 "在【外部类方法】中，创建【内部类】【对象】，进行访问"* D 局部内部类代码演示 定义类 class Party &#123;//外部类，聚会 public void puffBall()&#123;// 吹气球方法 class Ball &#123;// 内部类，气球 public void puff()&#123; System.out.println("气球膨胀了"); &#125; &#125; //创建内部类对象，调用puff方法 new Ball().puff(); &#125; &#125; 访问内部类 public static void main(String[] args) &#123; //创建外部类对象 Party p = new Party(); //调用外部类中的puffBall方法 p.puffBall(); &#125;————————————————————————————————————————————————————————————————————————————————————————举例：//局部内部类public class Outer &#123; private int num =380; public void method()&#123; final int TYU =56; System.out.println("外部类 Outer 的方法"); &#125; public int outer_func( String s)&#123; int num = 200; // num是局部变量 int yu=90; int [] arr = new int[1]; //局部内部类 class Inner&#123; int num =567; //如何调用 局部内部类 中的 方法？ public void inner_func()&#123; int num = 45456; // s = "dvd"; // yu =56; // yu++; //ERROR arr[0]++; arr[0]++;//通过引用数据类型，实现【局部内部类】中的 计数器 this.num++;// 该this指向【局部内部类 Inner 】【对象】的【成员属性】：567+1=568 System.out.println("局部内部类 Inner 的方法: " + this.num+ " "+ yu + s); System.out.println("局部内部类 Inner 的方法:调用局部变量 " + arr[0]); Outer.this.method(); &#125; public int inner_return()&#123; return this.num;//568 &#125; &#125; // 需要在【外部类】的【方法】中，创建【内部类】【对象】，进行访问 Inner in = new Inner(); in.inner_func(); System.out.println("this.num "+ this.num);// 该this指向 【外部类 Outer】【对象】的【成员属性】:380 return in.inner_return() + this.num + num;// num是局部变量：200 &#125;&#125; 18匿名内部类* A: 概述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。 最常用到的内部类就是匿名内部类，它是局部内部类的一种。 定义的【匿名内部类】有两个含义： "临时定义某一指定类型的子类" "定义后【即刻】创建刚刚定义的这个【子类】的【对象】"* B: 本质 "【匿名内部类】的【本质】是一个实现了【接口】或继承了某个【父类】的【子类匿名对象】".* C: 案例public interface Smoking &#123; public abstract void smoking(); &#125; /*【回顾之前采用的方式】 * 实现类,实现接口 重写接口抽象方法,创建实现类对象 * class XXX implements Smoking&#123; * public void smoking()&#123; * * &#125; * &#125; * XXX x = new XXX(); * x.smoking(); * Smoking s = new XXX(); * s.smoking(); * * 匿名内部类,简化问题: 定义实现类,重写方法,建立实现类对象,合为一步完成 */测试类:public class Test &#123; public static void main(String[] args) &#123; "//使用匿名内部类 /* * 定义实现类,重写方法,创建实现类对象,一步搞定 * 格式:" —————————————————————————————————————————————————————— new 接口或者父类()&#123; 重写抽象方法 &#125;; —————————————————————————————————————————————————————— "* 从 new开始,到分号结束 * 创建了接口的实现类的对象 */" new Smoking()&#123; public void smoking()&#123; System.out.println("人在吸烟"); &#125; &#125;.smoking(); &#125;&#125; 19匿名内部类_2* A: 匿名内部类案例演示 1234567891011121314151617181920212223242526272829303132333435 public abstract class Animal &#123; public abstract void eat(); public abstract void sleep(); &#125;测试代码/* * new Animal()&#123; public void eat()&#123; System.out.println("在吃饭"); &#125; public void sleep()&#123; System.out.println("在睡觉"); &#125; &#125;;*/ "以上代码,就是Animal的子类的对象 利用多态性, 父类引用 = 子类的对象"public class Test2 &#123; public static void main(String[] args) &#123; Animal a= new Animal()&#123; public void eat()&#123; System.out.println("在吃饭"); &#125; public void sleep()&#123; System.out.println("在睡觉"); &#125; &#125;; a.eat(); a.sleep(); &#125;&#125; 20包的概念* A: 概念 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354java的包，其实就是我们电脑系统中的文件夹，包里存放的是"类文件（.java 或者 .class 文件）"。当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为"分包管理"。在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是"以包作为边界"。"类中声明的包必须与实际class文件所在的文件夹情况【相一致】，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类"。"————————————————————————————————————————————————————————————————————————————————————————"* B 声明格式通常使用公司网址反写，"可以有【多层包】，包名采用【全部小写字母】，【多层包】之间用【”.”】连接" 类中包的声明格式： —————————————————————————————— package 包名.包名.包名…; —————————————————————————————— 如：网址itheima.com那么网址反写就为com.itheima itcast.cn 那么网址反写就为 cn.itcast "注意：声明包的语句，必须写在程序【有效代码】的【第一行】（注释不算）" 代码演示： package cn.itcast; //包的声明，必须在有效代码的第一行 import java.util.Scanner; import java.util.Random; public class Demo &#123;&#125;"————————————————————————————————————————————————————————————————————————————————————————"* C: 包的访问在访问类时，为了能够找到该类，"必须使用含有包名的【类全名】（包名.类名）"。即："包名.包名….类名"如： java.util.Scanner java.util.Random cn.itcast.Demo——————————————————————————————————————————————————————————带有包的类，创建对象格式：包名.类名 变量名 = new 包名.类名();——————————————————————————————————————————————————————————如： cn.itcast.Demo d = new cn.itcast.Demo(); 前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。"————————————————————————————————————————————————————————————————————————————————————————"*D:类的简化访问——————————————————————————————————————————————————————————当我们要使用一个类时，这个类与当前程序在"同一个包中（即同一个文件夹中）"，或者"这个类是【java.lang】包中的类"时通常"【可以省略】掉【包名】"，直接使用该类。——————————————————————————————————————————————————————————如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。—————————————————————————————————————————————————————————— 类名 变量名 = new类名(); Person p = new Person(); 当我们要使用的类，与当前程序"【不在】同一个包中（即【不同】文件夹中）"，要访问的类"必须"用public"修饰才可访问"。 package cn.itcst02; public class Person &#123;&#125; 22导入包* A:导入包 12345678910111213141516171819202122我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。导包的格式：import 包名.类名; 当程序导入指定的包后，使用类时，就可以简化了。演示如下//导入包前的方式//创建对象java.util.Random r1 = new java.util.Random();java.util.Random r2 = new java.util.Random();java.util.Scanner sc1 = new java.util.Scanner(System.in);java.util.Scanner sc2 = new java.util.Scanner(System.in);//导入包后的方式import java.util.Random;import java.util.Scanner;//创建对象Random r1 = new Random();Random r2 = new Random();Scanner sc1 = new Scanner(System.in);Scanner sc2 = new Scanner(System.in);import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名; 23权限修饰符* A 权限修饰符有哪些 12345678910111213141516171819202122232425262728293031 在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限， 以下表来说明不同权限的访问能力： public protected default private———————————————————————————————————————————————————————————————————————————————————————— "同一【类】中" √ √ √ √———————————————————————————————————————————————————————————————————————————————————————— "同一包中(子类与无关类)" √ √ √ ———————————————————————————————————————————————————————————————————————————————————————— "不同包的子类" √ √———————————————————————————————————————————————————————————————————————————————————————— "不同包中的无关类" √ ———————————————————————————————————————————————————————————————————————————————————————— * B: 小结归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问———————————————————————————————————————————————————————————————————————————————————————— private:要想"【仅能在本类中】"访问使用private修饰；———————————————————————————————————————————————————————————————————————————————————————— default:要想"【本包】"中的类都可以访问"【不加修饰符】"即可；———————————————————————————————————————————————————————————————————————————————————————— protected:要想"【本包】中的类与【其他包中的【子类】】"可以访问使用protected修饰注意： protected 修饰符 在"【跨包】调用成员"时： "【只能】在 【子类的内部】【进行调用】：&#123; 直接用 【成员名】 OR 【super.成员名】 调用&#125;并且【不能】在【子类中】 通过 【创建对象】 【进行调用】"———————————————————————————————————————————————————————————————————————————————————————— public:要想"【所有包】中的【所有类】"都可以访问使用public修饰。———————————————————————————————————————————————————————————————————————————————————————— 注意：如果类用public修饰，"则【类名】必须与【文件名】相同"。"一个文件中【只能】有一个" public修饰的类。———————————————————————————————————————————————————————————————————————————————————————— 24代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788* A: 概述:程序中用"【大括号括起来】"的代码叫"代码块"———————————————————————————————————————————————————————————————————————————————————————— * B: 分类"局部代码块" "构造代码块" "静态代码块" "同步代码块"———————————————————————————————————————————————————————————————————————————————————————— * C "局部代码块":"【局部代码块】是定义在【方法】或【语句】中"特点： "以”&#123;&#125;”划定的代码区域，此时只需要关注【作用域】的不同即可" "【方法】和【类】都是以【代码块】的方式【划定边界】的"———————————————————————————————————————————————————————————————————————————————————————— class Demo&#123; public static void main(String[] args) &#123; //局部代码块 &#123; int x = 1; System.out.println("局部代码块" + x); &#125; //局部变量作用域 int x = 99; System.out.println("代码块之外" + x); &#125;&#125; 结果： 普通代码块1 代码块之外99 "【局部代码块】作用:可以【限定变量】的【声明周期】".———————————————————————————————————————————————————————————————————————————————————————— * D: "构造代码块""【构造代码块】是定义在【类】中【成员位置】的代码块"特点： "【优先于】【构造方法】执行，构造代码块用于执行【所有对象】【均需要】的【初始化动作】" "每【创建一个】对象均会【执行一次】构造代码块"。public class Person &#123; private String name; private int age; //构造代码块 &#123; System.out.println("构造代码块执行了"); &#125; Person()&#123; System.out.println("Person无参数的构造函数执行"); &#125; Person(int age)&#123; this.age = age; System.out.println("Person（age）参数的构造函数执行"); &#125;&#125;class PersonDemo&#123; public static void main(String[] args) &#123; Person p = new Person(); Person p1 = new Person(23); &#125;&#125;结果： 构造代码块执行了 Person无参数的构造函数执行 构造代码块执行了 Person（age）参数的构造函数执行———————————————————————————————————————————————————————————————————————————————————————— * E: "静态代码块""【静态代码块】是定义在【成员位置】"，使用static "修饰的代码块"。特点： "它【优先于】【主方法】执行、【优先于】【构造代码块】执行， 当以任意形式【第一次使用到该类】时执行"。 "【该类】【不管创建多少对象】，【静态代码块】【只执行一次】"。 "可用于给【静态变量赋值】，用来给【类进行初始化】"。 public class Person &#123; private String name; private int age; //静态代码块 static&#123; System.out.println("静态代码块执行了"); &#125; &#125;———————————————————————————————————————————————————————————————————————————————————————— * F: "同步代码块"(多线程学习) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071————————————————————————————————————————————————————————————————————————————————————————举例：class Person &#123; public Person()&#123; System.out.println("Class Person 构造方法"); &#125; &#123; System.out.println("Class Person 构造代码块 "); &#125; static &#123; System.out.println("Class Person 【静态】代码块 "); &#125;&#125;class Student extends Person &#123; public Student() &#123; System.out.println(" Student 构造方法"); &#125; static &#123; System.out.println(" Student 【静态】代码块"); &#125; &#123; System.out.println(" Student 构造代码块"); &#125; &#125;public class Test &#123; public static void main(String[] args) &#123; new Student(); System.out.println("————————————————————————————"); new Student(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————运行结果：Class Person 【静态】代码块 Student 【静态】代码块Class Person 构造代码块 Class Person 构造方法 Student 构造代码块 Student 构造方法————————————————————————————Class Person 构造代码块 Class Person 构造方法 Student 构造代码块 Student 构造方法———————————————————————————————————————————————————————————————————————————————————————结论："【静态代码块】【只执行一次】执行顺序：* 静态代码块 &gt; 构造代码块（初始化块） &gt; 构造方法（构造器）* 父类 &gt; 子类结合下来的顺序： 【父类】静态代码块 【子类】静态代码块 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法" 25总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final：关键字，最终的意思 final修饰的类：最终的类，不能被继承 final修饰的变量： 相当于是一个常量, 在编译生产.class文件后，该变量变为常量值 final修饰的方法： 最终的方法，子类不能重写，可以继承过来使用————————————————————————————————————————————————————————————————————————————————————————static : 关键字， 静态的意思 可以用来修饰类中的成员(成员变量，成员方法) 注意： 也可以用来修饰成员内部类特点： 被静态所修饰的成员，会被所有的对象所共享 被静态所修饰的成员，可以通过类名直接调用，方便 Person.country = "中国"; Person.method();注意事项： 静态的成员，随着类的加载而加载，优先于对象存在 在静态方法中，没有this关键字 静态方法中，只能调用静态的成员(静态成员变量，静态成员方法————————————————————————————————————————————————————————————————————————————————————————匿名对象：一个没有名字的对象特点：创建匿名对象直接使用，没有变量名匿名对象在没有指定其引用变量时，只能使用一次匿名对象可以作为方法接收的参数、方法返回值使用————————————————————————————————————————————————————————————————————————————————————————内部类：在一个类中，定义了一个新类，这个新的类就是内部类 class A &#123;//外部类 class B&#123;// 内部类 &#125; &#125;特点： 内部类可以直接访问外部类的成员，包含私有的成员————————————————————————————————————————————————————————————————————————————————————————包的声明与访问类中包的声明格式： package 包名.包名.包名…;带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();cn.itcast.Demo d = new cn.itcast.Demo();导包的格式：import 包名.类名;————————————————————————————————————————————————————————————————————————————————————————权限修饰符 public : 公共的 protected: 受保护的 default: 默认的（可省略） private : 私有的 public protected default private———————————————————————————————————————————————————————————————————————————————————————— "同一【类】中" √ √ √ √———————————————————————————————————————————————————————————————————————————————————————— "同一包中(子类与无关类)" √ √ √ ———————————————————————————————————————————————————————————————————————————————————————— "不同包的子类" √ √———————————————————————————————————————————————————————————————————————————————————————— "不同包中的无关类" √ ———————————————————————————————————————————————————————————————————————————————————————— 代码块： 局部代码块：定义在方法中的，用来限制变量的作用范围 构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值 静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值———————————————————————————————————————————————————————————————————————————————————————— 以下代码的输出结果是？12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println("构造块"); &#125; static &#123; System.out.println("静态块"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125; 答案： 构造块 构造块 静态块 构造块 开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出’’构造块’’）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出’构造块’），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出’静态块’），接着执行，main方法，同样也，new了对象，调用构造函数输出（’构造块’） 并不是静态块最先初始化,而是静态域.而静态域中包含静态变量、静态块和静态方法,其中需要初始化的是静态变量和静态块.而他们两个的初始化顺序是靠他们俩的位置决定的!So！初始化顺序是 t1 t2 静态块]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础10(构造方法，this，super)]]></title>
    <url>%2F2016%2F10%2F13%2Fday12%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、构造方法2、this关键字3、super关键字4、综合案例 01构造方法引入* A:构造方法的引入 在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。 那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？ 这就要学习Java另外一门小技术，构造方法。 * B: 那什么是构造方法呢？ 从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时， 知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。 02构造方法作用* A: 构造方法的作用: 在new的同时给成员变量赋值,给对象属性进行初始化。 * B: 举例: Perons p = new Person(&quot;张三&quot;,23); 在new 的时候给p对象的name属性和age属性进行赋值,使这个对象的属性有值。 03构造方法的定义和运行特点* A: 构造方法定义 构造方法的格式： 修饰符 构造方法名(参数列表) { } * B: 构造方法的体现： 构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。 构造方法名称必须和类型保持一致。 构造方法没有具体的返回值。 构造方法的代码体现： * C: 构造方法举例 123456789101112131415 class Person &#123; // Person的成员属性age和name private int age; private String name; // Person的构造方法，拥有参数列表 Person(int a, String nm) &#123; // 接受到创建对象时传递进来的值，将值赋给成员属性 age = a; name = nm; &#125; &#125;* D: 构造方法运行特点: 在new 对象的时候自动调用执行。 04默认添加的构造方法* A: 每一class类都必须有一个构造方法，构造方法不写也有。 编译的时候，javac，系统会自动检查类中是否有构造方法，如果没有编译器就会自动添加一个构造方法 比如Person类， 编译器添加一个无参构造 public Person(){} 05构造方法的调用赋值* A: 理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？ 构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。现在来看看如何调用构造方法。 * B: 案例 1234567891011121314151617181920212223242526 class Person &#123; // Person的成员属性age和name private int age; private String name; // Person的构造方法，拥有参数列表 Person(int a, String nm) &#123; // 接受到创建对象时传递进来的值，将值赋给成员属性 age = a; name = nm; &#125; public void speak() &#123; System.out.println("name=" + name + ",age=" + age); &#125; &#125; class PersonDemo &#123; public static void main(String[] args) &#123; // 创建Person对象，并明确对象的年龄和姓名 Person p2 = new Person(23, "张三"); p2.speak(); &#125; &#125;上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法 06构造方法的内存A:内存加载的过程 有一个Person类, 创建Person 对象new Person() 1、首先会将main方法压入栈中，执行main方法中的 new Person(23,”张三”); 2、在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。 然后给成员变量进行默认初始化（name=null，age=0）。 3、执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age， 将变量nm对应的”张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。 执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。 07构造方法的重载* A：当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定， * 当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。 * 若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。 12345678910111213141516171819202122 构造方法的细节： 1、一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的 2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。* B: 举例 class Person &#123; private int age; private String name; // 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象 private Person() &#123; &#125; // 多个构造方法是以重载的形式存在 Person(int a) &#123; age = a; &#125; Person(String nm, int a) &#123; name = nm; age = a; &#125; &#125; 08构造方法和一般方法区别* A: 目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？ 12345678910111213141.格式不同 构造方法 : 修饰符 类名(参数类型 参数 ...)&#123; 初始化成员变量&#125;一般方法: 需要有返回值类型2.作用不同构造方法一般用来给成员变量初始化;一般方法根据需求而定;3.调用方式不同构造方法创建对象时调用, 或者this() super() 语句调用普通方法需要对象调用或者静态方法直接调用静态方法.4.执行不同构造方法在对象创建时就执行了，而且只执行一次。一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。 09this在构造方法之间的调用* A: 在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。 12345678910111213141516171819202122232425262728 构造方法之间的调用，可以通过this关键字来完成。 构造方法调用格式： this(参数列表);* B:调用构造方法的案例 class Person &#123; // Person的成员属性 private int age; private String name; // 无参数的构造方法 Person() &#123; &#125; // 给姓名初始化的构造方法 Person(String nm) &#123; name = nm; &#125; // 给姓名和年龄初始化的构造方法 Person(String nm, int a) &#123; // 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可 // 调用其他构造方法，需要通过this关键字来调用 this(nm); // 给年龄初始化 age = a; &#125; &#125; 10this在构造方法调用的内存图* A: 被加载的代码 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123; private int age; private String name; Person() &#123; &#125; Person(String nm) &#123; name = nm; &#125; Person(String nm, int a) &#123; this(nm); age = a; &#125;&#125;class PersonDemo &#123; public static void main(String[] args) &#123; Person p = new Person("张三", 23); &#125;&#125;* B: 构造方法调用的原理图* 1、先执行main方法，main方法压栈，执行其中的new Person(“张三”,23);2、堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null age = 0）；3、拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，哪个对象调用到这个构造方法，this就指向堆中的哪个对象。4、由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将“张三”传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把“张三”赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈。5、程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈。6、当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。注意：this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。 11this简易应用* A: 当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量 * B: 举例1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person &#123; private int age; private String name; // 给姓名和年龄初始化的构造方法 Person(String name, int age) &#123; // 当需要访问成员变量是，只需要在成员变量前面加上this.即可 this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125;&#125;class PersonDemo &#123; public static void main(String[] args) &#123; Person p = new Person("张三", 23); p.speak(); &#125;&#125;* C: 举例2学习完了构造方法、this的用法之后，现在做个小小的练习。需求：在Person类中定义功能，判断两个人是否是同龄人class Person &#123; private int age; private String name; // 给姓名和年龄初始化的构造方法 Person(String name, int age) &#123; // 当需要访问成员变量是，只需要在成员变量前面加上this.即可 this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125; // 判断是否为同龄人 public boolean equalsAge(Person p) &#123; // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较 // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替 /* * if(this.age == p.age) &#123; return true; &#125; return false; */ return this.age == p.age; &#125;&#125; 12super关键字_1* A: 子父类中构造方法的调用 12345678 在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。* B: 格式： 调用本类中的构造方法 this(实参列表); 调用父类中的空参数构造方法 super(); 调用父类中的有参数构造方法 super(实参列表); 13super关键字_2* A:子类构造方法,有一个默认添加的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Student extends Person &#123; public Student()&#123; super(); &#125;&#125;* B :为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容， 所以创建对象时，必须要先看父类是如何对其内容进行初始化的，看如下程序public class Test &#123; public static void main(String[] args) &#123; new Zi(); &#125; &#125;class Fu&#123; int num ; Fu()&#123; System.out.println("Fu构造方法"+num); num = 4; &#125;&#125;class Zi extends Fu&#123; Zi()&#123; //super(); 调用父类空参数构造方法 System.out.println("Zi构造方法"+num); &#125;&#125;执行结果： Fu构造方法0 Zi构造方法4通过结果发现，子类空参数构造方法执行时中，调用了父类空参数构造方法，这说明，子类空参数构造方法中有一句super()。@A: "【子类】中的【空参数构造方法】会有一句【隐式】的" super()原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。——————————————————————————————————————————————————————————————————————————————————————@B: "当父类中【没有】【空参数构造方法】时，子类的构造方法【必须】有【显示】的【super(参数)语句】， 指定要访问的父类【有参数】【构造方法】。否则报错！！！"public class Parent &#123; public Parent(String s)&#123; System.out.println("Parent"); &#125;&#125;public class Child extends Parent &#123; public Child(String s)&#123; super(s);//父类中【没有】【空参数构造方法】时，子类的构造方法【必须】有【显示】的【super(参数)语句】 System.out.println("Child"); &#125;&#125; 14子类父类的内存图 15super关键字_3* A: 创建子类对象的时候会必须调用父类的构造方法。 &quot;子类默认会调用父类的【无参构造】， 但如果父类【没有无参构造】，子类的构造方法继续调用父类的无参构造就会报错。&quot; &quot;因此子类构造方法的第一行需要调用父类的构造方法，既可以调用父类的无参构造，也可以调用父类的有参构造，这样语法上就不会报错。&quot; 16super关键字_41234567* A: 构造方法第一行,写this()还是super()* " this() 是调用本类的构造方法,super()是调用父类的构造方法, 且两条语句不能同时存在 "* " 保证子类的所有构造方法调用到父类的构造方法即可 "* B: 小结:*" 无论如何,子类的所有构造方法,直接或间接必须调用到父类构造方法;"* "子类的构造方法什么都不写,默认的构造方法第一行是super() ，即默认调用父类的空参数构造方法" 17创建子类对象过程的细节1234567891011121314* A 创建子类对象过程的细节* 如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？* 这时是没有的，"因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。"* 父类构造方法中是否有隐式的super呢？* 也是有的。记住：只要是构造方法默认第一行都是super();* 父类的父类是谁呢？super调用的到底是谁的构造方法呢？* Java体系在设计，定义了一个所有对象的父类Object* 注意：* "类中的构造方法默认第一行都有【隐式】的super()语句，访问父类中的【空参数构造方法】。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。如果默认的隐式super()语句在父类中【没有】对应的构造方法，那么必须在构造方法中通过 this(参数) 或者 super(参数) 的形式明确要调用的构造方法。" 18super的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* A: 练习：描述学生和工人这两个类，将他们的共性name和age抽取出来存放在父类中，并提供相应的get和set方法，同时需要在创建学生和工人对象就必须明确姓名和年龄* 案例://定义Person类，将Student和Worker共性抽取出来class Person &#123; private String name; private int age; public Person(String name, int age) &#123; // super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Student extends Person &#123; // Student类的构造方法 Student(String name, int age) &#123; // 使用super关键字调用父类构造方法，进行相应的初始化动作 super(name, age); &#125; public void study() &#123;// Studnet中特有的方法 System.out.println(this.getName() + "同学在学习"); &#125;&#125;class Worker extends Person &#123; Worker(String name, int age) &#123; // 使用super关键字调用父类构造方法，进行相应的初始化动作 super(name, age); &#125; public void work() &#123;// Worker 中特有的方法 System.out.println(this.getName() + "工人在工作"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Student stu = new Student("小明",23);stu.study(); Worker w = new Worker("小李",45);w.work(); &#125;&#125; 19总结123456789101112131415161718192021222324252627282930313233343536373839404142434445this关键字this关键字，本类对象的引用this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用this什么时候存在的？当创建对象的时候，this存在的this的作用：用来区别同名的成员变量与局部变量（this.成员变量） public void setName(String name) &#123; this.name = name; &#125;————————————————————————————————————————————————————————————————————————————"构造方法"： "用来给类的成员进行初始化操作"格式： 修饰符 类名 (参数列表) &#123; ...&#125;构造方法的特点：1, 方法名与类名相同2，【"没有返回值】，也【没有】【返回值类型】"，连void也没有构造方法什么时候会被调用执行？ "【只有】在创建对象的时候才可以被调用"————————————————————————————————————————————————————————————————————————————super: 指的是父类的存储空间(理解为"【父类的引用】") "调用父类的【成员变量】"： super.成员变量; "调用父类的【构造方法】": super(参数); "调用父类的【成员方法】": super.成员方法();继承中的构造方法注意事项：1，"如果我们【手动给出了构造方法】，编译器【不会】再给我们提供【默认】的【空参数构造方法】如果我们【没写】任何的构造方法，编译器提供给我们【一个隐式空参数构造方法】"2, 在构造方法中，【默认】的第一条语句为 super();它是用来访问父类中的【空参数构造方法】，进行父类成员的初始化操作3, 当父类中【没有】【空参数构造方法】的时候，怎么办？ a: 通过 super(参数) "访问【父类】【有参数的构造方法】" b: 通过 this(参数) "访问【本类】中其他构造方法" 注意:"【本类】中的其他构造方法应满足已经能够正常访问【父类构造方法】， 即本类其他构造方法（含有super(参数)）"4, "super(参数) 与 this(参数) 【不能】同时在构造方法中存在" 20完整员工案例分析 * A: 项目介绍 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。 工作内容 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站 Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件 网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通 硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。 * B: 案例分析 根据上述部门的描述，得出如下的员工体系图 根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。 工作内容 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站 Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件 网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通 硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 创建JavaEE工程师对象，完成工作方法的调用 21案例代码实现* A:定义员工类(抽象类) 1234567891011121314151617181920212223242526272829public abstract class Employee &#123; private String id;// 员工编号 private String name; // 员工姓名 //空参数构造方法 public Employee() &#123; super(); &#125; //有参数构造方法 public Employee(String id, String name) &#123; super(); this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //工作方法（抽象方法） public abstract void work(); &#125; * B : 定义研发部员工类Developer 继承 员工类Employee 12345678910public abstract class Developer extends Employee &#123; //空参数构造方法 public Developer() &#123; super(); &#125; //有参数构造方法 public Developer(String id, String name) &#123; super(id, name); &#125;&#125; * C: 定义维护部员工类Maintainer 继承 员工类 1234567891011Employeepublic abstract class Maintainer extends Employee &#123; //空参数构造方法 public Maintainer() &#123; super(); &#125; //有参数构造方法 public Maintainer(String id, String name) &#123; super(id, name); &#125;&#125; * D: 定义JavaEE工程师 继承 研发部员工类，重写工作方法 public class JavaEE extends Developer { //空参数构造方法 public JavaEE() { super(); } //有参数构造方法 public JavaEE(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝网站"); } } * E: 定义Android工程师 继承 研发部员工类，重写工作方法 public class Android extends Developer { //空参数构造方法 public Android() { super(); } //有参数构造方法 public Android(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件"); } } * F: 定义Network网络维护工程师 继承 维护部员工类，重写工作方法 public class Network extends Maintainer { //空参数构造方法 public Network() { super(); } //有参数构造方法 public Network(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在检查网络是否畅通"); } } * G: 定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 public class Hardware extends Maintainer { //空参数构造方法 public Hardware() { super(); } //有参数构造方法 public Hardware(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机"); } } * H: 在测试类中，创建JavaEE工程师对象，完成工作方法的调用 public class Test { public static void main(String[] args) { //创建JavaEE工程师员工对象，该员工的编号000015，员工的姓名 小明 JavaEE ee = new JavaEE("000015", "小明"); //调用该员工的工作方法 ee.work(); } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础9(接口，多态)]]></title>
    <url>%2F2016%2F10%2F12%2Fday11%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、接口2、多态 Java中引用数据类型只有三种，分别是类(class)、接口(interface)、数组。 Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。在函数中定义的一些【基本类型的变量】和【对象的引用变量】都是在函数的【栈内存】中分配。 当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。 【堆内存用于存放由new创建的对象或数组】。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于【数组或者对象在堆内存中的首地址】，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名。 【引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。】而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，【数组和对象在没有引用变量指向它的时候，才变成垃圾】，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针! 01接口的概念* A:接口的概念 接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。 接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。 请记住：一切事物均有功能，即一切事物均有接口。 02接口的定义123456789101112131415161718192021* A: 接口的定义 与定义类的class不同，接口定义时需要使用interface关键字。 定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。 这点可以让我们将接口看做是一种只包含了功能声明的特殊类。 * B : 定义格式 public interface 接口名 &#123; 抽象方法1; 抽象方法2; 抽象方法3;&#125;* C: 定义步骤 使用interface代替了原来的class，其他步骤与定义类相同： "接口中的方法均为【公共】访问的抽象方法": 定义为： public abstract 返回值类型 方法名(参数列表); 接口中无法定义普通的成员变量： public static final int NUM = 3;// NUM的值不能改变 03接口的实现类* A: 类与接口的关系 123456789101112131415"类与接口的关系为实现关系，即类实现接口"。实现的动作类似继承，只是关键字不同，"实现使用 implements "其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然需要重写方法以实现具体的功能。* B: 类实现接口的格式class 类 implements 接口 &#123; 重写接口中方法&#125; * C:注意事项"在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。"接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。在具体实现类中重写方法，实现功能，是方法的具体实现。 04接口中成员变量的特点1234567891011A:成员变量特点* a 接口中可以定义变量，但是变量"必须有固定的修饰符修饰" public static final 所以"接口中的变量也称之为常量，其值不能改变"。后面我们会讲解static与final关键字* B:案例interface Demo &#123; ///定义一个名称为Demo的接口。 public static final int NUM = 3;// NUM的值不能改变 //可以省略不写修饰符public static final，接口默认是public static final int NUMBER = 5;&#125; 05接口中成员方法的特点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* A: 成员方法特点 * a 接口中可以定义方法，"方法也有固定的修饰符"，public abstract 同样，"可以省略不写"修饰符public abstract ，接口的成员方法"默认"是public abstract 但是，"在【实现类】中【重写】【接口中的方法】 【必须有】" public————————————————————————————————————————————————————————————————————————————————————————此外，注意： @1 接口中可以定义"静态方法"（static method）：public interface MyInterface &#123; public abstract void func(); public static void static_func()&#123; System.out.println("接口中可以定义\"静态方法\" "); &#125;&#125;"调用方式： 接口名.静态方法名(); MyInterface.static_func();"——————————————————————————————————————————————————————————@2 接口中可以定义"默认方法"（default method）:通过default修饰符标记该方法。public interface MyInterface &#123; public abstract void func(); default void method()&#123; System.out.println("接口中可以定义\"默认方法\" "); &#125;&#125;———————————————————————————————————————————————————————————————————————————————————————— * b "子类必须覆盖掉接口中【所有的抽象方法】后，子类才可以实例化。否则子类是一个抽象类。" * "所有接口中的成员变量【必须是静态常量】，由于【接口】【没有】【构造方法】， * 所以【必须显示赋值】。可以【直接】用【接口名】访问" * " 访问接口中的静态变量 ": * "接口名.变量名" Inter.COUNT* B: 案例interface Demo &#123; ///定义一个名称为Demo的接口。 public abstract void show1(); public abstract void show2(); void show3();&#125;//定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 implementsclass DemoImpl implements Demo &#123; //子类实现Demo接口。 //重写接口中的方法。 public void show1()&#123;&#125; public void show2()&#123;&#125; public void show3()&#123;&#125;&#125; 06实现类还是一个抽象类A: 接口的实现类 一个类如果实现类接口,有两种操作方法: 第一:实现类是【非抽象类】,就需要【重写接口中所有】的抽象方法. ———————————————————————————————————————————————————————————————————————————————————————— 第二:实现类也声明为【抽象类】,那么实现类【可以不重写】接口中的抽象方法。 07类和接口的多实现* A：接口的多实现 了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？ 接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。 * B 多实现的优点 * 怎么解决多继承的弊端呢？ * 弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。 * 其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。 * 为什么多实现能解决了呢？ * 因为接口中的功能都没有方法体，由子类来明确。 C :案例演示 interface Fu1 { void show1(); } interface Fu2{ void show2(); } class Zi implements Fu1,Fu2 { // 多实现。同时实现多个接口。 public void show1(){} public void show2(){} } 08类在继承类的同时实现多接口A: 继承的同时实现接口 * 接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。 * 子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。 * 接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。 B: 代码演示1234567891011121314151617181920212223//父类：抽象类abstract class Fu &#123; public abstract void show();&#125;//接口interface Inter &#123; pulbic abstract void show1();&#125;//接口interface kock &#123; pulbic abstract void show1();&#125;//类Zi在继承父类Fu的同时实现多接口(Inter,kock) class Zi extends Fu implements Inter,kock &#123; //重写接口的抽象方法 public void show1() &#123; &#125; //重写父类的抽象方法 public void show()&#123; &#125;&#125;接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。 09接口的多继承* A: 接口的多继承 * 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。 ———————————————————————————————————————————————————————————————————————————————————————— * 【多个接口】之间可以使用【 extends 】进行【多继承】。 ———————————————————————————————————————————————————————————————————————————————————————— * 【类】【没有】【多继承】 ———————————————————————————————————————————————————————————————————————————————————————— * 【接口】【有】【多继承】 B 代码演示12345678910111213141516171819202122232425262728293031323334 interface AA&#123; void fun_A();&#125;interface BB&#123; void fun_B();&#125;interface CC&#123; void fun_C();&#125;//接口DD 多继承 AA,BB,CCinterface DD extends AA,BB,CC&#123; void fun_D();&#125;//EE类实现接口DDpublic class EE implements DD&#123;//EE类实现接口DD，需要重写DD以及DD多继承接口的全部抽象方法 public void fun_D()&#123; System.out.println("重写fun_D"); &#125; public void func_A()&#123; System.out.println("重写fun_A"); &#125; public void func_B()&#123; System.out.println("重写fun_B"); &#125; public void func_C()&#123; System.out.println("重写fun_C"); &#125;&#125;在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。 10接口思想* A:接口的思想 * 前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。 * 举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？ * 主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。 ———————————————————————————————————————————————————————————————————————————————————————— * B: 接口的好处 * 总结：接口在开发中的它好处 * 1、接口的出现扩展了功能。 * 2、接口其实就是暴漏出来的规则。 * 3、接口的出现【降低】了【耦合性】，即设备与设备之间实现了【解耦】。 * 接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。 11接口和抽象类的区别* A: 明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？ 通过实例进行分析和代码演示抽象类和接口的用法。 * B: 举例： * 犬： 行为： 吼叫； 吃饭； * 缉毒犬： 行为： 吼叫； 吃饭； 缉毒； * C:思考： * 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。 * 当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。 * 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。 * D: 代码演示 1234567891011121314151617181920212223interface 缉毒&#123; public abstract void 缉毒();&#125;//定义犬科的共性功能abstract class 犬科&#123; public abstract void 吃饭(); public abstract void 吼叫();&#125;// 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能class 缉毒犬 extends 犬科 implements 缉毒&#123; public void 缉毒() &#123; &#125; void 吃饭() &#123; &#125; void 吼叫() &#123; &#125;&#125;class 缉毒猪 implements 缉毒&#123; public void 缉毒() &#123; &#125;&#125; * E: 接口和抽象类区别总结 123456789101112131415 相同点: 都位于继承的顶端,用于被其他类实现或继承; "【都不能】直接实例化对象"; "都包含抽象方法,其子类都必须覆写这些抽象方法才能实例化";区别: "抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;" "【抽象类】【可以】【不包含】 【抽象方法】" "【接口】【只能】【含有】【抽象方法】"; " 一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承) " 抽象类是这个事物中"应该具备的内容", 继承体系是一种 is..a关系 接口是这个事物中的"【额外内容】",继承体系是一种 like..a关系二者的选用: " 优先选用接口,尽量少用抽象类; " 需要定义子类的行为,又要为子类提供共性功能时才选用抽象类; 12多态概述* A: 多态概述 1234567891011121314151617多态是继封装、继承之后，面向对象的第三大特性。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。 Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。**************************************************************" Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。"**************************************************************如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。**************************************************************" 最终多态体现为父类引用变量可以指向子类对象。多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。 "**************************************************************" 在使用多态后的【父类引用变量】【调用方法】时，会调用【子类】【重写】后的方法。"**************************************************************【多态的缺点】："【父类】【不能】调用【子类】的【特有内容】，需要【向下转型】调用子类的【特有内容】" 13多态调用的三种格式123456789101112131415161718192021222324252627282930313233343536373839404142434445* A:"多态的定义格式"： * 就是父类的引用变量指向子类对象 父类类型 变量名 = new 子类类型(); 变量名.方法名();* B: "普通类多态定义的格式" 父类 变量名 = new 子类(); 举例： class Fu &#123;&#125; class Zi extends Fu &#123;&#125; //类的多态使用 Fu f = new Zi();* C: "抽象类多态定义格式" 抽象类 变量名 = new 抽象类子类(); 举例： abstract class Fu &#123; public abstract void method(); &#125; class Zi extends Fu &#123; public void method()&#123; System.out.println("重写父类抽象方法"); &#125; &#125; //类的多态使用 Fu fu= new Zi();* D: "接口多态定义的格式" 接口 变量名 = new 接口实现类(); 如： interface Fu &#123; public abstract void method(); &#125; class Zi implements Fu &#123; public void method()&#123; System.out.println("重写接口抽象方法"); &#125; &#125; //接口的多态使用 Fu fu = new Zi();* E: "注意事项" "同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。" 如 Person p1 = new Student(); Person p2 = new Teacher(); p1.work(); //p1会调用Student类中重写的work方法 p2.work(); //p2会调用Teacher类中重写的work方法 当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。 14多态成员方法的特点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* A: 掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？* 前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化， * 那么当多态出现后，成员变量在使用上有没有变化呢？ * 多态出现后会导致子父类中的成员变量有微弱的变化* B: 代码演示 class Fu &#123; int num = 4; &#125; class Zi extends Fu &#123; int num = 5; &#125; class Demo &#123; public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num);//4 Zi z = new Zi(); System.out.println(z.num);//5 &#125; &#125;* C: "多态成员变量"* " &lt;&lt;参考基础11.[12]&gt;&gt;" "当子父类中出现同名的成员变量时，多态调用该变量时： 编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。 运行时期：也是调用引用型变量所属的类中的成员变量。" "简单记：编译和运行都参考等号的左边。编译运行看左边。"* D: 多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码 class Fu &#123; int num = 4; void show() &#123; System.out.println("Fu show num"); &#125; &#125; class Zi extends Fu &#123; int num = 5; void show() &#123; System.out.println("Zi show num"); &#125; &#125; class Demo &#123; public static void main(String[] args) &#123; Fu f = new Zi(); f.show(); &#125; &#125;* E: "多态成员方法" "编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。 运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。 简而言之：编译看左边，运行看右边。" 1234567891011121314151617181920212223242526public class Base&#123; private String baseName = "base"; public Base() &#123; callName(); &#125; public void callName() &#123; System. out. println(baseName); &#125; static class Sub extends Base &#123; private String baseName = "sub"; public void callName() &#123; System. out. println (baseName) ; &#125; &#125; public static void main(String[] args) &#123; Base b = new Sub(); &#125;&#125; A.首先，需要明白类的加载顺序。(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )(4) 父类构造函数(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )(6) 子类构造函数其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的) B.其次，需要理解子类覆盖父类方法的问题，也就是方法重写实现多态问题。Base b = new Sub();它为多态的一种表现形式，声明是Base,实现是Sub类， 理解为 b 编译时表现为Base类特性，运行时表现为Sub类特性。当子类覆盖了父类的方法后，意思是父类的方法已经被重写，题中 父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。由A.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。 15instanceof关键字12345678910* A: 作用 可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类* 格式: boolean b = 对象 instanceof 数据类型;* 举例: Person p1 = new Student(); // 前提条件，学生类已经继承了人类 boolean flag = p1 instanceof Student; //flag结果为true boolean flag2 = p1 instanceof Teacher; //flag2结果为false 16多态-向上转型* A: 多态的转型分为向上转型与向下转型两种： * B: 向上转型(自动类型转换)： * 当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。 123使用格式：父类类型 变量名 = new 子类类型();如：Person p = new Student(); 17多态-向下转型* A: 向下转型(强制类型转换)： 1234567891011* 一个已经向上转型的子类对象可以使用强制类型转换的格式，* "将【父类引用类型】强制转为【子类引用类型】，这个过程是向下转型。"* "好处：可以调用子类特有的方法"* "如果是直接创建父类对象，是无法向下转型的！" 使用格式： Person p = new Student();————————————————————————————————————————————————————————————————" 子类类型 变量名 = (子类类型) 父类类型的变量; " 如:Student stu = (Student) p; //变量p 实际上指向Student对象———————————————————————————————————————————————————————————————— 18多态的好处和弊端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* A: 多态的好处和弊端 * 当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。 向上转型的好处是隐藏了子类类型，提高了代码的扩展性。 * "但向上转型也有弊端，只能使用【父类共性】的内容，而【无法】使用【子类特有功能】，功能有限制"。 * B: 看如下代码 //描述动物类，并抽取共性eat方法 abstract class Animal &#123; abstract void eat(); &#125; // 描述狗类，继承动物类，重写eat方法，增加lookHome方法 class Dog extends Animal &#123; void eat() &#123; System.out.println("啃骨头"); &#125; void lookHome() &#123; System.out.println("看家"); &#125; &#125; // 描述猫类，继承动物类，重写eat方法，增加catchMouse方法 class Cat extends Animal &#123; void eat() &#123; System.out.println("吃鱼"); &#125; void catchMouse() &#123; System.out.println("抓老鼠"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); //多态形式，创建一个狗对象 a.eat(); // 调用对象中的方法，会执行狗类中的eat方法 // a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用 // 为了使用狗类的lookHome方法，需要向下转型 // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常 // 那么，在转之前需要做健壮性判断 if( !a instanceof Dog)&#123; // 判断当前对象是否是Dog类型 System.out.println("类型不匹配，不能转换"); return; &#125; Dog d = (Dog) a; //向下转型 d.lookHome();//调用狗类的lookHome方法 &#125; &#125; 123456789101112131415* C 多态总结:"什么时候使用向上转型： 当【不需要】面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。" 如： Animal a = new Dog(); a.eat();"什么时候使用向下转型 当要使用【子类特有功能】时，就需要使用【向下转型】。" 如：Dog d = (Dog) a; //向下转型 d.lookHome();//调用狗类的lookHome方法 "向下转型的好处：可以使用子类特有功能。" "弊端是：需要面对具体的【子类对象】；在向下转型时容易发生 ClassCastException 类型转换异常。 在转换之前必须做类型判断。"如：if( !a instanceof Dog)&#123;…&#125; 19多态举例12345678910111213141516171819202122232425262728293031323334353637383940* A: 刘老师和刘大爷的故事* 案例: /* 描述刘老师和刘大爷， 刘老师拥有讲课和看电影功能 刘大爷拥有讲课和钓鱼功能 */ class 刘大爷 &#123; void 讲课() &#123; System.out.println("语文"); &#125; void 钓鱼() &#123; System.out.println("钓鱼"); &#125; &#125; // 刘老师继承了刘大爷，就有拥有了刘大爷的讲课和钓鱼的功能， // 但刘老师和刘大爷的讲课内容不一样，因此刘老师要覆盖刘大爷的讲课功能 class 刘老师 extends 刘大爷 &#123; void 讲课() &#123; System.out.println("Java"); &#125; void 看电影() &#123; System.out.println("看电影"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; // 多态形式 刘大爷 a = new 刘老师(); // 向上转型 a.讲课(); // 这里表象是刘大爷，其实真正讲课的仍然是刘老师，因此调用的也是刘老师的讲课功能 a.钓鱼(); // 这里表象是刘大爷，但对象其实是刘老师，而刘老师继承了刘大爷，即刘老师也具有钓鱼功能 // 当要调用刘老师特有的看电影功能时，就必须进行类型转换 刘老师 b = (刘老师) a; // 向下转型 b.看电影(); &#125; 20笔记本电脑案例 * A:案例介绍 * 定义USB接口（具备开启功能、关闭功能），笔记本要使用USB设备，即笔记本在生产时需要预留可以插入USB设备的USB接口，即就是笔记本具备使用USB设备的功能， * 但具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用 * 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要符合USB接口 键盘类，要符合USB接口 * B: 案例分析 * 阶段一： 使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能 * 阶段二： 想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。 * 阶段三： 还想使用一个键盘 ，又要多一个功能和一个对象 * 问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。 降低鼠标、键盘等外围设备和笔记本电脑的耦合性。 21笔记本电脑案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172* A: 代码实现定义鼠标、键盘，笔记本三者之间应该遵守的规则interface USB &#123; void open();// 开启功能 void close();// 关闭功能&#125; 鼠标实现USB规则class Mouse implements USB &#123; public void open() &#123; System.out.println("鼠标开启"); &#125; public void close() &#123; System.out.println("鼠标关闭"); &#125;&#125; 键盘实现USB规则class KeyBoard implements USB &#123; public void open() &#123; System.out.println("键盘开启"); &#125; public void close() &#123; System.out.println("键盘关闭"); &#125;&#125; 定义笔记本class NoteBook &#123; // 笔记本开启运行功能 public void run() &#123; System.out.println("笔记本运行"); &#125; // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备 public void useUSB(USB usb) &#123; // 判断是否有USB设备 if (usb != null) &#123; usb.open(); usb.close(); &#125; &#125; public void shutDown() &#123; System.out.println("笔记本关闭"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 创建笔记本实体对象 NoteBook nb = new NoteBook(); // 笔记本开启 nb.run(); // 创建鼠标实体对象 Mouse m = new Mouse(); // 笔记本使用鼠标 nb.useUSB(m); // 创建键盘实体对象 KeyBoard kb = new KeyBoard(); // 笔记本使用键盘 nb.useUSB(kb); // 笔记本关闭 nb.shutDown(); &#125;&#125; 22小结接口：理解为是一个特殊的抽象类，但它不是类，是一个接口——————————————————————————————————————————————————————————接口的特点：1234561，定义一个接口用interface关键字 interface Inter&#123;&#125; 2，一个类实现一个接口，实现implements关键字 class Demo implements Inter&#123;&#125; 3, 接口不能直接创建对象 通过多态的方式，由子类来创建对象，接口多态 ——————————————————————————————————————————————————————————接口中的成员特点：12345678成员变量： 只能是final 修饰的常量 默认修饰符： public static final构造方法： 无成员方法： 只能是抽象方法 默认修饰符: public abstract ——————————————————————————————————————————————————————————类与类，类与接口，接口与接口之间的关系 类与类之间：继承关系，单继承，可以是多层继承 类与接口之间: 实现关系，单实现，也可以多实现 接口与接口之间：继承关系，单继承，也可以是多继承 Java中的类可以继承一个父类的同时，实现多个接口 ——————————————————————————————————————————————————————————多态：理解为同一种物质的多种形态多态使用的前提： 1，有继承或者实现关系 2，要方法重写 3，父类引用指向子类对象 —————————————————————————————————————————————————————————— 多态的成员访问特点： 方法的运行看右边，其他都看左边 多态的好处： 提高了程序的扩展性 —————————————————————————————————————————————————————————— 多态的弊端： 不能访问子类的特有功能 —————————————————————————————————————————————————————————— 多态的分类 ——————————————————————————————————————————————————————————类的多态1234567891011abstract class Fu &#123; public abstract void method();&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println(“重写父类抽象方法”);&#125;&#125;//类的多态使用Fu fu= new Zi(); ——————————————————————————————————————————————————————————接口的多态12345678910interface Fu &#123; public abstract void method();&#125;class Zi implements Fu &#123; public void method()&#123; System.out.println(“重写接口抽象方法”);&#125;&#125;//接口的多态使用Fu fu = new Zi(); ——————————————————————————————————————————————————————————instanceof 关键字 格式： 对象名 instanceof 类名 返回值： true, false 作用： 判断指定的对象 是否为 给定类创建的对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础8(继承，抽象类)]]></title>
    <url>%2F2016%2F10%2F11%2Fday10%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、继承2、抽象类3、综合案例—员工类系列定义 01继承的概述*A:继承的概念 *a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系 *b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类， 构建出来的新类被称作子类，现有类被称作父类 *B:继承关系的子类特点 *a:子类会自动拥有父类所有非private修饰的属性和方法 02继承的定义格式和使用123456789101112131415161718192021222324252627282930313233343536373839*A:继承的格式 class 子类 extends 父类 &#123;&#125;*B:雇员(Employee)与研发部员工(Developer)案例: *cn.itcast.demo01包下: *Employee.java: /* * 定义员工类Employee */ class Employee &#123; String name; // 定义name属性 public void work() &#123;// 定义员工的工作方法 System.out.println("尽心尽力地工作"); &#125; &#125; *Developer.java: /* * 定义研发部员工类Developer 继承 员工类Employee * 继承了父类中所有非private修饰的成员变量 */ class Developer extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println("name=" + name); &#125; &#125; *测试员工类与研发部员工类: /* * 定义测试类 */ public class Example01 &#123; public static void main(String[] args) &#123; Developer d = new Developer(); // 创建一个研发部员工类对象 d.name = "小明"; // 为该员工类的name属性进行赋值 d.printName(); // 调用该员工的printName()方法 d.work(); // 调用Developer类继承来的work()方法 &#125; &#125; *通过子类对象既可以调用自身的非private修饰的成员,也可以调用父类的非private修饰的成员 03继承的好处*A:继承的好处： *1、继承的出现提高了代码的复用性，提高软件开发效率。 *2、继承的出现让类与类之间产生了关系，提供了多态的前提。 04继承的注意事项1234567891011121314151617181920212223242526272829303132333435363738394041424344 *A:继承的注意事项 *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。 class A&#123;&#125; class B&#123;&#125; class C extends A,B&#123;&#125; // C类不可以同时继承A类和B类 假如支持多继承例如: class A&#123; int a=3; public void method()&#123; &#125; &#125; class B&#123; int a=5; public void method()&#123; &#125; &#125; class C extends A,B&#123; &#125; class Demo&#123; public static void main(String[] args)&#123; C c=new C(); System.out.println(c.a);//到底是调用A的还是B的成员变量??无法确定 c.method();//到底是调用A的还是B的成员方法??无法确定 &#125; &#125; *b:多个类可以继承一个父类，例如下面这种情况是允许的(就像你爹可以多个儿子,但是这些儿子都只有一个爹) class A&#123;&#125; class B extends A&#123;&#125; class C extends A&#123;&#125; // 类B和类C都可以继承类A *c:在Java中，多层继承是可以的， 即一个类的父类可以再去继承另外的父类， 例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。 class A&#123;&#125; class B extends A&#123;&#125; // 类B继承类A，类B是类A的子类 class C extends B&#123;&#125; // 类C继承类B，类C是类B的子类，同时也是类A的子类 *d:在Java中，子类和父类是一种相对概念， 也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。 05继承的体系 *A:继承的体系: 动物(吃) | ------------------------- | | 猫科动物(吃,胎生) 爬行动物(吃,卵生) | | ------------------------------- ----------------- | | | | 猫(吃,抓老鼠,胎生) 虎(吃,领地,胎生) 蛇(吃,冬眠,卵生) 鳄鱼(吃,潜水,卵生) *a:动物体系是对每个具体事物共性的抽取,子类的共性抽取形成父类 *b:父类:具有所有子类的共性内容 子类:不但有共性还有自身特有的内容 *c:整个继承体系,越向上越抽象,越向下越具体 06继承后子类父类成员变量的特点123456789101112131415161718192021222324252627A:继承后子类父类成员变量的特点 a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu&#123; //Fu中的成员变量。 int num = 5; &#125; class Zi extends Fu&#123; //Zi中的成员变量 int num2 = 6; //Zi中的成员方法 public void show() &#123; //访问父类中的num System.out.println("Fu num="+num); //访问子类中的num2 System.out.println("Zi num2="+num2); &#125; &#125; class Demo&#123; public static void main(String[] args) &#123; Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 &#125; &#125; 12345678910111213141516171819202122232425262728293031323334 b:当子父类中出现了同名成员变量 class Fu&#123; //Fu中的成员变量。 int num = 5;&#125;class Zi extends Fu&#123; //Zi中的成员变量 int num = 6; void show()&#123; //子类的局部变量 int num=7 //直接访问,遵循就近查找原则 System.out.println(num);//7 //子父类中出现了同名的成员变量时 //在子类中需要访问父类中非私有成员变量时，需要使用super关键字 //访问父类中的num System.out.println("Fu num="+super.num);//5 //访问子类中的num2 System.out.println("Zi num2="+this.num);//6 &#125;&#125;class Demo5 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 &#125;&#125; 07继承后子类父类成员方法的特性_子类重写父类方法12345678910111213141516171819A:继承后子类父类成员方法的特性 a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu&#123; public void show()&#123; System.out.println("Fu类中的show方法执行"); &#125; &#125; class Zi extends Fu&#123; public void show2()&#123; System.out.println("Zi类中的show2方法执行"); &#125; &#125; public class Test&#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); //子类中没有show方法，但是可以找到父类方法去执行 z.show2(); &#125; &#125; 12345678910111213b:为什么要有重写? class Fu&#123; public void method()&#123; //上千行代码 //Fu类中的方法最先存在,那么如果项目需求变了,该方法 //功能不能够满足我们的需求,此时我们也不会去改这个方法 //因为项目中可能有大量的功能已经使用到该方法,如果随意修改可能使调用该方法的功能出现问题 //所以使用重写方式基于原有功能提供更强的功能 &#125; &#125; class Zi extends Fu&#123; &#125; 12345678910111213141516171819 c:子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖 class Fu&#123; public void show()&#123; System.out.println("Fu show"); &#125; &#125; class Zi extends Fu&#123; //子类复写了父类的show方法 public void show()&#123; System.out.println("Zi show"); &#125;&#125; public class Test&#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); //Zi show 子类有直接使用子类 &#125;&#125; 08方法覆盖的需求A:方法覆盖的需求 a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能， 后期由于手机需要在来电显示功能中增加显示姓名和头像， 这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。 并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能 b:分析:我们不改装(破坏)原来的手机,而是再买一个新的智能手机,不但有原有的功能,而且还有特有功能 例:厂商发布新手机都是基于原有手机的升级,不会拿着原有的手机在卖,新产一款 1:分析类的构建: 手机类 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码 智能手机类: 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码,显示姓名和头像 手机类和智能手机类有共性内容: 发短信 打电话 显示来电号码 2:继承关系分析: 对于发短信和打电话功能,让智能手机直接沿用(继承)手机的就可以 但是在智能手机中的来电显示不但实现号码,还显示姓名和头像,同样的都是来电显示功能,智能手机的来电显示比手机的功能更加强大,我们考虑使用重写 09方法覆盖的手机案例实现12345678910111213141516171819202122232425262728293031323334353637//手机类class Phone&#123; public void sendMessage()&#123; System.out.println("发短信"); &#125; public void call()&#123; System.out.println("打电话"); &#125; public void showNum()&#123; System.out.println("来电显示号码"); &#125;&#125;//智能手机类class NewPhone extends Phone&#123; //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能 //从现实生活角度考虑沿用原有的showNum方法名便于用户更快熟悉和接受,而不是再起个新的名字 //用户还需要花费大量时间慢慢接受 public void showNum()&#123; //调用父类已经存在的功能使用super //如果不加super这是调用子类自身的showNum(),自己调用自己,递归 //方法不断入栈导致内存溢出 super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new NewPhone().showNum();//来电显示 显示来电姓名 显示头像 &#125;&#125; 10方法覆盖的注意事项1234567891011121314151617181920A:方法覆盖的注意事项 a:"权限:【子类方法】覆盖【父类方法】，【必须要保证】子类权限【大于等于】父类权限"。 四大权限:public&gt;默认=protected&gt;private class Fu&#123; void show()&#123;&#125;public void method()&#123;&#125; &#125; class Zi() extends Fu&#123;public void show()&#123;//编译运行没问题&#125; void method()&#123;//编译错误 &#125; &#125; 1234567891011121314151617181920212223242526272829303132 b:方法定义:子类方法和要重写的父类的方法:"方法的方法名和参数列表都要一样。" 关于方法的返回值:"如果是【基本数据类型】,子类的方法和重写的父类的方法【返回值类型】【必须相同】"" 如果是【引用数据类型】,子类的方法和重写的父类的方法【返回值类型】【可以相同】 或者【子类方法的返回值类型】是父类方法返回值类型的【子类】""【父类方法返回值类型】&gt;= 【子类方法的返回值类型】" class Fu&#123; int show()&#123; &#125; public Fu method()&#123; &#125; public Fu method2()&#123; &#125; &#125; class Zi() extends Fu&#123; public int show()&#123;//返回值为基本类型的重写 &#125; public Fu method()&#123;//子类的方法和重写的父类的方法返回值类型可以相同 &#125; public Zi method2()&#123;//子类方法的返回值类型是父类方法返回值类型的子类 &#125; &#125; 123456789101112131415161718192021222324252627 c:重载与重写对比: 重载: 权限修饰符(public private 默认):无关 方法名:重载的两个方法的方法名必须相同 形参列表: "形参类型的顺序不同 形参的个数不同 形参的类型不同 三者至少满足一个" 返回值类型: "重载与返回值类型无关"重写: 权限修饰符(public private 默认): "子类方法的权限&gt;=父类的方法的权限" 方法名: "子类方法和父类方法必须相同" 形参列表: "子类方法和父类方法的形参列表必须相同" 返回值类型: "基本类数据类型: 必须相同" "引用数据类型: 子类方法的返回值类型和父类方法的返回值类型相同 或者 子类方法的返回值类型是父类方法的返回值类型的 子类" "【父类方法返回值类型】⊇【子类方法的返回值类型】" 11抽象类的产生A:抽象类的产生 a:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。 12抽象类的定义格式A:抽象方法定义的格式： 123456789101112131415161718192021222324 a:public abstract 返回值类型 方法名(参数); 抽象类定义的格式：abstract class 类名 &#123; &#125; b:抽象类示例代码： /* * 定义类开发工程师类 * EE开发工程师 : 工作 * Android开发工程师 : 工作 * * 根据共性进行抽取,然后形成一个父类Develop * 定义方法,工作: 怎么工作,具体干什么呀 * * 抽象类,不能实例化对象, 不能new的 * 不能创建对象的原因: 如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行 * 抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象 */public abstract class Develop &#123; //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白 //就不说, 方法没有主体的方法,必须使用关键字abstract修饰 //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰 public abstract void work();&#125; 13抽象类的使用方式123456789101112131415161718192021222324252627282930313233343536 A:抽象类的使用方式 /* * 定义类,JavaEE的开发人员 * 继承抽象类Develop,重写抽象的方法 */public class JavaEE extends Develop&#123; //重写父类的抽象方法 //去掉abstract修饰符,加上方法主体 public void work()&#123; System.out.println("JavaEE工程师在开发B/S 软件"); &#125;&#125;/* * 定义Android类,继承开发人员类 * 重写抽象方法 */public class Android extends Develop&#123; public void work()&#123; System.out.println("Android工程师开发手机软件"); &#125;&#125;/* * 测试抽象类 * 创建他的子类的对象,使用子类的对象调用方法 */public class Test &#123; public static void main(String[] args) &#123; JavaEE ee = new JavaEE(); ee.work();//"JavaEE工程师在开发B/S 软件" Android and = new Android(); and.work();//"Android工程师开发手机软件" &#125;&#125; 14抽象类特点 A:抽象类的特点a:抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。b:抽象类不可以直接创建对象，原因：调用抽象方法没有意义。c:【只有覆盖了抽象类中所有的抽象方法后】，其子类才可以创建对象。【否则该子类还是一个抽象类】。之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。12345678910111213141516abstract class A&#123; public abstract void func(); public abstract void func2();&#125;class A2 extends A&#123;//A2把A中的两个抽象方法都重写掉了 //A2类不再是抽象类 public void func()&#123;&#125; public void func2()&#123;&#125;&#125;abstract class A3 extends A&#123;//含有抽象方法的类一定是抽象类 public void func()&#123; &#125; //public abstract void func2();//func2相当于被继承下来&#125; 15抽象类的设计思想A:抽象类的设计思想 a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法 抽象员工: 规定一个方法,work工作 EE员工,Android员工 Develop类 抽象类 abstract work(); | ------------- | | EE Android //是我开发的一员必须工作 work(){} work(){} 16抽象类的细节 A:抽象类的细节 a:抽象类一定是个父类？ 是的，因为不断抽取而来的。 b:抽象类中是否可以不定义抽象方法?1234567891011121314151617181920212223 是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用 (适配器设计模式) /* * "抽象类,可以没有抽象方法,可以定义带有方法体的方法" * 让子类继承后,可以直接使用 */public abstract class Animal &#123; public void sleep()&#123; System.out.println("动物睡觉"); &#125; &#125;public class Cat extends Animal&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; //Cat c = new Cat(); new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用 &#125; &#125; c:抽象关键字abstract不可以和哪些关键字共存？ 1234567891011121314151617181:private：私有的方法子类是无法继承到的，也不存在覆盖， 而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法, 而private修饰子类根本无法得到父类这个方法。互相矛盾。 /* * 抽象类,可以没有抽象方法,可以定义带有方法体的方法 * 让子类继承后,可以直接使用 */public abstract class Animal &#123; // private abstract void show(); //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写&#125;2:final，，后面学3:static，后面学 17员工案例分析A:员工案例分析: a:需求描述: 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。 研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师； 维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。  工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 b:继承体系: 员工 | -------------------------------------------- | | 研发部员工 维护部员工 | | ------------- ----------- | | | | JavaEE工程师 Android工程师 网络维护工程师 硬件维护工程师 c:详细描述:  根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。 则，把这些共同的属性与功能抽取到父类中（员工类）， 关于工作的内容由具体的工程师来进行指定。  工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机  创建JavaEE工程师对象，完成工作方法的调用 18员工案例Employee类的编写12345678910111213141516171819202122232425262728 A:员工案例Employee类的编写:按照分析的继承体系来逐个实现 /* * 定义员工类 * 内容,都是所有子类的共性抽取 * 属性: 姓名,工号 * 方法: 工作 */ public abstract class Employee &#123; private String id;// 员工编号 private String name; // 员工姓名 public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //工作方法（抽象方法） public abstract void work(); &#125; 19员工案例的子类的编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 B:员工案例的子类的编写: /* * 定义研发员工类 * 属于员工中的一种, 继承员工类 * 抽象类Develop 给自己的员工定义自己有的属性 */public abstract class Develop extends Employee&#123;&#125;/* * 描述JavaEE开发工程师类 * 工号,姓名 工作方法 * 其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了 * 是研发部员工的一种,继承研发部类 */public class JavaEE extends Develop&#123; //重写他父类的父类的抽象方法 public void work()&#123; //调用父类的get方法,获取name,id值 System.out.println("JavaEE的工程师开发淘宝"+ super.getName()+".."+super.getId()); &#125;&#125; /* *定义Android工程师 继承 研发部员工类，重写工作方法 */ public class Android extends Developer &#123; @Override public void work() &#123; System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件"); &#125; &#125; /* * 定义维护员工类,属于员工中的一种 * 继承员工类 * 抽象类Maintainer 给自己的员工定义自己有的属性 */public abstract class Maintainer extends Employee&#123;&#125; /* * 描述的是网络维护工程师 * 属于维护部的员工,继承维护部类 */public class Network extends Maintainer&#123; public void work()&#123; System.out.println("网络工程师在检查网络是否畅通"+super.getName()+"..."+super.getId()); &#125;&#125; /* *定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 */public class Hardware extends Maintainer &#123; @Override public void work() &#123; System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机"); &#125;&#125; 20小结（1） 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有继承的好处：可继承的属性和方法。 提高了代表的可维护性 提高了代码的复用性 让类与类之间产生了继承关系 继承的弊端： 类与类之间的耦合度过高 继承特点： java中类只能够单继承，不能多继承，可以多层继承 class Yy extends Object {} class Fu extends Yy{} class Zi extends Fu {} 所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类 继承的注意事项： 1，使用关键字 extends 让类与类之间 产生继承关系 2, 父类私有的成员，子类不能继承，因为根本看不到 3，不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系 苹果 is a 水果 男人 is a 人 狗 is a 人 ， 这种情况就不能继承了 继承中的成员变量关系： 不同名的变量： 子类直接继承使用 同名的变量： 默认访问的是子类自己的成员变量(this.成员变量), 想访问父类中的同名变量，请使用 (super.成员变量); 继承中的成员方法关系：1234567891011不同名的方法：子类直接继承使用同名的方法：默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();super:用来表示当前对象中包含的父类对象空间的引用调用父类的成员变量：super.成员变量;调用方法的成员方法:super.成员方法(); (2)方法重写(override)：指 在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写方法重写的注意事项：1231，子类的方法声明要与父类相同2, 子类要重写方法的方法，方法的权限修饰符不能比父类的更低3, 父类私有的方法，子类不能够进行方法重写 (3)方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同) (4)抽象123抽象方法： 方法只有声明部分，没有方法体,即 public abstract void method();抽象类： 包含抽象方法的类，一定是抽象类 使用 abstract 修饰的类，是抽象类 抽象类的特点：1234561，抽象类与抽象方法都必须使用 abstract来修饰 2，抽象类不能直接创建对象 3，抽象类中可以有抽象方法，也可以没有抽象方法 4，抽象类的子类 a，实现了抽象方法的具体类 b，抽象类 抽象类面试题： 1，抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？ 可以没有抽象方法，有意义，不会让其他人直接创建该类对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础7(类与对象，成员变量，封装)]]></title>
    <url>%2F2016%2F10%2F10%2Fday09%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、面向对象思想2、类与对象的关系3、局部变量和成员变量的关系4、封装思想5、private,this关键字6、随机点名器 面向对象思想面向对象和面向过程的思想* A: 面向过程与面向对象都是我们编程中，编写程序的一种思维方式 * a: 面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。 * b: 面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。 面向对象的思想的生活案例* A: 买电脑（组装机） * a: 面向过程：自己该怎么做 * b: 面向对象：找人帮我们做 面向对象好处* A: 面向对象好处 * a: 面向对象思维方式是一种更符合人们思考习惯的思想 * b: 面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。 * c: 面向对象思维方式将复杂的问题简单化。 大象装进冰箱的代码案例* A: 需求：把大象装冰箱里 * a: 面向过程 * 自己打开冰箱门 * 自己将大象装进去 * 自己关闭冰箱门 * b: 面向对象 * 分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具 备如下功能 * 冰箱打开 * 冰箱存储 * 冰箱关闭 * B: 通过伪代码描述大象和冰箱 * 描述大象： class 大象 { } * 描述冰箱 class冰箱 { void 打开(){} void 存储(大象){} void 关闭(){} } * C: 使用对象： * 1、创建冰箱的对象 * 冰箱 bx = new 冰箱(); * 2、调用冰箱的功能 * 对象.功能()； * bx.打开(); * bx.存储(new 大象()); * bx.关闭(); * D：总结： * 1、先按照名词提炼问题领域中的对象 * 2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能 * 3、通过new的方式就可以创建该事物的具体对象 * 4、通过该对象调用它以后的功能。 类与对象的关系定义小汽车类* A: 分析小汽车的属性和功能 * 属性 * 颜色 * 轮胎个数 * 功能 * 运行 * B: 通过伪代码描述小汽车 * 小汽车{ * 颜色 * 轮胎个数 * 运行(){} * } * C：通过JAVA代码描述小汽车 12345678* public class Car &#123; * String color; * int number; * void run() &#123; * System.out.println(color + ":" + number); * &#125;* &#125; 测试汽车类* A: 创见对象的格式 * a: 类名 变量名 = new 类名(); * B: 测试汽车类 1234567891011121314public class CarDemo &#123; public static void main(String[] args) &#123; /* 测试：Car类中的run方法。 */ // 1,创建Car的对象。给对象起个名字。 Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。 // 2,通过已有的对象调用该对象的功能。格式：对象.对象成员; // 3,可以该对象的属性赋值。 c.color = "red"; c.number = 4; c.run(); &#125;&#125; 对象的内存图 类和对象的关系* A: 类和对象的关系 * 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体 * B: 举例 * 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系 局部变量和成员变量的关系成员变量和局部变量的区别123456789101112* 区别一：定义的位置不同 * 定义在【类】中的变量是【成员变量】 * 定义在【方法】中或者&#123;&#125;语句里面的变量是【局部变量】* 区别二：在内存中的位置不同 * 【成员变量】存储在【堆内存】的对象中 * 【局部变量】存储在【栈内存】的方法中（局部变量跟随方法进栈）* 区别三：声明周期不同 * 成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失 * 局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失* 区别四：初始化不同 * 【成员变量】因为在堆内存中，【所有默认的初始化值】 * 【局部变量】【没有默认】的初始化值，必须手动的给其赋值才可以使用。 封装思想01方法参数是基本数据类型和引用数据类型* A.基本类型 123456789101112131415class Demo&#123; public static void main(String[] args) &#123; int x = 4; show(x); System.out.println("x="+x); &#125; public static void show(int x) &#123; x = 5; &#125;&#125; 基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。 * B.引用类型 12345678910111213141516171819202122class Demo &#123; int x ; public static void main(String[] args) &#123; Demo d = new Demo(); d.x = 5; show(d); System.out.println("x="+d.x); &#125; public static void show(Demo d) &#123; d.x = 6; &#125;&#125; 当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。* C.结论* 对于基本类型形式参数改变不会影响到实际参数* 对于引用类型形式参数改变会影响到实际参数 02封装的概述* A.面向对象三大特征 * 封装、继承、多态 * B.封装表现 * 1、方法就是一个最基本封装体 * 2、类其实也是一个封装体 * C.封装的好处 * 1、提高了代码的复用性 * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念 * 3、提高了安全性 03封装的生活中的举例* A.封装的生活中的举例 机箱： 一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。 总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。 * B.总结 * 机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式 private,this关键字private关键字1234567891011121314* A.private概述 * private可以修饰成员内容包括成员方法和成员变量 * 被private修饰的内容不能在其他类访问* B.使用步骤 * 1、通过private修饰属性* C.完整代码 class Person &#123; private int age; private String name; public void show() &#123; System.out.println("age=" + age + ",name" + name); &#125; &#125; get和set方法* A.get和set方法 * 年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。 一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。12345678910111213141516171819202122232425class Person &#123; // 私有成员变量 private int age; private String name; // 对外提供设置成员变量的方法 public void setAge(int a) &#123; // 由于是设置成员变量的值，这里可以加入数据的验证 if (a &lt; 0 || a &gt; 130) &#123; System.out.println(a + "不符合年龄的数据范围"); return; &#125; age = a; &#125; // 对外提供访问成员变量的方法 public void getAge() &#123; return age; &#125;&#125;* 总结 * 类中不需要对外提供的内容都私有化，包括属性和方法。以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问* 注意 * 私有仅仅是封装的体现形式而已 私有化Person类带get,set* 标准代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.demo05;/* * 类描述人: * 属性: 姓名和年龄 * 方法: 说话 * * 私有化所有的属性 (成员变量) ,必须写对应的get/set方法 * 凡是自定义的类,自定义成员变量,应该私有化,提供get/set * * this关键字: * 区分成员变量和局部变量同名情况 * 方法中,方位成员变量,写this. */public class Person &#123; private String name; private int age; // set方法,变量name,age赋值 public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; // get方法,变量name,age获取值 public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void speak() &#123; String name = "哈哈"; int age = 16; System.out.println("人在说话 " + this.name + "..." + this.age); &#125;&#125; * 标准测试代码 12345678910111213141516package cn.itcast.demo05;public class PersonTest &#123; public static void main(String[] args) &#123; Person p = new Person(); //调用set方法,对成员变量赋值 p.setAge(18); p.setName("旺财"); p.speak(); //调用get方法,获取成员变量的值// System.out.println(p.getName());// System.out.println(p.getAge()); &#125;&#125; this关键字_区分成员变量和局部变量的同名* A.什么时候用 * 当类中存在成员变量和局部变量同名的时候为了区分，就需要使用this关键字 * B.代码 class Person { private int age; private String name; public void speak() { this.name = &quot;小强&quot;; this.age = 18; System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age); } } class PersonDemo { public static void main(String[] args) { Person p = new Person(); p.speak(); } } this内存图* A.this内存图 this的年龄比较* A.需求：在Person类中定义功能，判断两个人是否是同龄人 * B.代码 12345678910111213141516171819202122232425262728293031323334class Person &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125; // 判断是否为同龄人 public boolean equalsAge(Person p) &#123; // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较 // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替 /* * if(this.age == p.age) &#123; return true; &#125; return false; */ return this.age == p.age; &#125;&#125; 随机点名器随机点名器案例重构* A.需求：随机点名器，即在全班同学中随机的找出一名同学，打印这名同学的个人信息 它具备以下3个内容： 存储所有同学姓名 总览全班同学姓名 随机点名其中一人，打印到控制台 * B.代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Random;import java.util.Scanner;/** * 思路： * 第一步：存储全班同学信息 * 第二步：打印全班同学每一个人的信息 * 第三部：随机对学生点名，打印学生信息 */public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //1.1创建一个可以存储多个同学名字的容器 //1.存储全班同学信息 addStudent(list); //2.打印全班同学每一个人的信息（姓名、年龄） printStudent(list); //3.随机对学生点名，打印学生信息 randomStudent(list); &#125; public static void addStudent(ArrayList&lt;Student&gt; list) &#123; //键盘输入多个同学名字存储到容器中 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; 3; i++) &#123; //创建学生 Student s = new Student(); System.out.println("存储第"+i+"个学生姓名："); String name = sc.next(); s.setName(name); System.out.println("存储第"+i+"个学生年龄："); int age = sc.nextInt(); s.setAge(age); //添加学生到集合 list.add(s); &#125; &#125; /** 2.打印全班同学每一个人的信息（姓名、年龄） */ public static void printStudent (ArrayList&lt;Student&gt; list) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; Student s = list.get(i); System.out.println("姓名："+s.getName() +",年龄："+s.getAge()); &#125; &#125; /** 3.随机对学生点名，打印学生信息 */ public static void randomStudent (ArrayList&lt;Student&gt; list) &#123; //在班级总人数范围内，随机产生一个随机数 int index = new Random().nextInt(list.size()); //在容器（ArrayList集合）中，查找该随机数所对应的同学信息（姓名、年龄） Student s = list.get(index); System.out.println("被随机点名的同学："+s.getName() + "，年龄:" + s.getAge()); &#125;&#125; 1234567891011121314151617181920212223/** * 学生信息类 */public class Student &#123; private String name; // 姓名 private int age; // 年龄 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 总结123456789101112131415161718192021222324252627282930313233343536* A.类与对象 * 类，用于描述多个对象的共同特征，它是对象的模板。 * 对象，用于描述现实中的个体，它是类的实例。 * 类的定义：使用关键字class来定义java中的类 * 格式： * class 类名 &#123; * //属性 * 数据类型 变量名; * … * //方法 * 修饰符 返回值类型 方法名(参数)&#123; &#125; * … * &#125; * * B.创建对象： * 格式： * 类名 对象名 = new 类名();* C.封装（private关键字） * 封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式 * 封装的体现： * 变量:使用 private 修饰，这就是变量的封装 * 方法:也是一种封装，封装了多条代码 * 类： 也是一种封装，封装了多个方法* D.private关键字，私有的意思 * 它可以用来修饰类中的成员(成员变量，成员方法) * private的特点： * private修饰的成员只能在当前类中访问，其他类中无法直接访问* E.this关键字 * this关键字，本类对象的引用 * this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用 * this什么时候存在的？当创建对象的时候，this存在的 * this的作用：用来区别同名的成员变量与局部变量（this.成员变量） * public void setName(String name) &#123; * this.name = name; * &#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础6(自定义类，ArrayList)]]></title>
    <url>%2F2016%2F10%2F09%2Fday06%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、自定义类型的定义及使用2、自定义类的内存图3、ArrayList集合的基本功能4、随机点名器案例及库存案例代码优化 01引用数据类型_类* A: 数据类型 * a: java中的数据类型分为：基本类型和引用类型 * B: 引用类型的分类 * a: Java为我们提供好的类，比如说：Scanner,Random等。 * b: 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 02自定义类的概述* A: 自定义类的概述 * java代码映射成现实事物的过程就是定义类的过程。 * 举例： 我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性 * 目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。 03自定义类的格式* A: 自定义类的格式 * a: 使用类的形式,对现实中的事物进行描述。 * b: 事物由方法和属性两部分组成。 * 方法: 这个事物具备的功能。 * 属性: 这个事物具备的特征。 * c: 格式 123456789public class 类名&#123; 属性定义 修饰符 数据类型 变量名 = 值 方法定义 修饰符 返回值类型 方法名(参数列表)&#123; &#125;&#125; 04自定义的手机类* A: 自定义的手机类 123456789* a: 案例代码 public class Phone&#123; /* 定义手机的属性 */ String color ; String brand ; double size ; &#125; 05测试手机类导包：我们将所有的类放到同一个文件夹下，可以避免导包。 创建对象：数据类型 变量名 = new 数据类型(); 调用方法：目前我们定义的自定义类不涉及方法，只是属性（自定义类中的方法部分在面向对象部分讲解）访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。)1234567891011121314151617181920212223* A: 调用方法执行流程* a: 实现引用类型的步骤 * 1: 导入包 , 类都是在同一个文件夹,不需要导入包 * 2: 创建引用类型的变量 * 3: 变量.类型中的功能* b: 案例代码 public class TestPhone&#123; public static void main(String[] args)&#123; // 2: 创建引用类型的变量 Phone p = new Phone(); //System.out.println(p); //输出内存的地址 //3: 变量.类型中的功能 //变量 p.的方式,调用类中的属性 //属性就是变量 , 赋值和获取值 p.color = "土豪金"; p.brand = "爱立信"; p.size = 5.0; //获取属性值 System.out.println(p.color+" "+p.brand+" "+p.size); &#125; &#125; 06自定义类的内存图_1* A: 自定义类的内存图_1 07自定义类的内存图_2* A: 自定义类的内存图_1 08两个引用类型变量内存图* A: 自定义类的内存图_1 09自定义类的练习* A: 实体类的代码 1234567891011121314151617181920212223242526272829303132333435363738/* 电饭锅，包含属性（品牌、容量大小、颜色等） 定义类,描述事物,电饭锅 属性: 品牌,大小 ,颜色 定义类,类名字,电饭锅 类的范围,定义三个属性*/public class DianFanGuo&#123; //定义三个属性 String brand ; double size ; String color ;&#125;/* 汽车，包含属性（品牌、排量、类型等） 定义类,类名 Car 属性 品牌 排量 类型 */public class Car&#123; //定义汽车三个属性 String brand ; double paiLiang ; String type;&#125; /* 学生，包含属性（姓名，年龄，性别等） 定义类,类名Student 三个属性: 姓名,年龄,性别 (char)*/public class Student&#123; String name; int age ; char sex ;&#125; * B: 测试类的代码 1234567891011121314151617181920212223242526272829303132/* 定义的测试类 同时测试,电饭锅,汽车,学生*/public class Test&#123; public static void main(String[] args)&#123; //创建电饭锅引用类型 DianFanGuo dfg = new DianFanGuo(); dfg.brand = "特斯拉"; dfg.color = "红色"; dfg.size = 30; System.out.println(dfg.brand+" "+dfg.color+" "+dfg.size); //创建汽车引用类型 Car c = new Car(); c.brand = "巨力"; c.type = "拖拉机"; c.paiLiang = 0.5; System.out.println(c.brand+" "+c.type+" "+c.paiLiang); //创建学生引用类型 Student stu = new Student(); stu.name = "张三"; stu.age = 20; stu.sex = '男'; System.out.println(stu.name+" "+stu.age+" "+stu.sex); &#125;&#125; 10ArrayList创建变量的步骤为了保存这些数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。在这里，我们先介绍ArrayList集合.导包：import java.util.ArrayList; 创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型： 1ArrayList&lt;要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;要存储元素的数据类型&gt;(); * A: ArrayList创建变量的步骤 * a: 导入包 java.util包中 * b: 创建引用类型的变量 数据类型&lt; 集合存储的数据类型&gt; 变量名 = new 数据类型&lt;集合存储的数据类型&gt;(); 集合存储的数据类型: 要将数据存储到集合的容器中 创建集合引用变量的时候,必须要指定好,存储的类型是什么 * c: 变量名.方法 注意: 集合存储的数据,8个基本类型对应8个引用类型 存储引用类型,不存储基本类型 “&lt;要存储元素的数据类型&gt;”中的数据类型必须是【引用数据类型】，不能是基本数据类型；下面给出8种基本数据类型所对应的引用数据类型表示形式: 基本数据类型 对应的引用数据类型表示形式 12345678byte Byteshort ShortInt Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 11ArrayList创建变量举例* A: ArrayList创建变量的示例代码 1234567891011121314import java.util.ArrayList;public class ArrayListDemo&#123; public static void main(String[] args)&#123; //创建集合容器,指定存储的数据类型 //存储字符串 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //创建集合容器,存储整数 ArrayList&lt;Integer&gt; array2 = new ArrayList&lt;Integer&gt;(); //创建集合容器,存储手机类型 ArrayList&lt;Phone&gt; array3 = new ArrayList&lt;Phone&gt;(); &#125;&#125; 12ArrayList的常见方法* A: ArrayList的常见方法 123* a: add(参数) 向集合中添加元素* b: get(int index) 取出集合中的元素,get方法的参数,写入索引* c: size() 返回集合的长度, 集合存储元素的个数 * B: 案例代码 1234567891011121314151617181920212223242526import java.util.ArrayList;public class ArrayListDemo_1&#123; public static void main(String[] args)&#123; //定义集合,存储字符串元素 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //调用集合方法add存储元素 array.add("abc"); array.add("itcast"); array.add("love"); array.add("java"); //输出集合的长度,调用集合方法size, size方法的返回值类型 int int size = array.size(); System.out.println(size); //获取出集合中的一个元素,获取1索引的元素 //集合的方法get, 获取元素后结果数据类型 String s = array.get(1); System.out.println(s); System.out.println(array.get(0)); System.out.println(array.get(1)); System.out.println(array.get(2)); System.out.println(array.get(3)); &#125;&#125; 13ArrayList集合的遍历* A: 案例代码 1234567891011121314151617181920212223/* 集合的遍历 实现思想也是索引思想 集合的索引从0开始,到 size()-1 方法get(int index)*/import java.util.ArrayList;public class ArrayListDemo_2&#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(121); array.add(125); array.add(123); array.add(120); array.add(128); //对集合进行遍历 //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++)&#123; System.out.println( array.get(i) ); &#125; &#125;&#125; 14ArrayList补充方法* A: ArrayList补充方法 1234* a: add(int 索引,存储的元素) 将元素添加到指定的索引上* b: set(int 索引,修改后的元素) 将指定索引的元素,进行修改* c: remove(int 索引) 删除指定索引上的元素* d: clear() 清空集合中的所有元素 * B: 案例代码 import java.util.ArrayList; public class ArrayListDemo_3{ public static void main(String[] args){ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(1); array.add(2); array.add(3); array.add(4); //在索引2上,添加元素7 array.add(2,7); //将0索引上的元素,修改成10 array.set(0,10); //将4索引上的元素,删除 array.remove(4); array.clear(); //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++){ System.out.println( array.get(i) ); } } } 15随机点名器案例分析* A: 随机点名器案例分析 全班同学中随机的找出一名同学，打印这名同学的个人信息。 我们对本案例进行分析，得出如下分析结果： 1.存储全班同学信息（姓名、年龄） 将容器换成集合，集合中存的是Student类型 2.打印全班同学每一个人的信息（姓名、年龄） 遍历集合 3.在班级总人数范围内，随机产生一个随机数，查找该随机数所对应的同学信息（姓名、年龄） 随机点名器明确地分为了三个功能。如果将多个独立功能的代码写到一起，则代码相对冗长，我们可以针对不同的功能可以将其封装到一个方法中，将完整独立的功能分离出来。 而在存储同学姓名时，如果对每一个同学都定义一个变量进行姓名存储，则会出现过多孤立的变量，很难一次性将全部数据持有。此时，我们采用ArrayList集合来解决多个学生信息的存储问题 16随机点名器代码实现* A: 随机点名器案例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 随机点名器,集合改进 (学生的姓名和年龄) 现实中有学生这个事物,使用定义类的形式,描述学生事物 属性: 姓名,年龄 姓名存储了数组, 将容器换成是集合 String[] s = &#123;"",""&#125;; 集合中,存储的是学生的姓名吗? 应该存储Student类型 存储学生: 学生类型,存储到集合中 总览: 遍历集合 随机: 随机数,作为索引,到集合中找到元素 三个功能,共享的数据,集合容器, 定义三个方法,必须参数传递集合*/import java.util.ArrayList;import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //定义集合,存储的是StudentName类型变量 ArrayList &lt;StudentName&gt; array = new ArrayList&lt;StudentName&gt;(); //调用添加方法 add (array); //调用遍历集合 printArrayList(array); randomStudentName(array); &#125; /* 随机数,当作集合的索引,到集合中找到元素 */ public static void randomStudentName(ArrayList&lt;StudentName&gt; array )&#123; Random r = new Random(); int number = r.nextInt( array.size()); //随机数,索引,到集合中get StudentName s = array.get(number); System.out.println( s.name +" "+s.age); &#125; /* 总览学生的信息,遍历集合 */ public static void printArrayList(ArrayList&lt;StudentName&gt; array)&#123; for(int i = 0 ; i &lt; array.size();i++)&#123; //存储集合的时候, 集合.add(sn1) sn1 是StudentName类型变量 //获取的时候,集合.get方法,获取出来的是什么, 还是StudentName类型变量 StudentName s = array.get(i); System.out.println(s.name+" "+s.age); &#125; &#125; /* 定义方法,实现存储学生的姓名和年龄 创建StudentName类型变量,存储到集合中 */ public static void add (ArrayList&lt;StudentName&gt; array)&#123; //创建StudentName类型变量 StudentName sn1 = new StudentName(); StudentName sn2 = new StudentName(); StudentName sn3 = new StudentName(); StudentName sn4 = new StudentName(); StudentName sn5 = new StudentName(); sn1.name = "张三1"; sn1.age = 201; sn2.name = "张三2"; sn2.age = 202; sn3.name = "张三3"; sn3.age = 203; sn4.name = "张三4"; sn4.age = 204; sn5.name = "张三5"; sn5.age = 205; //将StudentName变量,存储到集合中 array.add(sn1); array.add(sn2); array.add(sn3); array.add(sn4); array.add(sn5); &#125;&#125; 17库存案例分析加入集合* A: 库存案例分析加入集合 * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG 18库存案例添加商品信息* A: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 定义,.描述商品的类 商品 4个属性 商品名字 大小 价格 库存 String double double int 定义类,类名Goods 这个类型的变量,存储到集合中*/public class Goods&#123; //定义商品名字 String brand ; //大小属性 double size ; // 价格属性 double price ; //库存属性 int count ;&#125;/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125; 19库存案例查看库存清单* A: 案例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); &#125; /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array)&#123; //输出表头 System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++)&#123; //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+" "+g.size+" "+g.price+" "+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125; 20库存案例修改库存清单及测试代码的实现* A: 案例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额 3.修改商品的库存 集合遍历 ,获取出集合中存储的Goods类型变量 变量调用Goods类的属性count,值进行修改 (键盘输入)*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); //进入死循环中 while(true)&#123; //调用选择功能的方法,获取到用户输入的功能序号 int number = chooseFunction(); //对序号判断,如果=1 进入查看库存功能 = 2 进入修改库存功能 =3 结束 switch(number)&#123; case 1: //进入查看库存,调用查看库存的方法,传递存储商品信息的集合 printStore(array); break; case 2: //进入修改库存功能,调用修改库存的方法,传递集合 update(array); break; case 3: return ; default: System.out.println("无此功能"); break; &#125; &#125; &#125; /* 方法定义,修改库存 键盘的输入,将Goods中的属性值,修改 */ public static void update(ArrayList&lt;Goods&gt; array)&#123; Scanner sc = new Scanner(System.in); //遍历集合,获取集合中的每个元素 for(int i = 0 ; i &lt; array.size(); i++)&#123; //集合方法get获取的是集合的元素,元素类型Goods Goods g = array.get(i); System.out.println("请输入"+g.brand+"的库存数"); //Goods属性,count进行修改 g.count = sc.nextInt(); &#125; &#125; /* 定义方法,实现选择菜单,用户根据功能选择菜单 */ public static int chooseFunction()&#123; System.out.println("-------------库存管理------------"); System.out.println("1.查看库存清单"); System.out.println("2.修改商品库存数量"); System.out.println("3.退出"); System.out.println("请输入要执行的操作序号："); Scanner sc = new Scanner(System.in); int number = sc.nextInt(); return number; &#125; /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array)&#123; //输出表头 System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++)&#123; //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+" "+g.size+" "+g.price+" "+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础5(方法)]]></title>
    <url>%2F2016%2F10%2F08%2Fday05%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、方法基础知识2、方法高级内容3、方法案例 01方法的概述* A: 为什么要有方法 * 提高代码的复用性 * B: 什么是方法 * 完成特定功能的代码块。 02方法的定义格式* A: 方法的格式 * 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } * B: 方法的格式说明 * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 * 返回值类型：就是功能结果的数据类型。 * 方法名：符合命名规则即可。方便我们的调用。 * 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 * 参数类型：就是参数的数据类型 * 参数名：就是变量名 * 方法体语句：就是完成功能的代码。 * return：结束方法的。 * 返回值：就是功能的结果，由return带给调用者。 03定义方法计算面积* A: 定义方法计算面积 123456789101112131415161718192021222324public class MethodDemo&#123; public static void main(String[] args)&#123; //调用方法, 方法执行起来 // 在方法main中,调用方法 getArea int area = getArea(5,6); System.out.println("面积是: "+area); &#125; /* 要求: 计算一个长方形的面积 定义方法解决这个要求 分析方法定义过程: 1.明确方法计算后的结果的数据类型 int 定义格式对应的就是返回值类型 2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int 未知数的变量,定义在方法的小括号内 */ public static int getArea(int w, int h)&#123; //实现方法的功能主体 //int area = w * h; return w * h; &#125;&#125; 04调用方法* A: 调用方法 * a: 在main函数中调用方法，让方法执行起来 * b: 方法的形参 * 方法要什么参数我们就给什么类型的参数。 * c: 方法的返回值 * 方法返回什么类型的值我们就用对应的数据类型的变量来接收 05调用方法执行流程* A: 调用方法执行流程 * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。 * b: 方法的执行，是把实参传递给形参，从而来执行的。 * c: 方法只有被调用才会执行。 06方法调用的内存图 A: 方法调用的内存图 07方法调用的练习* A: 案例代码 12345678910111213141516171819202122/* 方法的定义练习*/import java.util.Scanner;public class MethodDemo_1&#123; public static void main(String[] args)&#123; //printRect(); //int number = getNumber(); //System.out.println(getNumber()); //printRect2(3,5); double avg = getAvg(2,2,3); System.out.println(avg); &#125; /* 定义有返回值有参数方法，如求三个数的平均值 明确方法计算后的数据类型, 返回值类型 double 明确方法未知数, 三个未知的整数 */ public static double getAvg(double a, double b,double c)&#123; return (a+b+c)/3; &#125; 12345678910111213/* 定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形 明确方法计算后结果,控制台输出图形,没有返回值的 方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int */ public static void printRect2(int m,int n)&#123; for(int i = 0 ; i &lt; m ; i++)&#123; for(int j = 0 ; j &lt; n ; j++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125; 12345678910/* 定义有返回值无参数方法，如键盘录入得到一个整数 明确方法计算后结果的数据类型 int 明确有没有未知数,没 */ public static int getNumber()&#123; Scanner sc = new Scanner(System.in); //int number = sc.nextInt(); return sc.nextInt(); &#125; 123456789101112131415/* 定义无返回值无参数方法，如打印3行，每行3个*号的矩形 为什么没有返回值: 打印矩形 ,输出效果,不需要将结果返回 明确未知数: 不需要未知数 */ public static void printRect()&#123; for(int i = 0 ; i &lt; 3 ; i++)&#123; for(int j = 0 ; j &lt; 3 ;j++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125; &#125; 08方法的定义和使用的注意事项* A: 方法的定义和使用的注意事项 12345678* a: 方法不能定义在另一个方法的里面* b: 写错方法名字* c: 写错了参数列表* d: 方法返回值是void,方法中可以省略return 不写 return 下面不能有代码* e 方法返回值类型,和return 后面数据类型必须匹配* f: 方法重复定义问题* g: 调用方法的时候,返回值是void, 不能写在输出语句中 09方法的重载* A: 方法的重载 1234567891011121314151617181920 * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 * 参数列表不同： * A:参数个数不同 * B:参数类型不同 * C:参数的顺序不同(算重载,但是在开发中不用)* B: 案例代码 public static int getSum(int a,int b)&#123; System.out.println("两个int参数"); return a+b; &#125; public static int getSum(int a,int b,int c)&#123; System.out.println("三个int参数"); return a+b+c; &#125; public static double getSum(double a,double b)&#123; System.out.println("两个double参数"); return a+b; &#125; 10方法重载注意事项* A: 方法重载注意事项 * a: 参数列表必须不同 * b: 重载和参数变量名无关 * c: 重载和返回值类型无关 * d: 重载和修饰符无关 * e: 技巧: 重载看方法名和参数列表 11方法参数是基本数据类型* A: 方法参数是基本数据类型 * a: 方法参数是基本类型时，传递的是值。 12方法参数是引用数据类型* A: 方法参数是引用数据类型 * a: 方法参数是引用类型时，传递的是内存地址值。 13随机点名器* A: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 实现随机点名器 1.存储所有学生姓名 2.预览所有学生姓名,遍历数组 3.随机数作为索引,到数组中找元素 将功能独立出来, 作成方法,调用方法即可 定义三个功能, 用到同一个姓名数据 姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数*/import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //定义数组,存储学生姓名 String[] names = new String[8]; //调用添加姓名方法 addStudent(names); //调用遍历数组方法 printStudentName(names); //调用随机姓名的方法 String name = randomStudentName(names); System.out.println(name); &#125; /* 定义方法,随机数,做索引,数组中找到学生姓名 返回值? 学生姓名 参数? 数组 */ public static String randomStudentName(String[] names)&#123; Random ran = new Random(); int index = ran.nextInt(names.length); return names[index]; &#125; /* 定义方法,遍历数组 返回值? 没有 参数? 数组 */ public static void printStudentName(String[] names)&#123; for(int i = 0 ; i &lt; names.length ;i++)&#123; System.out.println(names[i]); &#125; &#125; /* 定义方法,实现向数组中添加学生姓名 返回值? 没有, 参数? 参数就是数组 */ public static void addStudent(String[] names)&#123; names[0] = "张三"; names[1] = "李四"; names[2] = "王五"; names[3] = "李蕾"; names[4] = "韩梅梅"; names[5] = "小名"; names[6] = "老王"; names[7] = "小华"; &#125;&#125; 14库存案例代码实现_1* A: 案例代码 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } } 15库存案例代码实现_2* A: 案例代码 /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } 16库存案例代码测试* A: 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量*/import java.util.Scanner;public class Shopp&#123; public static void main(String[] args)&#123; //使用数组,保存商品的信息 //品名,尺寸,价格,库存数, 定义5个数组 String[] brand = &#123;"MacBookAir","ThinkpadT450"&#125;; double[] size = &#123;13.3,15.6&#125;; double[] price = &#123;9998.97,6789.56&#125;; int[] count = &#123;0,0&#125;; while(true)&#123; int choose = chooseFunction(); switch(choose)&#123; case 1: //调用查看库存清单方法 printStore(brand,size,price,count); break; case 2: //调用修改库存的方法 update(brand,count); break; case 3: return ; default: System.out.println("没有这个功能"); break; &#125; &#125; &#125; /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count)&#123; //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++)&#123; System.out.println("请输入"+brand[i]+"的库存数"); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; &#125; //int chooseNumber = sc.nextInt(); &#125; /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count)&#123; System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++)&#123; System.out.println(brand[i]+" "+size[i]+" "+price[i]+" "+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction()&#123; System.out.println("-------------库存管理------------"); System.out.println("1.查看库存清单"); System.out.println("2.修改商品库存数量"); System.out.println("3.退出"); System.out.println("请输入要执行的操作序号："); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础4(switch，数组)]]></title>
    <url>%2F2016%2F10%2F04%2Fday04%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、流程控制语句switch2、数组3、随机点名器案例 01switch语句解构* A:switch语句解构 * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。 1234567891011121314151617* b:格式如下: swtich(表达式)&#123; case 常量1 : 要执行的语句; break; case 常量2 : 要执行的语句; break; case 常量3 : 要执行的语句; break; default: 要执行的语句; break; 123456789101112* c: 执行流程: 表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束* d: 关键字: switch case default break * e:举例 如果等于1，则输出星期一 如果等于2，则输出星期二 如果等于3，则输出星期三 如果等于4，则输出星期四 如果等于5，则输出星期五 如果等于6，则输出星期六 如果等于7，则输出星期天 02switch语句的星期判断* A: switch语句的星期判断 123456789101112131415161718192021222324252627282930313233343536* a: 明确需求 需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期. * b: 代码实现public class SwitchDemo01 &#123; public static void main(String[] args) &#123; int week = 5; switch (week) &#123; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.out.println("星期五"); break; case 6: System.out.println("星期六"); break; case 7: System.out.println("星期天"); break; default: System.out.println("输入的数字不正确..."); break; &#125; &#125;&#125; 03switch语句接受的数据类型* A: switch语句接受的数据类型 * a:注意事项 switch语句中的表达式的数据类型,是有要求的 JDK1.0 - 1.4 数据类型接受 byte short int char JDK1.5 数据类型接受 byte short int char enum(枚举) JDK1.7 数据类型接受 byte short int char enum(枚举), String 04case穿透* A:case穿透 123* a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。* b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。* 注意：case 语句后面 没有break 就会一直穿透下去。 05数组的概述* A: 数组的概述 * a:数组的需求 现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成， 那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦. * b:数组的概述 数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 06数组的定义* A：数组的定义 123456789101112131415161718192021222324* b:格式: 数据类型[] 数组名 = new 数据类型[元素个数或数组长度]; * c:举例: int[] x = new int[100];* c:要点说明 1)数据类型: 数组中存储元素的数据类型 2) [] 表示数组的意思 3) 变量名 自定义标识符 4) new 创建容器关键字 5)数据类型: 数组中存储元素的数据类型 6)[] 表示数组的意思 7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长) 数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号 自动编号,最小值是0, 最大值,长度-1 自动编号专业名次, 索引(index), 下标, 角标 访问数组存储的元素,必须依赖于索引, 公式 数组名[索引] Java提供一个属性,操作索引的 数组的一个属性,就是数组的长度, 属性的名字 length 使用属性: 数组名.length 数据类型 int 数组的最小索引是0, 最大索引数组.length-1 07JVM内存划分* A：内存划分 * JVM对自己的内存划分为5个区域 * a: 寄存器:内存和CUP之间 * b: 本地方法栈: JVM调用了系统中的功能 * c: 方法和数据共享: 运行时期class文件进入的地方 * d: 方法栈:所有的方法运行的时候进入内存 * e: 堆:存储的是容器和对象 08数组的内存1234567* A: 数组的内存* int[] x; // 声明一个int[]类型的变量* x = new int[100]; // 创建一个长度为100的数组* 接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。* 第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值* 第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化* 引用数据类型 存的是变量的地址 09使用索引访问数组的元素* A: 使用索引访问数组的元素 * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。 * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1” 10数组的length属性* A: lenth属性 123456789101112* a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。* b 求数组的长度public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int[] arr; // 声明变量 arr = new int[3]; // 创建数组对象 System.out.println("arr[0]=" + arr[0]); // 访问数组中的第一个元素 System.out.println("arr[1]=" + arr[1]); // 访问数组中的第二个元素 System.out.println("arr[2]=" + arr[2]); // 访问数组中的第三个元素 System.out.println("数组的长度是：" + arr.length); // 打印数组长度 &#125;&#125; 11为数组的元素赋值* A: 为数组的元素赋值 * a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。 * 赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值 * b: 案例 123456789101112public class ArrayDemo02 &#123; public static void main(String[] args) &#123; int[] arr = new int[4]; // 定义可以存储4个整数的数组 arr[0] = 1; // 为第1个元素赋值1 arr[1] = 2; // 为第2个元素赋值2 // 下面的代码是打印数组中每个元素的值 System.out.println("arr[0]=" + arr[0]); System.out.println("arr[1]=" + arr[1]); System.out.println("arr[2]=" + arr[2]); System.out.println("arr[3]=" + arr[3]); &#125;&#125; 12数组的定义_2* A: 定义数组格式2 1234567891011121314* a: 数组初始化动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。 1、类型[] 数组名 = new 类型[长度]; int[] arr = new int[4]; 静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。 2、类型[] 数组名 = new 类型[]&#123;元素，元素，……&#125;; int[] arr = new int[]&#123;1,2,3,4&#125;; 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。 例如： arr = new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;; 3、类型[] 数组名 = &#123;元素，元素，元素，……&#125;; int[] arr = &#123; 1, 2, 3, 4 &#125;;* 数组拷贝 int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; int[] luckyNumbers = smallPrimes; 如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法： 123int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length) ;//第 2 个参数是新数组的长度。这个方法通常用来增加数组的大小luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 如果数组元素是数值型，那么多余的元素将被赋值为 0 ; 如果数组元素是布尔型， 则将赋值为 false。相反， 如果长度小于原始数组的长度，则只拷贝最前面的数据元素。 13遍历数组* A:遍历数组 * 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历 * B:练习 12345678910111213141516public class ArrayDemo04 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; // 定义数组 // 使用for循环遍历数组的元素 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); // 通过索引访问元素 &#125; &#125;&#125;上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来for each 循环 =&gt; 遍历数组for (variable : collection) &#123;statement&#125;例如: for(int element : a) System.out.println(element); 提示：有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串， 这些元素被放置在括号内， 并用逗号分隔， 例如，“ [2, 3, 5,7，11 ，13]”、 要想打印数组， 可以调用System.out.println(Arrays.toString(a)); 14数组中常见的异常* A: 数组操作中,常见的两个异常 数组的索引越界异常 空指针异常 * B: 练习 1234567891011121314public class ArrayDemo_4&#123; public static void main(String[] args)&#123; //数组的索引越界异常 //int[] arr = &#123;5,2,1&#125;; //数组中3个元素,索引 0,1,2 //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3 //空指针异常 int[] arr2 = &#123;1,5,8&#125;; System.out.println(arr2[2]); arr2 = null; // arr2 不在保存数组的地址了 System.out.println(arr2[2]);//java.lang.NullPointerException &#125;&#125; 15数组最值和排序* A: 数组获取最值的原理思想 * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素 * B: 数组排序 * 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法： int[] a = new int[10000]; Arrays.sort(a) 16数组获取最值代码实现* A: 代码实现 12345678910111213public class ArrayDemo05 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 4, 1, 6, 3, 9, 8 &#125;; // 定义一个数组 int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值 // 下面通过一个for循环遍历数组中的元素 for (int x = 1; x &lt; arr.length; x++) &#123; if (arr[x] &gt; max) &#123; // 比较 arr[x]的值是否大于max max = arr[x]; // 条件成立，将arr[x]的值赋给max &#125; &#125; System.out.println("max=" + max); // 打印最大值 &#125;&#125; 17二维数组的定义* A 二维数组的作用 * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？ * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。 * B 定义格式 123456789* a 第一种定义格式: * int[][] arr = new int[3][4]; * 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组* b 第二种定义格式 * int[][] arr = new int[3][]; * 第二种方式和第一种类似，只是数组中每个元素的长度不确定* c 第三种定义格式 * int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125;; * 二维数组中定义了三个元素，这三个元素都是数组，分别为&#123;1,2&#125;、&#123;3,4,5,6&#125;、&#123;7,8,9&#125; 18二维数组元素的访问* A: 二维数组的访问 * 案例: 12345678910111213141516171819202122232425262728293031class ArrayDemo08 &#123; public static void main(String[] args)&#123; //定义二维数组的方式 int[][] arr = new int[3][4]; System.out.println( arr ); System.out.println("二维数组的长度: " + arr.length); //获取二维数组的3个元素 System.out.println( arr[0] ); System.out.println( arr[1] ); System.out.println( arr[2] ); System.out.println("打印第一个一维数组的元素值"); System.out.println( arr[0][0] ); System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素 System.out.println( arr[0][2] ); System.out.println( arr[0][3] ); System.out.println("打印第二个一维数组的元素值"); System.out.println( arr[1][0] ); System.out.println( arr[1][1] ); System.out.println( arr[1][2] ); System.out.println( arr[1][3] ); System.out.println("打印第三个一维数组的元素值"); System.out.println( arr[2][0] ); System.out.println( arr[2][1] ); System.out.println( arr[2][2] ); System.out.println( arr[2][3] ); &#125;&#125; 19二维数组内存图* A: 二维数组内存图 * 举例:int[][] arr = new int[3][2]; * 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值 * 每一个大内存空间里又开辟连续的两个小的内存空间. 20二维数组的定义和访问1234567891011* A: 二维数组的定义和访问 * 格式1: * int[][] arr = new int[3][]; 不推荐 * 格式2 * int[][] arr = &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;; * * B: 二维数组的访问 举例:int[][] arr = &#123;&#123;1,2,4&#125;,&#123;5,8,7&#125;,&#123;0,9,3&#125;&#125;; 想要打印数组中7这个元素需要先找到大的元素索引&#123;5,7&#125; 索引为2 ,在找7在&#123;5,7&#125;中的索引2 那么结果为 arr[2][2] 第一个[2]代表大数组中&#123;5,8,7&#125;这个元素索引 第二个[2]代表&#123;5,8,7&#125;中7元素的索引 21二维数组的遍历* A:二维数组遍历 123456789101112131415161718 int[][] arr = &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;; 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素 * B:举例:遍历二维数组public class ArrayArrayDemo_2&#123; public static void main(String[] args)&#123; int[][] arr = &#123; &#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;,&#123;0&#125; &#125;; //外循环,遍历二维数组 for(int i = 0 ; i &lt; arr.length ;i++)&#123; //内循环,遍历每个一维数组 arr[0] arr[1] arr[i] for(int j = 0 ; j &lt; arr[i].length; j++)&#123; System.out.print(arr[i][j]); &#125; System.out.println(); &#125; &#125; * C:二维数组累加求和 12345678910111213 class ArrayDemo09 &#123; public static void main(String[] args)&#123; int[][] arr2 = &#123; &#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6,7,8,9,10&#125; &#125;; int sum2 = 0; for (int i=0; i&lt;arr2.length; i++) &#123; for (int j=0; j&lt;arr2[i].length; j++) &#123; //System.out.println(arr2[i][j]) sum2 += arr2[i][j]; &#125; &#125; System.out.println("sum2= "+ sum2); &#125;&#125; for each 循环语句不能自动处理二维数组的每一个元素。它是按照行， 也就是一维数组处理的要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示： 1234for (double [] row : a) for (double value : row) //do something with value System.out.println(value); 提示： 要想快速地打印一个二维数组的数据元素列表， 可以调用：System.out.println(Arrays.deepToString(a)) ;输出格式为：[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]] 22二维数组的求和练习* A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示 * 第一小组销售额为{11, 12}万元 * 第二小组销售额为{21, 22, 23}万元 * 第三小组销售额为{31, 32, 33, 34}万元。 * B 代码实现 123456789101112131415161718public class ArrayDemo10 &#123; public static void main(String[] args) &#123; int[][] arr = new int[3][]; // 定义一个长度为3的二维数组 arr[0] = new int[] &#123; 11, 12 &#125;; // 为数组的元素赋值 arr[1] = new int[] &#123; 21, 22, 23 &#125;; arr[2] = new int[] &#123; 31, 32, 33, 34 &#125;; int sum = 0; // 定义变量记录总销售额 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组元素 int groupSum = 0; // 定义变量记录小组销售总额 for (int j = 0; j &lt; arr[i].length; j++) &#123; // 遍历小组内每个人的销售额 groupSum = groupSum + arr[i][j]; &#125; sum = sum + groupSum; // 累加小组销售额 System.out.println("第" + (i + 1) + "小组销售额为：" + groupSum + " 万元"); &#125; System.out.println("总销售额为: " + sum + " 万元"); &#125;&#125; 23随机点名器案例分析* A 随机点名器案例分析 * B: 需求 * 随机点名器，即在全班同学中随机的打印出一名同学名字。 * C:分析: * 1)定义数组存数全班同学 * 2)生成随机数范围0 到 数组长度-1 * 3)根据这个索引找到数组中的同学名称 24随机点名器代码实现* A: 分析 随机点名器: 1 存储姓名 2. 预览所有人的姓名 3. 随机出一个人的姓名 * B 代码实现 123456789101112131415161718192021import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //存储姓名,姓名存储到数组中 //数组存储姓名,姓名的数据类型,String String[] names = &#123;"张三","李四","王五","李蕾","韩梅梅","小名","老王","小华","约翰逊","爱丽丝"&#125;; //预览: 遍历数组,打印所有姓名 for(int i = 0 ; i &lt; names.length ; i++)&#123; System.out.println(names[i]); &#125; System.out.println("============="); //随机出一个人的名 //利用随机数,生成一个整数,作为索引,到数组中找到对应的元素 Random ran = new Random(); //随机数,范围必须是0-数组的最大索引 int index = ran.nextInt(names.length);//index 就是随机数,作为索引 System.out.println(names[index]); &#125;&#125; 25随机点名器代码实现_2* A 代码优化: 1234567import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; String[] names = &#123;"张三","李四","王五","李蕾","韩梅梅","小名","老王","小华","约翰逊","爱丽丝"&#125;; System.out.println(names[new Random().nextInt(names.length)]); &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础3(引用类型，if，while)]]></title>
    <url>%2F2016%2F10%2F04%2Fday03%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、引用类型变量的创建及使用2、流程控制语句之选择语句3、流程控制语句之循环语句4、循环高级 01创建引用类型变量公式 A: 创建引用类型变量公式 a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。 b: 引用数据类型的定义格式 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。 数据类型 变量名 = new 数据类型(); c: 引用数据类型的使用 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。 变量名.方法名(); 02Scanner类的使用* A: Scanner类的使用 123456* a: 导包import java.util.Scanner;* b：创建键盘录入对象 Scanner sc = new Scanner(System.in);* c: 读取键盘录入的一个整数 * int enterNumber = sc.nextInt();* d: 读取键盘录入的字符串 * String enterString = sc.next(); * B: 案例代码 import java.util.Scanner; public class Demo05Scanner{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); System.out.println(&quot;用户输入的整数为&quot;+enterNumber); String enterString = sc.next(); System.out.println(&quot;用户输入的字符串为&quot;+enterString); } } 03Random随机数类的使用_1* A: Random随机数类的使用_1 123456789101112131415161718192021222324252627* a: 功能 * 生成随机数需要使用到引用类型随机数Random类* b: 使用方式 * import导包：所属包java.util. Random * 创建实例格式：Random random = new Random (); * 调用方法 * nextInt(int maxValue) 产生[0,maxValue)范围的随机数,包含0不包含maxValue * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextInt(100);//结果为0-99的一个数* B: 案例代码 import java.util.Random; public class RandomDemo&#123; public static void main(String[] args)&#123; Random ran = new Random(); // Random类中的,产生随机数的功能 int i = ran.nextInt(100); System.out.println(i); //问题? 产生随机数,范围 1-100之间 // nextInt(100) 0-99 + 1 &#125; &#125; 04Random随机数类的使用_2* A: Random随机数类的使用_2 12345* a: 调用方法 * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0) 05if语句格式第一种* A: if语句格式第一种 12345678* a: 书写格式 if(比较表达式) &#123; 语句体; &#125;* b：执行流程： * 先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体； * 如果是false，就不执行语句体； 12345678910111213* B: 案例代码 public class IfDemo&#123; public static void main(String[] args)&#123; int i = 5 ; //对变量i进行if判断 if(i &gt; 5)&#123; System.out.println("if中的条件是true"); i++; &#125; System.out.println(i); &#125; &#125; 06if语句格式第二种* A: if语句格式第二种 12345678910* a: 书写格式 if(比较表达式) &#123; 语句体1; &#125;else &#123; 语句体2; &#125;* b：执行流程： * 首先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体1； * 如果是false，就执行语句体2； 123456789101112* B: 案例代码 public class IfElseDemo&#123; public static void main(String[] args)&#123; int i = 16 ; //判断变量,是奇偶数, 除以2,看余数是0还是1 if( i % 2 == 0 )&#123; System.out.println(i+" 是偶数"); &#125;else&#123; System.out.println(i+" 是奇数"); &#125; &#125; &#125; 07if语句格式第三种* A: if语句格式第三种 123456789101112131415161718192021* a: 书写格式 if(比较表达式1) &#123; 语句体1; &#125;else if(比较表达式2) &#123; 语句体2; &#125;else if(比较表达式3) &#123; 语句体3; &#125; ... else &#123; 语句体n+1; &#125;* b：执行流程： * 首先计算比较表达式1看其返回值是true还是false， * 如果是true，就执行语句体1，if语句结束。 * 如果是false，接着计算比较表达式2看其返回值是true还是false， * 如果是true，就执行语句体2，if语句结束。 * 如果是false，接着计算比较表达式3看其返回值是true还是false， * 如果都是false，就执行语句体n+1。 12345678910111213141516171819* B: 案例代码 public class IfElseIfDemo&#123; public static void main(String[] args)&#123; //成绩判断要求 ,成绩&gt;80 成绩&gt;70 成绩&gt;60 不及格 //定义变量,保存成绩 int grade = 75; //使用if else if 语句对成绩判断 if( grade &gt; 80 )&#123; System.out.println(grade+" 成绩是优"); &#125;else if ( grade &gt; 70)&#123; System.out.println(grade+" 成绩是良"); &#125;else if ( grade &gt; 60)&#123; System.out.println(grade+" 成绩是中"); &#125;else&#123; System.out.println(grade+" 成绩是差"); &#125; &#125; &#125; 08if语句和三元运算符的互换* A: 三元运算符 12345678* a: 概念 * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行* b: 使用格式 * (条件表达式)？表达式1：表达式2；* c: 运算规则 * 1: 判断条件表达式，结果为一个布尔值 * 2: true，运算结果为表达式1 * 3: false，运算结果为表达式2 123456789101112131415161718192021* B: 案例代码 public class IfElseDemo_1&#123; public static void main(String[] args)&#123; int j = 6; int i = 15; //使用if语句,判断出最大值 if(i&gt;j)&#123; int j = 6; System.out.println(i+" 是最大值"); &#125;else&#123; System.out.println(j+" 是最大值"); &#125; //使用三元运算实现 int k = i&gt;j ? i : j; System.out.println(k+" 是最大值"); &#125; &#125;* C: 使用if语句还是三元表达式 * 判断条件多,使用if * 三元,必须有结果的, if 可以没有结果的 09while循环* A: while循环结构 123456789* a: 使用格式 初始化表达式； while(条件)&#123; 循环体 &#125;* b: 执行顺序 当条件是true,就执行循环体,执行完循环体后 程序再次执行while中的条件,如果条件还是true,继续执行循环体 直到条件是false的时候,循环就结束 123456789101112* B: 案例代码 public class WhileDemo&#123; public static void main(String[] args)&#123; //输出 1-4之间的整数 //定义变量,整数类型, 循环的条件 int i = 1; while( i &lt; 5 )&#123; System.out.println(i); i++; &#125; &#125; &#125; 10for循环_1* A: for循环_1 123456789101112131415161718 * a: 使用格式 for(初始化变量 ; 条件 ; 增量)&#123; 循环体; &#125; * b: 各模块解释 初始化变量: 定义变量,作用是用来控制循环的次数 条件: 当条件是true,执行循环体,条件是false,结束循环 增量: 变量自增情况 * B: 案例代码 public class ForDemo&#123; public static void main(String[] args)&#123; //for循环,输出0-10 for(int i = 0 ; i &lt; 11 ; i++)&#123; System.out.println(i); &#125; &#125; &#125; 11for循环_2* A: for循环的执行流程 for（①1 ; ②2 ; ③3）{ ④4 } 第一步，执行①1 第二步，执行②2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 第三步，执行④4 第四步，执行③3，然后重复执行第二步 第五步，退出循环 12for循环_3* A: 案例 * a: 利用for循环,计算1+4的结果 * B: 案例代码 123456789101112public class ForDemo_1&#123; public static void main(String[] args)&#123; // 定义变量,记录求和后的数据 int sum = 0; // 利用循环,将变量从1变化到4 for(int i = 1 ; i &lt;= 4 ; i++)&#123; //对变量进行求和 sum = sum + i; &#125; System.out.println(sum); &#125;&#125; 13do_while循环* A: do_while循环 12345678910111213141516171819* a: 使用格式 do&#123; 循环体; &#125;while(条件);* b: 执行顺序 先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体， 如果条件为false，循环结束。* c: 特点 * 无条件先执行一次* B: 案例代码public class DoWhileDemo&#123; public static void main(String[] args)&#123; int i = 0; do&#123; System.out.println(i); i++; &#125;while( i &lt; 5); &#125;&#125; 14死循环* A: 死循环概述 * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环 * B: 死循环格式 * while(true){} * for(;;){} 15嵌套for循环_1* A: 嵌套循环的概述 123* 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。* while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，* 如最常见的在for循环中嵌套for循环。 * B: 嵌套循环的格式 12345678for(初始化表达式; 循环条件; 操作表达式) &#123; ……… for(初始化表达式; 循环条件; 操作表达式) &#123; 执行语句 ……… &#125; ………&#125; * C: 各模块解释 12345* 总的循环次数 = 内循环次数 * 外循环的次数* 内循环,是外循环的循环体 * 外循环,控制的是行数* 内循环,控制的是每行的个数 16嵌套for循环_2* A: 案例 * a: 打印正三角形 * B: 案例代码 12345678910public class ForForDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 9 ; i++)&#123; for(int j = 0; j &lt; i+1 ;j++)&#123; System.out.print("* "); &#125; System.out.println(); &#125; &#125;&#125; 17break语句* A: break语句 123456789101112* a: 作用 * 跳出所在的循环体* b: 书写位置 * 必须出现在循环或选择结构内* c: 举例 for(int i=0; i&lt;10; i++) &#123; if(i&gt;5) &#123; break; &#125; System.out.println(“我爱Java”+i); &#125; //会从0-5输出6次“我爱Java” * B: break详细解释 123456789* a: 作用 * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中， 可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码， 这些关键字一旦出现就可以跳转语句执行顺序。* b: 使用方式 * 无法单独使用，必须将break关键字置于switch或循环语句中* c: 运行规律 * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构 * 只能跳出最近的代码块，不能跨越多级代码块 * C：循环标号 123456789* a: 为什么使用循环标号 * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.* b: 使用方式 * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。 使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可* c: 运行规律 * 当外层循环外定义了标号 * 内层使用break，终止内外双层循环。 * 内层使用continue，终止内层循环，继续外层循环。 18continue语句* A: continue语句 12345678910111213141516171819* a: 作用 * 提前结束本次循环，继续进行下次循环* b: 使用方式 * 无法单独使用，必须将continue关键字置于循环语句中* c：运行规律 * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环* d：案例代码 public class ContinueDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 10 ; i++)&#123; if(i%2==0)&#123; continue; &#125; System.out.println(i); &#125; &#125; &#125; //会把0-9之间所有的奇数打印到控制台上 19猜数字小游戏* A: 猜数字小游戏 * a: 分析 * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现， 但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件 * b: 需求分析 * 后台预先生成一个随机数1-100，用户键盘录入猜数字 * 如果猜对了，打印“恭喜您，答对了” * 如果猜错了 * 猜大了：打印“sorry，您猜大了!” * 猜小了：打印“sorry，您猜小了!” 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” * B: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 猜数字小游戏 完成猜数字小游戏： 1、产生随机数 后台预先生成一个随机数1-100，用户键盘录入猜数字 2、通过if语句对用户猜的数与随机数进行比较 如果猜对了，打印“恭喜您，答对了” 如果猜错了 猜大了：打印“sorry，您猜大了!” 猜小了：打印“sorry，您猜小了!” 3、通过for循环完成用户猜数的循环 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!”*/import java.util.Random;import java.util.Scanner;//通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。//import java.util.*;public class GuessNumber&#123; public static void main(String[] args) &#123; //1、产生随机数 //后台预先生成一个随机数1-100，用户键盘录入猜数字 //创建随机数对象 Random random = new Random(); //产生一个1-100的随机数 int randomNumber = random.nextInt(100)+1; //System.out.println("我产生的随机数是："+randomNumber+"你猜猜是多少？"); 作弊专用 //产生控制台录入的Scanner对象 Scanner sc = new Scanner(System.in); //3、通过for循环完成用户猜数的循环 //通过for循环完成猜数字逻辑 for(int i=1; i&lt;=5; i++)&#123; //提示用户输入要猜的数，用变量接收 System.out.println(); System.out.println("请您输入一个1-100的数："); int guessNumber = sc.nextInt(); //2、通过if语句对用户猜的数与随机数进行比较 //如果猜对了 if(guessNumber==randomNumber) &#123; //打印猜对后的提示 System.out.println("恭喜您，猜对了！"); //跳出循环，不用再猜了 break; &#125;else &#123;//如果猜错了 //如果猜大了 if(guessNumber&gt;randomNumber) &#123; System.out.println("sorry，您猜大了!"); &#125;else &#123;//如果猜小了 System.out.println("sorry，您猜小了!"); &#125; &#125; //如果猜到了最后的第5次仍然没有猜对就跳出循环 if(i==5) &#123; System.out.println("对不起，点太背，下次再来吧！"); break; &#125; //每次猜错后，都提示还有多少次机会 System.out.println("请注意，您还有"+(5-i)+"次机会，请慎重作答！"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS环境配置踩坑经历]]></title>
    <url>%2F2016%2F10%2F03%2FAS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[遇到的bugUnable to resolve dependency for &apos;:app@debug/compileClasspath&apos; 这是由于配置文件的依赖是通过Google下载的，然而该下载被墙了！[解决办法]： 在整个工程的build.gradle中添加以下框内代码：1234maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;maven &#123; url 'http://repo1.maven.org/maven2' &#125; app下的build.gradle配置如下:buildToolsVersion 需要和你的sdk安装目录 ~\sdk\build-tools文件里面已有的版本对应123456789101112131415161718android &#123; compileSdkVersion 26 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.example.administrator.myapplication" minSdkVersion 19 targetSdkVersion 22 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; implementation ‘com.android.support:appcompat-v7:26.+’ 中v7:26.+表示使用的sdk版本123456789101112dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.+' implementation 'com.android.support.constraint:constraint-layout:1.0.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:0.4' androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'// androidTestImplementation 'com.android.support.test:runner:1.0.1'// androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'&#125; 若配置后还没解决问题，依然报错打开 C:/Users/(用户名)/.gradle/gradle.properties把http代理的配置注释掉，例如： ## For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. # Default value: -Xmx1024m -XX:MaxPermSize=256m # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 # # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true #Sat Sep 29 23:37:12 CST 2018 #systemProp.http.proxyHost=mirrors.neusoft.edu.cn #systemProp.https.proxyPort=80 #systemProp.https.proxyHost=mirrors.neusoft.edu.cn #systemProp.http.proxyPort=80 More info: 参考该问题的csdn博客]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础1(变量，运算符)]]></title>
    <url>%2F2016%2F10%2F02%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、变量2、运算符 第一个Java程序Java代码Java程序是大小写敏感的 对格式没有严格要求，但用空格或Tab键缩进会比较好看 Hello.java12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println("Hello, world!");&#125;&#125; 文件名必须是Hello.java，文件名也要注意大小写，必须与程序的类名完全一致，扩展名是.java。 编译切换到Hello.java所在目录：1javac Hello.java 无任何输出表示成功，可查看编译出的Hello.class文件。 执行1java Hello 代码格式：public 和 static 是修饰符static表示静态方法 12345678910public class 类名 &#123; public static void 方法名(参数) &#123; //单行注释 你的程序代码; /* 多行注释 */&#125;&#125;//class定义结束 变量变量概述A: 什么是变量? 12a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。 计算机存储单元A: 计算机中储存和运算的最小单位是?123456789a: 一个字节,也就是一个byte. win+r--cmd--回车 b: 常用储存单位 *1B（字节） = 8bit *1KB = 1024B *1MB = 1024KB *1GB = 1024MB *1TB = 1024GB *1PB = 1024TB Java中数据类型四类八种 A: 数据类型四类八种123456789*四类 八种 字节数 数据表示范围*整型 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483648 long 8 -263～263-1*浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308*字符型 char 2 表示一个字符，如('a'，'A'，'0'，'家')*布尔型 boolean 1 只有两个值true与false 常量和数据类型 A:常量的定义1234* a: 整形常量默认是int类型* b: 小数常量默认是double类型* c: 定义长整形数据如果值超过int取值范围后面要+"L"* d: 定义float类型的数据后面要+"f" 否则默认是double 变量创建的三要素A: 定义变量的语法格式：1234567891011121314数据类型 变量名 = 变量值;* int a = 100; * B:代码:public class Variable &#123; public static void main(String[] args) &#123; int a = 10; double b = 3.14; char c = 'z'; String s = "i love java"; a = 20; System.out.println(a); &#125;&#125; 定义所有的基本数据类型变量 A: 案例演示 a: 八种基本类型数据的创建 定义字符串变量 A：案例演示 创建字符串数据类型变量 String 是引用数据类型变量定义使用注意事项 A：变量使用的注意事项12345678910111213141516* a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。 public static void main(String[] args) &#123; int x; x = 20; //为x赋值20 System.out.println(x);//读取x变量中的值，再打印 &#125; * c: 变量使用时有作用域的限制。 public static void main(String[] args) &#123; int x = 20; &#123; int y = 20; &#125; System.out.println(x);//读取x变量中的值，再打印 System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量 &#125; 数据类型转换_自动转换 A:  自动类型转换12345678* a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换 自动类型转换格式： 范围大的数据类型 变量 = 范围小的数据类型值； 如： double d = 1000; 或 int i = 100; double d2 = i; 数据类型转换_强制转换 A: 强制类型转换12345678*a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换*b: 强制类型转换格式：范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值;如：int i = (int)6.718; //i的值为6或double d = 3.14;int i2 = (int)d; //i2的值为3 运算符算数运算符_1 A: 常见操作 1234567891011运算符 运算规则 范例 结果+ 正号 +3 3+ 加 2+3 5+ 连接字符串 “中”+“国” “中国”- 负号 int a=3;-a -3- 减 3-1 2* 乘 2*3 6/ 除 5/2 2% 取模 5/2 1++ 自增 int a=1;a++/++a 2-- 自减 int b=3;a--/--a 2 B: 注意事项 12345*a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。*b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。 *c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。*d:整数做被除数，0不能做除数，否则报错。*e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN C:代码演示 1234567891011121314151617181920public class OperatorDemo1 &#123; public static void main(String[] args) &#123; /* * 常量使用算数运算符 */ System.out.println(10+20); /* * 变量使用算数运算符 */ int x = 10; int y = 20; //"+"作为加法运算使用 int z = x + y; //"+"作为连接字符串使用 System.out.println("x="+x); System.out.println("y="+y); System.out.println("z="+z);&#125;&#125; 算数运算符_2 算数运算符++、–* A:算数运算符++、--的使用 * a: ++运算符，会在原有值的基础上自增1 * b: --运算符，会在原有值的基础上自减1。 * B:++ -- 位置的使用 * a:++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1； * b:++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。 赋值运算符 A: 赋值运算符的使用 1234567运算符 运算规则 范例 结果= 赋值 int a=2 2+= 加后赋值 int a=2，a+=2 4-= 减后赋值 int a=2，a-=2 0*= 乘后赋值 int a=2，a*=2 4/= 整除后赋值 int a=2，a/=2 1%= 取模后赋值 int a=2，a%=2 0 B：案例演示 123456789101112 * 赋值运算符 * +=, -=, *=, /=, %= ： * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的 * 注意：赋值运算符左边必须是变量public class OperatorDemo2 &#123; public static void main(String[] args) &#123; byte x = 10; x += 20;// 相当于 x = (byte)(x+20); System.out.println(x); &#125;&#125; 比较运算符 A:比较运算符的使用 1234567运算符 运算规则 范例 结果== 相等于 4==3 False!= 不等于 4!=3 True&lt; 小于 4&lt;3 False&gt; 大于 4&gt;3 True&lt;= 小于等于 4&lt;=3 False&gt;= 大于等于 4&gt;=3 True 逻辑运算符A: 逻辑运算符的使用 123456789101112运算符 运算规则 范例 结果&amp; 与 false&amp;true False| 或 false|true True^ 异或 true^flase True! 非 !true Flase&amp;&amp; 短路与 false&amp;&amp;true False|| 短路或 false||true True规律小结: 短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false； 短路或||:参与运算的两边数据，有true，则运算结果为true； 逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。 三元运算符A: 格式: (条件表达式)？表达式1：表达式2； B: 代码案例 方式一： System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印 方式二： int a = 3; int b = 4; String result = (a==b) ? “相等” : “不相等”; //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result 方式三： int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200; //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n 运算符优先级1234567891011121314151617优先级 描述 运算符1 括号 ()、[]2 正负号 +、-3 自增自减，非 ++、--、!4 乘除，取余 *、/、%5 加减 +、-6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;7 大小关系 &gt;、&gt;=、&lt;、&lt;=8 相等关系 ==、!=9 按位与 &amp;10 按位异或 ^11 按位或 |12 逻辑与 &amp;&amp;13 逻辑或 ||14 条件运算 ?:15 赋值运算 =、+=、-=、*=、/=、%=16 位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 商场库存清单案例A: 案例分析. a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部） b:清单顶部为固定的数据，直接打印即可 c:清单中部为商品，为变化的数据，需要记录商品信息后，打印经过观察，我们确定一项商品应该有如下几个属性：品牌型号: 即商品名称，String型尺寸：物品大小，double型价格：物品单价，double型配置：这一项为每种商品的配置信息，String型库存数：这一项为每种商品的库存个数，int型 d:清单底部包含了统计操作，需经过计算后，打印我们发现两个单独的可变化量总库存数：所有商品总个数，int型库存商品总金额：所有商品金额，double型 B: 案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142//步骤一: 创建Demo01库存清单.java文件，编写main主方法public class Demo01库存清单 &#123; public static void main(String[] args) &#123; &#125;&#125;//步骤二: 记录每种库存商品信息//苹果笔记本电脑String macBrand = "MacBookAir";double macSize = 13.3;double macPrice = 6988.88;int macCount = 5;//联想Thinkpad笔记本电脑String thinkpadBrand = "ThinkpadT450";double thinkpadSize = 14.0;double thinkpadPrice = 5999.99;int thinkpadCount = 10;//华硕ASUS笔记本电脑String ASUSBrand = "ASUS-FL5800";double ASUSSize = 15.6;double ASUSPrice = 4999.50;int ASUSCount = 18;//步骤三: 统计库存总个数、库存总金额int totalCount = macCount + thinkpadCount + ASUSCount;double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);//步骤四: 列表顶部System.out.println("------------------------------商城库存清单-----------------------------");System.out.println("品牌型号 尺寸 价格 库存数");步骤四:打印库存清单中部信息//列表中部System.out.println(macBrand+" "+macSize+" "+macPrice+" "+macCount);System.out.println(thinkpadBrand+" "+thinkpadSize+" "+thinkpadPrice+" "+thinkpadCount);System.out.println(ASUSBrand+" "+ASUSSize+" "+ASUSPrice+" "ASUSCount);打印库存清单底部信息//列表底部System.out.println("-----------------------------------------------------------------------");System.out.println("总库存数："+totalCount); System.out.println("库存商品总金额："+totalMoney);]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
