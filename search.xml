<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[只是单纯地发个图片 hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 hexo deploy Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>first test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础18(Map接口、HashMap集合、LinkedHashMap集合、集合嵌套))]]></title>
    <url>%2F2016%2F10%2F29%2Fday20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Map接口2、HashMap集合、LinkedHashMap集合3、集合的嵌套4、集合应用举例 01Map集合概述12345678910111213A:Map集合概述:我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同 a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 "Collection中的集合称为【单列集合】，Map中的集合称为【双列集合】"。需要注意的是，"Map中的集合【不能】包含【重复的键】"，【"值】可以重复"；"每个【键】只能对应一个【值】"。"如果添加【重复的键】，会把之前的【键值】【覆盖】掉"Map |--HashMap |--LinkedHashMap 02Map接口中的常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A:Map接口中的常用方法 /* * Map接口中的常用方法 * 使用Map接口的实现类 HashMap */ public class MapDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* * 移除集合中的键值对,【返回】被【移除】之前的【值】 * V remove(K) * 如果集合中【没有】这个【键】,【返回null】，不移除任何元素 */" public static void function_2()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "a"); map.put(2, "b"); map.put(3, "c"); System.out.println(map); String value = map.remove(33);//null System.out.println(value); System.out.println(map); &#125; "/* * 通过键对象,获取值对象 * V get(K) * 如果集合中【没有】这个【键】,【返回null】 */" public static void function_1()&#123; //创建集合对象,作为键的对象整数,值的对象存储字符串 Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "a"); map.put(2, "b"); map.put(3, "c"); System.out.println(map); String value = map.get(4);//null System.out.println(value); &#125; "/* * 将键值对存储到集合中 * V put(K,V) K 作为键的对象, V作为值的对象 * 返回值：以前与 key 关联的值，如果没有针对 key 的映射关系，则返回 null。 * 存储的是重复的键,将原有的值,覆盖 * 返回值一般情况下返回null, * 存储重复键的时候,返回被覆盖之前的值 */" public static void function()&#123; //创建集合对象,HashMap,存储对象,键是字符串,值是整数 Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put("a", 1); map.put("b", 2); map.put("c", 3); System.out.println(map); &#125; &#125; 03Map集合遍历方式keySet方法1234567891011121314151617181920212223242526272829303132333435363738394041424344A:Map集合遍历方式"keySet方法" 1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键 2.遍历键的Set集合，得到每一个键 3.根据键利用get(key)去Map找所对应的值 "/* * Map集合的遍历 * 利用键获取值 * Map接口中定义方法keySet * 所有的键,存储到Set集合 */" public class MapDemo1 &#123; public static void main(String[] args) &#123; "/* * 1. 调用map集合的方法keySet,所有的键存储到Set集合中 * 2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键) * 3. 调用map集合方法get,通过键获取到值 */" Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put("a", 11); map.put("b", 12); map.put("c", 13); map.put("d", 14); "//1. 调用map集合的方法keySet,所有的键存储到Set集合中" Set&lt;String&gt; set = map.keySet(); "//2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)" Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; "//it.next返回是Set集合元素,也就是Map中的键 //3. 调用map集合方法get,通过键获取到值" String key = it.next(); Integer value = map.get(key); System.out.println(key+"...."+value); &#125; System.out.println("======================="); // for Each方法更简便 for(String key : map.keySet())&#123; Integer value = map.get(key); System.out.println(key+"...."+value); &#125; &#125; &#125; 04Map集合Entry对象12345678910111213141516171819202122232425在Map类设计时，提供了一个"嵌套接口"："Entry"。Entry将"【键值对】的【对应关系】""封装成了对象"，即"键值对对象"。这样我们在遍历Map集合时，就可以从每一个"键值对（Entry）对象"中获取对应的"键"与对应的"值"。"entrySet()方法"：用于"返回"Map集合中所有的"键值对(Entry)对象"，以"Set集合"形式返回。A:Map集合Entry对象 interface Map&#123; interface Entry&#123;"//Entry是Map的一个【内部接口】，是static的" //由Map的子类的内部类实现 &#125; &#125; class HashMap&#123; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;//Entry对象指的就是该类的对象 final K key; V value; &#125; &#125; 在Map类设计时，提供了一个"嵌套接口：Entry"。 Entry将键值对的对应关系封装成了对象。 即"键值对对象"，这样我们在遍历Map集合时，就可以"从每一个键值对（Entry）对象中获取对应的键与对应的值"。 a:Entry是Map接口中提供的一个"静态内部嵌套接口"。 b:相关方法  "getKey()方法"：获取Entry对象中的"键"  "getValue()方法"：获取Entry对象中的"值"  "entrySet()方法"：用于"返回"Map集合中所有的"键值对(Entry)对象"，以"Set集合形式返回"。 05Map集合遍历方式entrySet方法123456789101112131415161718192021222324252627282930313233343536A:Map集合遍历方式"entrySet方法"* * Map集合获取方式 * entrySet方法,"键值对映射关系"获取 * 实现步骤: * 1. 调用map集合方法entrySet()将集合中的"映射关系对象","存储"到"Set集合" *" Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); *" 2." 迭代Set集合" * 3. 获取出的"Set集合的元素",是"映射关系对象Map.Entry&lt;K, V&gt;" * 4. 通过映射关系对象的方法" getKet(), getValue()"获取"键值对" * * 创建内部类对象 外部类.内部类 = new */public class MapDemo2 &#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "abc"); map.put(2, "bcd"); map.put(3, "cde"); "//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合" Set&lt;Map.Entry &lt;Integer,String&gt; &gt; set = map.entrySet(); "//2. 迭代Set集合" Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator(); while(it.hasNext())&#123; "// 3. 获取出的Set集合的元素,是映射关系对象 // it.next 获取的是Map.Entry对象" Map.Entry&lt;Integer, String&gt; entry = it.next(); "//4. 通过映射关系对象方法 getKet, getValue获取键值对" Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"...."+value); &#125; &#125;&#125; 06Map集合遍历方式增强for循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748A:Map集合遍历方式"增强for循环" A:Map集合遍历方式"entrySet方法"* * Map集合获取方式 * entrySet方法,"键值对映射关系"获取 * 实现步骤: * 1. 调用map集合方法entrySet()将集合中的"映射关系对象","存储"到"Set集合" *" Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); *" 2." 迭代Set集合" * 3. 获取出的"Set集合的元素",是"映射关系对象Map.Entry&lt;K, V&gt;" * 4. 通过映射关系对象的方法" getKet(), getValue()"获取"键值对" * * 创建内部类对象 外部类.内部类 = new */—————————————————————————————————————————————————————————————————————————————————————— "注意"：Map接口"没有"继承自"Iterable&lt;E&gt;接口"， "【不能】"直接使用"迭代器或者foreach"进行遍历。"转成Set之后"才可以使用。—————————————————————————————————————————————————————————————————————————————————————— public class MapDemo2 &#123; public static void main(String[] args) &#123; Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "abc"); map.put(2, "bcd"); map.put(3, "cde"); //1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合 Set&lt;Map.Entry &lt;Integer,String&gt; &gt; set = map.entrySet(); //2. 迭代Set集合 Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator(); while(it.hasNext())&#123; // 3. 获取出的Set集合的元素,是映射关系对象 // it.next 获取的是什么对象,也是Map.Entry对象 Map.Entry&lt;Integer, String&gt; entry = it.next(); //4. 通过映射关系对象方法 getKet, getValue获取键值对 Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"...."+value); &#125; System.out.println("========================="); for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125; &#125;—————————————————————————————————————————————————————————————————————————————————————— "注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。"—————————————————————————————————————————————————————————————————————————————————————— 07HashMap集合存储和遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110A:HashMap集合存储和遍历 "/* * 使用HashMap集合,存储自定义的对象 * 自定义对象,作为键,出现,作为值出现 */" public class HashMapDemo &#123; public static void main(String[] args) &#123; function_1(); &#125; "/* * HashMap 存储自定义对象Person,作为键出现 * 键的对象,是Person类型,值是字符串 * 保证键的唯一性,存储到键的对象,【【重写hashCode equals】】，见下面的Person类 */" public static void function_1()&#123; HashMap&lt;Person, String&gt; map = new HashMap&lt;Person, String&gt;(); map.put(new Person("a",20), "里约热内卢"); map.put(new Person("b",18), "索马里"); map.put(new Person("b",18), "索马里"); map.put(new Person("c",19), "百慕大"); for(Person key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"..."+value); &#125; System.out.println("==================="); for(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125; "/* * HashMap 存储自定义的对象Person,作为值出现 * 【【键的对象,是字符串,可以保证唯一性】】 */" public static void function()&#123; HashMap&lt;String, Person&gt; map = new HashMap&lt;String, Person&gt;(); map.put("beijing", new Person("a",20)); map.put("tianjin", new Person("b",18)); map.put("shanghai", new Person("c",19)); for(String key : map.keySet())&#123; Person value = map.get(key); System.out.println(key+"..."+value); &#125; System.out.println("================="); for(Map.Entry&lt;String, Person&gt; entry : map.entrySet())&#123; String key = entry.getKey(); Person value = entry.getValue(); System.out.println(key+"..."+value); &#125; &#125; &#125;public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; //重写方法hashCode和equals @Override public int hashCode()&#123; return this.name.hashCode()+this.age*31; &#125; @Override public boolean equals(Object obj)&#123; if(this == obj)&#123; return true; &#125; if(obj == null)&#123; return false; &#125; if(obj instanceof Person)&#123; Person p = (Person) obj; return Objects.equals(this.name,p.name) &amp;&amp; this.age==p.age;// return this.name.equals(p.name) &amp;&amp; this.age==p.age; &#125; return false; &#125;&#125; 08LinkedHashMap的特点12345678910111213141516*A:LinkedHashMap的特点 "/* * LinkedHashMap继承HashMap * 保证迭代的顺序,有序的HashMap */" public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; link = new LinkedHashMap&lt;String, String&gt;(); link.put("1", "a"); link.put("13", "a"); link.put("15", "a"); link.put("17", "a"); System.out.println(link); &#125; &#125; 09Hashtable的特点123456789101112131415161718192021*A:Hashtable的特点 * * "Map接口实现类 Hashtable" * 底层数据结果哈希表,特点和HashMap是一样的 * "Hashtable" "线程安全"集合,运行"速度慢" * "HashMap" "线程不安全"的集合,运行"速度快" * * Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代 * * "HashMap" "允许存储""null值,null键" * "Hashtable" "不允许存储""null值,null键" * * Hashtable他的孩子,"子类 Properties 依然活跃"在开发舞台 * public class HashtableDemo &#123; public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new Hashtable&lt;String,String&gt;(); map.put(null, null); System.out.println(map); &#125; &#125; 10静态导入1234567891011121314151617181920212223242526272829303132333435363738394041*A:静态导入:如果"本类"中有和"静态导入"的"同名方法"会"优先使用""本类"的 如果还想使用静态导入的,依然需要类名来调用 "/* * JDK1.5新特性,静态导入 * 减少开发的代码量 * 标准的写法,【导入包】的时候才能使用 * * import static java.lang.System.out;【最末尾】,【必须】是一个【静态成员】 */" import static java.lang.System.out; import static java.util.Arrays.sort; public class StaticImportDemo &#123; public static void main(String[] args) &#123; out.println("hello"); int[] arr = &#123;1,4,2&#125;; sort(arr); &#125; &#125;例如：Map.Entry的访问，简化后为Entryimport static java.util.Map.Entry;public class HashMapTest &#123; public static void main(String[] args) &#123; "//1,创建hashmap集合对象。" Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); "//取出元素。键值对方式" //Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); Set&lt;Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();//静态导入后，直接用Entry //for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; for (Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key.toString()+"....."+value); &#125; &#125;&#125; 11方法的可变参数12345678910111213141516171819202122232425262728293031323334353637*A:方法的可变参数 * * JDK1.5新的特性,"方法的可变参数" * 前提: 方法参数数据类型确定,"参数的个数""任意" * 可变参数语法: "数据类型...变量名" * "可变参数","本质"就是一个"数组" */ public class VarArgumentsDemo &#123; public static void main(String[] args) &#123; //调用一个带有可变参数的方法,传递参数,可以任意 // getSum(); int sum = getSum(5,34,3,56,7,8,0); System.out.println(sum); &#125; /* * 定义方法,计算10个整数和 * 方法的可变参数实现 */ public static int getSum(int...a)&#123; int sum = 0 ; for(int i : a)&#123; sum = sum + i; &#125; return sum; &#125; "可变参数","本质"就是一个"数组" private static void func(int ... arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; arr[i] *= 2; System.out.println(arr[i]); &#125; &#125; &#125; 12可变参数的注意事项123456789*A:可变参数的注意事项 * * 可变参数的注意事项 * 1. "一个方法中,【可变参数】"只能"有【一个】" * 2. 方法的"参数列表"中"可变参数"和"普通参数""都有"时,"必须"写在参数列表的"末尾位置（最后）" */ private static void funb(int a,int b,int ... arr)&#123; &#125; 13Collections工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667A:Collections工具类 * * 集合操作的工具类 * "Collections" * 均为"静态方法"，通过"Collections.方法名"进行调用 */ public class CollectionsDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* * Collections.shuffle方法 * 对List集合中的元素,进行随机排列 */" public static void function_2()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(5); list.add(9); list.add(11); list.add(8); list.add(10); list.add(15); list.add(20); System.out.println(list); //调用工具类方法shuffle对集合随机排列 Collections.shuffle(list); System.out.println(list); &#125; "/* * Collections.binarySearch静态方法 * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素 * ！！！注意：使用该方法前，"必须"先进行"排序" */" public static void function_1()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(5); list.add(8); list.add(10); list.add(15); list.add(20); //调用工具类静态方法binarySearch int index = Collections.binarySearch(list, 16); System.out.println(index); &#125; "/* * Collections.sort静态方法 * 对于List集合,进行"升序排列" */" public static void function()&#123; //创建List集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("ewrew"); list.add("qwesd"); list.add("Qwesd"); list.add("bv"); list.add("wer"); System.out.println(list); //调用集合工具类的方法sort Collections.sort(list); System.out.println(list); &#125; &#125; 14集合的嵌套123456789101112131415161718192021222324252627282930313233343536373839404142A:集合的嵌套/* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); keySet(czbk); &#125; 15集合的嵌套keySet遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980A:集合的嵌套keySet遍历 /* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); keySet(czbk); &#125; "//keySet() Iterator 遍历"public static void keySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)&#123;"//调用czbk集合方法keySet将键存储到Set集合"Set&lt;String&gt; classNameSet = czbk.keySet();"//迭代Set集合"Iterator&lt;String&gt; classNameIt = classNameSet.iterator();while(classNameIt.hasNext())&#123; "//classNameIt.next获取出来的是Set集合元素,czbk集合的键" String classNameKey = classNameIt.next(); "//czbk集合的方法get获取值,值是一个HashMap集合" HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey); "//调用classMap集合方法keySet,键存储到Set集合" Set&lt;String&gt; studentNum = classMap.keySet(); Iterator&lt;String&gt; studentIt = studentNum.iterator(); while(studentIt.hasNext())&#123; "//studentIt.next获取出来的是classMap的键,学号" String numKey = studentIt.next(); "//调用classMap集合中的get方法获取值" String nameValue = classMap.get(numKey); System.out.println(classNameKey+".."+numKey+".."+nameValue); &#125;&#125;System.out.println("==================================");"//keySet() forEach 遍历"for(String className: czbk.keySet())&#123; HashMap&lt;String, String&gt; hashMap = czbk.get(className); for(String numKey : hashMap.keySet())&#123; String nameValue = hashMap.get(numKey); System.out.println(className+".."+numKey+".."+nameValue); &#125;&#125;&#125;&#125; 16集合的嵌套entrySet遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384A:集合的嵌套entrySet遍历/* * Map集合的嵌套,Map中存储的还是Map集合 * 要求: * 传智播客 * Java基础班 * 001 张三 * 002 李四 * * Java就业班 * 001 王五 * 002 赵六 * 对以上数据进行对象的存储 * 001 张三 键值对 * Java基础班: 存储学号和姓名的键值对 * Java就业班: * 传智播客: 存储的是班级 * * 基础班Map &lt;学号,姓名&gt; * 传智播客Map &lt;班级名字, 基础班Map&gt; */public class MapMapDemo &#123; public static void main(String[] args) &#123; //定义基础班集合 HashMap&lt;String, String&gt; javase = new HashMap&lt;String, String&gt;(); //定义就业班集合 HashMap&lt;String, String&gt; javaee = new HashMap&lt;String, String&gt;(); //向班级集合中,存储学生信息 javase.put("001", "张三"); javase.put("002", "李四"); javaee.put("001", "王五"); javaee.put("002", "赵六"); //定义传智播客集合容器,键是班级名字,值是两个班级容器 HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk = new HashMap&lt;String, HashMap&lt;String,String&gt;&gt;(); czbk.put("基础班", javase); czbk.put("就业班", javaee); entrySet(czbk);&#125;"//entrySet() Iterator 遍历"public static void entrySet(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)&#123;"//调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合"Set&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameSet = czbk.entrySet();"//迭代器迭代Set集合"Iterator&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameIt = classNameSet.iterator();while(classNameIt.hasNext())&#123; "//classNameIt.next方法,取出的是czbk集合的键值对关系对象" Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classNameEntry = classNameIt.next(); //classNameEntry方法 getKey,getValue String classNameKey = classNameEntry.getKey(); "//获取值,值是一个Map集合" HashMap&lt;String,String&gt; classMap = classNameEntry.getValue(); "//调用班级集合classMap方法entrySet,键值对关系对象存储Set集合" Set&lt;Map.Entry&lt;String, String&gt;&gt; studentSet = classMap.entrySet(); "//迭代Set集合" Iterator&lt;Map.Entry&lt;String, String&gt;&gt; studentIt = studentSet.iterator(); while(studentIt.hasNext())&#123; "//studentIt方法next获取出的是班级集合的键值对关系对象" Map.Entry&lt;String, String&gt; studentEntry = studentIt.next(); //studentEntry方法 getKey getValue String numKey = studentEntry.getKey(); String nameValue = studentEntry.getValue(); System.out.println(classNameKey+".."+numKey+".."+nameValue); &#125;&#125; System.out.println("==================================");"//entrySet() Iterator 遍历"for (Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; me : czbk.entrySet()) &#123; String classNameKey = me.getKey(); HashMap&lt;String, String&gt; numNameMapValue = me.getValue(); for (Map.Entry&lt;String, String&gt; nameMapEntry : numNameMapValue.entrySet()) &#123; String numKey = nameMapEntry.getKey(); String nameValue = nameMapEntry.getValue(); System.out.println(classNameKey + ".." + numKey + ".." + nameValue); &#125;&#125;&#125;&#125; 17斗地主的功能分析12345678910111213141516171819A:斗地主的功能分析 a:具体规则： 1. 组装54张扑克牌 2. 将54张牌顺序打乱 3. 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4. 查看三人各自手中的牌（按照牌的大小排序）、底牌 b:分析: 1.准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 2.洗牌： 通过数字完成洗牌发牌 3.发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 4.看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 18斗地主的准备牌123456789101112131415161718192021222324252627282930313233343536A:斗地主的准备牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */ public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王,索引是从0~54,对应大王,小王,...3(牌的顺序从大到小) pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); &#125; 19斗地主的洗牌123456789101112131415161718192021222324252627282930313233343536373839404142A:斗地主的洗牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */ public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); &#125; &#125; 20斗地主的发牌123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566A:斗地主的发牌/* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); //发牌功能,将牌编号,发给玩家集合,底牌集合 ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;(); //发牌采用的是集合索引%3 for(int i = 0 ; i &lt; pookerNumber.size() ; i++)&#123; //先将底牌做好 if(i &lt; 3)&#123; //存到底牌去 bottom.add( pookerNumber.get(i)); //对索引%3判断 &#125;else if(i % 3 == 0)&#123; //索引上的编号,发给玩家1 player1.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 1)&#123; //索引上的编号,发给玩家2 player2.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 2)&#123; //索引上的编号,发给玩家3 player3.add( pookerNumber.get(i) ); &#125; &#125; &#125; &#125; 21斗地主的看牌1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283A:斗地主的看牌 /* * 实现模拟斗地主的功能 * 1. 组合牌 * 2. 洗牌 * 3. 发牌 * 4. 看牌 */public class DouDiZhu &#123; public static void main(String[] args) &#123; //1. 组合牌 //创建Map集合,键是编号,值是牌 HashMap&lt;Integer,String&gt; pooker = new HashMap&lt;Integer, String&gt;(); //创建List集合,存储编号 ArrayList&lt;Integer&gt; pookerNumber = new ArrayList&lt;Integer&gt;(); //定义出13个点数的数组 String[] numbers = &#123;"2","A","K","Q","J","10","9","8","7","6","5","4","3"&#125;; //定义4个花色数组 String[] colors = &#123;"♠","♥","♣","♦"&#125;; //定义整数变量,作为键出现 int index = 2; //遍历数组,花色+点数的组合,存储到Map集合 for(String number : numbers)&#123; for(String color : colors)&#123; pooker.put(index, color+number); pookerNumber.add(index); index++; &#125; &#125; //存储大王,和小王 pooker.put(0, "大王"); pookerNumber.add(0); pooker.put(1, "小王"); pookerNumber.add(1); //洗牌,将牌的编号打乱 Collections.shuffle(pookerNumber); //发牌功能,将牌编号,发给玩家集合,底牌集合 ArrayList&lt;Integer&gt; player1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; player3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; bottom = new ArrayList&lt;Integer&gt;(); //发牌采用的是集合索引%3 for(int i = 0 ; i &lt; pookerNumber.size() ; i++)&#123; //先将底牌做好 if(i &lt; 3)&#123; //存到底牌去 bottom.add( pookerNumber.get(i)); //对索引%3判断 &#125;else if(i % 3 == 0)&#123; //索引上的编号,发给玩家1 player1.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 1)&#123; //索引上的编号,发给玩家2 player2.add( pookerNumber.get(i) ); &#125;else if( i % 3 == 2)&#123; //索引上的编号,发给玩家3 player3.add( pookerNumber.get(i) ); &#125; &#125; //对玩家手中的编号排序 Collections.sort(player1); Collections.sort(player2); Collections.sort(player3); //看牌,将玩家手中的编号,到Map集合中查找,根据键找值 //定义方法实现 look("刘德华",player1,pooker); look("张曼玉",player2,pooker); look("林青霞",player3,pooker); look("底牌",bottom,pooker);&#125; public static void look(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; pooker)&#123; //遍历ArrayList集合,获取元素,作为键,到集合Map中找值 System.out.print(name+" "); for(Integer key : player)&#123; String value = pooker.get(key); System.out.print(value+" "); &#125; System.out.println();&#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础17(List接口、Set接口以及其实现的集合类，哈希表(Hash table))]]></title>
    <url>%2F2016%2F10%2F28%2Fday19%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、List接口2、ArrayList集合、LinkedList集合3、Set接口4、哈希表(Hash table)5、HashSet集合、LinkedHashSet集合6、判断集合唯一性原理 01List接口的特点12345678910A:List接口的特点:a:"它是一个元素【存取有序】的集合。" 例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。b:"它是一个【带有索引】的集合"，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 c:"集合中【可以有重复】的元素"，通过元素的equals方法，来比较是否为重复的元素。 d:List接口的常用子类有： ArrayList集合 LinkedList集合 02List接口的特有方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576A:List接口的特有方法(带索引的方法)a:增加元素方法 add(Object e)："向集合末尾处，添加指定的元素"  add(int index, Object e) "向集合指定索引处，添加指定的元素，原有元素依次后移" /* * add(int index, E) * 将元素插入到列表的指定索引上 * 带有索引的操作,防止越界问题 * java.lang.IndexOutOfBoundsException * ArrayIndexOutOfBoundsException * StringIndexOutOfBoundsException */ public static void function()&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); list.add("abc4"); System.out.println(list); list.add(1, "itcast"); System.out.println(list); &#125;——————————————————————————————————————————————————————————————————————————————————————————b:删除元素删除 remove(Object e)："将指定元素对象，从集合中删除，返回值为被删除的元素" remove(int index)："将指定索引处的元素，从集合中删除，返回值为被删除的元素" /* * E remove(int index) * 移除指定索引上的元素 * 返回被删除之前的元素 */ public static void function_1()&#123; List&lt;Double&gt; list = new ArrayList&lt;Double&gt;(); list.add(1.1); list.add(1.2); list.add(1.3); list.add(1.4); Double d = list.remove(0); System.out.println(d); System.out.println(list); &#125;——————————————————————————————————————————————————————————————————————————————————————————c:替换元素方法 set(int index, Object e)："将指定索引处的元素，替换成指定的元素，返回值为替换前的元素"注意："指定的索引【必须】是List集合的有效索引"、例如集合长度是4，就不能指定替换索引为4处的元素。也就是说，set(int index, Object element)方法"【不会改变】List集合的【长度】" " /* * E set(int index, E) * 修改指定索引上的元素 * 返回【被修改之前】的元素 */" public static void function_2()&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); Integer i = list.set(0, 5); System.out.println(i); System.out.println(list); &#125;d:查询元素方法 get(int index)：获取指定索引处的元素，并返回该元素——————————————————————————————————————————————————————————————————————————————————————————e:指定元素的索引 indexOf int indexOf(Object o)"返回此列表中第一次出现的【指定元素的索引】；如果此列表不包含该元素，则返回 -1。"更确切地讲，返回满足 (o==null ? get(i)==null : o.equals(get(i))) 的"最低索引 i"；如果没有这样的索引，则返回 -1。 03迭代器的并发修改异常123456789101112131415161718192021222324252627282930313233343536373839A:迭代器的并发修改异常 "/* * 迭代器的并发修改异常 java.util.ConcurrentModificationException (并发修改异常) * 就是在遍历的过程中,使用了集合方法【修改】了【集合的长度】,不允许的 */" public class ListDemo1 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); list.add("abc4"); //对集合使用迭代器进行获取,获取时候判断集合中是否存在 "abc3"对象 //如果有,添加一个元素 "ABC3" Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); //对获取出的元素s,进行判断,是不是有"abc3" if(s.equals("abc3"))&#123; "添加一个元素 "ABC3",造成集合长度变化，抛出异常" list.add("ABC3");//error "修改指定索引的元素为"ABC3",【没有】造成集合长度变化，正常运行" list.set(list.indexOf("abc3"),"ABC3");//正常运行 &#125; System.out.println(s); &#125; &#125; &#125;运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？在迭代过程中，使用了集合的方法对元素进行操作。"导致迭代器并不知道集合中的变化，容易引发数据的不确定性"。"并发修改异常解决办法"："在迭代时，【不要使用】集合的方法操作元素"。或者"通过ListIterator迭代器操作元素是可以"的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。 04数据的存储结构12345678910A:数据的存储结构 a:栈结构:"后进先出/先进后出"(手枪弹夹) FILO (first in last out) b:队列结构:"先进先出/后进后出"(银行排队) FIFO(first in first out) c:数组结构: "【查询快】:通过索引快速找到元素" "【增删慢】:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中" " 开辟新数组耗费资源" d:链表结构 " 【查询慢】:每次都需要从链头或者链尾找起" "【增删快】:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素" 05ArrayList集合的自身特点1234567891011A:ArrayList集合的自身特点 底层采用的是数组结构 ArrayList al=new ArrayList();//创建了一个长度为0的Object类型数组 al.add("abc");"//底层会创建一个长度为10的Object数组 "Object[] obj=new Object[10] //obj[0]="abc" "//如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组" "//把原数组中的元素【拷贝】(Arrays.copyOf)到新数组,再把最后一个元素添加到新数组中"原数组: a b c d e f g h k l添加m: a b c d e f g h k l m null null null null 06LinkedList集合的自身特点123456789101112131415A:LinkedList集合的自身特点"底层采用链表结构,每次查询都要从【链头】或【链尾】找起,【查询】相对数组【较慢】""但是【删除元素】直接【修改元素记录的地址值】即可,不需要大量移动元素，【增删】相对数组【较快】"LinkedList的"索引"决定是从"链头"开始找还是从"链尾"开始找"如果该元素【小于】元素长度一半,从【链头】开始找起；如果【大于】元素长度的一半,则从【链尾】找起"实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在"列表的开头及结尾" get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将"链接列表"用作"堆栈、队列"或双端队列。LinkedList集合数据存储的结构是链表结构。"方便元素添加、删除的集合"。实际开发中对一个集合元素的添加与删除经常涉及到"首尾操作"，而LinkedList提供了大量"首尾操作"的方法 07LinkedList特有方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 *A:LinkedList特有方法:获取,添加,删除 * * LinkedList 链表集合的特有功能 * "自身特点: 链表底层实现,查询慢,增删快" * "* 子类的特有功能,不能多态调用，只能向下强制转换" * public class LinkedListDemo &#123; public static void main(String[] args) &#123; function_3(); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * E removeFirst() 移除并返回链表的开头 * E removeLast() 移除并返回链表的结尾 */ public static void function_3()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.add("1"); link.add("2"); link.add("3"); link.add("4"); String first = link.removeFirst(); String last = link.removeLast(); System.out.println(first); System.out.println(last); System.out.println(link); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * E getFirst() 获取链表的开头 * E getLast() 获取链表的结尾 */ public static void function_2()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.add("1"); link.add("2"); link.add("3"); link.add("4"); if(!link.isEmpty())&#123; String first = link.getFirst(); String last = link.getLast(); System.out.println(first); System.out.println(last); &#125; &#125; public static void function_1()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.addLast("a"); link.addLast("b"); link.addLast("c"); link.addLast("d"); link.addFirst("1"); link.addFirst("2"); link.addFirst("3"); System.out.println(link); &#125;———————————————————————————————————————————————————————————————————————————————————— /* * addFirst(E) 添加到链表的开头 * addLast(E) 添加到链表的结尾 */ public static void function()&#123; LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;(); link.addLast("heima"); link.add("abc"); link.add("bcd"); link.addFirst("itcast"); System.out.println(link); &#125; &#125; 08Vector类的特点12345*A:Vector类的特点 Vector集合数据存储的结构是数组结构，为JDK中"最早"提供的"集合",它是"线程同步"的 Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。 此接口Enumeration的功能与 Iterator 接口的功能是类似的。 " Vector集合已被 ArrayList【替代】。枚举Enumeration 已被 迭代器Iterator【替代】"。 09Set接口的特点12345678910Set接口类似于个"罐子"，"程序可以依次把多个对象“丢进”Set集合"，集合通常"不能"记住"元索的添加顺序"。"Set集合与Collection基本相同"，"【没有】提供【任何】【额外的方法】"。实际上Set就是Collection，只是行为略有不同("Set不允许包含重复元素")。A:Set接口的特点 a:它是个"【不包含】重复元素"的集合。 b:Set集合取出元素的方式可以采用："【迭代器】、【增强for】"。"不能通过索引进行取值"。 HashSet"没有提供get()方法"，同HashMap一样，"Set内部是无序的"，只能通过迭代的方式获得 c:Set集合有多个子类，这里我们介绍其中的"HashSet、LinkedHashSet"这两个集合。 10Set集合存储和迭代12345678910111213141516171819202122232425262728293031A:Set集合存储和迭代"HashSet类(散列集) 实现 Set 接口，由哈希表Hash table（实际上是一个 HashMap 实例）支持"。它"【不保证】 set 的迭代顺序"；"特别是它【不保证】该顺序恒久不变"。此类允许"使用 null 元素" "/* * Set接口,特点不重复元素,没索引 * * Set接口的实现类,HashSet * 特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素 * 代码的编写上,和ArrayList完全一致 */" public class HashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add("cn"); set.add("heima"); set.add("java"); set.add("java"); set.add("itcast"); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; System.out.println("=============="); for(String s : set)&#123; System.out.println(s); &#125; &#125; &#125; 11哈希表的数据结构1234567891011A:哈希表的数据结构:(参见图解)"加载因子:表中填入的记录数 / 哈希表的长度"例如:加载因子是0.75 代表: 数组中的16个位置,其中存入16*0.75=12个元素如果在存入第13个(&gt;12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会"扩充哈希表(再哈希 Rehash)",底层会"开辟一个长度为原长度2倍的数组",把老元素拷贝到新数组中,再把新元素添加数组中 当存入"元素数量" &gt; "哈希表长度*加载因子",就要"扩容",因此"加载因子决定扩容时机" 12字符串对象的哈希值(HashCode)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354A:字符串对象的哈希值"/** 对象的哈希值,普通的十进制整数* 父类Object,方法 public int hashCode() 计算结果int整数*/"举例：StringBuilder sb = new StringBuilder("abc");StringBuilder tb = new StringBuilder("abc");int s = sb.hashCode();int t = tb.hashCode();System.out.println("s: " + s);"//StringBuilder没有重写HashCode方法，返回对象的内存地址值"System.out.println("t: " + t);//StringBuilder没有重写HashCode方法，返回对象的内存地址值System.out.println(sb.equals(tb));"//比较的是对象的内存地址值"System.out.println("————————————————————————————————————————1");String ss= new String("abc");"//String重写HashCode方法，根据内容的值进行计算"String st = "abc";System.out.println("ss.hashCode(): " + ss.hashCode());System.out.println("st.hashCode(): " + st.hashCode());System.out.println(ss.equals(st));"//比较的是对象的内容是否完全相同"——————————————————————————————————————————————————————————————————————————————————————————public class HashDemo &#123; public static void main(String[] args) &#123; Person p = new Person(); int i = p.hashCode(); System.out.println(i); String s1 = new String("abc"); String s2 = new String("abc"); System.out.println(s1.hashCode());//96354 System.out.println(s2.hashCode());//96354 "两个【不同】字符串的hashCode值完全可能【相同】" System.out.println("重地".hashCode());//1179395 System.out.println("通话".hashCode());//1179395 &#125;&#125;//String类重写hashCode()方法//字符串都会存储在底层的value数组中&#123;'a','b','c'&#125;public int hashCode() &#123; int h = hash;//hash初值为0 if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; 13哈希表的存储过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657A:哈希表的存储原理当向哈希表中"存放元素"时，需要根据元素的"特有数据结合相应的算法"，这个算法其实就是"Object类中的【hashCode方法】"。由于任何对象都是Object类的子类，所以"任何对象都拥有这个方法"。即就是"在给哈希表中【存放对象】时，会【调用】对象的【hashCode方法】"，这里需要注意：算出对象在表中的存放位置，如果"两个对象hashCode方法算出【结果一样】"，这样现象称为"哈希冲突"，这时会调用对象的"equals方法"，比较这"两个对象【是不是】同一个对象"，(1)如果"equals方法返回的是true"，那么就"不会"把第二个对象存放在哈希表中，(2)如果"返回的是false"，就会"把这个值存放在哈希表中"。总结："保证HashSet集合元素的唯一"，其实就是根据"对象的 hashCode和 equals 方法"来决定的。！！！如果我们往集合中存放"自定义的对象"，那么保证其唯一，就"必须""重写hashCode和equals方法"建立属于当前对象的比较方式。——————————————————————————————————————————————————————————————————————————————————————————B:哈希表的存储过程 public static void main(String[] args) &#123; HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(new String("abc")); set.add(new String("abc")); set.add(new String("bbc")); set.add(new String("bbc")); System.out.println(set); &#125;存取原理:每存入一个新的元素都要走以下三步:1.首先调用"本类的hashCode()方法"算出哈希值2."在容器中找是否与【新元素】【哈希值相同】的【老元素】", "如果没有直接存入" 如果有转到第三步3."新元素会与该索引位置下的老元素利用equals方法"一一对比 一旦"新元素.equals(老元素)"返回true,停止对比,"说明重复","不再存入" 如果与该索引位置下的老元素都通过equals方法对比返回false,说明"没有重复","存入"——————————————————————————————————————————————————————————————————————————————————————————举例：HashSet&lt;String&gt; hset = new HashSet&lt;&gt;(); hset.add("abc");"//hashCode: 96354" hset.add("abc"); hset.add("ad%");"//hashCode: 96354" hset.add("yut"); System.out.println(hset);上述代码：第1行： "abc"的hashCode 为 96354第2行： "abc"的hashCode 为 96354，调用新元素.equals(老元素)，即"abc".equals("abc")结果为true,说明"元素重复，不添加到HashSet中";第3行： "ad%"的hashCode 也为 96354，调用新元素.equals(老元素)，即"ad%".equals("abc")结果为false，"没有元素重复，添加到HashSet中"; —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— 14HashSet存储自定义的对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152A:HashSet存储自定义的对象 "/* * HashSet集合的自身特点: * 底层数据结构,哈希表 * 存储,取出都比较快 * 线程不安全,运行速度快 */" public class HashSetDemo1 &#123; public static void main(String[] args) &#123; //将Person对象中的姓名,年龄,相同数据,看作同一个对象 "//判断对象是否重复,依赖对象自己的方法 hashCode(),equals()" HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;(); setPerson.add(new Person("a",11)); setPerson.add(new Person("b",10));"hashCode方法返回对象的地址值，地址值不同，会存入HashSet" setPerson.add(new Person("b",10));"hashCode方法返回对象的地址值，地址值不同，会存入HashSet" setPerson.add(new Person("c",25)); setPerson.add(new Person("d",19)); setPerson.add(new Person("e",17));"//每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】,【直接存入】" System.out.println(setPerson); &#125; &#125;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String toString()&#123; return name+".."+age; &#125; &#125; 15自定义对象重写hashCode和equals方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 A:自定义对象重写hashCode和equals方法"给HashSet中存放【自定义类型元素】时，需要【重写】对象中的hashCode和equals方法，建立【自己的比较方式】，才能【保证】HashSet集合中的【对象唯一】" "/* * HashSet集合的自身特点: * 底层数据结构,哈希表 * 存储,取出都比较快 * 线程不安全,运行速度快 */" public class HashSetDemo1 &#123; public static void main(String[] args) &#123; //将Person对象中的姓名,年龄,相同数据,看作同一个对象 "//判断对象是否重复,依赖【对象自己】的方法 hashCode,equals" HashSet&lt;Person&gt; setPerson = new HashSet&lt;Person&gt;(); setPerson.add(new Person("a",11)); setPerson.add(new Person("b",10)); setPerson.add(new Person("b",10)); setPerson.add(new Person("c",25)); setPerson.add(new Person("d",19)); setPerson.add(new Person("e",17)); System.out.println(setPerson); &#125; &#125; public class Person &#123; private String name; private int age;"/** 没有做重写父类(Obejct类)的hashCode和equals方法,每次运行结果都是不同整数， 因为每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】* 如果子类重写父类hashCode和equals方法,将会得到自定义的哈希值* 存储到HashSet集合的依据：用hashCode和equals方法进行判断* * 尽可能让不同的属性值产生不同的哈希值(优化hashCode的产生方法),这样就不用再调用equals方法去比较属性**/" public int hashCode()&#123; return name.hashCode()+age*55; &#125; //方法equals重写父类,保证和父类相同 //public boolean equals(Object obj)&#123;&#125; public boolean equals(Object obj)&#123; if(this == obj) return true; if(obj == null) return false; if(obj instanceof Person)&#123; Person p = (Person)obj; return name.equals(p.name) &amp;&amp; age==p.age; &#125; return false; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Person()&#123;&#125; public String toString()&#123; return name+".."+age; &#125; &#125; 16LinkedHashSet集合123456789101112131415161718192021A:LinkedHashSet集合 " /* * LinkedHashSet 基于【链表】的【哈希表】实现 * 继承自HashSet："有序"的hashSet * * LinkedHashSet 自身特性,"具有顺序",存储和取出的顺序相同 * 线程不安全的集合,"运行速度块" */" public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; LinkedHashSet&lt;Integer&gt; link = new LinkedHashSet&lt;Integer&gt;(); link.add(123); link.add(44); link.add(33); link.add(33); link.add(66); link.add(11); System.out.println(link); &#125; &#125; 17ArrayList,HashSet判断对象是否重复的原理12345678910111213141516171819202122232425262728ArrayList,HashSet判断对象是否重复的原理1： "ArrayList的【contains方法】判断元素是否重复"a:"ArrayList的【contains方法】原理:【底层依赖于】【equals方法】"ArrayList的【contains方法】会使用调用方法时， "传入的元素的equals方法依次与集合中的旧元素所比较"， 从而根据返回的布尔值判断是否有重复元素。b:"当ArrayList存放【自定义类型】时"，由于自定义类型在"未重写equals方法"之前， "判断是否重复的依据是内存地址值"，"所以如果想根据【内容】判断是否为重复元素，需要【重写】元素的equals方法"。——————————————————————————————————————————————————————————————————————————————————————————2: "HashSet的add/contains等方法判断元素是否重复""HashSet的【add()方法和contains方法()】【底层】都【依赖】 hashCode()方法与equals方法()"Set集合"不能"存放重复元素，"其add()方法在添加时会判断是否有重复元素，"有重复【不】添加"，"没重复则添加""。HashSet集合由于是"无序"的，其判断唯一的依据是元素类型的"hashCode与equals方法的返回结果"。规则如下：先判断新元素与集合内已经有的旧元素的"HashCode值"1): 如果"不同"，说明是"不同元"素，"添加到集合"。2): 如果"相同"，再"判断equals比较结果"。返回true则"相同元素"，"不予添加"； 返回false则"不同元素"，"添加到集合"。——————————————————————————————————————————————————————————————————————————————————————————总结：使用"HashSet""存储【自定义类型】"时，如果"没有重写"该类的hashCode与equals方法，则判断重复时，使用的是"内存地址值"，如果想通过"【内容】比较元素是否相同"，"需要重写"该元素类的hashcode与equals方法。 18hashCode和equals方法的面试题12345678910111213141516171819202122232425262728293031 A:hashCode和equals的面试题 两个对象 Person p1 p2 问题: (1)"如果两个对象的哈希值相同" p1.hashCode()==p2.hashCode() 两个对象的equals一定返回true吗 p1.equals(p2) 一定是true吗 正确答案:"p1.equals(p2)不一定"是true (2)"如果两个对象的equals方法返回true",p1.equals(p2)==true 两个对象的"哈希值一定相同"吗 正确答案: "哈希值一定相同"——————————————————————————————————————————————————————————————————————————————————————————在 Java 应用程序执行期间，"规定"：1."如果根据 equals(Object) 方法"，"两个对象是相等"的，那么对这两个对象中的每个对象调用 "hashCode 方法"都"必须生成相同的整数结果"。 2.如果根据 equals(java.lang.Object) 方法，"两个对象【不相等】"，那么对这两个对象中的任一对象上调用" hashCode 方法" "不要求"一定"生成不同的整数结果"。此时，hashCode值(可以"相同"也"可以不同") 2.1 两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法"哈希值""可相同"两个对象调用hashCode()方法哈希值不同=====&gt;equals返回true2.2 两个对象不同(对象属性值不同) equals返回false=====&gt;两个对象调用hashCode()方法"哈希值""可不同"两个对象调用hashCode()方法哈希值相同=====&gt;equals返回true"所以说两个对象【哈希值】无论【相同】还是【不同】,equals都可能返回"true 小结123456789101112131415161718192021222324252627282930 List与Set集合的区别？List: 它是一个有序的集合(元素存与取的顺序相同) 它可以存储重复的元素 Set: 它是一个无序的集合(元素存与取的顺序可能不同) 它不能存储重复的元素 List集合中的特有方法 void add(int index, Object element) 将指定的元素，添加到该集合中的指定位置上 Object get(int index)返回集合中指定位置的元素。 Object remove(int index) 移除列表中指定位置的元素, 返回的是被移除的元素 Object set(int index, Object element)用指定元素替换集合中指定位置的元素,返回值的更新前的元素 ArrayList: 底层数据结构是数组，查询快，增删慢 LinkedList: 底层数据结构是链表，查询慢，增删快 HashSet: 元素唯一，不能重复 底层结构是 哈希表结构 元素的存与取的顺序不能保证一致 如何保证元素的唯一的？ 重写hashCode() 与 equals()方法 LinkedHashSet: 元素唯一不能重复 底层结构是 哈希表结构 + 链表结构 元素的存与取的顺序一致]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础16(集合Collecton,Iterator迭代器,增强for循环,泛型)]]></title>
    <url>%2F2016%2F10%2F26%2Fday18%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、集合2、Iterator迭代器3、增强for循环4、泛型 01集合使用的回顾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 *A:集合使用的回顾 *a.ArrayList集合存储5个int类型元素 public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(111); list.add(222); list.add(333); list.add(444); list.add(555); for(int i=0; i&lt;list.size(); i++)&#123; System.out.println(list.get(i)); &#125; &#125; *b.ArrayList集合存储5个Person类型元素public class Person &#123; private String name; private int age; public Person()&#123; super(); &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写toString()方法 @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;public class ArraryListDemo &#123; public static void main(String[] args) &#123; ArrayList &lt;Person&gt; aa = new ArrayList&lt;Person&gt;(); aa.add(new Person("a",23)); aa.add(new Person("b",52)); aa.add(new Person("c",36)); for(Person p : aa)&#123; System.out.println(p);//默认调用toString()方法 &#125; &#125;&#125; 02集合的学习目标12345 集合，集合是java中提供的一种容器，可以用来存储多个数据。 在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，它们有啥区别呢？  "数组的长度是固定的。【集合】的【长度】是【可变】的。"  " 集合中存储的元素【必须】是【引用类型数据】" 03集合继承关系图123456789101112131415161718192021222324252627A:集合继承关系图 a:ArrayList的继承关系: 查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口 "Collection接口为【最顶层】【集合接口】了"。 源代码： interface List extends Collection &#123; &#125; public class ArrayList extends AbstractList implements List&#123; &#125;b:集合继承体系 "这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。那么，实现Collection接口的所有子类都会进行方法重写。  Collecton接口常用的子接口有：List接口、Set接口  List接口常用的子类有：ArrayList类、LinkedList类  Set接口常用的子类有：HashSet类、LinkedHashSet类 Collection 接口 | ---------------------------------------------------------------- | | List接口 Set接口 | | ---------------- ------------- | | | |ArrayList类 LinkedList类 HashSet类 LinkedHashSet类" 04集合Collection的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879A:集合Collection的方法 "/* * Collection接口中的方法 * 是集合中所有实现类必须拥有的方法 * 使用Collection接口的实现类,程序的演示 * ArrayList implements List * List extends Collection * 方法的执行,都是实现的重写 */" public class CollectionDemo &#123; public static void main(String[] args) &#123; function_2(); &#125; "/* Collection接口方法 * Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组 * 返回是一个存储对象的数组, 数组存储的数据类型是Object */" private static void function_2() &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); Object[] objs = coll.toArray(); for(int i = 0 ; i &lt; objs.length ; i++)&#123; System.out.println(objs[i]); &#125; &#125; "/* * 学习Java中三种长度表现形式 * —————————————————————————————————— * 数组.length 属性 返回值 int * —————————————————————————————————— * 字符串.length() 方法,返回值int * —————————————————————————————————— * 集合.size()方法, 返回值int */" "/* * Collection接口方法 * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true * 如果此 collection 包含【指定的元素】，则返回 true * 方法参数是Object类型 */" private static void function_1() &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); boolean b = coll.contains("itcast"); System.out.println(b); &#125; "/* * Collection接口的方法 * void clear() 清空集合中的所有元素 * 集合容器本身依然存在 */" public static void function()&#123; //接口多态的方式调用 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("bcd"); System.out.println(coll); coll.clear(); System.out.println(coll); &#125; &#125; 05集合Collection的remove方法1234567891011121314151617181920212223242526A:05集合Collection的remove方法 "/* * Collection接口方法 * boolean remove(Object o)移除集合中指定的元素 * 如果集合中包含多个相同的元素，remove方法只删除出现的第一个元素。 * * * 另外： * boolean removeAll(Collection&lt;?&gt; c) * 移除此 collection 中那些也包含在【指定 collection 】中的【所有元素】（可选操作）。 * 此调用返回后，collection 中将不包含任何与指定 collection 相同的元素。 */" private static void function_3()&#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("money"); coll.add("itcast"); coll.add("itheima"); coll.add("money"); coll.add("123"); System.out.println(coll); boolean b = coll.remove("money"); System.out.println(b); System.out.println(coll); &#125; 06迭代器的概述1234567891011A:迭代器概述:a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种"通用的获取方式"来完成。b:"Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为【迭代】。"c:"每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,我们都会有判断是否有元素以及取出里面的元素的动作,那么Java为我们提供一个【迭代器】定义了【统一的判断元素和取元素的方法】" 07迭代器的实现原理123456789101112131415161718 *A:迭代器的实现原理" /* * 集合中的迭代器: * 获取集合中元素方式 * 接口 Iterator : 两个抽象方法 * boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true * next() 取出集合中的下一个元素 * ———————————————————————————————————————————————————————————————————— * Iterator接口,找实现类. * Collection接口定义了iterator方法： * Iterator&lt;E&gt; iterator() * 返回在此 collection 的元素上进行迭代的迭代器 *———————————————————————————————————————————————————————————————————— * ArrayList类 重写方法 iterator(),返回了Iterator接口的实现类的对象 * 使用ArrayList集合的对象 * Iterator it =array.iterator(),运行结果就是Iterator接口的实现类ArrayList的对象 * it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代 */" 08迭代器的代码实现1234567891011121314151617181920212223242526*A:迭代器的代码实现 public class IteratorDemo &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); coll.add("abc4"); //迭代器,对集合ArrayList中的元素进行取出 //调用集合的方法iterator()获取出,Iterator接口的实现类的对象 Iterator&lt;String&gt; it = coll.iterator(); //接口实现类对象,调用方法hasNext()判断集合中是否有元素 //boolean b = it.hasNext(); //System.out.println(b); //接口的实现类对象,调用方法next()取出集合中的元素 //String s = it.next(); //System.out.println(s); //迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; &#125; &#125; 09迭代器的执行过程12345678910111213141516171819202122232425A:迭代器的执行过程 a:迭代器的原理: while(it.hasNext()) &#123; System.out.println(it.next()); &#125; //cursor记录的索引值不等于集合的长度返回true,否则返回false public boolean hasNext() &#123; return cursor != size; //cursor初值为0 &#125; //next()方法作用: //①返回cursor指向的当前元素 //②cursor++ public Object next() &#123; int i = cursor; cursor = i + 1; return elementData[lastRet = i]; &#125; b:for循环迭代写法: for (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext(); ) &#123; System.out.println(it2.next()); &#125; 10集合迭代中的转型12345678910111213141516171819202122232425262728293031323334A:集合迭代中的转型 a:在使用集合时，我们需要注意以下几点：  "集合中存储其实都是【对象的地址】"。  "集合中可以存储基本数值"：jdk1.5版本以后可以存储了。 "因为出现了【基本类型】的【包装类】，它提供了【自动装箱】操作（基本类型对象）"， 这样，"集合中的元素就是【基本数值】的【包装类】对象"。b:"存储时提升了Object。取出时要使用元素的【特有内容】，必须【向下转型】"。 "可以【不指定】【集合的存储类型】，即可以添加 Object 对象(任意对象)"，如下所示： Collection coll = new ArrayList(); coll.add("abc"); coll.add("aabbcc"); coll.add("shitcast"); Iterator it = coll.iterator(); while (it.hasNext()) &#123; //由于元素被存放进集合后全部被提升为Object类型 //当需要使用子类对象特有方法时，需要向下转型 String str = (String) it.next(); System.out.println(str.length()); &#125;" 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。"c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下： Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("aabbcc"); coll.add("shitcast"); Iterator&lt;String&gt; it = coll.iterator(); while (it.hasNext()) &#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; 11增强for循环遍历数组123456789101112131415161718192021222324252627282930313233*A:增强for循环遍历数组 a:格式: "/* * JDK1.5新特性,增强for循环 * JDK1.5版本后,出现新的接口 java.lang.Iterable * Collection开是继承Iterable * Iterable作用,实现增强for循环 * * 格式: * for( 数据类型 变量名 : 数组或者集合 )&#123; * sop(变量); * &#125; */" public static void function_1()&#123; "for each对于对象数组遍历的时候,可以【调用】【对象的方法】" String[] str = &#123;"abc","itcast","cn"&#125;; for(String s : str)&#123; System.out.println(s.length()); &#125; &#125; "/* * 实现for循环,遍历数组 * 好处: 代码少了,方便对容器遍历 * 弊端: 没有索引,不能操作容器里面的元素 */" public static void function()&#123; int[] arr = &#123;3,1,9,0&#125;; for(int i : arr)&#123; System.out.println(i+1); &#125; System.out.println(arr[0]); &#125; 12增强for循环遍历集合12345678910111213A:增强for循环遍历集合 " /* * 增强for循环遍历集合 * 存储自定义Person类型 */" public static void function_2()&#123; ArrayList&lt;Person&gt; array = new ArrayList&lt;Person&gt;(); array.add(new Person("a",20)); array.add(new Person("b",10)); for(Person p : array)&#123; System.out.println(p);// System.out.println(p.toString()); &#125; &#125; 13泛型的引入12345678910111213141516171819202122232425A:泛型的引入"在前面学习集合时，我们都知道集合中是可以【存放任意对象】的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用【类型转换】。"比如下面程序：public class GenericDemo &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add("abc"); list.add("itcast"); list.add(5);"//由于集合没有做任何限定，任何类型都可以存放" "//自动装箱:Object obj=new Integer(5);" Iterator it = list.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next();//String str=(String)obj; "//编译时期仅检查语法错误,String是Object的子类可以向下转型 //运行时期String str=(String)(new Integer(5)) //String与Integer没有父子关系所以转换失败 //程序在运行时发生了问题java.lang.ClassCastException" System.out.println(str.length()); &#125; &#125;&#125; 14泛型的定义和使用12345678910111213141516171819202122232425A:泛型的定义和使用"/* * JDK1.5 出现新的安全机制,保证程序的安全性 * 泛型: 指明了【集合】中【存储数据的类型】 &lt;类型变量&gt; */"public class GenericDemo &#123; public static void main(String[] args) &#123; function(); &#125; public static void function()&#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("abc"); coll.add("rtyg"); coll.add("43rt5yhju");// coll.add(1); Iterator&lt;String&gt; it = coll.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s.length()); &#125; &#125;&#125; 15Java中的伪泛型1234567891011121314151617181920212223242526272829303132333435363738A:Java中的【伪泛型】："泛型【只在】【编译时】存在,【编译后】就被【擦除】,在编译之前我们就可以限制集合的类型,起到安全作用""编译后得到的Class文件是【没有】【泛型】的，实际并不存在泛型类，【系统】【不会】生成泛型类"例如: ArrayList&lt;String&gt; al=new ArrayList&lt;String&gt;();"编译后": ArrayList al=new ArrayList();————————————————————————————————————————————————————————————————————————————————————————B："运行时类查询(getClass方法)【只适用】于【原始类型】"。可以理解为ArrayList&lt;String&gt;类是ArrayList的子类，事实上，ArrayList&lt;String&gt;类也确实像一种特殊的ArrayList类:"该ArrayList&lt;String&gt;对象【只能】添加【String对象】作为【集合元素】"。但实际上，"系统【并没有】为ArrayList&lt;String&gt;生成【新的class文件】， 而且也【不会】把ArrayList&lt;String&gt;当成【新类】来处理"例如:List&lt;String&gt; l1 =new ArrayList&lt;&gt;();List&lt;Integer&gt; ii = new ArrayList&lt;&gt;();System.out.println(l1.getClass());"//class java.util.ArrayList"System.out.println(ii.getClass());"//class java.util.ArrayList"System.out.println(l1.getClass() == ii.getClass());"true"————————————————————————————————————————————————————————————————————————————————————————C： "不管为泛型的【类型形参】传入哪一种一【类型实参】，对于Java来说，它们依然被当成【同一个类处理】，在内存中也【只占用一块内存空间】"，"因此在【静态方法】、【静态初始化块】或者【静态变量】的【声明和初始化】中【不允许】使用【类型形参】"。下面程序演示了这种"【错误】"。public class Apple&lt;T&gt; &#123; private static T age; "【error】" public static void bar(T mm)&#123; "【error】" &#125;————————————————————————————————————————————————————————————————————————————————————————D："由于系统中并不会真正生成泛型类，所以【instanceof运算符】后【不能】使用【泛型类】"List&lt;Integer&gt; ii = new ArrayList&lt;Integer&gt;();if(ii instanceof ArrayList)&#123;//true &#125;if(ii instanceof ArrayList&lt;Integer&gt;)&#123;"【error】" &#125; 16泛型类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697A:泛型类:a:定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; &#125;注意："泛型类的【静态方法】、【静态初始化块】或者【静态变量】的 【声明和初始化】中【不允许】使用【类型形参】T"private static T age;"【error】"public static void bar(T mm)&#123;"【error】"&#125;static&#123; T gr = 1;"【error】"&#125;————————————————————————————————————————————————————————————————————————————————————————b:使用格式： "创建对象时，确定泛型的类型" 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型 class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; &#125; 例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型 class ArrayList&lt;Integer&gt;&#123; public boolean add(Integer e)&#123; &#125; public Integer get(int index)&#123; &#125; &#125;————————————————————————————————————————————————————————————————————————————————————————c:"可以为【任何类，接口】【增加泛型声明】(【井不是】【只有】集合类才可以使用泛型声明，虽然集合类是泛型的重要使用场所)"例如：public class Apple&lt;T&gt; &#123; private T info; private String id; public Apple()&#123; super(); &#125; public Apple(T info)&#123; this.info = info; &#125; public Apple(T info, String id)&#123; this.info = info; this.id =id; &#125; public void setInfo(T info)&#123; this.info =info; &#125; public T getInfo()&#123; return this.info; &#125; public void setId(String id)&#123; this.id =id; &#125; public String getId()&#123; return this.id; &#125; @Override public String toString()&#123; return "&#123;"+ "id=: " +this.id+ "|"+" info=: "+ this.info +"&#125;"; &#125;&#125;public class AppleTest &#123; public static void main(String[] args) &#123; new Apple&lt;Double&gt;(); Apple&lt;Double&gt; a1= new Apple&lt;&gt;(25008.8,"刘鹏001"); Apple&lt;Integer&gt; b2 = new Apple&lt;&gt;(26000,"周莉002"); System.out.println(a1); System.out.println(b2); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————d: "当创建带泛型声明的自定义类，为该类定义【构造器】时， 【构造器名】还是【原来的类名】，【不能】【增加泛型声明】。例如，为Apple&lt;T&gt;类定义构造器，其【构造器名依然是Apple】，而【不是】Apple&lt;T&gt;!【调用】（new对象时）该构造器时却可以使用Apple&lt;T&gt;的形式，当然应该为T形参传入实际的类型参数"。如：public Apple(T info)&#123; this.info = info; &#125;public Apple(T info, String id)&#123; this.info = info; this.id =id; &#125; 17 泛型类派生子类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849A:当创建了带泛型声明的接口、父类之后，可以为该接创建实现类，或从该父类派生子类，"需要指出的是，当使用这些接口、父类时【不能】再【包含】【类型形参】。例如，下而代码就是【错误】的"public class SubApple extends Apple&lt;T&gt;&#123;&#125;"//error""除非：子类也是泛型类"，即：SubApple&lt;T&gt;public class SubApple&lt;T&gt; extends Apple&lt;T&gt;&#123;&#125;————————————————————————————————————————————————————————————————————————————————————————B:定义方法时可以声明数据形参，调用方法(使用方法)时必须为这些数据形参传入实际的数据:与此类似的是，"定义类、接口、方法时可以声明类型形参，使用类、接口、方法时应该为【类型形参】传入【实际的类型】"。public class SubApple11 extends Apple&lt;Integer&gt;&#123;&#125;public class SubApple11 extends Apple&lt;Integer&gt;&#123; public SubApple11()&#123; super(); &#125; public SubApple11(Integer d,String s)&#123; super(d,s); &#125; @Override public Integer getInfo()&#123; "//父类是Apple&lt;Integer&gt;" "返回值类型必须与Apple&lt;Integer&gt;的返回值类型完全相同" return super.getInfo() +5000; &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————C: 调用方法时必须为所有的数据形参传入参数值，"与调用方法不同的是"，"使用类、接口时【可以】【不为】类型形参传入【实际的类型参数】，即下面代码也是【正确】的"。"此时，系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理"。public class SubApple extends Apple&#123;&#125;举例：public class SubApple extends Apple&#123;//系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理public SubApple()&#123; super();&#125;public SubApple(Double d,String s)&#123; super(d,s);&#125;@Overridepublic Double getInfo()&#123; "//super.getInfo()是Object类型" return (Double) super.getInfo() +1000;&#125;&#125; 18泛型的方法123456789101112131415161718192021222324A:泛型的方法a:"定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125;"b:泛型方法的使用: 1:例如，API中的ArrayList集合中的方法： public &lt;T&gt; T[] toArray(T[] a)&#123; &#125; //该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组"使用格式：调用方法时，确定泛型的类型"例如: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); String[] arr = new String[100]; String[] result = list.toArray(arr); "此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同" public &lt;String&gt; String[] toArray(String[] a)&#123; &#125;  例如: ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); Integer[] arr = new Integer[100]; Integer [] result = list.toArray(arr); "此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同" public &lt;Integer&gt; Integer[] toArray(Integer[] a)&#123; &#125; 19泛型的接口12345678910111213141516171819202122A:泛型的接口: "/* * 带有泛型的接口 * * public interface List &lt;E&gt;&#123; * abstract boolean add(E e); * &#125; * ———————————————————————————————————————————————————————————————————— *A: 实现类,先实现接口,不理会泛型 * public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123; * &#125; * 调用者 : new ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型 * * ———————————————————————————————————————————————————————————————————— *B: 实现类,实现接口的同时,也指定了数据类型 * public class XXX implements List&lt;String&gt;&#123; * &#125; * new XXX() */" public class GenericDemo2 &#123; &#125; 20泛型的好处1234567891011121314151617181920A:泛型的好处a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。b:避免了类型强转的麻烦。演示下列代码：public class GenericDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); //list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 //集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); System.out.println(str.length()); //当使用Iterator&lt;String&gt; //控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 &#125; &#125; &#125; 21泛型的继承规则12345678910111213A："Manager类 是 Employee类 的【子类】。 但 Pair&lt;Manager&gt; 【不是】Pair&lt;Employee&gt; 的【子类】" ，"即 Pair&lt;Manager&gt; 与 Pair&lt;Employee&gt; 【没有】【继承关系】""无论 S 与 T 有什么联系，通常， Pair&lt;S&gt; 与 Pair&lt;T&gt; 没有联系"如：Integer是Number的子类List&lt;Integer&gt; ss = new ArrayList&lt;&gt;();List&lt;Number&gt; nn= ss; "// Error"B："数组和泛型有所不同：，假设Foo是Bar的一个子类型(子类或者子接口)，那么 Foo[]【依然是】Bar[] 的子类型;但 G&lt;Foo&gt; 【不是】 G&lt;Bar&gt; 的子类型"。Manager[] managerBuddies = &#123; ceo, cfo &#125;;Employee[] employeeBuddies = managerBuddies; // OK 22泛型的通配符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179A:泛型的通配符"为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号(?)，将一个问号作为类型实参传给List集合，写作:List&lt;?&gt; 意思是元素类型未知的List 。这个问号(?)被称为【通配符】，它的元素类型可以【匹配任何类型】(Object 类型)"注意："这种带通配符的List仅表示它是【各种泛型List】的【父类】， 【不能】把【元素】加入到其中，因为其类型是无法确定的" 但是程序【可以调用】get() 方法来返回List&lt;?&gt;集合指定索引处的元素， 其返回值是一个未知类型，但可以肯定的是，它总是一个【Object类型】如：List&lt;?&gt; c = new ArrayList&lt;&gt;();"//下面程序引起编译错误"c.add(new Object());"//error"—————————————————————————————————————————————————————————————————————————————————————————— /** 泛型的通配符*/public class GenericDemo &#123;public static void main(String[] args) &#123; ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); array.add("123"); array.add("456"); set.add(789); set.add(890); iterator(array); iterator(set);&#125;"/* * 定义方法,可以同时迭代2个集合 * 参数: 怎么实现 , 不能写ArrayList,也不能写HashSet * 参数: 或者共同实现的接口 * 泛型的通配,匹配所有的数据类型 ? */"public static void iterator(Collection&lt;?&gt; coll)&#123; Iterator&lt;?&gt; it = coll.iterator(); while(it.hasNext())&#123; //it.next()获取的对象是什么类型,就得到什么类型 System.out.println(it.next()); &#125;&#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————B：设定类型通配符的上限" List&lt;? extends Shape&gt; 是受限制通配符的例子，此处的问号(?)代表一个未知的类型，就像前面看到的通配符一样。但是此处的这个未知类型【必须】是【Shape的子类型(也可以是Shape本身)】，因此可以把Shape称为这个【通配符的上限】（upper bound）"类似地，"由于程序【无法确定】这个受限制的通配符的【具体类型】，所以【不能】把【Employee对象或其子类的对象】加入这个泛型集合中。例如，下面代码就是【错误】的。"public static void iterator_func(ArrayList&lt;? extends Employee&gt; list)&#123; list.add(new Manager());"//error"&#125;"————————————————————————————————extends通配符的缺陷————————————————————————————————""当使用 extends 通配符时，我们【无法】向其中【添加】【任何对象】。【只能】从中【取出】对象"例如：Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;();plate.add(new Apple()); "//Compile Error"plate.get(); // Compile Success因为编译时只看父类，运行时看子类，在我们还【未具体运行】时，1）进行"添加操作"时："JVM 并不知道我们要往plate里【添加】什么对象，只知道添加的是Fruit的【子类】，【无法确定】"。2）而执行"取出操作"时，JVM 知道结果"一定是父类Fruit的子类，可以做自动【向上转型】，用【父类的变量】接收【子类对象】"即：Fruit apple = plate.get();//多态的向上转型当然：如果考虑" Fruit类继承自 Food类"，还可以"继续向上转型"：即:Food food = plate.get();//多态的向上转型同样：Object food = plate.get(); 上述3种 赋值 都是"正确"的。举例："方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象" public static void iterator_func(ArrayList&lt;? extends Employee&gt; list)&#123; Iterator&lt;? extends Employee&gt; it = list.iterator(); while(it.hasNext())&#123; Employee e = it.next(); e.work(); &#125; &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————C：设定类型形参的上限Java泛型不仅允许在使用通配符形参时设定上限，"而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。"下面程序示范了这种用法。public class GenericDemo2&lt;T extends Number&gt; &#123; T nn; public static void main(String[] args) &#123; GenericDemo2&lt;Integer&gt; ii= new GenericDemo2&lt;&gt;(); GenericDemo2&lt;Double&gt; dd = new GenericDemo2&lt;&gt;(); "//下面代码将引发编译异常，下面代码试图把String类型传给T形参 //但String不是Number的子类型，所以引起编译错误" GenericDemo2&lt;String&gt; ss = new GenericDemo2&lt;&gt;();//error &#125;&#125;——————————————————————————————————————————————————————————————————————————————————————————D：设定类型形参的下限" List&lt;? super Type&gt;表示传入的未知类型【必须】是【Type本身，或者Type的父类型】"例如：Apple 类 和 Orange 类 继承自 Fruit类，Plate&lt;? super Apple&gt; plate = new Plate&lt;Fruit&gt;();Plate&lt;? super Apple&gt; plate = new Plate&lt;Object&gt;();上面的声明都是对的，因为 Object 是任何一个类的父类，而 Fruit类 是 Apple类 的父类。"————————————————————————————————super通配符的缺陷————————————————————————————————"&lt;? super T&gt;对于使用了 super 通配符的情况，我们"只能【存入】【 T 类型】及【 T 类型的子类】对象"。"【取出】的时候【必须】用【 Object 类型】的属性指向取出的对象"。例如：Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类Plate&lt;? super Fruit&gt; plate = new Plate&lt;&gt;();plate.add(new Fruit());plate.add(new Apple());plate.add(new Food()); "//Compile Error"plate 指向的具体类型可以是任何 "Fruit类及其父类"，JVM 在编译的时候肯定"无法判断具体是哪个类型"。但 JVM 能确定的是，"任何 Fruit 的子类【都可以】自动【向上转型】为 Fruit 类型"，"但任何 Fruit 的父类都【无法直接】转为 Fruit 类型，【只能】【向下强转】"。所以 "只能存入 T 类型及 T 类型的【子类】对象"，"T 类型的子类对象 能自动 【向上转型】为T 类型"Object object = plate.get();Fruit fruit = plate.get(); "//Error"Food food = plate.get(); "//Error"plate 指向的具体类型可以是任何 "Fruit类及其父类",接收类型是不确定的，"只能用Object 类型才能正确接收"。——————————————————————————————————————————————————————————————————————————————————————————总结：PECS(Producer Extends, Consumer Super)原则extends 和 super 通配符的使用和限制：对于 "extends 通配符"，我们"【无法】向其中【加入】任何对象"，但是"我们可以进行正常的取出"。对于 super 通配符，我们"可以存入 【T 类型】对象或 【T 类型的子类】对象"，但是我们取出的时候"【只能】用【 Object 类】变量指向取出的对象"。从上面的总结可以看出，"extends 通配符""偏向于内容的获取"，而 super 通配符更"偏向于内容的存入"。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。Producer Extends 说的是当你的情景是"生产者类型"，需要"获取资源"以供生产时，我们建议使用" extends 通配符"，因为使用了 extends 通配符的类型更适合获取资源。Consumer Super 说的是当你的场景是"消费者类型"，需要"存入资源"以供消费时，我们建议使用 "super 通配符"，因为使用 super 通配符的类型更适合存入资源。但如果你"既想存入，又想取出"，那么你最好还是不要使用 extends 或 super 通配符。 23泛型的限定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051A:泛型的限定" /** 将的酒店员工,厨师,服务员,经理,分别存储到3个集合中* 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法*/"import java.util.ArrayList;import java.util.Iterator;public class GenericTest &#123;public static void main(String[] args) &#123; //创建3个集合对象 ArrayList&lt;ChuShi&gt; cs = new ArrayList&lt;ChuShi&gt;(); ArrayList&lt;FuWuYuan&gt; fwy = new ArrayList&lt;FuWuYuan&gt;(); ArrayList&lt;JingLi&gt; jl = new ArrayList&lt;JingLi&gt;(); //每个集合存储自己的元素 cs.add(new ChuShi("张三", "后厨001")); cs.add(new ChuShi("李四", "后厨002")); fwy.add(new FuWuYuan("翠花", "服务部001")); fwy.add(new FuWuYuan("酸菜", "服务部002")); jl.add(new JingLi("小名", "董事会001", 123456789.32)); jl.add(new JingLi("小强", "董事会002", 123456789.33)); // ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;(); iterator(jl); iterator(fwy); iterator(cs);&#125;"/* * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法 * 强制转换: it.next()=Object o ==&gt; Employee * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象 * 【泛型的限定】 本案例,父类固定Employee,但是子类可以无限? * ———————————————————————————————————————————————————————————————————— * ? extends Employee 限制的是【父类】, 【上限限定】, 可以传递Employee,传递他的【子类】对象 * ———————————————————————————————————————————————————————————————————— * ? super Employee 限制的是【子类】, 【下限限定】, 可以传递Employee,传递他的【父类】对象 */"public static void iterator(ArrayList&lt;? extends Employee&gt; array)&#123; Iterator&lt;? extends Employee&gt; it = array.iterator(); while(it.hasNext())&#123; //获取出的next() 数据类型,是什么Employee Employee e = it.next(); e.work(); &#125;&#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础15(包装类,System类,Math类,Arrays类)]]></title>
    <url>%2F2016%2F10%2F25%2Fday17%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、基本类型包装类2、System类3、Math类4、Arrays类5、大数据运算 01基本数据类型对象包装类概述123456789101112*A:基本数据类型对象包装类概述 *a.基本类型包装类的产生 在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等 *b.八种基本类型对应的包装类 char Character int Integer byte Byte short Short long Long float Float double Double boolean Boolean 02Integer类parseInt方法123456789101112131415161718 *A:Integer类parseInt方法: *a:parseInt() int i = Integer.parseInt("12"); System.out.println(i/2);//6 *b:parseInt(String s, int radix) /* * Integer类静态方法parseInt(String s, int radix) * radix基数,进制 * "110",2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制 * 指定进制的字符串转换为十进制的整数 */ public static void function_1()&#123; int i = Integer.parseInt("110", 2); System.out.println(i); int a = Integer.parseInt("f",16); System.out.println(a); &#125; 03Integer类int转成字符串123456789*A:Integer类int转成字符串: *a:使用+与字符串拼接 int i = 3; String s = i+""; System.out.println(s+1);//"31" *b:toString(int ,int 进制),任意进制整数转成任意进制的字符串 (了解) String s1 = Integer.toString(5,2); System.out.println(s1); 04Integer类构造方法12345678910111213*A:Integer类构造方法 "/* * Integer类构造方法 * Integer (String s) * 将数字格式的字符串,传递到Integer类的构造方法中 * 创建Integer对象,包装的是一个字符串 * 将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue() */" public static void function_3()&#123; Integer in = new Integer("100"); int i = in.intValue(); System.out.println(--i);//99 &#125; 05Integer类其他方法12345678910111213141516171819202122232425*A:Integer类其他方法 "/** Integer类的3个静态方法* 做进制的转换* 十进制转成二进制 toBinarString(int)* 十进制转成八进制 toOctalString(int)* 十进制转成十六进制 toHexString(int)* 三个方法,返回值都是以String形式出现*/" a:十进制转二,八,十六进制 public static void function_1()&#123; System.out.println(Integer.toBinaryString(99)); System.out.println(Integer.toOctalString(99)); System.out.println(Integer.toHexString(999)); &#125; b:获取int的最大值和最小值 /* * Integer类的静态成员变量 * MAX_VALUE * MIN_VALUE */ public static void function()&#123; System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); &#125; 06自动装箱和自动拆箱12345678910111213141516171819 *A:自动装箱与自动拆箱: "//JDK1.5新特性//自动装箱,拆箱的 好处: 基本类型和引用类直接运算 //自动装箱:使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象 //自动拆箱:使用Integer对象.intValue()返回Integer对象中封装的整数值"public static void function()&#123; //引用类型 , 引用变量一定指向对象 //自动装箱, 基本数据类型1, 直接变成了对象 Integer in = 1; // Integer in = new Integer(1) //in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型 //in+1 ==&gt; in.inValue()+1 = 2 //in = 2 自动装箱 in = in + 1; System.out.println(in); &#125; 07自动装箱和自动拆箱练习题12345678910111213141516171819202122*A:自动装箱与自动拆箱: Integer i = new Integer(1);Integer j = new Integer(1);System.out.println(i==j);// false 对象地址System.out.println(i.equals(j));// true 继承Object重写equals,比较的对象数据System.out.println("===================");Integer a = 500;//Integer integer=Integer.valueOf(500) //integer=new Integer(500);Integer b = 500;System.out.println(a==b);//falseSystem.out.println(a.equals(b));//trueSystem.out.println("===================");"数据在byte(-128~127)范围内,JVM不会从新new对象"Integer aa = 127; // Integer aa = new Integer(127)Integer bb = 127; // Integer bb = aa;System.out.println(aa==bb); //trueSystem.out.println(aa.equals(bb));//true 08System类方法currentTimeMillis123456789101112131415161718192021在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息，和系统操作。System类"不能手动创建对象"，因为"构造方法"被private修饰，"阻止外界创建对象"。System类中的"都是"static方法，"类名访问即可"。在JDK中，有许多这样的类。*A:System类方法currentTimeMillis():用于计算程序的执行时间 /* * 获取系统当前毫秒值 * static long currentTimeMillis() * 对程序执行时间测试 */ public static void function()&#123; long start = System.currentTimeMillis();//当前时间x-1970年1月1日零时零分零秒 for(int i = 0 ; i &lt; 10000; i++)&#123; System.out.println(i); &#125; long end = System.currentTimeMillis();//当前时间y-1970年1月1日零时零分零秒 System.out.println(end - start);//当前时间y-当前时间x &#125; 09System类方法exit1234567891011 *A:System类方法exit()方法 /* * 退出虚拟机,所有程序全停止 * static void exit(0) */public static void function_1()&#123; while(true)&#123; System.out.println("hello"); System.exit(0);//该方法会在以后的finally代码块中使用(讲到再说) &#125;&#125; 10System类方法gc123456789101112131415161718192021222324A:System类方法gc public class Person &#123; public void finalize()&#123; System.out.println("垃圾收取了"); &#125; &#125; "* * JVM在内存中,收取对象的垃圾 * 当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象 * 同时调用回收对象所属类的 【finalize方法() * static void gc() *" public static void function_2()&#123; new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); new Person(); System.gc(); &#125; 11System类方法getProperties12345678A:System类方法getProperties(了解) /* * 获取当前操作系统的属性:例如操作系统名称, * static Properties getProperties() */ public static void function_3()&#123; System.out.println( System.getProperties() ); &#125; 12System类方法arraycopy1234567891011121314151617181920212223242526272829303132333435 " /* * System类方法,复制数组,这是一个本地方法 * arraycopy(Object src, int srcPos, Object dest, int destPos, int length) * Object src, 要复制的源数组 * int srcPos, 数组源的起始索引 * Object dest,复制后的目标数组 * int destPos,目标数组起始索引 * int length, 复制几个 */""从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的【源数组】到 dest 引用的【目标数组】，数组组件的一个【子序列】被复制下来。被复制的组件的编号等于 length 参数。【源数组】中位置在【 srcPos 】到【 srcPos+length-1 】之间的组件被分别复制到【目标数组】中的【 destPos 】到【 destPos+length-1 】位置。" A:System类方法arraycopy： /* * System类方法,复制数组 * arraycopy(Object src, int srcPos, Object dest, int destPos, int length) * Object src, 要复制的源数组 * int srcPos, 数组源的起始索引 * Object dest,复制后的目标数组 * int destPos,目标数组起始索引 * int length, 复制几个 */ public static void function_4()&#123; int[] src = &#123;11,22,33,44,55,66&#125;; int[] desc = &#123;77,88,99,0&#125;; System.arraycopy(src, 1, desc, 1, 2);//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上 for(int i = 0 ; i &lt; desc.length ; i++)&#123; System.out.println(desc[i]); &#125; &#125; 13Math类的方法_1123456789101112131415161718192021222324252627282930313233343536373839404142434445A:Math类中的方法/* * static double sqrt(double d) * 返回参数的平方根 */ public static void function_4()&#123; double d = Math.sqrt(-2); System.out.println(d); &#125; /*0 * static double pow(double a, double b) * a的b次方 */ public static void function_3()&#123; double d = Math.pow(2, 3); System.out.println(d); &#125; /* * static double floor(double d) * 返回小于或者等于参数d的最大整数 */ public static void function_2()&#123; double d = Math.floor(1.5); System.out.println(d); &#125; /* * static double ceil(double d) * 返回大于或者等于参数d的最小整数 */ public static void function_1()&#123; double d = Math.ceil(5.1); System.out.println(d); &#125; /* * static int abs(int i) * 获取参数的绝对值 */ public static void function()&#123; int i = Math.abs(0); System.out.println(i); &#125; 14Math类的方法_21234567891011121314151617181920A:Math类的方法_2 /* * static double round(doubl d) * 获取参数的四舍五入,取整数 */ public static void function_6()&#123; double d = Math.round(5.4195); System.out.println(d); &#125; /* * static double random() 返回随机数 0.0-1.0之间 * 来源,也是Random类 */ public static void function_5()&#123; for(int i = 0 ; i &lt; 10 ;i++)&#123; double d = Math.random(); System.out.println(d); &#125; &#125; 15Arrays工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859A:Arrays工具类: public class ArraysDemo &#123; public static void main(String[] args) &#123; function_2(); int[] arr = &#123;56,65,11,98,57,43,16,18,100,200&#125;; int[] newArray = test(arr); System.out.println(Arrays.toString(newArray)); &#125; "/* * 定义方法,接收输入,存储的是10个人考试成绩 * 将最后三个人的成绩,存储到新的数组中,返回新的数组 */" public static int[] test(int[] arr)&#123; //对数组排序 Arrays.sort(arr); //将最后三个成绩存储到新的数组中 int[] result = new int[3]; //成绩数组的最后三个元素,复制到新数组中 // System.arraycopy(arr, 0, result, 0, 3); for(int i = 0 ; i &lt; 3 ;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; "/* * static String toString(数组) * 将数组变成字符串 */" public static void function_2()&#123; int[] arr = &#123;5,1,4,6,8,9,0&#125;; String s = Arrays.toString(arr); System.out.println(s); &#125; "/* * static int binarySearch(数组, 被查找的元素) * 数组的二分搜索法 * 返回元素在数组中出现的索引 * 元素不存在, 返回的是 (-插入点-1) */" public static void function_1()&#123; int[] arr = &#123;1,4,7,9,11,15,18&#125;; int index = Arrays.binarySearch(arr, 10); System.out.println(index); &#125; "/* * static void sort(数组) * 对数组升序排列 */" public static void function()&#123; int[] arr = &#123;5,1,4,6,8,9,0&#125;; Arrays.sort(arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; &#125; 16数组复制练习12345678910111213141516171819202122*A:数组复制练习: public static void main(String[] args) &#123; int[] arr = &#123;56,65,11,98,57,43,16,18,100,200&#125;; int[] newArray = test(arr); System.out.println(Arrays.toString(newArray)); &#125; /* * 定义方法,接收输入,存储的是10个人考试成绩 * 将最后三个人的成绩,存储到新的数组中,返回新的数组 */ public static int[] test(int[] arr)&#123; //对数组排序 Arrays.sort(arr); //将最后三个成绩存储到新的数组中 int[] result = new int[3]; //成绩数组的最后三个元素,复制到新数组中 //System.arraycopy(arr, 0, result, 0, 3); for(int i = 0 ; i &lt; 3 ;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; 17BigInteger类概述和构造方法1234567891011121314A:BigInteger类概述和构造方法public static void main(String[] args) &#123; function(); &#125;/* * BigInteger类的构造方法 * 传递字符串,要求数字格式,没有长度限制 */ public static void function()&#123; BigInteger b = new BigInteger("8465846668464684562385634168451684568645684564564"); System.out.println(b); BigInteger b1 = new BigInteger("5861694569514568465846668464684562385634168451684568645684564564"); System.out.println(b1); &#125; 18BigInteger类四则运算12345678910111213141516171819202122232425262728A:BigInteger类四则运算 public static void main(String[] args) &#123; function_1(); &#125;/* * BigInteger对象的四则运算 * 调用方法计算,计算结果也只能是BigInteger对象 */ public static void function_1()&#123; BigInteger b1 = new BigInteger("5665464516451051581613661405146"); BigInteger b2 = new BigInteger("965855861461465516451051581613661405146"); //计算 b1+b2对象的和,调用方法 add BigInteger bigAdd = b1.add(b2);//965855867126930032902103163227322810292 System.out.println(bigAdd); //计算b1-b2对象的差,调用方法subtract BigInteger bigSub = b1.subtract(b2); System.out.println(bigSub); //计算b1*b2对象的乘积,调用方法multiply BigInteger bigMul = b1.multiply(b2); System.out.println(bigMul); //计算b2/b1对象商,调用方法divied BigInteger bigDiv = b2.divide(b1); System.out.println(bigDiv); &#125; 19员工案例的子类的编写1234567891011A:BigDecimal类概述 " /* * 计算结果,未知 * 原因: 计算机二进制中,表示浮点数不精确造成 * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal System.out.println(0.09 + 0.01);//0.09999999999999999 System.out.println(1.0 - 0.32);//0.6799999999999999 System.out.println(1.015 * 100);//101.49999999999999 System.out.println(1.301 / 100);//0.013009999999999999 */" 20BigDecimal类实现加法减法乘法123456789101112131415161718192021222324A:BigDecimal类实现加法减法乘法 /* * BigDecimal实现三则运算 * + - * */ public static void function()&#123; BigDecimal b1 = new BigDecimal("0.09"); BigDecimal b2 = new BigDecimal("0.01"); //计算b1+b2的和,调用方法add BigDecimal bigAdd = b1.add(b2); System.out.println(bigAdd); BigDecimal b3 = new BigDecimal("1"); BigDecimal b4 = new BigDecimal("0.32"); //计算b3-b2的差,调用方法subtract BigDecimal bigSub = b3.subtract(b4); System.out.println(bigSub); BigDecimal b5 = new BigDecimal("1.015"); BigDecimal b6 = new BigDecimal("100"); //计算b5*b6的成绩,调用方法 multiply BigDecimal bigMul = b5.multiply(b6); System.out.println(bigMul); &#125; 21BigDecimal类实现除法12345678910111213141516171819A:BigDecimal类实现除法/* * BigDecimal实现除法运算 * divide(BigDecimal divisor, int scale, int roundingMode) * int scale : 保留几位小数 * int roundingMode : 保留模式 * 保留模式 阅读API文档 * static int ROUND_UP 向上+1 * static int ROUND_DOWN 直接舍去 * static int ROUND_HALF_UP &gt;= 0.5 向上+1 * static int ROUND_HALF_DOWN &gt; 0.5 向上+1 ,否则直接舍去 */public static void function_1()&#123; BigDecimal b1 = new BigDecimal("1.0301"); BigDecimal b2 = new BigDecimal("100"); //计算b1/b2的商,调用方法divied BigDecimal bigDiv = b1.divide(b2,2,BigDecimal.ROUND_HALF_UP);//0.01301 System.out.println(bigDiv);&#125; 22小结12345678910111213141516171819202122232425262728293031323334353637383940 基本类型包装类 8种基本类型对应的包装类基本类型 包装类byte Byteshort Shortint " Integer "long Longfloat Floatdouble Doublechar " Character "boolean Boolean 自动装箱、自动拆箱 自动装箱：基本数值转成对象（int &gt;&gt; Integer） 自动拆箱：对象转成基本数值（Integer &gt;&gt; int） 常用方法public int parseInt(String str):把字符串转成基本类型intpublic static String toString(int x):把基本类型int转成字符串public static Integer valueOf(int x):返回一个表示指定的 int 值的 Integer 实例。如果不需要新的 Integer 实例，则通常应优先使用该方法。public int intValue():以 int类型返回该包装类对象的值 System类: 系统属性信息工具类 public static long currentTimeMillis()：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 public static void exit(int status)：用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态 public static void gc()：用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。 public static String getProperties()：用来获取指系统属性信息 Arrays类：数组操作工具类 public static void sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序） public static String toString方法，用来返回指定数组元素内容的字符串形式 public static void binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-插入点-1。要求该数组必须是个有序的数组 Math类：数学运算工具类 abs方法,结果都为正数 ceil方法，结果为比参数值大的最小整数的double值 floor方法，结果为比参数值小的最大整数的double值 max方法，返回两个参数值中较大的值 min方法，返回两个参数值中较小的值 pow方法，返回第一个参数的第二个参数次幂的值 round方法，返回参数值四舍五入的结果 random方法，产生一个大于等于0.0且小于1.0的double小数]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础14(正则表达式,Date类,Calendar类)]]></title>
    <url>%2F2016%2F10%2F20%2Fday16%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、正则表达式的定义及使用2、Date类的用法3、Calendar类的用法 01正则表达式的概念和作用* A: 正则表达式的概念和作用 123456* a: 正则表达式的概述 * "正则表达式也是一个【字符串】，用来定义匹配规则，在Pattern类中有简单的规则定义"。 "可以结合【字符串类】的【方法】使用"。 * 简单记：正则表达式是具有特殊含义的字符串。* b: 正则表达式的作用* 比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的 02正则表达式语法规则* A: 正则表达式语法规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* a: 字符 * x 代表的是字符x * \\ 代表的是反斜线字符'\' * \t 代表的是制表符 * \n 代表的是换行符 * \r 代表的是回车符——————————————————————————————————————————————————————————————————————————————————————* b: 字符类 * [abc] a、b 或 c（简单类） * [^abc] 任何字符，【除了】 a、b 或 c（否定） * [a-zA-Z] a到 z 或 A到 Z，【两头】的字母【包括在内（范围）】 * [0-9] 0到9的字符都包括 * [a-zA-Z_0-9] 代表的【字母】或者【数字】或者【下划线(即单词字符)】——————————————————————————————————————————————————————————————————————————————————————* c: 预定义字符类 * . : . 【任何字符】。 * \d ： [\\d] 数字：[0-9] ,相反地，[\\D]: 匹配字符不是数字 * \w ： [\\w] 单词字符：[a-zA-Z_0-9]如"com.itheima.tests"/finish——————————————————————————————————————————————————————————————————————————————————————* d: 边界匹配器 * ^ 代表的是行的开头 * $ 代表的是行的结尾 * \b 代表的是单词边界——————————————————————————————————————————————————————————————————————————————————————* e: 数量词 * X? X，一次或一次也没有 * X* X，零次或多次 * X+ X，一次或多次 * X&#123;n&#125; X，恰好 n 次 * X&#123;n,&#125; X，至少 n 次 * X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————举例：请写出满足如下匹配规则的字符串:规则："[0-9]&#123;6,12&#125;"该规则需要匹配的内容是：长度为6位到12位的数字。如：使用数据"123456789"进行匹配结果为true；使用数据"12345"进行匹配结果为false。规则："1[34578][0-9]&#123;9&#125;"该规则需要匹配的内容是：11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。如：使用数据"12345678901"进行匹配结果为false；使用数据"13312345678"进行匹配结果为true。规则："a*b"该规则需要匹配的内容是：在多个a或零个a后面有个b；b必须为最后一个字符。如：使用数据"aaaaab"进行匹配结果为true；使用数据"abc"进行匹配结果为false。 03正则表达式练习和相关的String类方法* A: 正则表达式练习和相关的String类方法 12345678910111213* a: boolean matches(String 正则的规则) ：告知此字符串是否匹配给定的正则表达式。 * "abc".matches("[a]") ：根据给定正则表达式的匹配拆分此字符串。 * 匹配成功返回true* b: String[] split(String 正则的规则) * "abc".split("a") * 使用规则将字符串进行切割 * String [] rr = "abc".split(""); // 按每个字符切割，得到:[a,b,c] * 返回：String [] 字符串数组，它是根据给定正则表达式的匹配拆分此字符串确定的 * c: String replaceAll( String 正则规则,String 字符串)：* 使用给定的字符串替换此字符串所有匹配给定的正则表达式的子字符串。 * "abc0123".repalceAll("[\\d]","#") * 按照正则的规则,替换字符串 04正则表达式匹配练习* A: 正则表达式匹配练习 12345678910111213141516171819202122232425262728293031* a: 案例代码public class RegexDemo &#123; public static void main(String[] args) &#123; checkTel(); &#125; /* * 检查手机号码是否合法 * 1开头 可以是34578 0-9 位数固定11位 */ public static void checkTel()&#123; String telNumber = "1335128005"; //String类的方法matches boolean b = telNumber.matches("1[34857][\\d]&#123;9&#125;"); System.out.println(b); &#125; /* * 检查QQ号码是否合法 * 0不能开头,全数字, 位数5,10位 * 123456 * \\d \\D匹配不是数字 */ public static void checkQQ()&#123; String QQ = "123456"; //检查QQ号码和规则是否匹配,String类的方法matches boolean b = QQ.matches("[1-9][\\d]&#123;4,9&#125;"); System.out.println(b); &#125;&#125; 05正则表达式切割练习* A: 正则表达式切割练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* a: 案例代码public class RegexDemo1 &#123; public static void main(String[] args) &#123; split_1(); split_2(); split_3(); &#125; /* * String类方法split对字符串进行切割 * 192.168.105.27 按照 点切割字符串 * 注意： * "\\."使用转义字符，因为"."表示【任何字符】 */ public static void split_3()&#123; String ip = "192.168.105.27"; String[] strArr = ip.split("\\."); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125; /* * String类方法split对字符串进行切割 * 18 22 40 65 按照空格切割字符串 */ public static void split_2()&#123; String str = "18 22 40 65"; String[] strArr = str.split(" +"); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125; /* * String类方法split对字符串进行切割 * 12-25-36-98 按照-对字符串进行切割 */ public static void split_1()&#123; String str = "12-25-36-98"; //按照-对字符串进行切割,String类方法split String[] strArr = str.split("-"); System.out.println("数组的长度"+strArr.length); for(int i = 0 ; i &lt; strArr.length ; i++)&#123; System.out.println(strArr[i]); &#125; &#125;&#125; 06正则表达式替换练习* A: 正则表达式替换练习 1234567891011121314151617 * a: 案例代码public class RegexDemo1 &#123; public static void main(String[] args) &#123; replaceAll_1(); &#125; /* * "Hello12345World6789012"将所有数字替换掉 * String类方法replaceAll(正则规则,替换后的新字符串) */ public static void replaceAll_1()&#123; String str = "Hello12345World6789012"; str = str.replaceAll("[\\d]+", "#"); System.out.println(str); &#125;&#125; 07正则表达式邮箱地址验证* A: 正则表达式邮箱地址验证 12345678910111213141516171819202122232425262728293031323334353637383940414243 匹配正确的数字匹配规则： 匹配正整数："\\d+" 匹配正小数："\\d+\\.\\d+" 匹配负整数："-\\d+" 匹配负小数："-\\d+\\.\\d+" 匹配保留两位小数的正数："\\d+\\.\\d&#123;2&#125;" 匹配保留1-3位小数的正数："\\d+\\.\\d&#123;1,3&#125;" 匹配合法的邮箱匹配规则： "[a-zA-Z_0-9]+@[a-zA-Z_0-9]+(\\.[a-zA-Z_0-9]+)+" "\\w+@\\w+(\\.\\w+)+" 注意；用() 表示多个相同的匹配规则 获取IP地址(192.168.1.100)中的每段数字匹配规则： "\\."* a: 案例代码public class RegexDemo2 &#123; public static void main(String[] args) &#123; checkMail(); &#125; /* * 检查邮件地址是否合法 * 规则: * 1234567@qq.com * mym_ail@sina.com * nimail@163.com * wodemail@yahoo.com.cn * * @: 前 数字字母_ 个数不能少于1个 * @: 后 数字字母 个数不能少于1个 * .: 后面 字母 * */ public static void checkMail()&#123; String email ="abc123@sina.com"; boolean b = email.matches("[a-zA-Z0-9_]+@[0-9a-z]+(\\.[a-z]+)+"); System.out.println(b); &#125;&#125; 08毫秒值概念* A: 毫秒值概念 12345678910* a: 时间和日期类 * java.util.Date* b: 毫秒概念 * 1000毫秒=1秒* c: 毫秒的0点 * System.currentTimeMillis() 返回值long类型参数 * 获取当前日期的毫秒值 3742769374405 * 时间原点; 公元1970年1月1日,午夜0:00:00 英国格林威治 毫秒值就是0 * 时间2088年8月8日 * 时间和日期的计算，必须依赖毫秒值 09Date类的构造方法* A: Date类的构造方法 1234* a: 空参构造 * public Date()* b: 带参构造 * public Date(long times) 10Date类的get和set方法* A：Date类的get和set方法 1234* public long getTime() * 将当前的日期对象，转为对应的毫秒值* public void setTime(long times); * 根据给定的毫秒值，生成对应的日期对象 11日期格式化SimpleDateFormat* A: 日期格式化SimpleDateFormat 12345678910111213141516* a: 对日期进行格式化(自定义) * 对日期格式化的类 java.text.DateFormat 抽象类, 普通方法,也有抽象的方法 * 实际使用是子类 java.text.SimpleDateFormat 可以使用父类普通方法,重写了抽象方法* b: 对日期进行格式化的步骤 * 1: 创建SimpleDateFormat对象 * 在类构造方法中,写入字符串的日期格式 (自己定义) * 2: SimpleDateFormat调用方法format对日期进行格式化 * public String format(Date date) 传递日期对象,返回字符串 * 日期模式: * yyyy 年份 * MM 月份 * dd 月中的天数 * HH 0-23小时 * mm 小时中的分钟 * ss 秒 * yyyy年MM月dd日 HH点mm分钟ss秒 汉字修改,: - 字母表示的每个字段不可以随便写 12字符串转成日期对象* A: 字符串转成日期对象 12345678* a: 使用步骤 * 1: 创建SimpleDateFormat的对象 * 构造方法中,指定日期模式 * 2: 子类对象,调用方法 parse 传递String,返回Date * 注意: 时间和日期的模式yyyy-MM-dd, 必须和字符串中的时间日期匹配 *西方星期的开始为周日，中国为周一。 在Calendar类中，"月份的表示是以0-11代表1-12月"。 日期是有大小关系的，时间靠后，时间越大。 13Calendar类_1* A: Calendar类_1 12345* a: 日历类(抽象类) * java.util.Calendar* b: 创建对象 * "Calendar类写了【静态方法】 getInstance() 【直接】返回了【子类的对象】" * "【不需要】直接new子类的对象,通过【静态方法】直接获取" 14Calendar类_2* A: Calendar类_2 123456789101112* a: 成员方法 * getTime() 把日历对象,转成Date日期对象 * get(日历字段) 获取指定日历字段的值* b: 代码演示 Calendar c = Calendar.getInstance(); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); 15Calendar类_3* A: Calendar类_3 12345678910111213141516171819202122232425* a: 成员方法 * set(int field,int value) 设置指定的时间* b: 代码演示 /* * Calendar类的set方法 设置日历 set(int field,int value) field 设置的是哪个日历字段 value * 设置后的具体数值 * * set(int year,int month,int day) 传递3个整数的年,月,日 */ public static void function_1() &#123; Calendar c = Calendar.getInstance(); // 设置,月份,设置到10月分 // c.set(Calendar.MONTH, 9); // 设置年,月,日 c.set(2099, 4, 1); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); &#125; 16Calendar类_4* A: Calendar类_4 12345678910111213141516171819202122* a: 成员方法 * add(int field, int value) 进行整数的偏移 * int get(int field) 获取指定字段的值* b: 案例演示 /* * Calendar类方法add 日历的偏移量, * 可以指定一个日历中的字段, * 进行整数的偏移 add(int field, int value) */ public static void function_2() &#123; Calendar c = Calendar.getInstance(); // 让日历中的天数,向后偏移280天 c.add(Calendar.DAY_OF_MONTH, -280); // 获取年份 int year = c.get(Calendar.YEAR); // 获取月份 int month = c.get(Calendar.MONTH) + 1; // 获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日"); &#125; 17日期练习_活了多少天* A: 日期练习_活了多少天 1234567891011121314151617181920212223242526272829303132* a: 案例代码 /* * 计算活了多少天 * 生日 今天的日期 * 两个日期变成毫秒值,减法 */ public static void function() throws Exception &#123; System.out.println("请输入出生日期 格式 YYYY-MM-dd"); //获取出生日期,键盘输入 String birthdayString = new Scanner(System.in).next(); //将字符串日期,转成Date对象 //创建SimpleDateFormat对象,写日期模式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //调用方法parse,字符串转成日期对象 Date birthdayDate = sdf.parse(birthdayString); //获取今天的日期对象 Date todayDate = new Date(); //将两个日期转成毫秒值,Date类的方法getTime long birthdaySecond = birthdayDate.getTime(); long todaySecond = todayDate.getTime(); long secone = todaySecond-birthdaySecond; if(secone &lt; 0)&#123; System.out.println("还没出生呢"); &#125; else&#123; System.out.println(secone/1000/60/60/24); &#125; &#125; 18日期练习_闰年计算* A: 日期练习_闰年计算 12345678910111213141516* a: 案例代码 /* * 闰年计算 * 2000 3000 * 高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,获取天数,29闰年 */ public static void function_1()&#123; Calendar c = Calendar.getInstance(); //将日历,设置到指定年的3月1日 c.set(2088, 2, 1); //日历add方法,向前偏移1天 c.add(Calendar.DAY_OF_MONTH, -1); //get方法获取天数 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(day); &#125; 19总结12345678910111213141516171819202122232425262728293031323334353637383940 正则表达式：用来定义匹配规则，匹配一系列符合某个句法规则的字符串。正则表达式的匹配规则请参见1.2 正则表达式的匹配规则正则表达式的常用方法：public boolean matches(String regex) //判断字符串是否匹配给定的规则public String[] split(String regex) //根据给定正则表达式的匹配规则，拆分此字符串public String replaceAll(String regex,String replacement) //将符合规则的字符串内容，全部替换为新字符串———————————————————————————————————————————————————————————————————————————————————————— Date: 日期/时间类构造方法：public Date()// 系统当前日期时间public Date(long date) 得到一个1970年1月1日 0点这个时间基础上，加上参数date 毫秒值对应的日期时间方法： public long getTime() 获取日期所对应的毫秒值 public void setTime(long times); * 根据给定的毫秒值，生成对应的日期对象———————————————————————————————————————————————————————————————————————————————————————— DateFormat:是日期/时间格式化子类的抽象类, 使用其子类SimpleDateFormat 实例化构造方法：public SimpleDateFormat() 默认的格式化操作 public SimpleDateFormat(String pattern) 按照指定的格式，进行日期格式化 日期和时间模式 y 年 M 年中的月份 d 月份中的天数 H 一天中的小时数（0-23） m 小时中的分钟数 s 分钟中的秒数 S 毫秒数 方法： public final String format(Date date) 把日期 格式化成字符串 public Date parse(String source) 把日期字符串 转换成 日期对象———————————————————————————————————————————————————————————————————————————————————————— Calendar:日历类，可获取日期中指定字段的值方法：public static Calendar getInstance() //获取日期对象public int get(int field) //获取时间字段值public void add(int field,int amount) //指定字段增加某值public final void set(int field,int value)//设置指定字段的值public final Date getTime() //获取该日历对象转成的日期对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础13(Object,String,StringBuilder)]]></title>
    <url>%2F2016%2F10%2F18%2Fday15%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Object2、String3、StringBuilder 01API概念123456* A:API(Application Programming Interface) * 应用程序编程接口* B:Java API * 就是Java提供给我们使用的类，这些类将底层的实现封装了起来， * 我们不需要关心这些类是如何实现的，只需要学习这些类如何使用。* C: 演示查看Object类中的相关方法 02Object类概述123456789* A:Object类概述 * "类层次结构的【根类】 * 【所有类】都【直接】或者【间接】的【继承】自该类 * Object中描述的【所有方法】【子类】【都可以使用】 * 所有类在创建对象的时候，最终找的父类就是Object"。* B:构造方法 * public Object() * 回想面向对象中为什么说： * 子类的构造方法默认访问的是父类的无参构造方法 03equals方法比较内存地址* A:equals方法比较内存地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* a: Object类中的equals方法 * 用于比较两个对象是否相同，Object类中就是使用两个对象的内存地址在比较。 * Object类中的equals方法内部使用的就是==比较运算符。 * b: 案例代码 public class Person extends Object&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* * 将父类的equals方法写过来,重写父类的方法 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址 * */ public boolean equals(Object obj)&#123; return this == obj; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; //测试代码 public class TestEquals &#123; public static void main(String[] args) &#123; //Person类继承Object类,继承下来了父类的方法equals Person p1 = new Person("李四",20); Person p2 = new Person("张三",20); //Person对象p1,调用父类的方法equals,进行对象的比较 boolean b = p1.equals(p1); System.out.println(b); &#125; &#125; 04重写equals方法* A: 重写equals方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788* a: 开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较 * b: 在开发经常需要子类重写equals方法根据对象的属性值进行比较。 * c: ==号和equals方法的区别* "==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,* 基本数据类型比较的是值,引用数据类型比较的是地址值"* "equals方法是一个方法,【只能】【比较】【引用数据类型】,所有的对象都会继承Object类中的方法,如果【没有】重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性"* d: 案例代码public class Person extends Object&#123; private String name; private int age; public Person()&#123;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; /* * 重写父类的方法toString() * 没有必要让调用者看到内存地址 * 要求: 方法中,返回类中所有成员变量的值 */ public String toString()&#123; return name + age; &#125; /* * 将父类的equals方法写过来,重写父类的方法 * 但是,不改变父类方法的源代码, 方法equals 比较两个对象的内存地址 * * 两个对象,比较地址,没有意义 * 比较两个对象的成员变量,age * 两个对象变量age相同,返回true,不同返回false * * 重写父类的equals,自己定义自己对象的比较方式 */ public boolean equals(Object obj)&#123; if( this == obj)&#123; return true; &#125; //对参数obj,非null判断 if( obj == null)&#123; return false; &#125; if( obj instanceof Person)&#123; // 参数obj接受到是Person对象,才能转型 "由于多态【编译】看父类，【父类】Object 没有成员变量age, 必须【向下转型】为 Person 类型，才能调用成员变量 age" // 对obj参数进行类型的向下转型,obj转成Person类型 Person p = (Person)obj; return this.age == p.age; &#125; return false; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;//测试代码public class TestEquals &#123; public static void main(String[] args) &#123; //Person类继承Object类,继承下来了父类的方法equals Person p1 = new Person("李四",20); Person p2 = new Person("张三",20); //Person对象p1,调用父类的方法equals,进行对象的比较 boolean b = p1.equals(p1); System.out.println(b); &#125;&#125; 05重写toString方法* A: 重写toString方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445* a: 为什么要重写toString方法 * "toString方法返回该对象的【字符串】表示"， * 其实该字符串内容就是"【对象的类型】+ @ + 【内存地址值】"。 * 由于toString方法返回的结果是内存地址， * 而在"开发"中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要"重写"它。 * "Object类中的toString的核心代码" " getClass().getName() + @ + Integer.toHexString(hashCode()) " * 由于默认情况下的数据对我们来说没有意义，一般建议重写该方法。* b: 案例核心代码(重写Person类中的toString方法) /* * 重写父类的方法toString() * 没有必要让调用者看到内存地址 * 要求: 方法中,返回类中所有成员变量的值 */ public String toString()&#123; return name + age; &#125; //Eclipse中自动生成的toString @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; //测试代码 public class TestToString &#123; public static void main(String[] args) &#123; //调用Person类的方法toString() //输出语句中,写的是一个对象,默认调用对象的toString方法 Person p = new Person("张三",20); String s = p.toString(); System.out.println(p); System.out.println(s); /* * System.out.println(p); * System.out.println(p.toString()); */ /*Random r = new Random(); System.out.println(r.toString()); Scanner sc = new Scanner(System.in); System.out.println(sc.toString());*/ &#125; &#125; 06String类的概念和不变性* A: String类的概念和不变性 12345678910111213141516171819202122232425262728293031323334353637383940* a:String类* API中的String类的描述，发现String 类代表字符串* Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。* ———————————————————————————————————————————————————————————————————————————————————————* "【字符串】是【常量】,在创建之后不能更改"* ———————————————————————————————————————————————————————————————————————————————————————* "其实就是说一旦这个字符串确定了，那么就会【在内存区域中】就【生成】了【这个字符串】。"* ———————————————————————————————————————————————————————————————————————————————————————*" 【字符串】【本身】【不能改变】，但str变量中记录的【地址值】是【可以改变】的。"* ———————————————————————————————————————————————————————————————————————————————————————* 源码分析,String类底层采用的是"【字符数组】": private final char value[] private 修饰说明"value只能在【String类内部】使用,而且又没有提供get方法, 所以【外部无法获取value数组】,就无法改变数组中元素的值" final修饰说明"value是常量,【一旦创建】,就【不能被改变】, value一旦被初始化成某个数组,将永远指向这个数组,不可能再指向其它的数组了" * b: 案例代码" /* * String类特点: * 一切都是对象,字符串事物 "" 也是对象 * 类是描述事物,String类,描述字符串对象的类 * 所有的 "" 都是String类的对象 * * 字符串是一个常量,一旦创建,不能改变 * 字符串本质是 【字符数组】 */" public class StringDemo &#123; public static void main(String[] args) &#123; //引用变量str指向内存变化 //定义好的字符串对象,不变 String str = "itcast"; System.out.println(str); str = "itheima"; System.out.println(str); &#125; &#125; 07String类创建方式和比较* A: String类创建方式和比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* a: "创建对象的【数量】比较" * String s3 = "abc"; * "在内存中【只有一个对象】。这个对象在【字符串常量池】中"——————————————————————————————————————————————————————————————————————————————————————— * String s4 = new String("abc"); * "在内存中有【两个对象】。一个new的对象在【堆】中，另一个是字符串本身对象，在【字符串常量池】中"———————————————————————————————————————————————————————————————————————————————————————"String重写了equals方法，建立了字符串自己的判断相同的依据（通过【字符串对象】中的【字符】进行判断）"，"即【字符】相同" ，返回true；否则，返回false。———————————————————————————————————————————————————————————————————————————————————————"引用数据类型,比较对象的地址""如果String缓冲池内【存在】与其【指定值】【【相同】】的String对象，那么此时虚拟机将【不】为此创建【新】的String对象】，而直接返回【已存在】的String对象的【引用】。"String s1 = "java";String s2 = "java";System.out.println(s1==s2); //true"如果String缓冲池内【【不存在】】与其指定值相同的String对象，那么此时虚拟机将为此【【创建新】】的String对象，并存放在String缓冲池内。"———————————————————————————————————————————————————————————————————————————————————————* b: 案例代码public class StringDemo2 &#123; public static void main(String[] args) &#123; //字符串定义方式2个, 直接= 使用String类的构造方法 String str1 = new String("abc"); String str2 = "abc"; System.out.println(str1); System.out.println(str2); //str1==str2 "引用数据类型,比较对象的地址" System.out.println(str1==str2);//引用数据类型,比较对象的地址 false //str1.equals(str2) "因为String重写了equals方法， 建立了字符串自己的判断相同的依据（通过【字符串对象】中的【字符】进行判断）" System.out.println(str1.equals(str2));//true ///// String s1 = "java"; String s2 = "java"; "引用数据类型,比较对象的地址" "如果String缓冲池内存在与其【指定值】【相同】的String对象， 那么此时虚拟机将【不】为此创建【新】的String对象】， 而直接返回【已存在】的String对象的【引用】。" System.out.println(s1==s2); //true System.out.println(s1.equals(s2)); //true &#125;&#125; 08String类构造方法* A: String类构造方法 12345678910111213141516171819202122232425262728293031323334353637* a: 常见构造方法 * public String():空构造 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(String original):把字符串常量值转成字符串* b: 案例代码 public class StringDemo3 &#123; public static void main(String[] args) &#123; function_1(); &#125; /* * 定义方法,String类的构造方法 * String(byte[] bytes) 传递字节数组 * 字节数组转成字符串 * 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 * 平台 : 机器操作系统 * 默认字符集: 操作系统中的默认编码表, 默认编码表GBK * 将字节数组中的每个字节,查询了编码表,得到的结果 * 字节是负数,汉字的字节编码就是负数, 默认编码表 ,一个汉字采用2个字节表示 * * String(byte[] bytes, int offset, int length) 传递字节数组 * 字节数组的一部分转成字符串 * offset 数组的起始的索引 * length 个数,转几个 , 不是结束的索引 */ public static void function()&#123; byte[] bytes = &#123;97,98,99,100&#125;; //调用String类的构造方法,传递字节数组 String s = new String(bytes); System.out.println(s); byte[] bytes1 =&#123;65,66,67,68,69&#125;; //调用String构造方法,传递数组,传递2个int值 String s1 = new String(bytes1,1,3); System.out.println(s1); &#125; &#125; 09String类构造方法_2* A: String类构造方法 1234567891011121314151617181920212223242526272829303132* a: 常见构造方法 * public String(char[] value):把字符数组转成字符串 * public String(char[] value,int index,int count):把字符数组的一部分转成字符串* B: 案例代码 /* * String类构造方法 * String类的构造方法,重载形式 * */public class StringDemo3 &#123; public static void main(String[] args) &#123; function_1(); &#125; /* * String(char[] value) 传递字符数组 * 将字符数组,转成字符串, 字符数组的参数,不查询编码表 * * String(char[] value, int offset, int count) 传递字符数组 * 将字符数组的一部分转成字符串 * offset 数组开始索引 * count 个数 */ public static void function_1()&#123; char[] ch = &#123;'a','b','c','d','e','f'&#125;; //调用String构造方法,传递字符数组 String s = new String(ch); System.out.println(s); String s1 = new String(ch,1,4); System.out.println(s1); &#125;&#125; 10String类的其他方法* A：String类的其他方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143* a: 方法介绍* char charAt(int index):返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。* int length(): 返回字符串的长度* String substring(int beginIndex,int endIndex): 获取字符串的一部分* String substring(int beginIndex): 获取字符串的一部分* boolean startsWith(String prefix): 判断一个字符串是不是另一个字符串的前缀,开头* boolean endsWith(String prefix): 判断一个字符串是不是另一个字符串的后缀,结尾* boolean contains (String s): 判断一个字符串中,是否包含另一个字符串* int indexOf(char ch): 查找一个字符,在字符串中第一次出现的索引,被查找的字符不存在,返回-1* byte[] getBytes(): 将字符串转成字节数组,此功能和String构造方法相反,byte数组相关的功能,查询编码表* char[] toCharArray(): 将字符串转成字符数组,功能和构造方法相反* boolean equals(Object obj): 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true* boolean equalsIgnoreCase(String s): 传递字符串,判断字符串中的字符是否相同,忽略大小写 * b: 案例代码 public class StringDemo4 &#123; public static void main(String[] args) &#123; function_9(); &#125; /* * boolean equals(Object obj) * 方法传递字符串,判断字符串中的字符是否完全相同,如果完全相同返回true * * boolean equalsIgnoreCase(String s) * 传递字符串,判断字符串中的字符是否相同,忽略大小写 */ public static void function_9()&#123; String str1 = "Abc"; String str2 = "abc"; //分别调用equals和equalsIgnoreCase boolean b1 = str1.equals(str2); boolean b2 = str1.equalsIgnoreCase(str2); System.out.println(b1); System.out.println(b2); &#125; /* * char[] toCharArray() 将字符串转成字符数组 * 功能和构造方法相反 */ public static void function_8()&#123; String str = "itcast"; //调用String类的方法toCharArray() char[] ch = str.toCharArray(); for(int i = 0 ; i &lt; ch.length ; i++)&#123; System.out.println(ch[i]); &#125; &#125; /* * byte[] getBytes() 将字符串转成字节数组 * 此功能和String构造方法相反 * byte数组相关的功能,查询编码表 */ public static void function_7()&#123; String str = "abc"; //调用String类方法getBytes字符串转成字节数组 byte[] bytes = str.getBytes(); for(int i = 0 ; i &lt; bytes.length ; i++)&#123; System.out.println(bytes[i]); &#125; &#125; /* * int indexOf(char ch) * 查找一个字符,在字符串中第一次出现的索引 * 被查找的字符不存在,返回-1 */ public static void function_6()&#123; String str = "itcast.cn"; //调用String类的方法indexOf int index = str.indexOf('x'); System.out.println(index); &#125; /* * boolean contains (String s) * 判断一个字符串中,是否包含另一个字符串 */ public static void function_5()&#123; String str = "itcast.cn"; //调用String类的方法contains boolean b =str.contains("ac"); System.out.println(b); &#125; /* * boolean endsWith(String prefix) * 判断一个字符串是不是另一个字符串的后缀,结尾 * Demo.java * .java */ public static void function_4()&#123; String str = "Demo.java"; //调用String类方法endsWith boolean b = str.endsWith(".java"); System.out.println(b); &#125; /* * boolean startsWith(String prefix) * 判断一个字符串是不是另一个字符串的前缀,开头 * howareyou * hOw */ public static void function_3()&#123; String str = "howareyou"; //调用String类的方法startsWith boolean b = str.startsWith("hOw"); System.out.println(b); &#125; /* * String substring(int beginIndex,int endIndex) 获取字符串的一部分 * 返回新的字符串 * 包含头,不包含尾巴 * * String substring(int beginIndex)获取字符串的一部分 * 包含头,后面的字符全要 */ public static void function_2()&#123; String str = "howareyou"; //调用String类方法substring获取字符串一部分 str= str.substring(1, 5); System.out.println(str); String str2 = "HelloWorld"; str2 = str2.substring(1); System.out.println(str2); &#125; /* * int length() 返回字符串的长度 * 包含多少个字符 */ public static void function()&#123; String str = "cfxdf#$REFewfrt54GT"; //调用String类方法length,获取字符串长度 int length = str.length(); System.out.println(length); &#125; &#125; 11String类练习* A: 获取指定字符串中，大写字母、小写字母、数字的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445* a: 题目分析 * 为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。 * 为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。 * 对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1； * 如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。 * 显示大写字母、小写字母、数字的个数* b: 解题步骤 * 略* 案例代码public class StringTest &#123; public static void main(String[] args) &#123; getCount("A%A3eBr1FFy"); &#125; /* * 获取指定字符串中，大写字母、小写字母、数字的个数。 * 思想: * 1. 计数器,就是int变量,满足一个条件 ++ * 2. 遍历字符串, 长度方法length() + charAt() 遍历 * 3. 字符判断是大写,是小写,还是数字 */ public static void getCount(String str)&#123; //定义三个变量,计数 int upper = 0; int lower = 0; int digit = 0; //对字符串遍历 for(int i = 0 ; i &lt; str.length() ; i++)&#123; //String方法charAt,索引,获取字符 char c = str.charAt(i); //利用编码表 65('A')-90('Z') 97('a')-122('z') 48('0')-57('9') if(c &gt;='A' &amp;&amp; c &lt;='Z')&#123; upper++; &#125;else if( c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123; lower++; &#125;else if( c &gt;= '0' &amp;&amp; c &lt;='9')&#123; digit++; &#125; &#125; System.out.println(upper); System.out.println(lower); System.out.println(digit); &#125;&#125; 12String类练习_2* A: 将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。 12345678910111213141516171819202122232425262728293031323334* a: 题目分析* String toUpperCase(): 返回要转换为大写的 String。* String toLowerCase(): 返回要转换为小写的 String。 * 把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。 * 把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母 * 把两部分字符串连接在一起，得到一个完整的字符串* b: 解题步骤 * 略* C: 案例代码 public class StringTest &#123; public static void main(String[] args) &#123; System.out.println(toConvert("aBc5%4dEF")); &#125; /* * 将字符串的首字母转成大写,其他内容转成小写 * 思想: * 获取首字母, charAt(0) substring(0,1) * 转成大写 toUpperCase() * * 获取剩余字符串, substring(1) toLowerCase() */ public static String toConvert(String str)&#123; //定义变量,保存首字母,和剩余字符 String first = str.substring(0,1); String after = str.substring(1); //调用String类方法,大写,小写转换 first = first.toUpperCase(); after = after.toLowerCase(); return first+after; &#125; &#125; 13String类练习_3* A: 查询大字符串中，出现指定小字符串的次数 * 如&quot;hellojava,nihaojava,javazhenbang&quot;中查询出现&quot;java&quot;的次数。 12345678910111213141516171819202122232425262728293031323334353637*利用：* int indexOf(String str):返回指定子字符串在此字符串中第一次出现处的索引。* String substring(int beginIndex) :返回一个新的字符串，它是此字符串的一个子字符串。* a: 题目分析 * 在大串中，查找小串出现的位置，出现了就次数+1 * 在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。 * 回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止* b: 解题步骤 * 略* C: 案例代码 package cn.itcast.demo02;public class StringTest &#123; public static void main(String[] args) &#123; System.out.println(getStringCount("hellojava,nijavahaojava,javazhenbang", "java")); &#125; /* * 获取一个字符串中,另一个字符串出现的次数 * 思想: * 1. indexOf到字符串中到第一次出现的索引 * 2. 找到的索引+被找字符串长度,截取字符串 * 3. 计数器++ */ public static int getStringCount(String str, String key)&#123; //定义计数器 int count = 0; //定义变量,保存indexOf查找后的索引的结果 int index = 0; "开始循环找,条件,indexOf==-1 字符串没有了" while(( index = str.indexOf(key) )!= -1)&#123; count++; //获取到的索引,和字符串长度求和,截取字符串 str = str.substring(index+key.length()); &#125; return count; &#125;&#125; 14StringBuffer特点可变字符数组* A:StringBuffer类概述 1234567 *"StringBuffe：可变字符数组" * 通过JDK提供的API，查看StringBuffer类的说明 * "【线程安全】的【可变字符序列】 " * "底层采用【字符数组】实现,初始容量为【16】"* B:StringBuffer和String的区别 * "String是一个【不可变】的字符序列" * "StringBuffer是一个【可变】的字符序列" 15StringBuffer类的方法* A: StringBuffer类的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697* a: 方法介绍* StringBuffer append(), 将任意类型的数据,添加缓冲区 * append 返回值,写return this * 调用者是谁,返回值就是谁* delete(int start,int end): 删除缓冲区中字符 * 开始索引包含,结尾索引不包含* insert(int index, 任意类型): 将任意类型数据,插入到缓冲区的指定索引上* replace(int start,int end, String str): 将指定的索引范围内的所有字符,替换成新的字符串* reverse(): 将缓冲区中的字符反转* String toString(): 继承Object,重写toString() * 将缓冲区中的所有字符,变成字符串* b: 案例代码 public class StringBufferDemo &#123; public static void main(String[] args) &#123; function_5(); &#125; /* * StringBuffer类的方法 * String toString() 继承Object,重写toString() * 将缓冲区中的所有字符,变成字符串 */ public static void function_5()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.append(12345); //将可变的字符串缓冲区对象,变成了不可变String对象 String s = buffer.toString(); System.out.println(s); &#125; /* * StringBuffer类的方法 * reverse() 将缓冲区中的字符反转 */ public static void function_4()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.reverse(); System.out.println(buffer); &#125; /* * StringBuffer类方法 * replace(int start,int end, String str) * 将指定的索引范围内的所有字符,替换成新的字符串 */ public static void function_3()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.replace(1, 4, "Q"); System.out.println(buffer); &#125; /* * StringBuffer类方法 insert * insert(int index, 任意类型) * 将任意类型数据,插入到缓冲区的指定索引上 */ public static void function_2()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.insert(3, 9.5); System.out.println(buffer); &#125; /* * StringBuffer类方法 * delete(int start,int end) 删除缓冲区中字符 * 开始索引包含,结尾索引不包含 */ public static void function_1()&#123; StringBuffer buffer = new StringBuffer(); buffer.append("abcdef"); buffer.delete(1,5); System.out.println(buffer); &#125; /* * StringBuffer类方法 * StringBuffer append, 将任意类型的数据,添加缓冲区 * append 返回值,写return this * 调用者是谁,返回值就是谁 */ public static void function()&#123; StringBuffer buffer = new StringBuffer(); //调用StringBuffer方法append向缓冲区追加内容 buffer.append(6).append(false).append('a').append(1.5); System.out.println(buffer); &#125; &#125; 16StringBuilder类* A:StringBuilder的概述 1234567891011* 通过查看API了解一下StringBuilder类* B:面试题* "String,StringBuffer,StringBuilder的区别"——————————————————————————————————————————————————————————————————————————————————————* StringBuffer和StringBuilder的区别 * "【StringBuffer】是jdk1.0版本的,是【线程安全】的,【效率低】 " * "【StringBuilder】是jdk1.5版本的,【不保证同步】，是【线程不安全】的,【效率高】 "——————————————————————————————————————————————————————————————————————————————————————* String和StringBuffer,StringBuilder的区别 * "【String】是一个【不可变】的【字符序列】 " * "StringBuffer,StringBuilder是【可变】的【字符序列】 " 17StringBuffer类案例拼接数组* A: StringBuffer类案例拼接数组 12345678910111213141516171819202122232425262728293031323334353637* a: 题目分析 * 定义StringBuffer对象 * 遍历数组,按照格式要求拼接处新的字符串,追加到StringBuffer容器中 * 将StringBuffer中的内容以String的形式返回* b: 解题步骤 * 略* C: 案例代码 public class StringBufferTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,1,4,56,7,8,76&#125;; System.out.println(toString(arr)); &#125; /* * int[] arr = &#123;34,12,89,68&#125;;将一个int[]中元素转成字符串 * 格式 [34,12,89,68] * String s = "[" * 数组遍历 * s+= arr[i]; * s+"]" * StringBuffer实现,节约内存空间, String + 在缓冲区中,append方法 */ public static String toString(int[] arr)&#123; //创建字符串缓冲区 StringBuffer buffer = new StringBuffer(); buffer.append("["); //数组遍历 for(int i = 0 ; i &lt; arr.length;i++)&#123; //判断是不是数组的最后一个元素 if(i == arr.length-1)&#123; buffer.append(arr[i]).append("]"); &#125;else&#123; buffer.append(arr[i]).append(","); &#125; &#125; return buffer.toString(); &#125; &#125; 18总结1234567891011121314151617181920212223242526272829303132333435363738394041424344 Object: 它是所有类的超类，祖宗类。java中所有的类都直接或间接的继承这个类 方法public String toString() 返回当前对象中的内容, 对于Object类默认操作来说，返回的对象的类型+@+内存地址值public boolean equals(Object obj) 比较两个对象内容是否相同，对于Object类默认操作来说,比较的是地址值—————————————————————————————————————————————————————————————————————————————————————— String: 字符串类，字符串是常量；它们的值在创建之后不能更改 方法boolean equals(Object obj) 判断两个字符串中的内容是否相同boolean equalsIgnoreCase(String str) 判断两个字符串中的内容是否相同, 忽略大小写boolean contains(String str) 判断该字符串中 是否包含给定的字符串boolean startsWith(String str) 判断该字符串 是否以给定的字符串开头boolean endsWith(String str) 判断该字符串 是否以给定的字符串结尾boolean isEmpty() 判断该字符串的内容是否为空的字符串 ""int length() 获取该字符串的长度char charAt(int index) 获取该字符串中指定位置上的字符 String substring(int start) 从指定位置开始，到末尾结束，截取该字符串，返回新字符串String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串，返回新字符串 int indexOf(int ch ) 获取给定的字符，在该字符串中第一次出现的位置int indexOf(String str) 获取给定的字符串，在该字符串中第一次出现的位置int indexOf(int ch,int fromIndex) 从指定位置开始，获取给定的字符，在该字符byte[] getBytes() 把该字符串 转换成 字节数组char[] toCharArray() 把该字符串 转换成 字符数组String replace(char old,char new) 在该字符串中，将给定的旧字符，用新字符替换String replace(String old,String new) 在该字符串中， 将给定的旧字符串，用新字符串替换String trim() 去除字符串两端空格，中间的不会去除，返回一个新字符串String toLowerCase() 把该字符串转换成 小写字符串 String toUpperCase() 把该字符串转换成 大写字符串int indexOf(String str,int fromIndex) 从指定位置开始，获取给定的字符串，在该字符串中第一次出现的位置—————————————————————————————————————————————————————————————————————————————————————— StringBuffer/StringBuilder: 方法public StringBuffer append(String str) 在原有字符串缓冲区内容基础上，在末尾追加新数据public StringBuffer insert(int offset,String str) 在原有字符串缓冲区内容基础上，在指定位置插入新数据public StringBuffer deleteCharAt(int index) 在原有字符串缓冲区内容基础上，删除指定位置上的字符public StringBuffer delete(int start,int end) 在原有字符串缓冲区内容基础上，删除指定范围内的多个字符public StringBuffer replace(int start,int end,String str)在原有字符串缓冲区内容基础上， 将指定范围内的多个字符 用给定的字符串替换public StringBuffer reverse() 将字符串缓冲区的内容 反转 "abc"----"cba"public String substring(int start) 从指定位置开始，到末尾结束，截取该字符串缓冲区，返回新字符串public String substring(int start,int end) 从指定位置开始，到指定位置结束，截取该字符串缓冲区，返回新字符串]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础12(修饰符,“变参”方法,Comparable、Comparator接口,lambda表达式)]]></title>
    <url>%2F2016%2F10%2F16%2Fday14%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、不同修饰符混合使用细节2、辨析何时定义变量为成员变量3、类、抽象类、接口作为方法参数4、类、抽象类、接口作为方法返回值5、参数数量可变的方法（“变参”方法）6、Comparable 接口 &amp;&amp; Comparator 接口7、lambda表达式 不同修饰符使用细节A: 常用来修饰类、方法、变量的修饰符如下：12345678910111213 public 权限修饰符，【公共访问】, "类,方法,成员变量"————————————————————————————————————————————————————————— protected 权限修饰符，【受保护访问】, "方法,成员变量"，"注意【不能】修饰类"————————————————————————————————————————————————————————— 【默认什么也不写】 也是一种权限修饰符，【默认访问】, "类,方法,成员变量"————————————————————————————————————————————————————————— private 权限修饰符，【私有访问】, "方法,成员变量"———————————————————————————————————————————————————————————————————————————————————————— static 静态修饰符 "方法,成员变量,静态内部类"————————————————————————————————————————————————————————— final 最终修饰符 "类,方法,成员变量,局部变量"————————————————————————————————————————————————————————— abstract 抽象修饰符 "类 ,方法" B: 不能同时使用的修饰符12345678910111213141516171819202122232425262728同时，abstract 与 private "不能"同时使用；(私有abstract不能继承，无意义)同时，abstract 与 static "不能"同时使用；(abstract没有方法体，静态通过类名调用，无意义)同时，abstract 与 final "不能"同时使用。(abstract没有方法体，final不能重写，无意义)————————————————————————————————————————————————————————————————————————————————————————小结：1.抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量。抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。抽象类中有构造函数用于给子类对象进行初始化，同时"抽象类中【可以】含有非抽象方法"。—————————————————————————————————————————————————————————abstract关键字"不可以"与final，private,static关键字共存，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。如果static和abstract共同修饰父类中的方法，static表示是"静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现"，这与abstract关键字矛盾。————————————————————————————————————————————————————————————————————————————————————————2.static用于修饰成员变量和成员函数，想要"实现对象中的【共性数据】的【对象共享】"，可以将这个数据进行静态修饰，"被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在"。"静态方法只能访问静态成员（静态方法和静态变量），不可以【直接】用【成员名】访问非静态成员，需要new（创建对象）访问。这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员"。静态方法中"不能"使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。————————————————————————————————————————————————————————————————————————————————————————3.final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。被final修饰的变量只能是一个常量，只能赋值一次。内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。  C: 修饰类能够使用的修饰符：123456789修饰类【只能】使用public、默认的、final、abstract关键字静态内部类：static使用最多的是 public关键字a:代码案例 public class Demo &#123;&#125; //最常用的方式 class Demo2&#123;&#125; public final class Demo3&#123;&#125; public abstract class Demo4&#123;&#125; D:修饰成员变量能够使用的修饰符：1234567891011121314151617181920public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————final : 最终的static : 静态的使用最多的是 private修饰【成员变量】,【除了】 abstract 都可以————————————————————————————————————————————————————————————————————————————————————————a: 代码案例 public int count = 100; protected int count2 = 100; int count3 = 100; private int count4 = 100; //最常用的方式 public final int count5 = 100; public static int count6 = 100;  E:修饰构造方法能够使用的修饰符： 1234567891011121314public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————使用最多的是 publica:代码案例 public Demo()&#123;&#125; //最常用的方式 protected Demo()&#123;&#125; Demo()&#123;&#125; private Demo()&#123;&#125;  F:修饰成员方法能够使用的修饰符：123456789101112131415161718192021222324public : 公共的protected : 受保护的 : 默认的private ：私有的"【权限修饰符都可以】"————————————————————————————————————————————————————————————————————————————————————————final : 最终的static : 静态的abstract : 抽象的————————————————————————————————————————————————————————————————————————————————————————使用最多的是 publica:代码案例 public void method1()&#123;&#125;//最常用的方式 protected void method2()&#123;&#125; void method3()&#123;&#125; private void method4()&#123;&#125; public final void method5()&#123;&#125; public static void method6()&#123;&#125;//最常用的方式 public abstract void method7();//最常用的方式 局部变量和成员变量解析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 定义长方形类，包含求周长与求面积的方法 定义数学工具类，包含求两个数和的二倍与求两个数积的方法【思考】：这两个类的计算方法均需要两个数参与计算，请问两个数定义在【成员位置】还是【形参位置】更好，为什么？"如果变量是【该类的一部分】时，定义成【成员变量】。 ""如果变量【不应该是类的一部分】，而仅仅是【功能】当中需要【参与计算的数】，则定义为【形参变量】。"* A：程序编译 数学工具类public class MathTool &#123; //求两个数的和的二倍 public double sum2times(int number,int number2) &#123; return (number+number2)*2; &#125; //求两个数的积 public double area(int number,int number2) &#123; return number*number2; &#125;&#125; 长方形类public class CFX &#123; //因为长与宽，在现实事物中属于事物的一部分，所以定义成员变量 private int chang; private int kuan; public CFX(int chang, int kuan) &#123; this.chang = chang; this.kuan = kuan; &#125; //求长与宽的周长 public double zhouChang() &#123; return (chang+kuan)*2; &#125; //求长与宽的面积 public double mianJi() &#123; return chang*kuan; &#125; public int getChang() &#123; return chang; &#125; public void setChang(int chang) &#123; this.chang = chang; &#125; public int getKuan() &#123; return kuan; &#125; public void setKuan(int kuan) &#123; this.kuan = kuan; &#125;&#125; 类作为方法的参数与返回值* A： 类作为方法参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647在编写程序中，会经常碰到调用的方法要接收的是一个类类型的情况，那么这时，要向方法中传入该类的对象。如下代码演示： class Person&#123; public void show()&#123; System.out.println("show方法执行了"); &#125; &#125; //测试类 public class Test &#123; public static void main(String[] args) &#123; //创建Person对象 Person p = new Person(); //调用method方法 method(p); &#125; //定义一个方法method，用来接收一个Person对象，在方法中调用Person对象的show方法 public static void method(Person p)&#123; p.show(); &#125;———————————————————————————————————————————————————————————————————————————————————————— B：类作为方法返回值写程序调用方法时，我们以后会经常碰到"【返回】一个【类】类型的【返回值】"，那么这时，该方法要"返回"（return）一个"【该类的对象】"。如下代码演示：class Person&#123; public void show()&#123; System.out.println("show方法执行了"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的Person对象 Person p = method(); //调用p对象中的show方法 p.show(); &#125; //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建 public static Person method()&#123; Person p = new Person(); //返回的是 【类的对象】 return p; &#125;&#125; 抽象类作为方法参数与返回值* A: 抽象类作为方法参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667今后开发中，【抽象类】作为【方法参数】的情况也很多见。"当遇到【方法参数】为【抽象类】类型时，要传入一个【实现】【抽象类】【所有抽象方法】的【子类对象】"。"抽象类【没有对象】，只能通过【多态】的方式，传递【抽象类】的【子类】的【对象】"如下代码演示：//抽象类abstract class Person&#123; public abstract void show();&#125;class Student extends Person&#123; @Override public void show() &#123; System.out.println("重写了show方法"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //通过多态的方式，创建一个Person类型的变量，而这个对象实际是Student Person p = new Student(); //调用method方法 method(p); &#125; //定义一个方法method，用来接收一个Person类型对象，在方法中调用Person对象的show方法 public static void method(Person p)&#123;//抽象类作为参数 //抽象类【没有对象】，只能通过【多态】的方式，传递【抽象类】的【子类】的【对象】 //通过p变量调用show方法,这时实际调用的是Student对象中的show方法 p.show(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————* B: 抽象类作为方法返回值"【抽象类】作为【方法返回值】的情况，这时需要【返回】一个实现抽象类【所有抽象方法】的【子类对象】。""抽象类【没有对象】，只能通过【多态】的方式，返回的是【抽象类】的【子类】的【对象】"如下代码演示：//抽象类abstract class Person&#123; public abstract void show();&#125;class Student extends Person&#123; @Override public void show() &#123; System.out.println("重写了show方法"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的Person对象 Person p = method(); //通过p变量调用show方法,这时实际调用的是Student对象中的show方法 p.show(); &#125; //定义一个方法method，用来获取一个Person对象，在方法中完成Person对象的创建 public static Person method()&#123; Person p = new Student(); //抽象类【没有对象】，只能通过【多态】的方式，返回的是【抽象类】的【子类】的【对象】 return p; &#125;&#125; 接口作为方法参数与返回值* A: 接口作为方法参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465【接口】作为【方法参数】的情况是很常见的，经常会碰到。当遇到方法参数为【接口类型】时，那么该方法要传入一个"【接口实现类】【对象】"。"【接口】【没有对象】，只能通过【多态】的方式，【传入】的是【接口】的【实现类】的【对象】"如下代码演示。//接口interface Smoke&#123; public abstract void smoking();&#125;class Student implements Smoke&#123; @Override public void smoking() &#123; System.out.println("no smoking"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //通过多态的方式，创建一个Smoke类型的变量，而这个对象实际是Student Smoke s = new Student(); //调用method方法 method(s); &#125; //定义一个方法method，用来接收一个Smoke类型对象，在方法中调用Smoke对象的show方法 public static void method(Smoke sm)&#123;//接口作为参数 //通过sm变量调用smoking方法，这时实际调用的是Student对象中的smoking方法 sm.smoking(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————* B: 接口作为方法返回值接口作为方法返回值的情况，在后面的学习中会碰到。当遇到方法返回值是接口类型时，那么该方法需要返回一个"【接口实现类对象】"。"【接口】【没有对象】，只能通过【多态】的方式，【返回】的是【接口】的【实现类】的【对象】"如下代码演示。//接口interface Smoke&#123; public abstract void smoking();&#125;class Student implements Smoke&#123; @Override public void smoking() &#123; System.out.println("no smoking"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //调用method方法，获取返回的会吸烟的对象 Smoke s = method(); //通过s变量调用smoking方法,这时实际调用的是Student对象中的smoking方法 s.smoking(); &#125; //定义一个方法method，用来获取一个具备吸烟功能的对象，并在方法中完成吸烟者的创建 public static Smoke method()&#123; Smoke sm = new Student(); return sm; &#125;&#125; 星级酒店案例* A:  根据“某五星级酒店，资金雄厚……都有自己的工作要做。”分析出，该题 目中包含酒店，可以把它封装成类，多名员工）。 1234567891011121314151617181920212223242526272829class 员工 &#123; 属性：姓名属性：工号方法：工作&#125;class 厨师 extends 员工&#123;&#125;class 服务员 extends 员工&#123;&#125;class 经理 extends 员工 &#123; 属性：奖金&#125;员工的类型有经理、厨师、服务员，它们有共同的属性（姓名、工号、），经理额外属性（奖金）。 根据“向酒店中，增加多名员工（其中包含1名经理，1名厨师、2名服务员）”。分析出，要创建一个酒店对象，并添加4名员工到酒店对象的员工集合中。酒店员工集合添加新员工： 经理对象酒店员工集合添加新员工： 厨师对象酒店员工集合添加新员工： 服务员对象酒店员工集合添加新员工： 服务员对象 根据“获取酒店幸运员工”。分析出，从酒店员工集合随机得到一名员工对象。1. 从酒店员工集合长度范围内，随机产生一个随机数2. 使用该随机数作为集合的索引，返回该索引处对应的员工对象 根据“酒店开设VIP服务，酒店的厨师与服务员可以提供VIP服务。（厨师做菜加量、服务员给顾客倒酒）”。分析出，这是要增加一个VIP的接口，接口中提供个VIP服务的方法。让厨师与服务员实现该接口。interface VIP服务&#123; 抽象方法：服务&#125;class 厨师 extends 员工 implements VIP服务&#123; 重写服务方法 &#125;class 服务员 extends 员工 implements VIP服务&#123; 重写服务方法 &#125; B:  VIP服务 public interface VIP { public abstract void server(); //服务 }  员工 1234567891011121314151617181920212223242526272829303132333435363738/** 员工：姓名 String工号 String*/public abstract class YuanGong &#123; // 成员变量 private String xingMing; private String gongHao; // 构造方法 public YuanGong() &#123; super(); &#125; public YuanGong(String xingMing, String gongHao) &#123; super(); this.xingMing = xingMing; this.gongHao = gongHao; &#125; // 抽象方法 public abstract void work(); // getters与setters public String getXingMing() &#123; return xingMing; &#125; public void setXingMing(String xingMing) &#123; this.xingMing = xingMing; &#125; public String getGongHao() &#123; return gongHao; &#125; public void setGongHao(String gongHao) &#123; this.gongHao = gongHao; &#125; &#125;  服务员 1234567891011121314151617181920/** 定义员工的子类 服务员类*/public class FuWuYuan extends YuanGong implements VIP &#123; public FuWuYuan() &#123; super(); &#125; public FuWuYuan(String xingMing, String gongHao) &#123; super(xingMing, gongHao); &#125; @Override public void work() &#123; System.out.println("亲，全身心为您服务，记得给好评哦"); &#125; @Override public void server() &#123; System.out.println("给顾客倒酒"); &#125;&#125;  经理 1234567891011121314151617181920212223242526/** 经理在员工的基础上，添加了奖金成员*/public class JingLi extends YuanGong &#123; private double jiangJin; public JingLi() &#123; super(); &#125; public JingLi(String xingMing, String gongHao, double jiangJin) &#123; super(xingMing, gongHao); this.jiangJin = jiangJin; &#125; public double getJiangJin() &#123; return jiangJin; &#125; public void setJiangJin(double jiangJin) &#123; this.jiangJin = jiangJin; &#125; @Override public void work() &#123; System.out.println("哪个员工让顾客不满意，我扣谁钱"); &#125;;&#125;  厨师 1234567891011121314151617181920/** 定义员工的子类 厨师类*/public class ChuShi extends YuanGong implements VIP&#123; public ChuShi() &#123; super(); &#125; public ChuShi(String xingMing, String gongHao) &#123; super(xingMing, gongHao); &#125; @Override public void work() &#123; System.out.println("我做饭，放心吃吧，包您满意"); &#125; @Override public void server() &#123; System.out.println("做菜加量加料"); &#125;&#125; 参数数量可变的方法（“变参”方法）1234567891011121314151617181920212223242526272829303132333435现在的版本提供了可以用可变的参数数量调用的方法（有时称为“ 变参” 方法。)printf方法是这样定义的：public class PrintStream&#123; public PrintStream printf(String fmt , Object ... args) &#123; return format(fmt, args); &#125;&#125;这里的省略号 . . . 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象（除 format参数之外。)———————————————————————————————————————————————————————————————————————————————————————————实际上，printf 方法接收"两个参数"， 一个是"格式字符串"， 另一个是 "Object [] 数组"， "Object [] 数组" 保存着所有的参数（"如果调用者提供的是【整型数组或者其他基本类型】的值， 【自动装箱】功能将【把它们】【转换成对象】 )。现在将扫描format 字符串， 并将第 i 个格式说明符与 args[i] 的值匹配起来"=&gt;&gt; "Object… 参数类型与 Object[ ] 完全一样"———————————————————————————————————————————————————————————————————————————————————————————编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上， 并在必要的时候进行自动装箱：System.out.printf("%d %s", new Object [] &#123; new Integer(n), "widgets" &#125; );"用户自己也可以定义可变参数的方法， 并将参数指定为【任意类型】， 【甚至】是【基本类型】"———————————————————————————————————————————————————————————————————————————————————————————public class Demo &#123; public static void main(String[] args) &#123; func("How ","are ","you"); &#125; public static void func(String ... args)&#123;//等效于 args -&gt; new String []&#123;"How ","are ","you"&#125;; for(String value : args)&#123; System.out.println(value); &#125; &#125;&#125;编译器将 new String []&#123;"How ","are ","you"&#125; 传递给 args甚至可以将 main 方法声明为下列形式：public static void main(String... args) Comparable 接口 &amp;&amp; Comparator 接口123456789101112131415### 总结``` java不同修饰符的使用类，最常使用public修饰成员变量，最常使用private修饰成员方法，最常使用public修饰自定义数据类型的使用"【类】作为【方法参数】时，说明要向方法中传入【该类的对象】""【类】作为【方法返回值】时，说明该方法要返回一个【该类的对象】。""【抽象类】作为【方法参数】时，说明要传入一个实现【抽象类】【所有抽象方法】的【子类对象】。""【抽象类】作为【方法返回值】时，说明需要返回一个实现【抽象类】【所有抽象方法】的【子类对象】。""【接口】作为【方法参数】时，说明该方法要传入一个【接口】【实现类对象】。""【接口】作为【方法返回值】时，说明该方法需要返回一个【接口】【实现类对象】。"]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础11(final、static，内部类，包，代码块)]]></title>
    <url>%2F2016%2F10%2F15%2Fday13%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、final 关键字2、static 关键字3、匿名对象4、内部类5、包的声明与访问6、访问修饰符7、代码块 01final关键字概念* A: 概述 12345继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。 02final修饰类义* A: final 修饰类 12345 final修饰类"【不可以】【被继承】，但是【可以继承】其他类"。* B: 案例 class Yy &#123;&#125; final class Fu extends Yy&#123;&#125; //可以继承Yy类 class Zi extends Fu&#123;&#125; //不能继承Fu类 03final修饰方法* A: final修饰方法 1234567891011  final修饰的方法"不可以被覆盖","但如果父类中【没有】被final修饰方法，子类【覆盖】"后可以加final。* B: 案例 class Fu &#123; // final修饰的方法，不可以被覆盖，但可以继承使用 public final void method1()&#123;&#125; public void method2()&#123;&#125; &#125; class Zi extends Fu &#123; //重写method2方法 public final void method2()&#123;&#125; &#125; 04final修饰局部变量* A:修饰基本数据类型变量 1234567891011121314151617final修饰的变量称为常量，这些变量只能赋值一次 * B:案例1 final int i = 20; i = 30; //赋值报错，final修饰的变量只能赋值一次 * C: 修饰引用数据类型 "【引用类型】的变量值为【对象地址值】，地址值【不能更改】， 但是【地址内的对象属性值可以修改】"* D: 修饰引用数据类型 final Person p = new Person(); Person p2 = new Person(); p = p2; //final修饰的变量p，所记录的地址值不能改变 p.name = "小明";//可以更改p对象中name属性值 p不能为别的对象，而p对象中的name或age属性值可更改。 05final修饰成员变量* A: 修饰成员变量 123456789101112131415 "修饰成员变量，需要在【创建对象】前赋值，否则报错。(当没有显式赋值时，如有多个构造方法，则均需要为其赋值。)"* B: 案例 class Demo &#123; //直接赋值 final int m = 100; //final修饰的成员变量，需要在创建对象前赋值，否则报错。 final int n; public Demo()&#123; //可以在创建对象时所调用的构造方法中，为变量n赋值 n = 2016; &#125; &#125; 06static的概念* A：概念 1234当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。"当在调用对象的某个方法时，但是这个方法【没有】访问到对象的【特有数据】时，方法创建这个对象有些多余。"可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？"可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。" 07static修饰的对象特有数据* A：特点1: 12345678910111213141516171819202122被 static "修饰的成员变量" "【属于类】"，"【不属于】这个类的某个对象"。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即"多个对象共享同一个" static 成员变量）" 被静态修饰的成员，可以被 【类名】 【直接调用】""对象的【特有数据】： （非静态修饰）=&gt; 【调用者只能是New 对象】对象的【共享数据】： （静态修饰） =&gt; 【调用者是类名，也可以是New 对象(不建议这样用)】"* B: 代码演示 class Demo &#123; public static int num = 100; &#125; class Test &#123; public static void main(String[] args) &#123; Demo d1 = new Demo(); Demo d2 = new Demo(); d1.num = 200; System.out.println(d1.num); //结果为200 System.out.println(d2.num); //结果为200 &#125; &#125; 08static的内存图 09static注意事项_【静态不能直接调用非静态】* A: 注意事项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 被static修饰的成员可以并且"建议通过类名直接访问"。 * B: 访问静态成员的格式：" 类名.静态成员变量名 类名.静态成员方法名(参数)" 对象名.静态成员变量名 ------不建议使用该方式，会出现警告 对象名.静态成员方法名(参数) ------不建议使用该方式，会出现警告 * C: 代码演示 class Demo &#123; //静态成员变量 public static int num = 100; //静态方法 public static void method()&#123; System.out.println("静态方法"); &#125; &#125; class Test &#123; public static void main(String[] args) &#123; System.out.println(Demo.num); Demo.method(); &#125; &#125;————————————————————————————————————————————————————————————————————————————————————————*"【静态内容】是优先于【对象】存在，【只能访问静态】"，"不能"使用this/super。"静态修饰的内容存于静态区"。class Demo &#123; //成员变量 public int num = 100; //静态方法 public static void method()&#123; //this.num; 不能使用this/super。 System.out.println(this.num); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"同一个类中，静态成员【只能】访问静态成员"class Demo &#123; //成员变量 public int num = 100; //静态成员变量 public static int count = 200; //静态方法 public static void method()&#123; //System.out.println(num); 静态方法中，只能访问静态成员变量或静态成员方法 System.out.println(count); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"【非静态内容】 【只能】 通过 创建【本类对象】，再通过【 对象.成员变量 】 OR 【 对象.成员方法(参数) 】的方式调用"class Demo &#123; //成员变量 public int num = 100; //静态成员变量 public static int count = 200; //非静态方法 public void function()&#123; System.out.println("这是非静态方法 function"); &#125; //静态方法 public static void method()&#123; //System.out.println(num); // 静态方法中，只能访问静态成员变量或静态成员方法 System.out.println(count); //【非静态内容】 【只能】 通过 创建【本类对象】， // 再通过【 对象.成员变量 】 OR 【 对象.成员方法(参数) 】的方式调用 Demo d = new Demo(); System.out.println(d.num); d.function(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————*"main方法为静态方法仅仅为程序执行入口，它【不属于任何一个对象】，可以定义在任意类中。"————————————————————————————————————————————————————————————————————————————————————————举例：class Test&#123; public static void hello()&#123; System.out.println("hello"); &#125; &#125;public class TTTss &#123; public static void main(String[] args) &#123; Test tt = null; tt.hello(); &#125;&#125;运行结果：能编译通过，并能正常运行，打印：hello。注意：Test类中的方法 hello() 是静态static 的，因此，"hello()方法归类所有，与对象无关。当实例化Test类的时候，【静态成员】会被【优先加载】而且【只加载一次】，所以【不受】【实例化对象】 new Test();影响"，"只要是用到了Test类，都会加载静态 hello()方法。"此外，在【其他类】的【静态方法】中也能调用public的静态hello()方法。—————————————————————————————————————————————————————————总结： "静态方法【不受】实例化对象的影响"，即使Test tt = null; 这是只要调用了Test类，就会加载静态方法，tt中包含了Test类的初始化数据。 此外，如果hello()是【非静态的方法】，那就会报NullPointerException异常。 10static静态的使用场景* A: 使用场景 1234567static可以修饰"【成员变量】"和"【成员方法】"。 什么时候使用static修饰"成员变量"？ 加static修饰成员的时候，"这个成员会被类的所有对象所共享。一般我们把【共性数据】定义为静态的变量。"————————————————————————————————————————————————————————————————————————————————————————什么时候使用static修饰"成员方法"？ "静态的方法【只能】访问静态的成员"，" 如果静态方法中引用到了静态的其他成员，那么这个方法需要声明为静态的方法。" "方法中【没有】调用【非静态成员变量】，则将方法定义为【静态】" 11对象中的静态调用* A: 对象的静态调用 123456789101112131415"在多态中，无论是【静态成员变量】 还是【非静态成员变量】，【都看父类】"————————————————————————————————————————————————————————————————————————————————————————" 在多态中，【非静态成员方法】【编译】【看父类】，【运行】【看子类】，【父类没有】则编译失败。"————————————————————————————————————————————————————————————————————————————————————————" 但多态中的【静态成员方法】,【编译看父类】,【运行仍然看父类】。因为【静态和对象没有关系】，属于【静态绑定】。"————————————————————————————————————————————————————————————————————————————————————————即："【只有】【非静态成员方法】 运行看 【子类】,其他看父类"————————————————————————————————————————————————————————————————————————————————————————* B: 举例public class Test&#123; public static void main(String[] args)&#123; Fu f = new Zi(); f.show(); //父类的引用和父类的方法绑定,和对象无关,不会在运行时动态的执行子类特有的方法。 &#125;&#125; 12定义静态常量* A: 静态常量 123456789101112131415161718192021222324252627开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。"此时变量名用【全部大写】，多个单词使用下划线连接。"* B: 定义格式： public static final 数据类型 变量名 = 值; * C: 如下演示： class Company &#123; public static final String COMPANY_NAME = "传智播客"; public static void method()&#123; System.out.println("一个静态方法"); &#125; &#125; "当我们想使用类的静态成员时，【不需要创建对象】，【直接使用类名】来访问即可。" System.out.println(Company.COMPANY_NAME); //打印传智播客 Company.method(); // 调用一个静态方法* D: 注意： "接口中的每个【成员变量】都默认使用" public static final修饰。 "所有【接口】中的【成员变量】【必须是静态常量】，由于【接口】【没有】【构造方法】， 所以【必须显示赋值】。可以【直接】用【接口名】访问" interface Inter &#123; public static final int COUNT = 100; &#125; " 访问接口中的静态变量 ": Inter.COUNT&#125; 13匿名对象* A:匿名对象的概述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546* 匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。* B:案例public class Person&#123; public void eat()&#123; System.out.println();&#125;&#125;创建一个普通对象Person p = new Person();"创建一个匿名对象"new Person();* C: 匿名对象的特点a:"创建匿名对象【直接使用】，【没有变量名】"。 new Person().eat() //"eat方法被一个没有名字的Person对象调用了"。b:"【匿名对象】在【没有指定】其【引用变量】时，【只能】【使用一次】，第二次使用则【重新】创建了【新的匿名对象】"。 new Person().eat(); 创建一个匿名对象，调用eat方法 new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象 c:"【匿名对象】可以作为【方法接收的参数】、【方法返回值】使用" class Demo &#123; public static Person getPerson()&#123; //普通方式 //Person p = new Person(); //return p; //匿名对象作为方法返回值 return new Person(); &#125; public static void method(Person p)&#123;&#125; &#125; class Test &#123; public static void main(String[] args) &#123; //调用getPerson方法，得到一个Person对象 Person person = Demo.getPerson(); //调用method方法 Demo.method(person); //匿名对象作为方法接收的参数 Demo.method(new Person()); &#125; &#125; 14内部类及其特点12345678910111213141516171819202122232425262728293031323334353637383940" 将类写在其他类的【内部】，可以写在其他类的【成员位置】和【局部位置】，这时写在其他类内部的类就称为【内部类】。其他类也称为外部类 "。* B: 什么时候使用内部类 在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机， 这时发动机就可以使用内部类来描述。 class 汽车 &#123; //外部类 class 发动机 &#123; //内部类 &#125; &#125;* C: 内部类的分类 注意：(1) "外部类 修饰符 【只能】使用 public 和 【省略访问控制符】" —————————————————————————————————————————————— "内部类 修饰符 可以使用：public protected private static 和 【省略访问控制符】"解释： 外部类的上一级程序单元是包，所以它只有2个作用域:"同一个包内和任何位置"。因此只需2种访问权限:"包访问权限和公开访问权限"，正好对应"省略访问控制符和public访问控制符"。省略访问控制符是包访问权限，即同一包中的其他类可以访问省略访问控制符的成员。因此，如果一个外部类不使用任何访问控制符修饰，则只能被同一个包中其他类访问。而内部类的上一级程序单元是外部类，它就具有4个作用域:同一个类、同一个包、父子类和任何位置，因此可以使用4种访问控制权限————————————————————————————————————————————————————————————————————————————————————————(2) "【非静态成员内部类】【不能】拥有【静态成员】" 根据静态成员不能直接访非静态成员的规则， "外部类的【静态方法】、静态代码块【不能直接】访问【非静态内部类】， 包括不能直接使用非静态内部类定义变量、创建实例等。" 总之，【不允许】在外部类的【静态成员】中直接使用【非静 态内部类】 —————————————————————————————————————————————— 《 非静态方法可以调用静态成员方法和静态成员变量 》———————————————————————————————————————————————————————————————————————————————————————— "内部类分为【成员内部类】与【局部内部类】"。———————————————————————————————————————————————————————————————————————————————————————— "我们【定义】【内部类】时，就是一个【正常定义类】的过程， 【同样】【包含】各种【修饰符】、【继承】与【实现关系】等"。———————————————————————————————————————————————————————————————————————————————————————— "在【内部类】中可以【直接】访问【外部类】的【所有成员】"。 15成员内部类的调用格式* A: 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102"【成员内部类】，定义在【外部类】中的【成员位置】。与类中的成员变量【相似】，可通过【外部类】【对象】进行访问"* B: 定义格式class 外部类 &#123; 修饰符 class 内部类 &#123; //其他代码 &#125;&#125;* C: 访问方式————————————————————————————————————————————————————————————————————————————————————————外部类名.内部类名 变量名 = new 外部类名().new 内部类名();Outer.this.成员 &gt;&gt;&gt; "表示内部类对外部类的成员引用"this.成员 &gt;&gt;&gt; "表示内部类对自己成员的调用"————————————————————————————————————————————————————————————————————————————————————————注：其他类调用内部类的成员：（一）访问"【非静态成员内部类】"："——————————————————————————————————————————————————————————"外部类名.内部类名 变量名 = new 外部类名().new 内部类名();"——————————————————————————————————————————————————————————"*************************************************************************************************"【非静态内部类】【不能】 定义【 静态方法、静态成员变量、静态初始化块】"*************************************************************************************************"需要在外部类中创建 内部类对象 ==&gt;&gt;&gt;调用方法"： 根据静态成员不能直接访非静态成员的规则， "外部类的【静态方法】、静态代码块【不能直接】访问【非静态内部类】， 包括不能直接使用非静态内部类定义变量、创建实例等。" 总之，【不允许】在中直接使用【非静 态内部类】举例：public class Outer_0 &#123; //非静态内部类 public class Inner_0&#123; &#125; //外部类的【静态方法】 public static void static_method()&#123; new Inner_0();//error,不允许在外部类的【静态成员】中【直接使用】非静态静内部类 "正确调用方式" new Outer_0().new Inner_0(); &#125;&#125;访问"【非静态成员内部类】"：（1）在【外部类】的"【非静态方法】"中访问： "【new 内部类名()" OR "【 new 外部类名().new 内部类名() 】" （2）在【外部类以外】的"【非静态方法】"中访问： "【只能】【 new 外部类名().new 内部类名() 】"（3）在【外部类】及 【外部类以外】的"【静态方法】"中访问：" 【只能】通过【 new 外部类名().new 内部类名() 】" 方式访问————————————————————————————————————————————————————————————————————————————————————————（二）访问"【静态成员内部类】"："——————————————————————————————————————————————————————————"（1）在【外部类】中使用静态内部类new 静态内部类名();调用静态内部类的"【非静态方法】"：new 外部类名.静态内部类名()调用静态内部类的"【静态方法】"： 静态内部类名.静态方法名(); （2）在【外部类以外】使用静态内部类 因为【静态内部类】是外部类"类相关"的，"因此创建静态内部类对象时【无须】创建外部类对象"。在【外部类以外】的地方创建静态内部类实例的语法："***************************************************************************************"外部类名.内部类名 变量名 = new 外部类名.静态内部类名();"***************************************************************************************" A:【调用非静态方法】： 变量名.静态方法名() OR new 外部类名.静态内部类名().静态方法名()"——————————————————————————————————————————————————————————" B:【调用静态方法】："在【外部类以外】：访问方式无需创建对象，利用 【 外部类名.静态内部类名.内部类静态方法 】访问内部类【静态方法】"————————————————————————————————————————————————————————————————————————————————————————* D: 成员内部类代码演示class Body &#123;//外部类，身体 private boolean life= true; //生命状态 public class Heart &#123; //内部类，心脏 public void jump() &#123; System.out.println("心脏噗通噗通的跳") System.out.println("生命状态" + life); //访问外部类成员变量 &#125; &#125;&#125;访问内部类public static void main(String[] args) &#123; //创建内部类对象 Body.Heart bh = new Body().new Heart(); //调用内部类中的方法 bh.jump();&#125; 16成员内部类的同名变量调用* A: 代码实现 1234567891011121314151617181920212223242526272829当在"【非静态内部类】"的"方法内"访问某个变量时，(1)系统优先在该"方法内"查找是否存在该名字的"局部变量"，如果存在就使用该变量;"方法内"的"局部变量"：直接用变量名 调用(2)如果不存在，则到该方法所在的"内部类"中查找是否存在该名字的成员变量，如果存在则使用该"成员变量";"内部类"中的"成员变量"：this.成员变量名 调用(3)如果不存在，则到该内部类所在的"外部类"中查找是否存在该名字的"成员变量"，如果存在则使用该成员变量;"外部类"中的"成员变量"：外部类名.this.成员变量名 调用如果依然不存在，系统将出现编译错误:提示找不到该变量。public class Outer &#123; int num = 1; class Inner &#123; int num = 2; public void inner()&#123; int num = 3; //18,就近原则 System.out.println("成员内部类 Inner 的方法 func &gt;&gt; num: "+ num); //视为 访问 内部类对象（this）的成员变量，用this System.out.println("成员内部类 Inner 的方法 func &gt;&gt; this.num: "+ this.num); //视为 访问 外部类对象(Outer.this)的成员变量，用Outer.this System.out.println("成员内部类 Inner 的方法 func &gt;&gt; Outer.this.num: "+ Outer.this.num); &#125; &#125;&#125; 17 局部内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687* A "局部内部类"，定义在"【外部类方法】"中的"局部位置"。"与访问方法中的【局部变量】【相似】，* 可通过【调用方法】【进行访问】".* 局部类 "【不能】" 用 public或 private "修饰符进行声明，它的作用域被限定在所声明的【局部类的块】中。"* B 定义格式 class 【外部类】 &#123; 修饰符 返回值类型 【方法名(参数)】 &#123; class 【内部类】 &#123; //其他代码 &#125; &#125; &#125;* C 访问方式 "在【外部类方法】中，创建【内部类】【对象】，进行访问"* D 局部内部类代码演示 定义类 class Party &#123;//外部类，聚会 public void puffBall()&#123;// 吹气球方法 class Ball &#123;// 内部类，气球 public void puff()&#123; System.out.println("气球膨胀了"); &#125; &#125; //创建内部类对象，调用puff方法 new Ball().puff(); &#125; &#125; 访问内部类 public static void main(String[] args) &#123; //创建外部类对象 Party p = new Party(); //调用外部类中的puffBall方法 p.puffBall(); &#125;————————————————————————————————————————————————————————————————————————————————————————举例：//局部内部类public class Outer &#123; private int num =380; public void method()&#123; final int TYU =56; System.out.println("外部类 Outer 的方法"); &#125; public int outer_func( String s)&#123; int num = 200; // num是局部变量 int yu=90; int [] arr = new int[1]; //局部内部类 class Inner&#123; int num =567; //如何调用 局部内部类 中的 方法？ public void inner_func()&#123; int num = 45456; // s = "dvd"; // yu =56; // yu++; //ERROR arr[0]++; arr[0]++;//通过引用数据类型，实现【局部内部类】中的 计数器 this.num++;// 该this指向【局部内部类 Inner 】【对象】的【成员属性】：567+1=568 System.out.println("局部内部类 Inner 的方法: " + this.num+ " "+ yu + s); System.out.println("局部内部类 Inner 的方法:调用局部变量 " + arr[0]); Outer.this.method(); &#125; public int inner_return()&#123; return this.num;//568 &#125; &#125; // 需要在【外部类】的【方法】中，创建【内部类】【对象】，进行访问 Inner in = new Inner(); in.inner_func(); System.out.println("this.num "+ this.num);// 该this指向 【外部类 Outer】【对象】的【成员属性】:380 return in.inner_return() + this.num + num;// num是局部变量：200 &#125;&#125; 18匿名内部类* A: 概述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。 最常用到的内部类就是匿名内部类，它是局部内部类的一种。 定义的【匿名内部类】有两个含义： "临时定义某一指定类型的子类" "定义后【即刻】创建刚刚定义的这个【子类】的【对象】"* B: 本质 "【匿名内部类】的【本质】是一个实现了【接口】或继承了某个【父类】的【子类匿名对象】".* C: 案例public interface Smoking &#123; public abstract void smoking(); &#125; /*【回顾之前采用的方式】 * 实现类,实现接口 重写接口抽象方法,创建实现类对象 * class XXX implements Smoking&#123; * public void smoking()&#123; * * &#125; * &#125; * XXX x = new XXX(); * x.smoking(); * Smoking s = new XXX(); * s.smoking(); * * 匿名内部类,简化问题: 定义实现类,重写方法,建立实现类对象,合为一步完成 */测试类:public class Test &#123; public static void main(String[] args) &#123; "//使用匿名内部类 /* * 定义实现类,重写方法,创建实现类对象,一步搞定 * 格式:" —————————————————————————————————————————————————————— new 接口或者父类()&#123; 重写抽象方法 &#125;; —————————————————————————————————————————————————————— "* 从 new开始,到分号结束 * 创建了接口的实现类的对象 */" new Smoking()&#123; public void smoking()&#123; System.out.println("人在吸烟"); &#125; &#125;.smoking(); &#125;&#125; 19匿名内部类_2* A: 匿名内部类案例演示 1234567891011121314151617181920212223242526272829303132333435 public abstract class Animal &#123; public abstract void eat(); public abstract void sleep(); &#125;测试代码/* * new Animal()&#123; public void eat()&#123; System.out.println("在吃饭"); &#125; public void sleep()&#123; System.out.println("在睡觉"); &#125; &#125;;*/ "以上代码,就是Animal的子类的对象 利用多态性, 父类引用 = 子类的对象"public class Test2 &#123; public static void main(String[] args) &#123; Animal a= new Animal()&#123; public void eat()&#123; System.out.println("在吃饭"); &#125; public void sleep()&#123; System.out.println("在睡觉"); &#125; &#125;; a.eat(); a.sleep(); &#125;&#125; 20包的概念* A: 概念 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354java的包，其实就是我们电脑系统中的文件夹，包里存放的是"类文件（.java 或者 .class 文件）"。当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为"分包管理"。在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是"以包作为边界"。"类中声明的包必须与实际class文件所在的文件夹情况【相一致】，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类"。"————————————————————————————————————————————————————————————————————————————————————————"* B 声明格式通常使用公司网址反写，"可以有【多层包】，包名采用【全部小写字母】，【多层包】之间用【”.”】连接" 类中包的声明格式： —————————————————————————————— package 包名.包名.包名…; —————————————————————————————— 如：网址itheima.com那么网址反写就为com.itheima itcast.cn 那么网址反写就为 cn.itcast "注意：声明包的语句，必须写在程序【有效代码】的【第一行】（注释不算）" 代码演示： package cn.itcast; //包的声明，必须在有效代码的第一行 import java.util.Scanner; import java.util.Random; public class Demo &#123;&#125;"————————————————————————————————————————————————————————————————————————————————————————"* C: 包的访问在访问类时，为了能够找到该类，"必须使用含有包名的【类全名】（包名.类名）"。即："包名.包名….类名"如： java.util.Scanner java.util.Random cn.itcast.Demo——————————————————————————————————————————————————————————带有包的类，创建对象格式：包名.类名 变量名 = new 包名.类名();——————————————————————————————————————————————————————————如： cn.itcast.Demo d = new cn.itcast.Demo(); 前提：包的访问与访问权限密切相关，这里以一般情况来说，即类用public修饰的情况。"————————————————————————————————————————————————————————————————————————————————————————"*D:类的简化访问——————————————————————————————————————————————————————————当我们要使用一个类时，这个类与当前程序在"同一个包中（即同一个文件夹中）"，或者"这个类是【java.lang】包中的类"时通常"【可以省略】掉【包名】"，直接使用该类。——————————————————————————————————————————————————————————如：cn.itcast包中有两个类，PersonTest类，与Person类。我们在PersonTest类中，访问Person类时，由于是同一个包下，访问时可以省略包名，即直接通过类名访问 Person。—————————————————————————————————————————————————————————— 类名 变量名 = new类名(); Person p = new Person(); 当我们要使用的类，与当前程序"【不在】同一个包中（即【不同】文件夹中）"，要访问的类"必须"用public"修饰才可访问"。 package cn.itcst02; public class Person &#123;&#125; 22导入包* A:导入包 12345678910111213141516171819202122我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。导包的格式：import 包名.类名; 当程序导入指定的包后，使用类时，就可以简化了。演示如下//导入包前的方式//创建对象java.util.Random r1 = new java.util.Random();java.util.Random r2 = new java.util.Random();java.util.Scanner sc1 = new java.util.Scanner(System.in);java.util.Scanner sc2 = new java.util.Scanner(System.in);//导入包后的方式import java.util.Random;import java.util.Scanner;//创建对象Random r1 = new Random();Random r2 = new Random();Scanner sc1 = new Scanner(System.in);Scanner sc2 = new Scanner(System.in);import导包代码书写的位置：在声明包package后，定义所有类class前，使用导包import包名.包名.类名; 23权限修饰符* A 权限修饰符有哪些 12345678910111213141516171819202122232425262728293031 在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限， 以下表来说明不同权限的访问能力： public protected default private———————————————————————————————————————————————————————————————————————————————————————— "同一【类】中" √ √ √ √———————————————————————————————————————————————————————————————————————————————————————— "同一包中(子类与无关类)" √ √ √ ———————————————————————————————————————————————————————————————————————————————————————— "不同包的子类" √ √———————————————————————————————————————————————————————————————————————————————————————— "不同包中的无关类" √ ———————————————————————————————————————————————————————————————————————————————————————— * B: 小结归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问———————————————————————————————————————————————————————————————————————————————————————— private:要想"【仅能在本类中】"访问使用private修饰；———————————————————————————————————————————————————————————————————————————————————————— default:要想"【本包】"中的类都可以访问"【不加修饰符】"即可；———————————————————————————————————————————————————————————————————————————————————————— protected:要想"【本包】中的类与【其他包中的【子类】】"可以访问使用protected修饰注意： protected 修饰符 在"【跨包】调用成员"时： "【只能】在 【子类的内部】【进行调用】：&#123; 直接用 【成员名】 OR 【super.成员名】 调用&#125;并且【不能】在【子类中】 通过 【创建对象】 【进行调用】"———————————————————————————————————————————————————————————————————————————————————————— public:要想"【所有包】中的【所有类】"都可以访问使用public修饰。———————————————————————————————————————————————————————————————————————————————————————— 注意：如果类用public修饰，"则【类名】必须与【文件名】相同"。"一个文件中【只能】有一个" public修饰的类。———————————————————————————————————————————————————————————————————————————————————————— 24代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788* A: 概述:程序中用"【大括号括起来】"的代码叫"代码块"———————————————————————————————————————————————————————————————————————————————————————— * B: 分类"局部代码块" "构造代码块" "静态代码块" "同步代码块"———————————————————————————————————————————————————————————————————————————————————————— * C "局部代码块":"【局部代码块】是定义在【方法】或【语句】中"特点： "以”&#123;&#125;”划定的代码区域，此时只需要关注【作用域】的不同即可" "【方法】和【类】都是以【代码块】的方式【划定边界】的"———————————————————————————————————————————————————————————————————————————————————————— class Demo&#123; public static void main(String[] args) &#123; //局部代码块 &#123; int x = 1; System.out.println("局部代码块" + x); &#125; //局部变量作用域 int x = 99; System.out.println("代码块之外" + x); &#125;&#125; 结果： 普通代码块1 代码块之外99 "【局部代码块】作用:可以【限定变量】的【声明周期】".———————————————————————————————————————————————————————————————————————————————————————— * D: "构造代码块""【构造代码块】是定义在【类】中【成员位置】的代码块"特点： "【优先于】【构造方法】执行，构造代码块用于执行【所有对象】【均需要】的【初始化动作】" "每【创建一个】对象均会【执行一次】构造代码块"。public class Person &#123; private String name; private int age; //构造代码块 &#123; System.out.println("构造代码块执行了"); &#125; Person()&#123; System.out.println("Person无参数的构造函数执行"); &#125; Person(int age)&#123; this.age = age; System.out.println("Person（age）参数的构造函数执行"); &#125;&#125;class PersonDemo&#123; public static void main(String[] args) &#123; Person p = new Person(); Person p1 = new Person(23); &#125;&#125;结果： 构造代码块执行了 Person无参数的构造函数执行 构造代码块执行了 Person（age）参数的构造函数执行———————————————————————————————————————————————————————————————————————————————————————— * E: "静态代码块""【静态代码块】是定义在【成员位置】"，使用static "修饰的代码块"。特点： "它【优先于】【主方法】执行、【优先于】【构造代码块】执行， 当以任意形式【第一次使用到该类】时执行"。 "【该类】【不管创建多少对象】，【静态代码块】【只执行一次】"。 "可用于给【静态变量赋值】，用来给【类进行初始化】"。 public class Person &#123; private String name; private int age; //静态代码块 static&#123; System.out.println("静态代码块执行了"); &#125; &#125;———————————————————————————————————————————————————————————————————————————————————————— * F: "同步代码块"(多线程学习) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071————————————————————————————————————————————————————————————————————————————————————————举例：class Person &#123; public Person()&#123; System.out.println("Class Person 构造方法"); &#125; &#123; System.out.println("Class Person 构造代码块 "); &#125; static &#123; System.out.println("Class Person 【静态】代码块 "); &#125;&#125;class Student extends Person &#123; public Student() &#123; System.out.println(" Student 构造方法"); &#125; static &#123; System.out.println(" Student 【静态】代码块"); &#125; &#123; System.out.println(" Student 构造代码块"); &#125; &#125;public class Test &#123; public static void main(String[] args) &#123; new Student(); System.out.println("————————————————————————————"); new Student(); &#125;&#125;————————————————————————————————————————————————————————————————————————————————————————运行结果：Class Person 【静态】代码块 Student 【静态】代码块Class Person 构造代码块 Class Person 构造方法 Student 构造代码块 Student 构造方法————————————————————————————Class Person 构造代码块 Class Person 构造方法 Student 构造代码块 Student 构造方法———————————————————————————————————————————————————————————————————————————————————————结论："【静态代码块】【只执行一次】执行顺序：* 静态代码块 &gt; 构造代码块（初始化块） &gt; 构造方法（构造器）* 父类 &gt; 子类结合下来的顺序： 【父类】静态代码块 【子类】静态代码块 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法" 25总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final：关键字，最终的意思 final修饰的类：最终的类，不能被继承 final修饰的变量： 相当于是一个常量, 在编译生产.class文件后，该变量变为常量值 final修饰的方法： 最终的方法，子类不能重写，可以继承过来使用————————————————————————————————————————————————————————————————————————————————————————static : 关键字， 静态的意思 可以用来修饰类中的成员(成员变量，成员方法) 注意： 也可以用来修饰成员内部类特点： 被静态所修饰的成员，会被所有的对象所共享 被静态所修饰的成员，可以通过类名直接调用，方便 Person.country = "中国"; Person.method();注意事项： 静态的成员，随着类的加载而加载，优先于对象存在 在静态方法中，没有this关键字 静态方法中，只能调用静态的成员(静态成员变量，静态成员方法————————————————————————————————————————————————————————————————————————————————————————匿名对象：一个没有名字的对象特点：创建匿名对象直接使用，没有变量名匿名对象在没有指定其引用变量时，只能使用一次匿名对象可以作为方法接收的参数、方法返回值使用————————————————————————————————————————————————————————————————————————————————————————内部类：在一个类中，定义了一个新类，这个新的类就是内部类 class A &#123;//外部类 class B&#123;// 内部类 &#125; &#125;特点： 内部类可以直接访问外部类的成员，包含私有的成员————————————————————————————————————————————————————————————————————————————————————————包的声明与访问类中包的声明格式： package 包名.包名.包名…;带有包的类，创建对象格式：包名.类名 变量名 = new包名.类名();cn.itcast.Demo d = new cn.itcast.Demo();导包的格式：import 包名.类名;————————————————————————————————————————————————————————————————————————————————————————权限修饰符 public : 公共的 protected: 受保护的 default: 默认的（可省略） private : 私有的 public protected default private———————————————————————————————————————————————————————————————————————————————————————— "同一【类】中" √ √ √ √———————————————————————————————————————————————————————————————————————————————————————— "同一包中(子类与无关类)" √ √ √ ———————————————————————————————————————————————————————————————————————————————————————— "不同包的子类" √ √———————————————————————————————————————————————————————————————————————————————————————— "不同包中的无关类" √ ———————————————————————————————————————————————————————————————————————————————————————— 代码块： 局部代码块：定义在方法中的，用来限制变量的作用范围 构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值 静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值————————————————————————————————————————————————————————————————————————————————————————]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础10(构造方法，this，super)]]></title>
    <url>%2F2016%2F10%2F13%2Fday12%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、构造方法2、this关键字3、super关键字4、综合案例 01构造方法引入* A:构造方法的引入 在开发中经常需要在创建对象的同时明确对象的属性值，比如员工入职公司就要明确他的姓名、年龄等属性信息。 那么，创建对象就要明确属性值，那怎么解决呢？也就是在创建对象的时候就要做的事情，当使用new关键字创建对象时，怎么给对象的属性初始化值呢？ 这就要学习Java另外一门小技术，构造方法。 * B: 那什么是构造方法呢？ 从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是对象创建时要执行的方法，那么只要在new对象时， 知道其执行的构造方法是什么，就可以在执行这个方法的时候给对象进行属性赋值。 02构造方法作用* A: 构造方法的作用: 在new的同时给成员变量赋值,给对象属性进行初始化。 * B: 举例: Perons p = new Person(&quot;张三&quot;,23); 在new 的时候给p对象的name属性和age属性进行赋值,使这个对象的属性有值。 03构造方法的定义和运行特点* A: 构造方法定义 构造方法的格式： 修饰符 构造方法名(参数列表) { } * B: 构造方法的体现： 构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束。 构造方法名称必须和类型保持一致。 构造方法没有具体的返回值。 构造方法的代码体现： * C: 构造方法举例 123456789101112131415 class Person &#123; // Person的成员属性age和name private int age; private String name; // Person的构造方法，拥有参数列表 Person(int a, String nm) &#123; // 接受到创建对象时传递进来的值，将值赋给成员属性 age = a; name = nm; &#125; &#125;* D: 构造方法运行特点: 在new 对象的时候自动调用执行。 04默认添加的构造方法* A: 每一class类都必须有一个构造方法，构造方法不写也有。 编译的时候，javac，系统会自动检查类中是否有构造方法，如果没有编译器就会自动添加一个构造方法 比如Person类， 编译器添加一个无参构造 public Person(){} 05构造方法的调用赋值* A: 理解构造方法的格式和基本功能之后，现在就要研究构造方法是怎么执行的呢？在创建对象的时候是如何初始化的呢？ 构造方法是专门用来创建对象的，也就是在new对象时要调用构造方法。现在来看看如何调用构造方法。 * B: 案例 1234567891011121314151617181920212223242526 class Person &#123; // Person的成员属性age和name private int age; private String name; // Person的构造方法，拥有参数列表 Person(int a, String nm) &#123; // 接受到创建对象时传递进来的值，将值赋给成员属性 age = a; name = nm; &#125; public void speak() &#123; System.out.println("name=" + name + ",age=" + age); &#125; &#125; class PersonDemo &#123; public static void main(String[] args) &#123; // 创建Person对象，并明确对象的年龄和姓名 Person p2 = new Person(23, "张三"); p2.speak(); &#125; &#125;上述代码演示了创建对象时构造方法的调用。即在创建对象时，会调用与参数列表对应的构造方法 06构造方法的内存A:内存加载的过程 有一个Person类, 创建Person 对象new Person() 1、首先会将main方法压入栈中，执行main方法中的 new Person(23,&quot;张三&quot;); 2、在堆内存中分配一片区域，用来存放创建的Person对象，这片内存区域会有属于自己的内存地址（0x88）。然后给成员变量进行默认初始化（name=null，age=0）。 3、执行构造方法中的代码（age = a ; name = nm;）,将变量a对应的23赋值给age，将变量nm对应的”张三赋值给name，这段代码执行结束后，成员变量age和name的值已经改变。执行结束之后构造方法弹栈，Person对象创建完成。将Person对象的内存地址0x88赋值给p2。 07构造方法的重载* A：当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的时候书写带参数的构造方法。 * 若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写也有默认的构造方法）。 12345678910111213141516171819202122 构造方法的细节： 1、一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的 2、构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。* B: 举例 class Person &#123; private int age; private String name; // 私有无参数的构造方法，即外界不能通过new Person();语句创建本类对象 private Person() &#123; &#125; // 多个构造方法是以重载的形式存在 Person(int a) &#123; age = a; &#125; Person(String nm, int a) &#123; name = nm; age = a; &#125; &#125; 08构造方法和一般方法区别* A: 目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？ 12345678910111213141.格式不同 构造方法 : 修饰符 类名(参数类型 参数 ...)&#123; 初始化成员变量&#125;一般方法: 需要有返回值类型2.作用不同构造方法一般用来给成员变量初始化;一般方法根据需求而定;3.调用方式不同构造方法创建对象时调用, 或者this() super() 语句调用普通方法需要对象调用或者静态方法直接调用静态方法.4.执行不同构造方法在对象创建时就执行了，而且只执行一次。一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。 09this在构造方法之间的调用* A: 在之前学习方法之间调用时，可以通过方法名进行调用。可是针对构造方法，无法通过构造方法名来相互调用。 12345678910111213141516171819202122232425262728 构造方法之间的调用，可以通过this关键字来完成。 构造方法调用格式： this(参数列表);* B:调用构造方法的案例 class Person &#123; // Person的成员属性 private int age; private String name; // 无参数的构造方法 Person() &#123; &#125; // 给姓名初始化的构造方法 Person(String nm) &#123; name = nm; &#125; // 给姓名和年龄初始化的构造方法 Person(String nm, int a) &#123; // 由于已经存在给姓名进行初始化的构造方法 name = nm;因此只需要调用即可 // 调用其他构造方法，需要通过this关键字来调用 this(nm); // 给年龄初始化 age = a; &#125; &#125; 10this在构造方法调用的内存图* A: 被加载的代码 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123; private int age; private String name; Person() &#123; &#125; Person(String nm) &#123; name = nm; &#125; Person(String nm, int a) &#123; this(nm); age = a; &#125;&#125;class PersonDemo &#123; public static void main(String[] args) &#123; Person p = new Person("张三", 23); &#125;&#125;* B: 构造方法调用的原理图* 1、先执行main方法，main方法压栈，执行其中的new Person(“张三”,23);2、堆内存中开辟空间，并为其分配内存地址0x33，，紧接着成员变量默认初始化（name=null age = 0）；3、拥有两个参数的构造方法（Person（String nm , int a））压栈，在这个构造方法中有一个隐式的this，因为构造方法是给对象初始化的，哪个对象调用到这个构造方法，this就指向堆中的哪个对象。4、由于Person（String nm , int a）构造方法中使用了this(nm);构造方法Person(String nm)就会压栈，并将“张三”传递给nm。在Person（String nm , int a）构造方法中同样也有隐式的this，this的值同样也为0x33，这时会执行其中name = nm，即把“张三”赋值给成员的name。当赋值结束后Person（String nm , int a）构造方法弹栈。5、程序继续执行构造方法（Person（String nm , int a）中的age = a；这时会将23赋值给成员属性age。赋值结束构造方法（Person（String nm , int a）弹栈。6、当构造方法（Person（String nm , int a）弹栈结束后，Person对象在内存中创建完成，并将0x33赋值给main方法中的p引用变量。注意：this到底代表什么呢？this代表的是对象，具体代表哪个对象呢？哪个对象调用了this所在的方法，this就代表哪个对象。调用其他构造方法的语句必须定义在构造方法的第一行，原因是初始化动作要最先执行。 11this简易应用* A: 当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量 * B: 举例1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person &#123; private int age; private String name; // 给姓名和年龄初始化的构造方法 Person(String name, int age) &#123; // 当需要访问成员变量是，只需要在成员变量前面加上this.即可 this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125;&#125;class PersonDemo &#123; public static void main(String[] args) &#123; Person p = new Person("张三", 23); p.speak(); &#125;&#125;* C: 举例2学习完了构造方法、this的用法之后，现在做个小小的练习。需求：在Person类中定义功能，判断两个人是否是同龄人class Person &#123; private int age; private String name; // 给姓名和年龄初始化的构造方法 Person(String name, int age) &#123; // 当需要访问成员变量是，只需要在成员变量前面加上this.即可 this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125; // 判断是否为同龄人 public boolean equalsAge(Person p) &#123; // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较 // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替 /* * if(this.age == p.age) &#123; return true; &#125; return false; */ return this.age == p.age; &#125;&#125; 12super关键字_1* A: 子父类中构造方法的调用 12345678 在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默认的隐式super();语句。* B: 格式： 调用本类中的构造方法 this(实参列表); 调用父类中的空参数构造方法 super(); 调用父类中的有参数构造方法 super(实参列表); 13super关键字_2* A:子类构造方法,有一个默认添加的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Student extends Person &#123; public Student()&#123; super(); &#125;&#125;* B :为什么子类对象创建都要访问父类中的构造方法？因为子类继承了父类的内容， 所以创建对象时，必须要先看父类是如何对其内容进行初始化的，看如下程序public class Test &#123; public static void main(String[] args) &#123; new Zi(); &#125; &#125;class Fu&#123; int num ; Fu()&#123; System.out.println("Fu构造方法"+num); num = 4; &#125;&#125;class Zi extends Fu&#123; Zi()&#123; //super(); 调用父类空参数构造方法 System.out.println("Zi构造方法"+num); &#125;&#125;执行结果： Fu构造方法0 Zi构造方法4通过结果发现，子类空参数构造方法执行时中，调用了父类空参数构造方法，这说明，子类空参数构造方法中有一句super()。@A: "【子类】中的【空参数构造方法】会有一句【隐式】的" super()原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。——————————————————————————————————————————————————————————————————————————————————————@B: "当父类中【没有】【空参数构造方法】时，子类的构造方法【必须】有【显示】的【super(参数)语句】， 指定要访问的父类【有参数】【构造方法】。否则报错！！！"public class Parent &#123; public Parent(String s)&#123; System.out.println("Parent"); &#125;&#125;public class Child extends Parent &#123; public Child(String s)&#123; super(s);//父类中【没有】【空参数构造方法】时，子类的构造方法【必须】有【显示】的【super(参数)语句】 System.out.println("Child"); &#125;&#125; 14子类父类的内存图 15super关键字_3* A: 创建子类对象的时候会必须调用父类的构造方法。 &quot;子类默认会调用父类的【无参构造】， 但如果父类【没有无参构造】，子类的构造方法继续调用父类的无参构造就会报错。&quot; &quot;因此子类构造方法的第一行需要调用父类的构造方法，既可以调用父类的无参构造，也可以调用父类的有参构造，这样语法上就不会报错。&quot; 16super关键字_41234567* A: 构造方法第一行,写this()还是super()* " this() 是调用本类的构造方法,super()是调用父类的构造方法, 且两条语句不能同时存在 "* " 保证子类的所有构造方法调用到父类的构造方法即可 "* B: 小结:*" 无论如何,子类的所有构造方法,直接或间接必须调用到父类构造方法;"* "子类的构造方法什么都不写,默认的构造方法第一行是super() ，即默认调用父类的空参数构造方法" 17创建子类对象过程的细节1234567891011121314* A 创建子类对象过程的细节* 如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？* 这时是没有的，"因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。"* 父类构造方法中是否有隐式的super呢？* 也是有的。记住：只要是构造方法默认第一行都是super();* 父类的父类是谁呢？super调用的到底是谁的构造方法呢？* Java体系在设计，定义了一个所有对象的父类Object* 注意：* "类中的构造方法默认第一行都有【隐式】的super()语句，访问父类中的【空参数构造方法】。所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。如果默认的隐式super()语句在父类中【没有】对应的构造方法，那么必须在构造方法中通过 this(参数) 或者 super(参数) 的形式明确要调用的构造方法。" 18super的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152* A: 练习：描述学生和工人这两个类，将他们的共性name和age抽取出来存放在父类中，并提供相应的get和set方法，同时需要在创建学生和工人对象就必须明确姓名和年龄* 案例://定义Person类，将Student和Worker共性抽取出来class Person &#123; private String name; private int age; public Person(String name, int age) &#123; // super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Student extends Person &#123; // Student类的构造方法 Student(String name, int age) &#123; // 使用super关键字调用父类构造方法，进行相应的初始化动作 super(name, age); &#125; public void study() &#123;// Studnet中特有的方法 System.out.println(this.getName() + "同学在学习"); &#125;&#125;class Worker extends Person &#123; Worker(String name, int age) &#123; // 使用super关键字调用父类构造方法，进行相应的初始化动作 super(name, age); &#125; public void work() &#123;// Worker 中特有的方法 System.out.println(this.getName() + "工人在工作"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Student stu = new Student("小明",23);stu.study(); Worker w = new Worker("小李",45);w.work(); &#125;&#125; 19总结123456789101112131415161718192021222324252627282930313233343536373839404142434445this关键字this关键字，本类对象的引用this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用this什么时候存在的？当创建对象的时候，this存在的this的作用：用来区别同名的成员变量与局部变量（this.成员变量） public void setName(String name) &#123; this.name = name; &#125;————————————————————————————————————————————————————————————————————————————"构造方法"： "用来给类的成员进行初始化操作"格式： 修饰符 类名 (参数列表) &#123; ...&#125;构造方法的特点：1, 方法名与类名相同2，【"没有返回值】，也【没有】【返回值类型】"，连void也没有构造方法什么时候会被调用执行？ "【只有】在创建对象的时候才可以被调用"————————————————————————————————————————————————————————————————————————————super: 指的是父类的存储空间(理解为"【父类的引用】") "调用父类的【成员变量】"： super.成员变量; "调用父类的【构造方法】": super(参数); "调用父类的【成员方法】": super.成员方法();继承中的构造方法注意事项：1，"如果我们【手动给出了构造方法】，编译器【不会】再给我们提供【默认】的【空参数构造方法】如果我们【没写】任何的构造方法，编译器提供给我们【一个隐式空参数构造方法】"2, 在构造方法中，【默认】的第一条语句为 super();它是用来访问父类中的【空参数构造方法】，进行父类成员的初始化操作3, 当父类中【没有】【空参数构造方法】的时候，怎么办？ a: 通过 super(参数) "访问【父类】【有参数的构造方法】" b: 通过 this(参数) "访问【本类】中其他构造方法" 注意:"【本类】中的其他构造方法应满足已经能够正常访问【父类构造方法】， 即本类其他构造方法（含有super(参数)）"4, "super(参数) 与 this(参数) 【不能】同时在构造方法中存在" 20完整员工案例分析 * A: 项目介绍 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。 工作内容 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站 Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件 网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通 硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。 * B: 案例分析 根据上述部门的描述，得出如下的员工体系图 根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。 工作内容 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站 Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件 网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通 硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 创建JavaEE工程师对象，完成工作方法的调用 21案例代码实现* A:定义员工类(抽象类) 1234567891011121314151617181920212223242526272829public abstract class Employee &#123; private String id;// 员工编号 private String name; // 员工姓名 //空参数构造方法 public Employee() &#123; super(); &#125; //有参数构造方法 public Employee(String id, String name) &#123; super(); this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //工作方法（抽象方法） public abstract void work(); &#125; * B : 定义研发部员工类Developer 继承 员工类Employee 12345678910public abstract class Developer extends Employee &#123; //空参数构造方法 public Developer() &#123; super(); &#125; //有参数构造方法 public Developer(String id, String name) &#123; super(id, name); &#125;&#125; * C: 定义维护部员工类Maintainer 继承 员工类 1234567891011Employeepublic abstract class Maintainer extends Employee &#123; //空参数构造方法 public Maintainer() &#123; super(); &#125; //有参数构造方法 public Maintainer(String id, String name) &#123; super(id, name); &#125;&#125; * D: 定义JavaEE工程师 继承 研发部员工类，重写工作方法 public class JavaEE extends Developer { //空参数构造方法 public JavaEE() { super(); } //有参数构造方法 public JavaEE(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝网站"); } } * E: 定义Android工程师 继承 研发部员工类，重写工作方法 public class Android extends Developer { //空参数构造方法 public Android() { super(); } //有参数构造方法 public Android(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件"); } } * F: 定义Network网络维护工程师 继承 维护部员工类，重写工作方法 public class Network extends Maintainer { //空参数构造方法 public Network() { super(); } //有参数构造方法 public Network(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在检查网络是否畅通"); } } * G: 定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 public class Hardware extends Maintainer { //空参数构造方法 public Hardware() { super(); } //有参数构造方法 public Hardware(String id, String name) { super(id, name); } @Override public void work() { System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机"); } } * H: 在测试类中，创建JavaEE工程师对象，完成工作方法的调用 public class Test { public static void main(String[] args) { //创建JavaEE工程师员工对象，该员工的编号000015，员工的姓名 小明 JavaEE ee = new JavaEE("000015", "小明"); //调用该员工的工作方法 ee.work(); } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础9(接口，多态)]]></title>
    <url>%2F2016%2F10%2F12%2Fday11%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、接口2、多态 Java中引用数据类型只有三种，分别是类(class)、接口(interface)、数组。 Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。在函数中定义的一些【基本类型的变量】和【对象的引用变量】都是在函数的【栈内存】中分配。 当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。 【堆内存用于存放由new创建的对象或数组】。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于【数组或者对象在堆内存中的首地址】，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名。 【引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。】而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，【数组和对象在没有引用变量指向它的时候，才变成垃圾】，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针! 01接口的概念* A:接口的概念 接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。 接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。 请记住：一切事物均有功能，即一切事物均有接口。 02接口的定义123456789101112131415161718192021* A: 接口的定义 与定义类的class不同，接口定义时需要使用interface关键字。 定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。 这点可以让我们将接口看做是一种只包含了功能声明的特殊类。 * B : 定义格式 public interface 接口名 &#123; 抽象方法1; 抽象方法2; 抽象方法3;&#125;* C: 定义步骤 使用interface代替了原来的class，其他步骤与定义类相同： "接口中的方法均为【公共】访问的抽象方法": 定义为： public abstract 返回值类型 方法名(参数列表); 接口中无法定义普通的成员变量： public static final int NUM = 3;// NUM的值不能改变 03接口的实现类* A: 类与接口的关系 123456789101112131415"类与接口的关系为实现关系，即类实现接口"。实现的动作类似继承，只是关键字不同，"实现使用 implements "其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然需要重写方法以实现具体的功能。* B: 类实现接口的格式class 类 implements 接口 &#123; 重写接口中方法&#125; * C:注意事项"在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。"接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。在具体实现类中重写方法，实现功能，是方法的具体实现。 04接口中成员变量的特点1234567891011A:成员变量特点* a 接口中可以定义变量，但是变量"必须有固定的修饰符修饰" public static final 所以"接口中的变量也称之为常量，其值不能改变"。后面我们会讲解static与final关键字* B:案例interface Demo &#123; ///定义一个名称为Demo的接口。 public static final int NUM = 3;// NUM的值不能改变 //可以省略不写修饰符public static final，接口默认是public static final int NUMBER = 5;&#125; 05接口中成员方法的特点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455* A: 成员方法特点 * a 接口中可以定义方法，"方法也有固定的修饰符"，public abstract 同样，"可以省略不写"修饰符public abstract ，接口的成员方法"默认"是public abstract 但是，"在【实现类】中【重写】【接口中的方法】 【必须有】" public————————————————————————————————————————————————————————————————————————————————————————此外，注意： @1 接口中可以定义"静态方法"（static method）：public interface MyInterface &#123; public abstract void func(); public static void static_func()&#123; System.out.println("接口中可以定义\"静态方法\" "); &#125;&#125;"调用方式： 接口名.静态方法名(); MyInterface.static_func();"——————————————————————————————————————————————————————————@2 接口中可以定义"默认方法"（default method）:通过default修饰符标记该方法。public interface MyInterface &#123; public abstract void func(); default void method()&#123; System.out.println("接口中可以定义\"默认方法\" "); &#125;&#125;———————————————————————————————————————————————————————————————————————————————————————— * b "子类必须覆盖掉接口中【所有的抽象方法】后，子类才可以实例化。否则子类是一个抽象类。" * "所有接口中的成员变量【必须是静态常量】，由于【接口】【没有】【构造方法】， * 所以【必须显示赋值】。可以【直接】用【接口名】访问" * " 访问接口中的静态变量 ": * "接口名.变量名" Inter.COUNT* B: 案例interface Demo &#123; ///定义一个名称为Demo的接口。 public abstract void show1(); public abstract void show2(); void show3();&#125;//定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 implementsclass DemoImpl implements Demo &#123; //子类实现Demo接口。 //重写接口中的方法。 public void show1()&#123;&#125; public void show2()&#123;&#125; public void show3()&#123;&#125;&#125; 06实现类还是一个抽象类A: 接口的实现类 一个类如果实现类接口,有两种操作方法: 第一:实现类是【非抽象类】,就需要【重写接口中所有】的抽象方法. ———————————————————————————————————————————————————————————————————————————————————————— 第二:实现类也声明为【抽象类】,那么实现类【可以不重写】接口中的抽象方法。 07类和接口的多实现* A：接口的多实现 了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？ 接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。 * B 多实现的优点 * 怎么解决多继承的弊端呢？ * 弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。 * 其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。 * 为什么多实现能解决了呢？ * 因为接口中的功能都没有方法体，由子类来明确。 C :案例演示 interface Fu1 { void show1(); } interface Fu2{ void show2(); } class Zi implements Fu1,Fu2 { // 多实现。同时实现多个接口。 public void show1(){} public void show2(){} } 08类在继承类的同时实现多接口A: 继承的同时实现接口 * 接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。 * 子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。 * 接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。 B: 代码演示1234567891011121314151617181920212223//父类：抽象类abstract class Fu &#123; public abstract void show();&#125;//接口interface Inter &#123; pulbic abstract void show1();&#125;//接口interface kock &#123; pulbic abstract void show1();&#125;//类Zi在继承父类Fu的同时实现多接口(Inter,kock) class Zi extends Fu implements Inter,kock &#123; //重写接口的抽象方法 public void show1() &#123; &#125; //重写父类的抽象方法 public void show()&#123; &#125;&#125;接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。 09接口的多继承* A: 接口的多继承 * 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。 ———————————————————————————————————————————————————————————————————————————————————————— * 【多个接口】之间可以使用【 extends 】进行【多继承】。 ———————————————————————————————————————————————————————————————————————————————————————— * 【类】【没有】【多继承】 ———————————————————————————————————————————————————————————————————————————————————————— * 【接口】【有】【多继承】 B 代码演示12345678910111213141516171819202122232425262728293031323334 interface AA&#123; void fun_A();&#125;interface BB&#123; void fun_B();&#125;interface CC&#123; void fun_C();&#125;//接口DD 多继承 AA,BB,CCinterface DD extends AA,BB,CC&#123; void fun_D();&#125;//EE类实现接口DDpublic class EE implements DD&#123;//EE类实现接口DD，需要重写DD以及DD多继承接口的全部抽象方法 public void fun_D()&#123; System.out.println("重写fun_D"); &#125; public void func_A()&#123; System.out.println("重写fun_A"); &#125; public void func_B()&#123; System.out.println("重写fun_B"); &#125; public void func_C()&#123; System.out.println("重写fun_C"); &#125;&#125;在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。 10接口思想* A:接口的思想 * 前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。 * 举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？ * 主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。 ———————————————————————————————————————————————————————————————————————————————————————— * B: 接口的好处 * 总结：接口在开发中的它好处 * 1、接口的出现扩展了功能。 * 2、接口其实就是暴漏出来的规则。 * 3、接口的出现【降低】了【耦合性】，即设备与设备之间实现了【解耦】。 * 接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。 11接口和抽象类的区别* A: 明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？ 通过实例进行分析和代码演示抽象类和接口的用法。 * B: 举例： * 犬： 行为： 吼叫； 吃饭； * 缉毒犬： 行为： 吼叫； 吃饭； 缉毒； * C:思考： * 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。 * 当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。 * 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。 * D: 代码演示 1234567891011121314151617181920212223interface 缉毒&#123; public abstract void 缉毒();&#125;//定义犬科的共性功能abstract class 犬科&#123; public abstract void 吃饭(); public abstract void 吼叫();&#125;// 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能class 缉毒犬 extends 犬科 implements 缉毒&#123; public void 缉毒() &#123; &#125; void 吃饭() &#123; &#125; void 吼叫() &#123; &#125;&#125;class 缉毒猪 implements 缉毒&#123; public void 缉毒() &#123; &#125;&#125; * E: 接口和抽象类区别总结 123456789101112131415 相同点: 都位于继承的顶端,用于被其他类实现或继承; "【都不能】直接实例化对象"; "都包含抽象方法,其子类都必须覆写这些抽象方法才能实例化";区别: "抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;" "【抽象类】【可以】【不包含】 【抽象方法】" "【接口】【只能】【含有】【抽象方法】"; " 一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承) " 抽象类是这个事物中"应该具备的内容", 继承体系是一种 is..a关系 接口是这个事物中的"【额外内容】",继承体系是一种 like..a关系二者的选用: " 优先选用接口,尽量少用抽象类; " 需要定义子类的行为,又要为子类提供共性功能时才选用抽象类; 12多态概述* A: 多态概述 1234567891011121314151617多态是继封装、继承之后，面向对象的第三大特性。现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。 Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。**************************************************************" Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。"**************************************************************如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。**************************************************************" 最终多态体现为父类引用变量可以指向子类对象。多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。 "**************************************************************" 在使用多态后的【父类引用变量】【调用方法】时，会调用【子类】【重写】后的方法。"**************************************************************【多态的缺点】："【父类】【不能】调用【子类】的【特有内容】，需要【向下转型】调用子类的【特有内容】" 13多态调用的三种格式123456789101112131415161718192021222324252627282930313233343536373839404142434445* A:"多态的定义格式"： * 就是父类的引用变量指向子类对象 父类类型 变量名 = new 子类类型(); 变量名.方法名();* B: "普通类多态定义的格式" 父类 变量名 = new 子类(); 举例： class Fu &#123;&#125; class Zi extends Fu &#123;&#125; //类的多态使用 Fu f = new Zi();* C: "抽象类多态定义格式" 抽象类 变量名 = new 抽象类子类(); 举例： abstract class Fu &#123; public abstract void method(); &#125; class Zi extends Fu &#123; public void method()&#123; System.out.println("重写父类抽象方法"); &#125; &#125; //类的多态使用 Fu fu= new Zi();* D: "接口多态定义的格式" 接口 变量名 = new 接口实现类(); 如： interface Fu &#123; public abstract void method(); &#125; class Zi implements Fu &#123; public void method()&#123; System.out.println("重写接口抽象方法"); &#125; &#125; //接口的多态使用 Fu fu = new Zi();* E: "注意事项" "同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。" 如 Person p1 = new Student(); Person p2 = new Teacher(); p1.work(); //p1会调用Student类中重写的work方法 p2.work(); //p2会调用Teacher类中重写的work方法 当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。 14多态成员方法的特点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* A: 掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？* 前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化， * 那么当多态出现后，成员变量在使用上有没有变化呢？ * 多态出现后会导致子父类中的成员变量有微弱的变化* B: 代码演示 class Fu &#123; int num = 4; &#125; class Zi extends Fu &#123; int num = 5; &#125; class Demo &#123; public static void main(String[] args) &#123; Fu f = new Zi(); System.out.println(f.num);//4 Zi z = new Zi(); System.out.println(z.num);//5 &#125; &#125;* C: "多态成员变量"* " &lt;&lt;参考基础11.[12]&gt;&gt;" "当子父类中出现同名的成员变量时，多态调用该变量时： 编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。 运行时期：也是调用引用型变量所属的类中的成员变量。" "简单记：编译和运行都参考等号的左边。编译运行看左边。"* D: 多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码 class Fu &#123; int num = 4; void show() &#123; System.out.println("Fu show num"); &#125; &#125; class Zi extends Fu &#123; int num = 5; void show() &#123; System.out.println("Zi show num"); &#125; &#125; class Demo &#123; public static void main(String[] args) &#123; Fu f = new Zi(); f.show(); &#125; &#125;* E: "多态成员方法" "编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。 运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。 简而言之：编译看左边，运行看右边。" 15instanceof关键字12345678910* A: 作用 可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类* 格式: boolean b = 对象 instanceof 数据类型;* 举例: Person p1 = new Student(); // 前提条件，学生类已经继承了人类 boolean flag = p1 instanceof Student; //flag结果为true boolean flag2 = p1 instanceof Teacher; //flag2结果为false 16多态-向上转型* A: 多态的转型分为向上转型与向下转型两种： * B: 向上转型(自动类型转换)： * 当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。 123使用格式：父类类型 变量名 = new 子类类型();如：Person p = new Student(); 17多态-向下转型* A: 向下转型(强制类型转换)： 1234567891011* 一个已经向上转型的子类对象可以使用强制类型转换的格式，* "将【父类引用类型】强制转为【子类引用类型】，这个过程是向下转型。"* "好处：可以调用子类特有的方法"* "如果是直接创建父类对象，是无法向下转型的！" 使用格式： Person p = new Student();————————————————————————————————————————————————————————————————" 子类类型 变量名 = (子类类型) 父类类型的变量; " 如:Student stu = (Student) p; //变量p 实际上指向Student对象———————————————————————————————————————————————————————————————— 18多态的好处和弊端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* A: 多态的好处和弊端 * 当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。 向上转型的好处是隐藏了子类类型，提高了代码的扩展性。 * "但向上转型也有弊端，只能使用【父类共性】的内容，而【无法】使用【子类特有功能】，功能有限制"。 * B: 看如下代码 //描述动物类，并抽取共性eat方法 abstract class Animal &#123; abstract void eat(); &#125; // 描述狗类，继承动物类，重写eat方法，增加lookHome方法 class Dog extends Animal &#123; void eat() &#123; System.out.println("啃骨头"); &#125; void lookHome() &#123; System.out.println("看家"); &#125; &#125; // 描述猫类，继承动物类，重写eat方法，增加catchMouse方法 class Cat extends Animal &#123; void eat() &#123; System.out.println("吃鱼"); &#125; void catchMouse() &#123; System.out.println("抓老鼠"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Dog(); //多态形式，创建一个狗对象 a.eat(); // 调用对象中的方法，会执行狗类中的eat方法 // a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用 // 为了使用狗类的lookHome方法，需要向下转型 // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常 // 那么，在转之前需要做健壮性判断 if( !a instanceof Dog)&#123; // 判断当前对象是否是Dog类型 System.out.println("类型不匹配，不能转换"); return; &#125; Dog d = (Dog) a; //向下转型 d.lookHome();//调用狗类的lookHome方法 &#125; &#125; 123456789101112131415* C 多态总结:"什么时候使用向上转型： 当【不需要】面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。" 如： Animal a = new Dog(); a.eat();"什么时候使用向下转型 当要使用【子类特有功能】时，就需要使用【向下转型】。" 如：Dog d = (Dog) a; //向下转型 d.lookHome();//调用狗类的lookHome方法 "向下转型的好处：可以使用子类特有功能。" "弊端是：需要面对具体的【子类对象】；在向下转型时容易发生 ClassCastException 类型转换异常。 在转换之前必须做类型判断。"如：if( !a instanceof Dog)&#123;…&#125; 19多态举例12345678910111213141516171819202122232425262728293031323334353637383940* A: 刘老师和刘大爷的故事* 案例: /* 描述刘老师和刘大爷， 刘老师拥有讲课和看电影功能 刘大爷拥有讲课和钓鱼功能 */ class 刘大爷 &#123; void 讲课() &#123; System.out.println("语文"); &#125; void 钓鱼() &#123; System.out.println("钓鱼"); &#125; &#125; // 刘老师继承了刘大爷，就有拥有了刘大爷的讲课和钓鱼的功能， // 但刘老师和刘大爷的讲课内容不一样，因此刘老师要覆盖刘大爷的讲课功能 class 刘老师 extends 刘大爷 &#123; void 讲课() &#123; System.out.println("Java"); &#125; void 看电影() &#123; System.out.println("看电影"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; // 多态形式 刘大爷 a = new 刘老师(); // 向上转型 a.讲课(); // 这里表象是刘大爷，其实真正讲课的仍然是刘老师，因此调用的也是刘老师的讲课功能 a.钓鱼(); // 这里表象是刘大爷，但对象其实是刘老师，而刘老师继承了刘大爷，即刘老师也具有钓鱼功能 // 当要调用刘老师特有的看电影功能时，就必须进行类型转换 刘老师 b = (刘老师) a; // 向下转型 b.看电影(); &#125; 20笔记本电脑案例 * A:案例介绍 * 定义USB接口（具备开启功能、关闭功能），笔记本要使用USB设备，即笔记本在生产时需要预留可以插入USB设备的USB接口，即就是笔记本具备使用USB设备的功能， * 但具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用 * 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要符合USB接口 键盘类，要符合USB接口 * B: 案例分析 * 阶段一： 使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能 * 阶段二： 想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。 * 阶段三： 还想使用一个键盘 ，又要多一个功能和一个对象 * 问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。 降低鼠标、键盘等外围设备和笔记本电脑的耦合性。 21笔记本电脑案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172* A: 代码实现定义鼠标、键盘，笔记本三者之间应该遵守的规则interface USB &#123; void open();// 开启功能 void close();// 关闭功能&#125; 鼠标实现USB规则class Mouse implements USB &#123; public void open() &#123; System.out.println("鼠标开启"); &#125; public void close() &#123; System.out.println("鼠标关闭"); &#125;&#125; 键盘实现USB规则class KeyBoard implements USB &#123; public void open() &#123; System.out.println("键盘开启"); &#125; public void close() &#123; System.out.println("键盘关闭"); &#125;&#125; 定义笔记本class NoteBook &#123; // 笔记本开启运行功能 public void run() &#123; System.out.println("笔记本运行"); &#125; // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备 public void useUSB(USB usb) &#123; // 判断是否有USB设备 if (usb != null) &#123; usb.open(); usb.close(); &#125; &#125; public void shutDown() &#123; System.out.println("笔记本关闭"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; // 创建笔记本实体对象 NoteBook nb = new NoteBook(); // 笔记本开启 nb.run(); // 创建鼠标实体对象 Mouse m = new Mouse(); // 笔记本使用鼠标 nb.useUSB(m); // 创建键盘实体对象 KeyBoard kb = new KeyBoard(); // 笔记本使用键盘 nb.useUSB(kb); // 笔记本关闭 nb.shutDown(); &#125;&#125; 22小结接口：理解为是一个特殊的抽象类，但它不是类，是一个接口——————————————————————————————————————————————————————————接口的特点：1234561，定义一个接口用interface关键字 interface Inter&#123;&#125; 2，一个类实现一个接口，实现implements关键字 class Demo implements Inter&#123;&#125; 3, 接口不能直接创建对象 通过多态的方式，由子类来创建对象，接口多态 ——————————————————————————————————————————————————————————接口中的成员特点：12345678成员变量： 只能是final 修饰的常量 默认修饰符： public static final构造方法： 无成员方法： 只能是抽象方法 默认修饰符: public abstract ——————————————————————————————————————————————————————————类与类，类与接口，接口与接口之间的关系 类与类之间：继承关系，单继承，可以是多层继承 类与接口之间: 实现关系，单实现，也可以多实现 接口与接口之间：继承关系，单继承，也可以是多继承 Java中的类可以继承一个父类的同时，实现多个接口 ——————————————————————————————————————————————————————————多态：理解为同一种物质的多种形态多态使用的前提： 1，有继承或者实现关系 2，要方法重写 3，父类引用指向子类对象 —————————————————————————————————————————————————————————— 多态的成员访问特点： 方法的运行看右边，其他都看左边 多态的好处： 提高了程序的扩展性 —————————————————————————————————————————————————————————— 多态的弊端： 不能访问子类的特有功能 —————————————————————————————————————————————————————————— 多态的分类 ——————————————————————————————————————————————————————————类的多态1234567891011abstract class Fu &#123; public abstract void method();&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println(“重写父类抽象方法”);&#125;&#125;//类的多态使用Fu fu= new Zi(); ——————————————————————————————————————————————————————————接口的多态12345678910interface Fu &#123; public abstract void method();&#125;class Zi implements Fu &#123; public void method()&#123; System.out.println(“重写接口抽象方法”);&#125;&#125;//接口的多态使用Fu fu = new Zi(); ——————————————————————————————————————————————————————————instanceof 关键字 格式： 对象名 instanceof 类名 返回值： true, false 作用： 判断指定的对象 是否为 给定类创建的对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础8(继承，抽象类)]]></title>
    <url>%2F2016%2F10%2F11%2Fday10%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、继承2、抽象类3、综合案例—员工类系列定义 01继承的概述*A:继承的概念 *a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系 *b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类， 构建出来的新类被称作子类，现有类被称作父类 *B:继承关系的子类特点 *a:子类会自动拥有父类所有非private修饰的属性和方法 02继承的定义格式和使用123456789101112131415161718192021222324252627282930313233343536373839*A:继承的格式 class 子类 extends 父类 &#123;&#125;*B:雇员(Employee)与研发部员工(Developer)案例: *cn.itcast.demo01包下: *Employee.java: /* * 定义员工类Employee */ class Employee &#123; String name; // 定义name属性 public void work() &#123;// 定义员工的工作方法 System.out.println("尽心尽力地工作"); &#125; &#125; *Developer.java: /* * 定义研发部员工类Developer 继承 员工类Employee * 继承了父类中所有非private修饰的成员变量 */ class Developer extends Employee &#123; // 定义一个打印name的方法 public void printName() &#123; System.out.println("name=" + name); &#125; &#125; *测试员工类与研发部员工类: /* * 定义测试类 */ public class Example01 &#123; public static void main(String[] args) &#123; Developer d = new Developer(); // 创建一个研发部员工类对象 d.name = "小明"; // 为该员工类的name属性进行赋值 d.printName(); // 调用该员工的printName()方法 d.work(); // 调用Developer类继承来的work()方法 &#125; &#125; *通过子类对象既可以调用自身的非private修饰的成员,也可以调用父类的非private修饰的成员 03继承的好处*A:继承的好处： *1、继承的出现提高了代码的复用性，提高软件开发效率。 *2、继承的出现让类与类之间产生了关系，提供了多态的前提。 04继承的注意事项1234567891011121314151617181920212223242526272829303132333435363738394041424344 *A:继承的注意事项 *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。 class A&#123;&#125; class B&#123;&#125; class C extends A,B&#123;&#125; // C类不可以同时继承A类和B类 假如支持多继承例如: class A&#123; int a=3; public void method()&#123; &#125; &#125; class B&#123; int a=5; public void method()&#123; &#125; &#125; class C extends A,B&#123; &#125; class Demo&#123; public static void main(String[] args)&#123; C c=new C(); System.out.println(c.a);//到底是调用A的还是B的成员变量??无法确定 c.method();//到底是调用A的还是B的成员方法??无法确定 &#125; &#125; *b:多个类可以继承一个父类，例如下面这种情况是允许的(就像你爹可以多个儿子,但是这些儿子都只有一个爹) class A&#123;&#125; class B extends A&#123;&#125; class C extends A&#123;&#125; // 类B和类C都可以继承类A *c:在Java中，多层继承是可以的， 即一个类的父类可以再去继承另外的父类， 例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。 class A&#123;&#125; class B extends A&#123;&#125; // 类B继承类A，类B是类A的子类 class C extends B&#123;&#125; // 类C继承类B，类C是类B的子类，同时也是类A的子类 *d:在Java中，子类和父类是一种相对概念， 也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。 05继承的体系 *A:继承的体系: 动物(吃) | ------------------------- | | 猫科动物(吃,胎生) 爬行动物(吃,卵生) | | ------------------------------- ----------------- | | | | 猫(吃,抓老鼠,胎生) 虎(吃,领地,胎生) 蛇(吃,冬眠,卵生) 鳄鱼(吃,潜水,卵生) *a:动物体系是对每个具体事物共性的抽取,子类的共性抽取形成父类 *b:父类:具有所有子类的共性内容 子类:不但有共性还有自身特有的内容 *c:整个继承体系,越向上越抽象,越向下越具体 06继承后子类父类成员变量的特点123456789101112131415161718192021222324252627A:继承后子类父类成员变量的特点 a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu&#123; //Fu中的成员变量。 int num = 5; &#125; class Zi extends Fu&#123; //Zi中的成员变量 int num2 = 6; //Zi中的成员方法 public void show() &#123; //访问父类中的num System.out.println("Fu num="+num); //访问子类中的num2 System.out.println("Zi num2="+num2); &#125; &#125; class Demo&#123; public static void main(String[] args) &#123; Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 &#125; &#125; 12345678910111213141516171819202122232425262728293031323334 b:当子父类中出现了同名成员变量 class Fu&#123; //Fu中的成员变量。 int num = 5;&#125;class Zi extends Fu&#123; //Zi中的成员变量 int num = 6; void show()&#123; //子类的局部变量 int num=7 //直接访问,遵循就近查找原则 System.out.println(num);//7 //子父类中出现了同名的成员变量时 //在子类中需要访问父类中非私有成员变量时，需要使用super关键字 //访问父类中的num System.out.println("Fu num="+super.num);//5 //访问子类中的num2 System.out.println("Zi num2="+this.num);//6 &#125;&#125;class Demo5 &#123; public static void main(String[] args) &#123; Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 &#125;&#125; 07继承后子类父类成员方法的特性_子类重写父类方法12345678910111213141516171819A:继承后子类父类成员方法的特性 a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu&#123; public void show()&#123; System.out.println("Fu类中的show方法执行"); &#125; &#125; class Zi extends Fu&#123; public void show2()&#123; System.out.println("Zi类中的show2方法执行"); &#125; &#125; public class Test&#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); //子类中没有show方法，但是可以找到父类方法去执行 z.show2(); &#125; &#125; 12345678910111213b:为什么要有重写? class Fu&#123; public void method()&#123; //上千行代码 //Fu类中的方法最先存在,那么如果项目需求变了,该方法 //功能不能够满足我们的需求,此时我们也不会去改这个方法 //因为项目中可能有大量的功能已经使用到该方法,如果随意修改可能使调用该方法的功能出现问题 //所以使用重写方式基于原有功能提供更强的功能 &#125; &#125; class Zi extends Fu&#123; &#125; 12345678910111213141516171819 c:子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖 class Fu&#123; public void show()&#123; System.out.println("Fu show"); &#125; &#125; class Zi extends Fu&#123; //子类复写了父类的show方法 public void show()&#123; System.out.println("Zi show"); &#125;&#125; public class Test&#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); //Zi show 子类有直接使用子类 &#125;&#125; 08方法覆盖的需求A:方法覆盖的需求 a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能， 后期由于手机需要在来电显示功能中增加显示姓名和头像， 这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。 并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能 b:分析:我们不改装(破坏)原来的手机,而是再买一个新的智能手机,不但有原有的功能,而且还有特有功能 例:厂商发布新手机都是基于原有手机的升级,不会拿着原有的手机在卖,新产一款 1:分析类的构建: 手机类 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码 智能手机类: 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码,显示姓名和头像 手机类和智能手机类有共性内容: 发短信 打电话 显示来电号码 2:继承关系分析: 对于发短信和打电话功能,让智能手机直接沿用(继承)手机的就可以 但是在智能手机中的来电显示不但实现号码,还显示姓名和头像,同样的都是来电显示功能,智能手机的来电显示比手机的功能更加强大,我们考虑使用重写 09方法覆盖的手机案例实现12345678910111213141516171819202122232425262728293031323334353637//手机类class Phone&#123; public void sendMessage()&#123; System.out.println("发短信"); &#125; public void call()&#123; System.out.println("打电话"); &#125; public void showNum()&#123; System.out.println("来电显示号码"); &#125;&#125;//智能手机类class NewPhone extends Phone&#123; //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能 //从现实生活角度考虑沿用原有的showNum方法名便于用户更快熟悉和接受,而不是再起个新的名字 //用户还需要花费大量时间慢慢接受 public void showNum()&#123; //调用父类已经存在的功能使用super //如果不加super这是调用子类自身的showNum(),自己调用自己,递归 //方法不断入栈导致内存溢出 super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; new NewPhone().showNum();//来电显示 显示来电姓名 显示头像 &#125;&#125; 10方法覆盖的注意事项1234567891011121314151617181920A:方法覆盖的注意事项 a:"权限:【子类方法】覆盖【父类方法】，【必须要保证】子类权限【大于等于】父类权限"。 四大权限:public&gt;默认=protected&gt;private class Fu&#123; void show()&#123;&#125;public void method()&#123;&#125; &#125; class Zi() extends Fu&#123;public void show()&#123;//编译运行没问题&#125; void method()&#123;//编译错误 &#125; &#125; 1234567891011121314151617181920212223242526272829303132 b:方法定义:子类方法和要重写的父类的方法:"方法的方法名和参数列表都要一样。" 关于方法的返回值:"如果是【基本数据类型】,子类的方法和重写的父类的方法【返回值类型】【必须相同】"" 如果是【引用数据类型】,子类的方法和重写的父类的方法【返回值类型】【可以相同】 或者【子类方法的返回值类型】是父类方法返回值类型的【子类】""【父类方法返回值类型】&gt;= 【子类方法的返回值类型】" class Fu&#123; int show()&#123; &#125; public Fu method()&#123; &#125; public Fu method2()&#123; &#125; &#125; class Zi() extends Fu&#123; public int show()&#123;//返回值为基本类型的重写 &#125; public Fu method()&#123;//子类的方法和重写的父类的方法返回值类型可以相同 &#125; public Zi method2()&#123;//子类方法的返回值类型是父类方法返回值类型的子类 &#125; &#125; 123456789101112131415161718192021222324252627 c:重载与重写对比: 重载: 权限修饰符(public private 默认):无关 方法名:重载的两个方法的方法名必须相同 形参列表: "形参类型的顺序不同 形参的个数不同 形参的类型不同 三者至少满足一个" 返回值类型: "重载与返回值类型无关"重写: 权限修饰符(public private 默认): "子类方法的权限&gt;=父类的方法的权限" 方法名: "子类方法和父类方法必须相同" 形参列表: "子类方法和父类方法的形参列表必须相同" 返回值类型: "基本类数据类型: 必须相同" "引用数据类型: 子类方法的返回值类型和父类方法的返回值类型相同 或者 子类方法的返回值类型是父类方法的返回值类型的 子类" "【父类方法返回值类型】⊇【子类方法的返回值类型】" 11抽象类的产生A:抽象类的产生 a:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。 12抽象类的定义格式A:抽象方法定义的格式： 123456789101112131415161718192021222324 a:public abstract 返回值类型 方法名(参数); 抽象类定义的格式：abstract class 类名 &#123; &#125; b:抽象类示例代码： /* * 定义类开发工程师类 * EE开发工程师 : 工作 * Android开发工程师 : 工作 * * 根据共性进行抽取,然后形成一个父类Develop * 定义方法,工作: 怎么工作,具体干什么呀 * * 抽象类,不能实例化对象, 不能new的 * 不能创建对象的原因: 如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行 * 抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象 */public abstract class Develop &#123; //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白 //就不说, 方法没有主体的方法,必须使用关键字abstract修饰 //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰 public abstract void work();&#125; 13抽象类的使用方式123456789101112131415161718192021222324252627282930313233343536 A:抽象类的使用方式 /* * 定义类,JavaEE的开发人员 * 继承抽象类Develop,重写抽象的方法 */public class JavaEE extends Develop&#123; //重写父类的抽象方法 //去掉abstract修饰符,加上方法主体 public void work()&#123; System.out.println("JavaEE工程师在开发B/S 软件"); &#125;&#125;/* * 定义Android类,继承开发人员类 * 重写抽象方法 */public class Android extends Develop&#123; public void work()&#123; System.out.println("Android工程师开发手机软件"); &#125;&#125;/* * 测试抽象类 * 创建他的子类的对象,使用子类的对象调用方法 */public class Test &#123; public static void main(String[] args) &#123; JavaEE ee = new JavaEE(); ee.work();//"JavaEE工程师在开发B/S 软件" Android and = new Android(); and.work();//"Android工程师开发手机软件" &#125;&#125; 14抽象类特点 A:抽象类的特点a:抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。b:抽象类不可以直接创建对象，原因：调用抽象方法没有意义。c:【只有覆盖了抽象类中所有的抽象方法后】，其子类才可以创建对象。【否则该子类还是一个抽象类】。之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。12345678910111213141516abstract class A&#123; public abstract void func(); public abstract void func2();&#125;class A2 extends A&#123;//A2把A中的两个抽象方法都重写掉了 //A2类不再是抽象类 public void func()&#123;&#125; public void func2()&#123;&#125;&#125;abstract class A3 extends A&#123;//含有抽象方法的类一定是抽象类 public void func()&#123; &#125; //public abstract void func2();//func2相当于被继承下来&#125; 15抽象类的设计思想A:抽象类的设计思想 a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法 抽象员工: 规定一个方法,work工作 EE员工,Android员工 Develop类 抽象类 abstract work(); | ------------- | | EE Android //是我开发的一员必须工作 work(){} work(){} 16抽象类的细节 A:抽象类的细节 a:抽象类一定是个父类？ 是的，因为不断抽取而来的。 b:抽象类中是否可以不定义抽象方法?1234567891011121314151617181920212223 是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用 (适配器设计模式) /* * "抽象类,可以没有抽象方法,可以定义带有方法体的方法" * 让子类继承后,可以直接使用 */public abstract class Animal &#123; public void sleep()&#123; System.out.println("动物睡觉"); &#125; &#125;public class Cat extends Animal&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; //Cat c = new Cat(); new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用 &#125; &#125; c:抽象关键字abstract不可以和哪些关键字共存？ 1234567891011121314151617181:private：私有的方法子类是无法继承到的，也不存在覆盖， 而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法, 而private修饰子类根本无法得到父类这个方法。互相矛盾。 /* * 抽象类,可以没有抽象方法,可以定义带有方法体的方法 * 让子类继承后,可以直接使用 */public abstract class Animal &#123; // private abstract void show(); //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写&#125;2:final，，后面学3:static，后面学 17员工案例分析A:员工案例分析: a:需求描述: 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。 研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师； 维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。  工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 b:继承体系: 员工 | -------------------------------------------- | | 研发部员工 维护部员工 | | ------------- ----------- | | | | JavaEE工程师 Android工程师 网络维护工程师 硬件维护工程师 c:详细描述:  根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。 则，把这些共同的属性与功能抽取到父类中（员工类）， 关于工作的内容由具体的工程师来进行指定。  工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机  创建JavaEE工程师对象，完成工作方法的调用 18员工案例Employee类的编写12345678910111213141516171819202122232425262728 A:员工案例Employee类的编写:按照分析的继承体系来逐个实现 /* * 定义员工类 * 内容,都是所有子类的共性抽取 * 属性: 姓名,工号 * 方法: 工作 */ public abstract class Employee &#123; private String id;// 员工编号 private String name; // 员工姓名 public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //工作方法（抽象方法） public abstract void work(); &#125; 19员工案例的子类的编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 B:员工案例的子类的编写: /* * 定义研发员工类 * 属于员工中的一种, 继承员工类 * 抽象类Develop 给自己的员工定义自己有的属性 */public abstract class Develop extends Employee&#123;&#125;/* * 描述JavaEE开发工程师类 * 工号,姓名 工作方法 * 其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了 * 是研发部员工的一种,继承研发部类 */public class JavaEE extends Develop&#123; //重写他父类的父类的抽象方法 public void work()&#123; //调用父类的get方法,获取name,id值 System.out.println("JavaEE的工程师开发淘宝"+ super.getName()+".."+super.getId()); &#125;&#125; /* *定义Android工程师 继承 研发部员工类，重写工作方法 */ public class Android extends Developer &#123; @Override public void work() &#123; System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在研发淘宝手机客户端软件"); &#125; &#125; /* * 定义维护员工类,属于员工中的一种 * 继承员工类 * 抽象类Maintainer 给自己的员工定义自己有的属性 */public abstract class Maintainer extends Employee&#123;&#125; /* * 描述的是网络维护工程师 * 属于维护部的员工,继承维护部类 */public class Network extends Maintainer&#123; public void work()&#123; System.out.println("网络工程师在检查网络是否畅通"+super.getName()+"..."+super.getId()); &#125;&#125; /* *定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 */public class Hardware extends Maintainer &#123; @Override public void work() &#123; System.out.println("员工号为 " + getId() + " 的 " + getName() + " 员工，正在修复打印机"); &#125;&#125; 20小结（1） 继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有继承的好处：可继承的属性和方法。 提高了代表的可维护性 提高了代码的复用性 让类与类之间产生了继承关系 继承的弊端： 类与类之间的耦合度过高 继承特点： java中类只能够单继承，不能多继承，可以多层继承 class Yy extends Object {} class Fu extends Yy{} class Zi extends Fu {} 所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类 继承的注意事项： 1，使用关键字 extends 让类与类之间 产生继承关系 2, 父类私有的成员，子类不能继承，因为根本看不到 3，不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系 苹果 is a 水果 男人 is a 人 狗 is a 人 ， 这种情况就不能继承了 继承中的成员变量关系： 不同名的变量： 子类直接继承使用 同名的变量： 默认访问的是子类自己的成员变量(this.成员变量), 想访问父类中的同名变量，请使用 (super.成员变量); 继承中的成员方法关系：1234567891011不同名的方法：子类直接继承使用同名的方法：默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();super:用来表示当前对象中包含的父类对象空间的引用调用父类的成员变量：super.成员变量;调用方法的成员方法:super.成员方法(); (2)方法重写(override)：指 在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写方法重写的注意事项：1231，子类的方法声明要与父类相同2, 子类要重写方法的方法，方法的权限修饰符不能比父类的更低3, 父类私有的方法，子类不能够进行方法重写 (3)方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同) (4)抽象123抽象方法： 方法只有声明部分，没有方法体,即 public abstract void method();抽象类： 包含抽象方法的类，一定是抽象类 使用 abstract 修饰的类，是抽象类 抽象类的特点：1234561，抽象类与抽象方法都必须使用 abstract来修饰 2，抽象类不能直接创建对象 3，抽象类中可以有抽象方法，也可以没有抽象方法 4，抽象类的子类 a，实现了抽象方法的具体类 b，抽象类 抽象类面试题： 1，抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？ 可以没有抽象方法，有意义，不会让其他人直接创建该类对象]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础7(类与对象，成员变量，封装)]]></title>
    <url>%2F2016%2F10%2F10%2Fday09%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、面向对象思想2、类与对象的关系3、局部变量和成员变量的关系4、封装思想5、private,this关键字6、随机点名器 面向对象思想面向对象和面向过程的思想* A: 面向过程与面向对象都是我们编程中，编写程序的一种思维方式 * a: 面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。 * b: 面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。 面向对象的思想的生活案例* A: 买电脑（组装机） * a: 面向过程：自己该怎么做 * b: 面向对象：找人帮我们做 面向对象好处* A: 面向对象好处 * a: 面向对象思维方式是一种更符合人们思考习惯的思想 * b: 面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。 * c: 面向对象思维方式将复杂的问题简单化。 大象装进冰箱的代码案例* A: 需求：把大象装冰箱里 * a: 面向过程 * 自己打开冰箱门 * 自己将大象装进去 * 自己关闭冰箱门 * b: 面向对象 * 分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具 备如下功能 * 冰箱打开 * 冰箱存储 * 冰箱关闭 * B: 通过伪代码描述大象和冰箱 * 描述大象： class 大象 { } * 描述冰箱 class冰箱 { void 打开(){} void 存储(大象){} void 关闭(){} } * C: 使用对象： * 1、创建冰箱的对象 * 冰箱 bx = new 冰箱(); * 2、调用冰箱的功能 * 对象.功能()； * bx.打开(); * bx.存储(new 大象()); * bx.关闭(); * D：总结： * 1、先按照名词提炼问题领域中的对象 * 2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能 * 3、通过new的方式就可以创建该事物的具体对象 * 4、通过该对象调用它以后的功能。 类与对象的关系定义小汽车类* A: 分析小汽车的属性和功能 * 属性 * 颜色 * 轮胎个数 * 功能 * 运行 * B: 通过伪代码描述小汽车 * 小汽车{ * 颜色 * 轮胎个数 * 运行(){} * } * C：通过JAVA代码描述小汽车 12345678* public class Car &#123; * String color; * int number; * void run() &#123; * System.out.println(color + ":" + number); * &#125;* &#125; 测试汽车类* A: 创见对象的格式 * a: 类名 变量名 = new 类名(); * B: 测试汽车类 1234567891011121314public class CarDemo &#123; public static void main(String[] args) &#123; /* 测试：Car类中的run方法。 */ // 1,创建Car的对象。给对象起个名字。 Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。 // 2,通过已有的对象调用该对象的功能。格式：对象.对象成员; // 3,可以该对象的属性赋值。 c.color = "red"; c.number = 4; c.run(); &#125;&#125; 对象的内存图 类和对象的关系* A: 类和对象的关系 * 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体 * B: 举例 * 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系 局部变量和成员变量的关系成员变量和局部变量的区别123456789101112* 区别一：定义的位置不同 * 定义在【类】中的变量是【成员变量】 * 定义在【方法】中或者&#123;&#125;语句里面的变量是【局部变量】* 区别二：在内存中的位置不同 * 【成员变量】存储在【堆内存】的对象中 * 【局部变量】存储在【栈内存】的方法中（局部变量跟随方法进栈）* 区别三：声明周期不同 * 成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失 * 局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失* 区别四：初始化不同 * 【成员变量】因为在堆内存中，【所有默认的初始化值】 * 【局部变量】【没有默认】的初始化值，必须手动的给其赋值才可以使用。 封装思想01方法参数是基本数据类型和引用数据类型* A.基本类型 123456789101112131415class Demo&#123; public static void main(String[] args) &#123; int x = 4; show(x); System.out.println("x="+x); &#125; public static void show(int x) &#123; x = 5; &#125;&#125; 基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。 * B.引用类型 12345678910111213141516171819202122class Demo &#123; int x ; public static void main(String[] args) &#123; Demo d = new Demo(); d.x = 5; show(d); System.out.println("x="+d.x); &#125; public static void show(Demo d) &#123; d.x = 6; &#125;&#125; 当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。* C.结论* 对于基本类型形式参数改变不会影响到实际参数* 对于引用类型形式参数改变会影响到实际参数 02封装的概述* A.面向对象三大特征 * 封装、继承、多态 * B.封装表现 * 1、方法就是一个最基本封装体 * 2、类其实也是一个封装体 * C.封装的好处 * 1、提高了代码的复用性 * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念 * 3、提高了安全性 03封装的生活中的举例* A.封装的生活中的举例 机箱： 一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。 总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。 * B.总结 * 机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式 private,this关键字private关键字1234567891011121314* A.private概述 * private可以修饰成员内容包括成员方法和成员变量 * 被private修饰的内容不能在其他类访问* B.使用步骤 * 1、通过private修饰属性* C.完整代码 class Person &#123; private int age; private String name; public void show() &#123; System.out.println("age=" + age + ",name" + name); &#125; &#125; get和set方法* A.get和set方法 * 年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。 一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。12345678910111213141516171819202122232425class Person &#123; // 私有成员变量 private int age; private String name; // 对外提供设置成员变量的方法 public void setAge(int a) &#123; // 由于是设置成员变量的值，这里可以加入数据的验证 if (a &lt; 0 || a &gt; 130) &#123; System.out.println(a + "不符合年龄的数据范围"); return; &#125; age = a; &#125; // 对外提供访问成员变量的方法 public void getAge() &#123; return age; &#125;&#125;* 总结 * 类中不需要对外提供的内容都私有化，包括属性和方法。以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问* 注意 * 私有仅仅是封装的体现形式而已 私有化Person类带get,set* 标准代码 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.demo05;/* * 类描述人: * 属性: 姓名和年龄 * 方法: 说话 * * 私有化所有的属性 (成员变量) ,必须写对应的get/set方法 * 凡是自定义的类,自定义成员变量,应该私有化,提供get/set * * this关键字: * 区分成员变量和局部变量同名情况 * 方法中,方位成员变量,写this. */public class Person &#123; private String name; private int age; // set方法,变量name,age赋值 public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; // get方法,变量name,age获取值 public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void speak() &#123; String name = "哈哈"; int age = 16; System.out.println("人在说话 " + this.name + "..." + this.age); &#125;&#125; * 标准测试代码 12345678910111213141516package cn.itcast.demo05;public class PersonTest &#123; public static void main(String[] args) &#123; Person p = new Person(); //调用set方法,对成员变量赋值 p.setAge(18); p.setName("旺财"); p.speak(); //调用get方法,获取成员变量的值// System.out.println(p.getName());// System.out.println(p.getAge()); &#125;&#125; this关键字_区分成员变量和局部变量的同名* A.什么时候用 * 当类中存在成员变量和局部变量同名的时候为了区分，就需要使用this关键字 * B.代码 class Person { private int age; private String name; public void speak() { this.name = &quot;小强&quot;; this.age = 18; System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age); } } class PersonDemo { public static void main(String[] args) { Person p = new Person(); p.speak(); } } this内存图* A.this内存图 this的年龄比较* A.需求：在Person类中定义功能，判断两个人是否是同龄人 * B.代码 12345678910111213141516171819202122232425262728293031323334class Person &#123; private int age; private String name; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println("name=" + this.name + ",age=" + this.age); &#125; // 判断是否为同龄人 public boolean equalsAge(Person p) &#123; // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较 // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替 /* * if(this.age == p.age) &#123; return true; &#125; return false; */ return this.age == p.age; &#125;&#125; 随机点名器随机点名器案例重构* A.需求：随机点名器，即在全班同学中随机的找出一名同学，打印这名同学的个人信息 它具备以下3个内容： 存储所有同学姓名 总览全班同学姓名 随机点名其中一人，打印到控制台 * B.代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.ArrayList;import java.util.Random;import java.util.Scanner;/** * 思路： * 第一步：存储全班同学信息 * 第二步：打印全班同学每一个人的信息 * 第三部：随机对学生点名，打印学生信息 */public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //1.1创建一个可以存储多个同学名字的容器 //1.存储全班同学信息 addStudent(list); //2.打印全班同学每一个人的信息（姓名、年龄） printStudent(list); //3.随机对学生点名，打印学生信息 randomStudent(list); &#125; public static void addStudent(ArrayList&lt;Student&gt; list) &#123; //键盘输入多个同学名字存储到容器中 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; 3; i++) &#123; //创建学生 Student s = new Student(); System.out.println("存储第"+i+"个学生姓名："); String name = sc.next(); s.setName(name); System.out.println("存储第"+i+"个学生年龄："); int age = sc.nextInt(); s.setAge(age); //添加学生到集合 list.add(s); &#125; &#125; /** 2.打印全班同学每一个人的信息（姓名、年龄） */ public static void printStudent (ArrayList&lt;Student&gt; list) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; Student s = list.get(i); System.out.println("姓名："+s.getName() +",年龄："+s.getAge()); &#125; &#125; /** 3.随机对学生点名，打印学生信息 */ public static void randomStudent (ArrayList&lt;Student&gt; list) &#123; //在班级总人数范围内，随机产生一个随机数 int index = new Random().nextInt(list.size()); //在容器（ArrayList集合）中，查找该随机数所对应的同学信息（姓名、年龄） Student s = list.get(index); System.out.println("被随机点名的同学："+s.getName() + "，年龄:" + s.getAge()); &#125;&#125; 1234567891011121314151617181920212223/** * 学生信息类 */public class Student &#123; private String name; // 姓名 private int age; // 年龄 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 总结123456789101112131415161718192021222324252627282930313233343536* A.类与对象 * 类，用于描述多个对象的共同特征，它是对象的模板。 * 对象，用于描述现实中的个体，它是类的实例。 * 类的定义：使用关键字class来定义java中的类 * 格式： * class 类名 &#123; * //属性 * 数据类型 变量名; * … * //方法 * 修饰符 返回值类型 方法名(参数)&#123; &#125; * … * &#125; * * B.创建对象： * 格式： * 类名 对象名 = new 类名();* C.封装（private关键字） * 封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式 * 封装的体现： * 变量:使用 private 修饰，这就是变量的封装 * 方法:也是一种封装，封装了多条代码 * 类： 也是一种封装，封装了多个方法* D.private关键字，私有的意思 * 它可以用来修饰类中的成员(成员变量，成员方法) * private的特点： * private修饰的成员只能在当前类中访问，其他类中无法直接访问* E.this关键字 * this关键字，本类对象的引用 * this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用 * this什么时候存在的？当创建对象的时候，this存在的 * this的作用：用来区别同名的成员变量与局部变量（this.成员变量） * public void setName(String name) &#123; * this.name = name; * &#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础6(自定义类，ArrayList)]]></title>
    <url>%2F2016%2F10%2F09%2Fday06%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、自定义类型的定义及使用2、自定义类的内存图3、ArrayList集合的基本功能4、随机点名器案例及库存案例代码优化 01引用数据类型_类* A: 数据类型 * a: java中的数据类型分为：基本类型和引用类型 * B: 引用类型的分类 * a: Java为我们提供好的类，比如说：Scanner,Random等。 * b: 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 02自定义类的概述* A: 自定义类的概述 * java代码映射成现实事物的过程就是定义类的过程。 * 举例： 我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性 * 目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。 03自定义类的格式* A: 自定义类的格式 * a: 使用类的形式,对现实中的事物进行描述。 * b: 事物由方法和属性两部分组成。 * 方法: 这个事物具备的功能。 * 属性: 这个事物具备的特征。 * c: 格式 123456789public class 类名&#123; 属性定义 修饰符 数据类型 变量名 = 值 方法定义 修饰符 返回值类型 方法名(参数列表)&#123; &#125;&#125; 04自定义的手机类* A: 自定义的手机类 123456789* a: 案例代码 public class Phone&#123; /* 定义手机的属性 */ String color ; String brand ; double size ; &#125; 05测试手机类导包：我们将所有的类放到同一个文件夹下，可以避免导包。 创建对象：数据类型 变量名 = new 数据类型(); 调用方法：目前我们定义的自定义类不涉及方法，只是属性（自定义类中的方法部分在面向对象部分讲解）访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。)1234567891011121314151617181920212223* A: 调用方法执行流程* a: 实现引用类型的步骤 * 1: 导入包 , 类都是在同一个文件夹,不需要导入包 * 2: 创建引用类型的变量 * 3: 变量.类型中的功能* b: 案例代码 public class TestPhone&#123; public static void main(String[] args)&#123; // 2: 创建引用类型的变量 Phone p = new Phone(); //System.out.println(p); //输出内存的地址 //3: 变量.类型中的功能 //变量 p.的方式,调用类中的属性 //属性就是变量 , 赋值和获取值 p.color = "土豪金"; p.brand = "爱立信"; p.size = 5.0; //获取属性值 System.out.println(p.color+" "+p.brand+" "+p.size); &#125; &#125; 06自定义类的内存图_1* A: 自定义类的内存图_1 07自定义类的内存图_2* A: 自定义类的内存图_1 08两个引用类型变量内存图* A: 自定义类的内存图_1 09自定义类的练习* A: 实体类的代码 1234567891011121314151617181920212223242526272829303132333435363738/* 电饭锅，包含属性（品牌、容量大小、颜色等） 定义类,描述事物,电饭锅 属性: 品牌,大小 ,颜色 定义类,类名字,电饭锅 类的范围,定义三个属性*/public class DianFanGuo&#123; //定义三个属性 String brand ; double size ; String color ;&#125;/* 汽车，包含属性（品牌、排量、类型等） 定义类,类名 Car 属性 品牌 排量 类型 */public class Car&#123; //定义汽车三个属性 String brand ; double paiLiang ; String type;&#125; /* 学生，包含属性（姓名，年龄，性别等） 定义类,类名Student 三个属性: 姓名,年龄,性别 (char)*/public class Student&#123; String name; int age ; char sex ;&#125; * B: 测试类的代码 1234567891011121314151617181920212223242526272829303132/* 定义的测试类 同时测试,电饭锅,汽车,学生*/public class Test&#123; public static void main(String[] args)&#123; //创建电饭锅引用类型 DianFanGuo dfg = new DianFanGuo(); dfg.brand = "特斯拉"; dfg.color = "红色"; dfg.size = 30; System.out.println(dfg.brand+" "+dfg.color+" "+dfg.size); //创建汽车引用类型 Car c = new Car(); c.brand = "巨力"; c.type = "拖拉机"; c.paiLiang = 0.5; System.out.println(c.brand+" "+c.type+" "+c.paiLiang); //创建学生引用类型 Student stu = new Student(); stu.name = "张三"; stu.age = 20; stu.sex = '男'; System.out.println(stu.name+" "+stu.age+" "+stu.sex); &#125;&#125; 10ArrayList创建变量的步骤为了保存这些数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。在这里，我们先介绍ArrayList集合.导包：import java.util.ArrayList; 创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型： 1ArrayList&lt;要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;要存储元素的数据类型&gt;(); * A: ArrayList创建变量的步骤 * a: 导入包 java.util包中 * b: 创建引用类型的变量 数据类型&lt; 集合存储的数据类型&gt; 变量名 = new 数据类型&lt;集合存储的数据类型&gt;(); 集合存储的数据类型: 要将数据存储到集合的容器中 创建集合引用变量的时候,必须要指定好,存储的类型是什么 * c: 变量名.方法 注意: 集合存储的数据,8个基本类型对应8个引用类型 存储引用类型,不存储基本类型 “&lt;要存储元素的数据类型&gt;”中的数据类型必须是【引用数据类型】，不能是基本数据类型；下面给出8种基本数据类型所对应的引用数据类型表示形式: 基本数据类型 对应的引用数据类型表示形式 12345678byte Byteshort ShortInt Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 11ArrayList创建变量举例* A: ArrayList创建变量的示例代码 1234567891011121314import java.util.ArrayList;public class ArrayListDemo&#123; public static void main(String[] args)&#123; //创建集合容器,指定存储的数据类型 //存储字符串 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //创建集合容器,存储整数 ArrayList&lt;Integer&gt; array2 = new ArrayList&lt;Integer&gt;(); //创建集合容器,存储手机类型 ArrayList&lt;Phone&gt; array3 = new ArrayList&lt;Phone&gt;(); &#125;&#125; 12ArrayList的常见方法* A: ArrayList的常见方法 123* a: add(参数) 向集合中添加元素* b: get(int index) 取出集合中的元素,get方法的参数,写入索引* c: size() 返回集合的长度, 集合存储元素的个数 * B: 案例代码 1234567891011121314151617181920212223242526import java.util.ArrayList;public class ArrayListDemo_1&#123; public static void main(String[] args)&#123; //定义集合,存储字符串元素 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //调用集合方法add存储元素 array.add("abc"); array.add("itcast"); array.add("love"); array.add("java"); //输出集合的长度,调用集合方法size, size方法的返回值类型 int int size = array.size(); System.out.println(size); //获取出集合中的一个元素,获取1索引的元素 //集合的方法get, 获取元素后结果数据类型 String s = array.get(1); System.out.println(s); System.out.println(array.get(0)); System.out.println(array.get(1)); System.out.println(array.get(2)); System.out.println(array.get(3)); &#125;&#125; 13ArrayList集合的遍历* A: 案例代码 1234567891011121314151617181920212223/* 集合的遍历 实现思想也是索引思想 集合的索引从0开始,到 size()-1 方法get(int index)*/import java.util.ArrayList;public class ArrayListDemo_2&#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(121); array.add(125); array.add(123); array.add(120); array.add(128); //对集合进行遍历 //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++)&#123; System.out.println( array.get(i) ); &#125; &#125;&#125; 14ArrayList补充方法* A: ArrayList补充方法 1234* a: add(int 索引,存储的元素) 将元素添加到指定的索引上* b: set(int 索引,修改后的元素) 将指定索引的元素,进行修改* c: remove(int 索引) 删除指定索引上的元素* d: clear() 清空集合中的所有元素 * B: 案例代码 import java.util.ArrayList; public class ArrayListDemo_3{ public static void main(String[] args){ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(1); array.add(2); array.add(3); array.add(4); //在索引2上,添加元素7 array.add(2,7); //将0索引上的元素,修改成10 array.set(0,10); //将4索引上的元素,删除 array.remove(4); array.clear(); //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++){ System.out.println( array.get(i) ); } } } 15随机点名器案例分析* A: 随机点名器案例分析 全班同学中随机的找出一名同学，打印这名同学的个人信息。 我们对本案例进行分析，得出如下分析结果： 1.存储全班同学信息（姓名、年龄） 将容器换成集合，集合中存的是Student类型 2.打印全班同学每一个人的信息（姓名、年龄） 遍历集合 3.在班级总人数范围内，随机产生一个随机数，查找该随机数所对应的同学信息（姓名、年龄） 随机点名器明确地分为了三个功能。如果将多个独立功能的代码写到一起，则代码相对冗长，我们可以针对不同的功能可以将其封装到一个方法中，将完整独立的功能分离出来。 而在存储同学姓名时，如果对每一个同学都定义一个变量进行姓名存储，则会出现过多孤立的变量，很难一次性将全部数据持有。此时，我们采用ArrayList集合来解决多个学生信息的存储问题 16随机点名器代码实现* A: 随机点名器案例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 随机点名器,集合改进 (学生的姓名和年龄) 现实中有学生这个事物,使用定义类的形式,描述学生事物 属性: 姓名,年龄 姓名存储了数组, 将容器换成是集合 String[] s = &#123;"",""&#125;; 集合中,存储的是学生的姓名吗? 应该存储Student类型 存储学生: 学生类型,存储到集合中 总览: 遍历集合 随机: 随机数,作为索引,到集合中找到元素 三个功能,共享的数据,集合容器, 定义三个方法,必须参数传递集合*/import java.util.ArrayList;import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //定义集合,存储的是StudentName类型变量 ArrayList &lt;StudentName&gt; array = new ArrayList&lt;StudentName&gt;(); //调用添加方法 add (array); //调用遍历集合 printArrayList(array); randomStudentName(array); &#125; /* 随机数,当作集合的索引,到集合中找到元素 */ public static void randomStudentName(ArrayList&lt;StudentName&gt; array )&#123; Random r = new Random(); int number = r.nextInt( array.size()); //随机数,索引,到集合中get StudentName s = array.get(number); System.out.println( s.name +" "+s.age); &#125; /* 总览学生的信息,遍历集合 */ public static void printArrayList(ArrayList&lt;StudentName&gt; array)&#123; for(int i = 0 ; i &lt; array.size();i++)&#123; //存储集合的时候, 集合.add(sn1) sn1 是StudentName类型变量 //获取的时候,集合.get方法,获取出来的是什么, 还是StudentName类型变量 StudentName s = array.get(i); System.out.println(s.name+" "+s.age); &#125; &#125; /* 定义方法,实现存储学生的姓名和年龄 创建StudentName类型变量,存储到集合中 */ public static void add (ArrayList&lt;StudentName&gt; array)&#123; //创建StudentName类型变量 StudentName sn1 = new StudentName(); StudentName sn2 = new StudentName(); StudentName sn3 = new StudentName(); StudentName sn4 = new StudentName(); StudentName sn5 = new StudentName(); sn1.name = "张三1"; sn1.age = 201; sn2.name = "张三2"; sn2.age = 202; sn3.name = "张三3"; sn3.age = 203; sn4.name = "张三4"; sn4.age = 204; sn5.name = "张三5"; sn5.age = 205; //将StudentName变量,存储到集合中 array.add(sn1); array.add(sn2); array.add(sn3); array.add(sn4); array.add(sn5); &#125;&#125; 17库存案例分析加入集合* A: 库存案例分析加入集合 * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG 18库存案例添加商品信息* A: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 定义,.描述商品的类 商品 4个属性 商品名字 大小 价格 库存 String double double int 定义类,类名Goods 这个类型的变量,存储到集合中*/public class Goods&#123; //定义商品名字 String brand ; //大小属性 double size ; // 价格属性 double price ; //库存属性 int count ;&#125;/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125; 19库存案例查看库存清单* A: 案例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); &#125; /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array)&#123; //输出表头 System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++)&#123; //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+" "+g.size+" "+g.price+" "+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125; 20库存案例修改库存清单及测试代码的实现* A: 案例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额 3.修改商品的库存 集合遍历 ,获取出集合中存储的Goods类型变量 变量调用Goods类的属性count,值进行修改 (键盘输入)*///import java.util.ArrayList;import java.util.*;public class Shopp&#123; public static void main(String[] args)&#123; //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); //进入死循环中 while(true)&#123; //调用选择功能的方法,获取到用户输入的功能序号 int number = chooseFunction(); //对序号判断,如果=1 进入查看库存功能 = 2 进入修改库存功能 =3 结束 switch(number)&#123; case 1: //进入查看库存,调用查看库存的方法,传递存储商品信息的集合 printStore(array); break; case 2: //进入修改库存功能,调用修改库存的方法,传递集合 update(array); break; case 3: return ; default: System.out.println("无此功能"); break; &#125; &#125; &#125; /* 方法定义,修改库存 键盘的输入,将Goods中的属性值,修改 */ public static void update(ArrayList&lt;Goods&gt; array)&#123; Scanner sc = new Scanner(System.in); //遍历集合,获取集合中的每个元素 for(int i = 0 ; i &lt; array.size(); i++)&#123; //集合方法get获取的是集合的元素,元素类型Goods Goods g = array.get(i); System.out.println("请输入"+g.brand+"的库存数"); //Goods属性,count进行修改 g.count = sc.nextInt(); &#125; &#125; /* 定义方法,实现选择菜单,用户根据功能选择菜单 */ public static int chooseFunction()&#123; System.out.println("-------------库存管理------------"); System.out.println("1.查看库存清单"); System.out.println("2.修改商品库存数量"); System.out.println("3.退出"); System.out.println("请输入要执行的操作序号："); Scanner sc = new Scanner(System.in); int number = sc.nextInt(); return number; &#125; /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array)&#123; //输出表头 System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++)&#123; //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+" "+g.size+" "+g.price+" "+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array)&#123; //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = "MacBook"; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = "Thinkpad"; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础5(方法)]]></title>
    <url>%2F2016%2F10%2F08%2Fday05%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、方法基础知识2、方法高级内容3、方法案例 01方法的概述* A: 为什么要有方法 * 提高代码的复用性 * B: 什么是方法 * 完成特定功能的代码块。 02方法的定义格式* A: 方法的格式 * 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } * B: 方法的格式说明 * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 * 返回值类型：就是功能结果的数据类型。 * 方法名：符合命名规则即可。方便我们的调用。 * 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 * 参数类型：就是参数的数据类型 * 参数名：就是变量名 * 方法体语句：就是完成功能的代码。 * return：结束方法的。 * 返回值：就是功能的结果，由return带给调用者。 03定义方法计算面积* A: 定义方法计算面积 123456789101112131415161718192021222324public class MethodDemo&#123; public static void main(String[] args)&#123; //调用方法, 方法执行起来 // 在方法main中,调用方法 getArea int area = getArea(5,6); System.out.println("面积是: "+area); &#125; /* 要求: 计算一个长方形的面积 定义方法解决这个要求 分析方法定义过程: 1.明确方法计算后的结果的数据类型 int 定义格式对应的就是返回值类型 2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int 未知数的变量,定义在方法的小括号内 */ public static int getArea(int w, int h)&#123; //实现方法的功能主体 //int area = w * h; return w * h; &#125;&#125; 04调用方法* A: 调用方法 * a: 在main函数中调用方法，让方法执行起来 * b: 方法的形参 * 方法要什么参数我们就给什么类型的参数。 * c: 方法的返回值 * 方法返回什么类型的值我们就用对应的数据类型的变量来接收 05调用方法执行流程* A: 调用方法执行流程 * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。 * b: 方法的执行，是把实参传递给形参，从而来执行的。 * c: 方法只有被调用才会执行。 06方法调用的内存图 A: 方法调用的内存图 07方法调用的练习* A: 案例代码 12345678910111213141516171819202122/* 方法的定义练习*/import java.util.Scanner;public class MethodDemo_1&#123; public static void main(String[] args)&#123; //printRect(); //int number = getNumber(); //System.out.println(getNumber()); //printRect2(3,5); double avg = getAvg(2,2,3); System.out.println(avg); &#125; /* 定义有返回值有参数方法，如求三个数的平均值 明确方法计算后的数据类型, 返回值类型 double 明确方法未知数, 三个未知的整数 */ public static double getAvg(double a, double b,double c)&#123; return (a+b+c)/3; &#125; 12345678910111213/* 定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形 明确方法计算后结果,控制台输出图形,没有返回值的 方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int */ public static void printRect2(int m,int n)&#123; for(int i = 0 ; i &lt; m ; i++)&#123; for(int j = 0 ; j &lt; n ; j++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125; 12345678910/* 定义有返回值无参数方法，如键盘录入得到一个整数 明确方法计算后结果的数据类型 int 明确有没有未知数,没 */ public static int getNumber()&#123; Scanner sc = new Scanner(System.in); //int number = sc.nextInt(); return sc.nextInt(); &#125; 123456789101112131415/* 定义无返回值无参数方法，如打印3行，每行3个*号的矩形 为什么没有返回值: 打印矩形 ,输出效果,不需要将结果返回 明确未知数: 不需要未知数 */ public static void printRect()&#123; for(int i = 0 ; i &lt; 3 ; i++)&#123; for(int j = 0 ; j &lt; 3 ;j++)&#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125; &#125; 08方法的定义和使用的注意事项* A: 方法的定义和使用的注意事项 12345678* a: 方法不能定义在另一个方法的里面* b: 写错方法名字* c: 写错了参数列表* d: 方法返回值是void,方法中可以省略return 不写 return 下面不能有代码* e 方法返回值类型,和return 后面数据类型必须匹配* f: 方法重复定义问题* g: 调用方法的时候,返回值是void, 不能写在输出语句中 09方法的重载* A: 方法的重载 1234567891011121314151617181920 * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 * 参数列表不同： * A:参数个数不同 * B:参数类型不同 * C:参数的顺序不同(算重载,但是在开发中不用)* B: 案例代码 public static int getSum(int a,int b)&#123; System.out.println("两个int参数"); return a+b; &#125; public static int getSum(int a,int b,int c)&#123; System.out.println("三个int参数"); return a+b+c; &#125; public static double getSum(double a,double b)&#123; System.out.println("两个double参数"); return a+b; &#125; 10方法重载注意事项* A: 方法重载注意事项 * a: 参数列表必须不同 * b: 重载和参数变量名无关 * c: 重载和返回值类型无关 * d: 重载和修饰符无关 * e: 技巧: 重载看方法名和参数列表 11方法参数是基本数据类型* A: 方法参数是基本数据类型 * a: 方法参数是基本类型时，传递的是值。 12方法参数是引用数据类型* A: 方法参数是引用数据类型 * a: 方法参数是引用类型时，传递的是内存地址值。 13随机点名器* A: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 实现随机点名器 1.存储所有学生姓名 2.预览所有学生姓名,遍历数组 3.随机数作为索引,到数组中找元素 将功能独立出来, 作成方法,调用方法即可 定义三个功能, 用到同一个姓名数据 姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数*/import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //定义数组,存储学生姓名 String[] names = new String[8]; //调用添加姓名方法 addStudent(names); //调用遍历数组方法 printStudentName(names); //调用随机姓名的方法 String name = randomStudentName(names); System.out.println(name); &#125; /* 定义方法,随机数,做索引,数组中找到学生姓名 返回值? 学生姓名 参数? 数组 */ public static String randomStudentName(String[] names)&#123; Random ran = new Random(); int index = ran.nextInt(names.length); return names[index]; &#125; /* 定义方法,遍历数组 返回值? 没有 参数? 数组 */ public static void printStudentName(String[] names)&#123; for(int i = 0 ; i &lt; names.length ;i++)&#123; System.out.println(names[i]); &#125; &#125; /* 定义方法,实现向数组中添加学生姓名 返回值? 没有, 参数? 参数就是数组 */ public static void addStudent(String[] names)&#123; names[0] = "张三"; names[1] = "李四"; names[2] = "王五"; names[3] = "李蕾"; names[4] = "韩梅梅"; names[5] = "小名"; names[6] = "老王"; names[7] = "小华"; &#125;&#125; 14库存案例代码实现_1* A: 案例代码 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } } 15库存案例代码实现_2* A: 案例代码 /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } 16库存案例代码测试* A: 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量*/import java.util.Scanner;public class Shopp&#123; public static void main(String[] args)&#123; //使用数组,保存商品的信息 //品名,尺寸,价格,库存数, 定义5个数组 String[] brand = &#123;"MacBookAir","ThinkpadT450"&#125;; double[] size = &#123;13.3,15.6&#125;; double[] price = &#123;9998.97,6789.56&#125;; int[] count = &#123;0,0&#125;; while(true)&#123; int choose = chooseFunction(); switch(choose)&#123; case 1: //调用查看库存清单方法 printStore(brand,size,price,count); break; case 2: //调用修改库存的方法 update(brand,count); break; case 3: return ; default: System.out.println("没有这个功能"); break; &#125; &#125; &#125; /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count)&#123; //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++)&#123; System.out.println("请输入"+brand[i]+"的库存数"); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; &#125; //int chooseNumber = sc.nextInt(); &#125; /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count)&#123; System.out.println("----------商场库存清单----------"); System.out.println("品牌型号 尺寸 价格 库存数"); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++)&#123; System.out.println(brand[i]+" "+size[i]+" "+price[i]+" "+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; &#125; System.out.println("总库存数: "+totalCount); System.out.println("商品库存总金额: "+totalMoney); &#125; /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction()&#123; System.out.println("-------------库存管理------------"); System.out.println("1.查看库存清单"); System.out.println("2.修改商品库存数量"); System.out.println("3.退出"); System.out.println("请输入要执行的操作序号："); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础4(switch，数组)]]></title>
    <url>%2F2016%2F10%2F04%2Fday04%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、流程控制语句switch2、数组3、随机点名器案例 01switch语句解构* A:switch语句解构 * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。 1234567891011121314151617* b:格式如下: swtich(表达式)&#123; case 常量1 : 要执行的语句; break; case 常量2 : 要执行的语句; break; case 常量3 : 要执行的语句; break; default: 要执行的语句; break; 123456789101112* c: 执行流程: 表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束* d: 关键字: switch case default break * e:举例 如果等于1，则输出星期一 如果等于2，则输出星期二 如果等于3，则输出星期三 如果等于4，则输出星期四 如果等于5，则输出星期五 如果等于6，则输出星期六 如果等于7，则输出星期天 02switch语句的星期判断* A: switch语句的星期判断 123456789101112131415161718192021222324252627282930313233343536* a: 明确需求 需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期. * b: 代码实现public class SwitchDemo01 &#123; public static void main(String[] args) &#123; int week = 5; switch (week) &#123; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; case 3: System.out.println("星期三"); break; case 4: System.out.println("星期四"); break; case 5: System.out.println("星期五"); break; case 6: System.out.println("星期六"); break; case 7: System.out.println("星期天"); break; default: System.out.println("输入的数字不正确..."); break; &#125; &#125;&#125; 03switch语句接受的数据类型* A: switch语句接受的数据类型 * a:注意事项 switch语句中的表达式的数据类型,是有要求的 JDK1.0 - 1.4 数据类型接受 byte short int char JDK1.5 数据类型接受 byte short int char enum(枚举) JDK1.7 数据类型接受 byte short int char enum(枚举), String 04case穿透* A:case穿透 123* a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。* b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。* 注意：case 语句后面 没有break 就会一直穿透下去。 05数组的概述* A: 数组的概述 * a:数组的需求 现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成， 那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦. * b:数组的概述 数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 06数组的定义* A：数组的定义 123456789101112131415161718192021222324* b:格式: 数据类型[] 数组名 = new 数据类型[元素个数或数组长度]; * c:举例: int[] x = new int[100];* c:要点说明 1)数据类型: 数组中存储元素的数据类型 2) [] 表示数组的意思 3) 变量名 自定义标识符 4) new 创建容器关键字 5)数据类型: 数组中存储元素的数据类型 6)[] 表示数组的意思 7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长) 数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号 自动编号,最小值是0, 最大值,长度-1 自动编号专业名次, 索引(index), 下标, 角标 访问数组存储的元素,必须依赖于索引, 公式 数组名[索引] Java提供一个属性,操作索引的 数组的一个属性,就是数组的长度, 属性的名字 length 使用属性: 数组名.length 数据类型 int 数组的最小索引是0, 最大索引数组.length-1 07JVM内存划分* A：内存划分 * JVM对自己的内存划分为5个区域 * a: 寄存器:内存和CUP之间 * b: 本地方法栈: JVM调用了系统中的功能 * c: 方法和数据共享: 运行时期class文件进入的地方 * d: 方法栈:所有的方法运行的时候进入内存 * e: 堆:存储的是容器和对象 08数组的内存1234567* A: 数组的内存* int[] x; // 声明一个int[]类型的变量* x = new int[100]; // 创建一个长度为100的数组* 接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。* 第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值* 第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化* 引用数据类型 存的是变量的地址 09使用索引访问数组的元素* A: 使用索引访问数组的元素 * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。 * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1” 10数组的length属性* A: lenth属性 123456789101112* a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。* b 求数组的长度public class ArrayDemo01 &#123; public static void main(String[] args) &#123; int[] arr; // 声明变量 arr = new int[3]; // 创建数组对象 System.out.println("arr[0]=" + arr[0]); // 访问数组中的第一个元素 System.out.println("arr[1]=" + arr[1]); // 访问数组中的第二个元素 System.out.println("arr[2]=" + arr[2]); // 访问数组中的第三个元素 System.out.println("数组的长度是：" + arr.length); // 打印数组长度 &#125;&#125; 11为数组的元素赋值* A: 为数组的元素赋值 * a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。 * 赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值 * b: 案例 123456789101112public class ArrayDemo02 &#123; public static void main(String[] args) &#123; int[] arr = new int[4]; // 定义可以存储4个整数的数组 arr[0] = 1; // 为第1个元素赋值1 arr[1] = 2; // 为第2个元素赋值2 // 下面的代码是打印数组中每个元素的值 System.out.println("arr[0]=" + arr[0]); System.out.println("arr[1]=" + arr[1]); System.out.println("arr[2]=" + arr[2]); System.out.println("arr[3]=" + arr[3]); &#125;&#125; 12数组的定义_2* A: 定义数组格式2 1234567891011121314* a: 数组初始化动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。 1、类型[] 数组名 = new 类型[长度]; int[] arr = new int[4]; 静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。 2、类型[] 数组名 = new 类型[]&#123;元素，元素，……&#125;; int[] arr = new int[]&#123;1,2,3,4&#125;; 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。 例如： arr = new int[] &#123; 17, 19, 23, 29, 31, 37 &#125;; 3、类型[] 数组名 = &#123;元素，元素，元素，……&#125;; int[] arr = &#123; 1, 2, 3, 4 &#125;;* 数组拷贝 int[] smallPrimes = &#123; 2, 3, 5, 7, 11, 13 &#125;; int[] luckyNumbers = smallPrimes; 如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法： 123int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length) ;//第 2 个参数是新数组的长度。这个方法通常用来增加数组的大小luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 如果数组元素是数值型，那么多余的元素将被赋值为 0 ; 如果数组元素是布尔型， 则将赋值为 false。相反， 如果长度小于原始数组的长度，则只拷贝最前面的数据元素。 13遍历数组* A:遍历数组 * 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历 * B:练习 12345678910111213141516public class ArrayDemo04 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; // 定义数组 // 使用for循环遍历数组的元素 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); // 通过索引访问元素 &#125; &#125;&#125;上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来for each 循环 =&gt; 遍历数组for (variable : collection) &#123;statement&#125;例如: for(int element : a) System.out.println(element); 提示：有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串， 这些元素被放置在括号内， 并用逗号分隔， 例如，“ [2, 3, 5,7，11 ，13]”、 要想打印数组， 可以调用System.out.println(Arrays.toString(a)); 14数组中常见的异常* A: 数组操作中,常见的两个异常 数组的索引越界异常 空指针异常 * B: 练习 1234567891011121314public class ArrayDemo_4&#123; public static void main(String[] args)&#123; //数组的索引越界异常 //int[] arr = &#123;5,2,1&#125;; //数组中3个元素,索引 0,1,2 //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3 //空指针异常 int[] arr2 = &#123;1,5,8&#125;; System.out.println(arr2[2]); arr2 = null; // arr2 不在保存数组的地址了 System.out.println(arr2[2]);//java.lang.NullPointerException &#125;&#125; 15数组最值和排序* A: 数组获取最值的原理思想 * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素 * B: 数组排序 * 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法： int[] a = new int[10000]; Arrays.sort(a) 16数组获取最值代码实现* A: 代码实现 12345678910111213public class ArrayDemo05 &#123; public static void main(String[] args) &#123; int[] arr = &#123; 4, 1, 6, 3, 9, 8 &#125;; // 定义一个数组 int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值 // 下面通过一个for循环遍历数组中的元素 for (int x = 1; x &lt; arr.length; x++) &#123; if (arr[x] &gt; max) &#123; // 比较 arr[x]的值是否大于max max = arr[x]; // 条件成立，将arr[x]的值赋给max &#125; &#125; System.out.println("max=" + max); // 打印最大值 &#125;&#125; 17二维数组的定义* A 二维数组的作用 * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？ * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。 * B 定义格式 123456789* a 第一种定义格式: * int[][] arr = new int[3][4]; * 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组* b 第二种定义格式 * int[][] arr = new int[3][]; * 第二种方式和第一种类似，只是数组中每个元素的长度不确定* c 第三种定义格式 * int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5,6&#125;,&#123;7,8,9&#125;&#125;; * 二维数组中定义了三个元素，这三个元素都是数组，分别为&#123;1,2&#125;、&#123;3,4,5,6&#125;、&#123;7,8,9&#125; 18二维数组元素的访问* A: 二维数组的访问 * 案例: 12345678910111213141516171819202122232425262728293031class ArrayDemo08 &#123; public static void main(String[] args)&#123; //定义二维数组的方式 int[][] arr = new int[3][4]; System.out.println( arr ); System.out.println("二维数组的长度: " + arr.length); //获取二维数组的3个元素 System.out.println( arr[0] ); System.out.println( arr[1] ); System.out.println( arr[2] ); System.out.println("打印第一个一维数组的元素值"); System.out.println( arr[0][0] ); System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素 System.out.println( arr[0][2] ); System.out.println( arr[0][3] ); System.out.println("打印第二个一维数组的元素值"); System.out.println( arr[1][0] ); System.out.println( arr[1][1] ); System.out.println( arr[1][2] ); System.out.println( arr[1][3] ); System.out.println("打印第三个一维数组的元素值"); System.out.println( arr[2][0] ); System.out.println( arr[2][1] ); System.out.println( arr[2][2] ); System.out.println( arr[2][3] ); &#125;&#125; 19二维数组内存图* A: 二维数组内存图 * 举例:int[][] arr = new int[3][2]; * 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值 * 每一个大内存空间里又开辟连续的两个小的内存空间. 20二维数组的定义和访问1234567891011* A: 二维数组的定义和访问 * 格式1: * int[][] arr = new int[3][]; 不推荐 * 格式2 * int[][] arr = &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;; * * B: 二维数组的访问 举例:int[][] arr = &#123;&#123;1,2,4&#125;,&#123;5,8,7&#125;,&#123;0,9,3&#125;&#125;; 想要打印数组中7这个元素需要先找到大的元素索引&#123;5,7&#125; 索引为2 ,在找7在&#123;5,7&#125;中的索引2 那么结果为 arr[2][2] 第一个[2]代表大数组中&#123;5,8,7&#125;这个元素索引 第二个[2]代表&#123;5,8,7&#125;中7元素的索引 21二维数组的遍历* A:二维数组遍历 123456789101112131415161718 int[][] arr = &#123;&#123;1,2,4&#125;,&#123;4,7&#125;,&#123;0,9,3&#125;&#125;; 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素 * B:举例:遍历二维数组public class ArrayArrayDemo_2&#123; public static void main(String[] args)&#123; int[][] arr = &#123; &#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;,&#123;0&#125; &#125;; //外循环,遍历二维数组 for(int i = 0 ; i &lt; arr.length ;i++)&#123; //内循环,遍历每个一维数组 arr[0] arr[1] arr[i] for(int j = 0 ; j &lt; arr[i].length; j++)&#123; System.out.print(arr[i][j]); &#125; System.out.println(); &#125; &#125; * C:二维数组累加求和 12345678910111213 class ArrayDemo09 &#123; public static void main(String[] args)&#123; int[][] arr2 = &#123; &#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6,7,8,9,10&#125; &#125;; int sum2 = 0; for (int i=0; i&lt;arr2.length; i++) &#123; for (int j=0; j&lt;arr2[i].length; j++) &#123; //System.out.println(arr2[i][j]) sum2 += arr2[i][j]; &#125; &#125; System.out.println("sum2= "+ sum2); &#125;&#125; for each 循环语句不能自动处理二维数组的每一个元素。它是按照行， 也就是一维数组处理的要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示： 1234for (double [] row : a) for (double value : row) //do something with value System.out.println(value); 提示： 要想快速地打印一个二维数组的数据元素列表， 可以调用：System.out.println(Arrays.deepToString(a)) ;输出格式为：[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]] 22二维数组的求和练习* A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示 * 第一小组销售额为{11, 12}万元 * 第二小组销售额为{21, 22, 23}万元 * 第三小组销售额为{31, 32, 33, 34}万元。 * B 代码实现 123456789101112131415161718public class ArrayDemo10 &#123; public static void main(String[] args) &#123; int[][] arr = new int[3][]; // 定义一个长度为3的二维数组 arr[0] = new int[] &#123; 11, 12 &#125;; // 为数组的元素赋值 arr[1] = new int[] &#123; 21, 22, 23 &#125;; arr[2] = new int[] &#123; 31, 32, 33, 34 &#125;; int sum = 0; // 定义变量记录总销售额 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组元素 int groupSum = 0; // 定义变量记录小组销售总额 for (int j = 0; j &lt; arr[i].length; j++) &#123; // 遍历小组内每个人的销售额 groupSum = groupSum + arr[i][j]; &#125; sum = sum + groupSum; // 累加小组销售额 System.out.println("第" + (i + 1) + "小组销售额为：" + groupSum + " 万元"); &#125; System.out.println("总销售额为: " + sum + " 万元"); &#125;&#125; 23随机点名器案例分析* A 随机点名器案例分析 * B: 需求 * 随机点名器，即在全班同学中随机的打印出一名同学名字。 * C:分析: * 1)定义数组存数全班同学 * 2)生成随机数范围0 到 数组长度-1 * 3)根据这个索引找到数组中的同学名称 24随机点名器代码实现* A: 分析 随机点名器: 1 存储姓名 2. 预览所有人的姓名 3. 随机出一个人的姓名 * B 代码实现 123456789101112131415161718192021import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; //存储姓名,姓名存储到数组中 //数组存储姓名,姓名的数据类型,String String[] names = &#123;"张三","李四","王五","李蕾","韩梅梅","小名","老王","小华","约翰逊","爱丽丝"&#125;; //预览: 遍历数组,打印所有姓名 for(int i = 0 ; i &lt; names.length ; i++)&#123; System.out.println(names[i]); &#125; System.out.println("============="); //随机出一个人的名 //利用随机数,生成一个整数,作为索引,到数组中找到对应的元素 Random ran = new Random(); //随机数,范围必须是0-数组的最大索引 int index = ran.nextInt(names.length);//index 就是随机数,作为索引 System.out.println(names[index]); &#125;&#125; 25随机点名器代码实现_2* A 代码优化: 1234567import java.util.Random;public class CallName&#123; public static void main(String[] args)&#123; String[] names = &#123;"张三","李四","王五","李蕾","韩梅梅","小名","老王","小华","约翰逊","爱丽丝"&#125;; System.out.println(names[new Random().nextInt(names.length)]); &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础3(引用类型，if，while)]]></title>
    <url>%2F2016%2F10%2F04%2Fday03%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、引用类型变量的创建及使用2、流程控制语句之选择语句3、流程控制语句之循环语句4、循环高级 01创建引用类型变量公式 A: 创建引用类型变量公式 a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。 b: 引用数据类型的定义格式 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。 数据类型 变量名 = new 数据类型(); c: 引用数据类型的使用 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。 变量名.方法名(); 02Scanner类的使用* A: Scanner类的使用 123456* a: 导包import java.util.Scanner;* b：创建键盘录入对象 Scanner sc = new Scanner(System.in);* c: 读取键盘录入的一个整数 * int enterNumber = sc.nextInt();* d: 读取键盘录入的字符串 * String enterString = sc.next(); * B: 案例代码 import java.util.Scanner; public class Demo05Scanner{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); System.out.println(&quot;用户输入的整数为&quot;+enterNumber); String enterString = sc.next(); System.out.println(&quot;用户输入的字符串为&quot;+enterString); } } 03Random随机数类的使用_1* A: Random随机数类的使用_1 123456789101112131415161718192021222324252627* a: 功能 * 生成随机数需要使用到引用类型随机数Random类* b: 使用方式 * import导包：所属包java.util. Random * 创建实例格式：Random random = new Random (); * 调用方法 * nextInt(int maxValue) 产生[0,maxValue)范围的随机数,包含0不包含maxValue * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextInt(100);//结果为0-99的一个数* B: 案例代码 import java.util.Random; public class RandomDemo&#123; public static void main(String[] args)&#123; Random ran = new Random(); // Random类中的,产生随机数的功能 int i = ran.nextInt(100); System.out.println(i); //问题? 产生随机数,范围 1-100之间 // nextInt(100) 0-99 + 1 &#125; &#125; 04Random随机数类的使用_2* A: Random随机数类的使用_2 12345* a: 调用方法 * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0) 05if语句格式第一种* A: if语句格式第一种 12345678* a: 书写格式 if(比较表达式) &#123; 语句体; &#125;* b：执行流程： * 先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体； * 如果是false，就不执行语句体； 12345678910111213* B: 案例代码 public class IfDemo&#123; public static void main(String[] args)&#123; int i = 5 ; //对变量i进行if判断 if(i &gt; 5)&#123; System.out.println("if中的条件是true"); i++; &#125; System.out.println(i); &#125; &#125; 06if语句格式第二种* A: if语句格式第二种 12345678910* a: 书写格式 if(比较表达式) &#123; 语句体1; &#125;else &#123; 语句体2; &#125;* b：执行流程： * 首先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体1； * 如果是false，就执行语句体2； 123456789101112* B: 案例代码 public class IfElseDemo&#123; public static void main(String[] args)&#123; int i = 16 ; //判断变量,是奇偶数, 除以2,看余数是0还是1 if( i % 2 == 0 )&#123; System.out.println(i+" 是偶数"); &#125;else&#123; System.out.println(i+" 是奇数"); &#125; &#125; &#125; 07if语句格式第三种* A: if语句格式第三种 123456789101112131415161718192021* a: 书写格式 if(比较表达式1) &#123; 语句体1; &#125;else if(比较表达式2) &#123; 语句体2; &#125;else if(比较表达式3) &#123; 语句体3; &#125; ... else &#123; 语句体n+1; &#125;* b：执行流程： * 首先计算比较表达式1看其返回值是true还是false， * 如果是true，就执行语句体1，if语句结束。 * 如果是false，接着计算比较表达式2看其返回值是true还是false， * 如果是true，就执行语句体2，if语句结束。 * 如果是false，接着计算比较表达式3看其返回值是true还是false， * 如果都是false，就执行语句体n+1。 12345678910111213141516171819* B: 案例代码 public class IfElseIfDemo&#123; public static void main(String[] args)&#123; //成绩判断要求 ,成绩&gt;80 成绩&gt;70 成绩&gt;60 不及格 //定义变量,保存成绩 int grade = 75; //使用if else if 语句对成绩判断 if( grade &gt; 80 )&#123; System.out.println(grade+" 成绩是优"); &#125;else if ( grade &gt; 70)&#123; System.out.println(grade+" 成绩是良"); &#125;else if ( grade &gt; 60)&#123; System.out.println(grade+" 成绩是中"); &#125;else&#123; System.out.println(grade+" 成绩是差"); &#125; &#125; &#125; 08if语句和三元运算符的互换* A: 三元运算符 12345678* a: 概念 * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行* b: 使用格式 * (条件表达式)？表达式1：表达式2；* c: 运算规则 * 1: 判断条件表达式，结果为一个布尔值 * 2: true，运算结果为表达式1 * 3: false，运算结果为表达式2 123456789101112131415161718192021* B: 案例代码 public class IfElseDemo_1&#123; public static void main(String[] args)&#123; int j = 6; int i = 15; //使用if语句,判断出最大值 if(i&gt;j)&#123; int j = 6; System.out.println(i+" 是最大值"); &#125;else&#123; System.out.println(j+" 是最大值"); &#125; //使用三元运算实现 int k = i&gt;j ? i : j; System.out.println(k+" 是最大值"); &#125; &#125;* C: 使用if语句还是三元表达式 * 判断条件多,使用if * 三元,必须有结果的, if 可以没有结果的 09while循环* A: while循环结构 123456789* a: 使用格式 初始化表达式； while(条件)&#123; 循环体 &#125;* b: 执行顺序 当条件是true,就执行循环体,执行完循环体后 程序再次执行while中的条件,如果条件还是true,继续执行循环体 直到条件是false的时候,循环就结束 123456789101112* B: 案例代码 public class WhileDemo&#123; public static void main(String[] args)&#123; //输出 1-4之间的整数 //定义变量,整数类型, 循环的条件 int i = 1; while( i &lt; 5 )&#123; System.out.println(i); i++; &#125; &#125; &#125; 10for循环_1* A: for循环_1 123456789101112131415161718 * a: 使用格式 for(初始化变量 ; 条件 ; 增量)&#123; 循环体; &#125; * b: 各模块解释 初始化变量: 定义变量,作用是用来控制循环的次数 条件: 当条件是true,执行循环体,条件是false,结束循环 增量: 变量自增情况 * B: 案例代码 public class ForDemo&#123; public static void main(String[] args)&#123; //for循环,输出0-10 for(int i = 0 ; i &lt; 11 ; i++)&#123; System.out.println(i); &#125; &#125; &#125; 11for循环_2* A: for循环的执行流程 for（①1 ; ②2 ; ③3）{ ④4 } 第一步，执行①1 第二步，执行②2，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 第三步，执行④4 第四步，执行③3，然后重复执行第二步 第五步，退出循环 12for循环_3* A: 案例 * a: 利用for循环,计算1+4的结果 * B: 案例代码 123456789101112public class ForDemo_1&#123; public static void main(String[] args)&#123; // 定义变量,记录求和后的数据 int sum = 0; // 利用循环,将变量从1变化到4 for(int i = 1 ; i &lt;= 4 ; i++)&#123; //对变量进行求和 sum = sum + i; &#125; System.out.println(sum); &#125;&#125; 13do_while循环* A: do_while循环 12345678910111213141516171819* a: 使用格式 do&#123; 循环体; &#125;while(条件);* b: 执行顺序 先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体， 如果条件为false，循环结束。* c: 特点 * 无条件先执行一次* B: 案例代码public class DoWhileDemo&#123; public static void main(String[] args)&#123; int i = 0; do&#123; System.out.println(i); i++; &#125;while( i &lt; 5); &#125;&#125; 14死循环* A: 死循环概述 * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环 * B: 死循环格式 * while(true){} * for(;;){} 15嵌套for循环_1* A: 嵌套循环的概述 123* 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。* while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，* 如最常见的在for循环中嵌套for循环。 * B: 嵌套循环的格式 12345678for(初始化表达式; 循环条件; 操作表达式) &#123; ……… for(初始化表达式; 循环条件; 操作表达式) &#123; 执行语句 ……… &#125; ………&#125; * C: 各模块解释 12345* 总的循环次数 = 内循环次数 * 外循环的次数* 内循环,是外循环的循环体 * 外循环,控制的是行数* 内循环,控制的是每行的个数 16嵌套for循环_2* A: 案例 * a: 打印正三角形 * B: 案例代码 12345678910public class ForForDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 9 ; i++)&#123; for(int j = 0; j &lt; i+1 ;j++)&#123; System.out.print("* "); &#125; System.out.println(); &#125; &#125;&#125; 17break语句* A: break语句 123456789101112* a: 作用 * 跳出所在的循环体* b: 书写位置 * 必须出现在循环或选择结构内* c: 举例 for(int i=0; i&lt;10; i++) &#123; if(i&gt;5) &#123; break; &#125; System.out.println(“我爱Java”+i); &#125; //会从0-5输出6次“我爱Java” * B: break详细解释 123456789* a: 作用 * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中， 可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码， 这些关键字一旦出现就可以跳转语句执行顺序。* b: 使用方式 * 无法单独使用，必须将break关键字置于switch或循环语句中* c: 运行规律 * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构 * 只能跳出最近的代码块，不能跨越多级代码块 * C：循环标号 123456789* a: 为什么使用循环标号 * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.* b: 使用方式 * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。 使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可* c: 运行规律 * 当外层循环外定义了标号 * 内层使用break，终止内外双层循环。 * 内层使用continue，终止内层循环，继续外层循环。 18continue语句* A: continue语句 12345678910111213141516171819* a: 作用 * 提前结束本次循环，继续进行下次循环* b: 使用方式 * 无法单独使用，必须将continue关键字置于循环语句中* c：运行规律 * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环* d：案例代码 public class ContinueDemo&#123; public static void main(String[] args)&#123; for(int i = 0 ; i &lt; 10 ; i++)&#123; if(i%2==0)&#123; continue; &#125; System.out.println(i); &#125; &#125; &#125; //会把0-9之间所有的奇数打印到控制台上 19猜数字小游戏* A: 猜数字小游戏 * a: 分析 * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现， 但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件 * b: 需求分析 * 后台预先生成一个随机数1-100，用户键盘录入猜数字 * 如果猜对了，打印“恭喜您，答对了” * 如果猜错了 * 猜大了：打印“sorry，您猜大了!” * 猜小了：打印“sorry，您猜小了!” 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” * B: 案例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 猜数字小游戏 完成猜数字小游戏： 1、产生随机数 后台预先生成一个随机数1-100，用户键盘录入猜数字 2、通过if语句对用户猜的数与随机数进行比较 如果猜对了，打印“恭喜您，答对了” 如果猜错了 猜大了：打印“sorry，您猜大了!” 猜小了：打印“sorry，您猜小了!” 3、通过for循环完成用户猜数的循环 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!”*/import java.util.Random;import java.util.Scanner;//通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。//import java.util.*;public class GuessNumber&#123; public static void main(String[] args) &#123; //1、产生随机数 //后台预先生成一个随机数1-100，用户键盘录入猜数字 //创建随机数对象 Random random = new Random(); //产生一个1-100的随机数 int randomNumber = random.nextInt(100)+1; //System.out.println("我产生的随机数是："+randomNumber+"你猜猜是多少？"); 作弊专用 //产生控制台录入的Scanner对象 Scanner sc = new Scanner(System.in); //3、通过for循环完成用户猜数的循环 //通过for循环完成猜数字逻辑 for(int i=1; i&lt;=5; i++)&#123; //提示用户输入要猜的数，用变量接收 System.out.println(); System.out.println("请您输入一个1-100的数："); int guessNumber = sc.nextInt(); //2、通过if语句对用户猜的数与随机数进行比较 //如果猜对了 if(guessNumber==randomNumber) &#123; //打印猜对后的提示 System.out.println("恭喜您，猜对了！"); //跳出循环，不用再猜了 break; &#125;else &#123;//如果猜错了 //如果猜大了 if(guessNumber&gt;randomNumber) &#123; System.out.println("sorry，您猜大了!"); &#125;else &#123;//如果猜小了 System.out.println("sorry，您猜小了!"); &#125; &#125; //如果猜到了最后的第5次仍然没有猜对就跳出循环 if(i==5) &#123; System.out.println("对不起，点太背，下次再来吧！"); break; &#125; //每次猜错后，都提示还有多少次机会 System.out.println("请注意，您还有"+(5-i)+"次机会，请慎重作答！"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS环境配置踩坑经历]]></title>
    <url>%2F2016%2F10%2F03%2FAS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[遇到的bugUnable to resolve dependency for &apos;:app@debug/compileClasspath&apos; 这是由于配置文件的依赖是通过Google下载的，然而该下载被墙了！[解决办法]： 在整个工程的build.gradle中添加以下框内代码：1234maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;maven &#123; url 'http://repo1.maven.org/maven2' &#125; app下的build.gradle配置如下:buildToolsVersion 需要和你的sdk安装目录 ~\sdk\build-tools文件里面已有的版本对应123456789101112131415161718android &#123; compileSdkVersion 26 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.example.administrator.myapplication" minSdkVersion 19 targetSdkVersion 22 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; implementation ‘com.android.support:appcompat-v7:26.+’ 中v7:26.+表示使用的sdk版本123456789101112dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.+' implementation 'com.android.support.constraint:constraint-layout:1.0.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:0.4' androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'// androidTestImplementation 'com.android.support.test:runner:1.0.1'// androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'&#125; 若配置后还没解决问题，依然报错打开 C:/Users/(用户名)/.gradle/gradle.properties把http代理的配置注释掉，例如： ## For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. # Default value: -Xmx1024m -XX:MaxPermSize=256m # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 # # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true #Sat Sep 29 23:37:12 CST 2018 #systemProp.http.proxyHost=mirrors.neusoft.edu.cn #systemProp.https.proxyPort=80 #systemProp.https.proxyHost=mirrors.neusoft.edu.cn #systemProp.http.proxyPort=80 More info: 参考该问题的csdn博客]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础1(变量，运算符)]]></title>
    <url>%2F2016%2F10%2F02%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1、变量2、运算符 第一个Java程序Java代码Java程序是大小写敏感的 对格式没有严格要求，但用空格或Tab键缩进会比较好看 Hello.java12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println("Hello, world!");&#125;&#125; 文件名必须是Hello.java，文件名也要注意大小写，必须与程序的类名完全一致，扩展名是.java。 编译切换到Hello.java所在目录：1javac Hello.java 无任何输出表示成功，可查看编译出的Hello.class文件。 执行1java Hello 代码格式：public 和 static 是修饰符static表示静态方法 12345678910public class 类名 &#123; public static void 方法名(参数) &#123; //单行注释 你的程序代码; /* 多行注释 */&#125;&#125;//class定义结束 变量变量概述A: 什么是变量? 12a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。 计算机存储单元A: 计算机中储存和运算的最小单位是?123456789a: 一个字节,也就是一个byte. win+r--cmd--回车 b: 常用储存单位 *1B（字节） = 8bit *1KB = 1024B *1MB = 1024KB *1GB = 1024MB *1TB = 1024GB *1PB = 1024TB Java中数据类型四类八种 A: 数据类型四类八种123456789*四类 八种 字节数 数据表示范围*整型 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483648 long 8 -263～263-1*浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308*字符型 char 2 表示一个字符，如('a'，'A'，'0'，'家')*布尔型 boolean 1 只有两个值true与false 常量和数据类型 A:常量的定义1234* a: 整形常量默认是int类型* b: 小数常量默认是double类型* c: 定义长整形数据如果值超过int取值范围后面要+"L"* d: 定义float类型的数据后面要+"f" 否则默认是double 变量创建的三要素A: 定义变量的语法格式：1234567891011121314数据类型 变量名 = 变量值;* int a = 100; * B:代码:public class Variable &#123; public static void main(String[] args) &#123; int a = 10; double b = 3.14; char c = 'z'; String s = "i love java"; a = 20; System.out.println(a); &#125;&#125; 定义所有的基本数据类型变量 A: 案例演示 a: 八种基本类型数据的创建 定义字符串变量 A：案例演示 创建字符串数据类型变量 String 是引用数据类型变量定义使用注意事项 A：变量使用的注意事项12345678910111213141516* a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。 public static void main(String[] args) &#123; int x; x = 20; //为x赋值20 System.out.println(x);//读取x变量中的值，再打印 &#125; * c: 变量使用时有作用域的限制。 public static void main(String[] args) &#123; int x = 20; &#123; int y = 20; &#125; System.out.println(x);//读取x变量中的值，再打印 System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量 &#125; 数据类型转换_自动转换 A:  自动类型转换12345678* a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换 自动类型转换格式： 范围大的数据类型 变量 = 范围小的数据类型值； 如： double d = 1000; 或 int i = 100; double d2 = i; 数据类型转换_强制转换 A: 强制类型转换12345678*a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换*b: 强制类型转换格式：范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值;如：int i = (int)6.718; //i的值为6或double d = 3.14;int i2 = (int)d; //i2的值为3 运算符算数运算符_1 A: 常见操作 1234567891011运算符 运算规则 范例 结果+ 正号 +3 3+ 加 2+3 5+ 连接字符串 “中”+“国” “中国”- 负号 int a=3;-a -3- 减 3-1 2* 乘 2*3 6/ 除 5/2 2% 取模 5/2 1++ 自增 int a=1;a++/++a 2-- 自减 int b=3;a--/--a 2 B: 注意事项 12345*a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。*b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。 *c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。*d:整数做被除数，0不能做除数，否则报错。*e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN C:代码演示 1234567891011121314151617181920public class OperatorDemo1 &#123; public static void main(String[] args) &#123; /* * 常量使用算数运算符 */ System.out.println(10+20); /* * 变量使用算数运算符 */ int x = 10; int y = 20; //"+"作为加法运算使用 int z = x + y; //"+"作为连接字符串使用 System.out.println("x="+x); System.out.println("y="+y); System.out.println("z="+z);&#125;&#125; 算数运算符_2 算数运算符++、–* A:算数运算符++、--的使用 * a: ++运算符，会在原有值的基础上自增1 * b: --运算符，会在原有值的基础上自减1。 * B:++ -- 位置的使用 * a:++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1； * b:++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。 赋值运算符 A: 赋值运算符的使用 1234567运算符 运算规则 范例 结果= 赋值 int a=2 2+= 加后赋值 int a=2，a+=2 4-= 减后赋值 int a=2，a-=2 0*= 乘后赋值 int a=2，a*=2 4/= 整除后赋值 int a=2，a/=2 1%= 取模后赋值 int a=2，a%=2 0 B：案例演示 123456789101112 * 赋值运算符 * +=, -=, *=, /=, %= ： * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的 * 注意：赋值运算符左边必须是变量public class OperatorDemo2 &#123; public static void main(String[] args) &#123; byte x = 10; x += 20;// 相当于 x = (byte)(x+20); System.out.println(x); &#125;&#125; 比较运算符 A:比较运算符的使用 1234567运算符 运算规则 范例 结果== 相等于 4==3 False!= 不等于 4!=3 True&lt; 小于 4&lt;3 False&gt; 大于 4&gt;3 True&lt;= 小于等于 4&lt;=3 False&gt;= 大于等于 4&gt;=3 True 逻辑运算符A: 逻辑运算符的使用 123456789101112运算符 运算规则 范例 结果&amp; 与 false&amp;true False| 或 false|true True^ 异或 true^flase True! 非 !true Flase&amp;&amp; 短路与 false&amp;&amp;true False|| 短路或 false||true True规律小结: 短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false； 短路或||:参与运算的两边数据，有true，则运算结果为true； 逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。 三元运算符A: 格式: (条件表达式)？表达式1：表达式2； B: 代码案例 方式一： System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印 方式二： int a = 3; int b = 4; String result = (a==b) ? “相等” : “不相等”; //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result 方式三： int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200; //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n 运算符优先级1234567891011121314151617优先级 描述 运算符1 括号 ()、[]2 正负号 +、-3 自增自减，非 ++、--、!4 乘除，取余 *、/、%5 加减 +、-6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;7 大小关系 &gt;、&gt;=、&lt;、&lt;=8 相等关系 ==、!=9 按位与 &amp;10 按位异或 ^11 按位或 |12 逻辑与 &amp;&amp;13 逻辑或 ||14 条件运算 ?:15 赋值运算 =、+=、-=、*=、/=、%=16 位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 商场库存清单案例A: 案例分析. a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部） b:清单顶部为固定的数据，直接打印即可 c:清单中部为商品，为变化的数据，需要记录商品信息后，打印经过观察，我们确定一项商品应该有如下几个属性：品牌型号: 即商品名称，String型尺寸：物品大小，double型价格：物品单价，double型配置：这一项为每种商品的配置信息，String型库存数：这一项为每种商品的库存个数，int型 d:清单底部包含了统计操作，需经过计算后，打印我们发现两个单独的可变化量总库存数：所有商品总个数，int型库存商品总金额：所有商品金额，double型 B: 案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142//步骤一: 创建Demo01库存清单.java文件，编写main主方法public class Demo01库存清单 &#123; public static void main(String[] args) &#123; &#125;&#125;//步骤二: 记录每种库存商品信息//苹果笔记本电脑String macBrand = "MacBookAir";double macSize = 13.3;double macPrice = 6988.88;int macCount = 5;//联想Thinkpad笔记本电脑String thinkpadBrand = "ThinkpadT450";double thinkpadSize = 14.0;double thinkpadPrice = 5999.99;int thinkpadCount = 10;//华硕ASUS笔记本电脑String ASUSBrand = "ASUS-FL5800";double ASUSSize = 15.6;double ASUSPrice = 4999.50;int ASUSCount = 18;//步骤三: 统计库存总个数、库存总金额int totalCount = macCount + thinkpadCount + ASUSCount;double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);//步骤四: 列表顶部System.out.println("------------------------------商城库存清单-----------------------------");System.out.println("品牌型号 尺寸 价格 库存数");步骤四:打印库存清单中部信息//列表中部System.out.println(macBrand+" "+macSize+" "+macPrice+" "+macCount);System.out.println(thinkpadBrand+" "+thinkpadSize+" "+thinkpadPrice+" "+thinkpadCount);System.out.println(ASUSBrand+" "+ASUSSize+" "+ASUSPrice+" "ASUSCount);打印库存清单底部信息//列表底部System.out.println("-----------------------------------------------------------------------");System.out.println("总库存数："+totalCount); System.out.println("库存商品总金额："+totalMoney);]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
