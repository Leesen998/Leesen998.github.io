<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[只是单纯地发个图片 hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 hexo deploy Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>first test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础8]]></title>
    <url>%2F2016%2F10%2F11%2Fday10%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、继承2、抽象类3、综合案例—员工类系列定义 01继承的概述*A:继承的概念 *a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系 *b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类， 构建出来的新类被称作子类，现有类被称作父类 *B:继承关系的子类特点 *a:子类会自动拥有父类所有非private修饰的属性和方法 02继承的定义格式和使用*A:继承的格式 class 子类 extends 父类 {} *B:雇员(Employee)与研发部员工(Developer)案例: *cn.itcast.demo01包下: *Employee.java: /* * 定义员工类Employee */ class Employee { String name; // 定义name属性 public void work() {// 定义员工的工作方法 System.out.println(&quot;尽心尽力地工作&quot;); } } *Developer.java: /* * 定义研发部员工类Developer 继承 员工类Employee * 继承了父类中所有非private修饰的成员变量 */ class Developer extends Employee { // 定义一个打印name的方法 public void printName() { System.out.println(&quot;name=&quot; + name); } } *测试员工类与研发部员工类: /* * 定义测试类 */ public class Example01 { public static void main(String[] args) { Developer d = new Developer(); // 创建一个研发部员工类对象 d.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值 d.printName(); // 调用该员工的printName()方法 d.work(); // 调用Developer类继承来的work()方法 } } *通过子类对象既可以调用自身的非private修饰的成员,也可以调用父类的非private修饰的成员 03继承的好处*A:继承的好处： *1、继承的出现提高了代码的复用性，提高软件开发效率。 *2、继承的出现让类与类之间产生了关系，提供了多态的前提。 04继承的注意事项 *A:继承的注意事项 *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。 class A{} class B{} class C extends A,B{} // C类不可以同时继承A类和B类 假如支持多继承例如: class A{ int a=3; public void method(){ } } class B{ int a=5; public void method(){ } } class C extends A,B{ } class Demo{ public static void main(String[] args){ C c=new C(); System.out.println(c.a);//到底是调用A的还是B的成员变量??无法确定 c.method();//到底是调用A的还是B的成员方法??无法确定 } }  *b:多个类可以继承一个父类，例如下面这种情况是允许的(就像你爹可以多个儿子,但是这些儿子都只有一个爹) class A{} class B extends A{} class C extends A{} // 类B和类C都可以继承类A  *c:在Java中，多层继承是可以的， 即一个类的父类可以再去继承另外的父类， 例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。 class A{} class B extends A{} // 类B继承类A，类B是类A的子类 class C extends B{} // 类C继承类B，类C是类B的子类，同时也是类A的子类  *d:在Java中，子类和父类是一种相对概念， 也就是说一个类是某个类父类的同时，也可以是另一个类的子类。 例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。 05继承的体系 *A:继承的体系: 动物(吃) | ------------------------- | | 猫科动物(吃,胎生) 爬行动物(吃,卵生) | | ------------------------------- ----------------- | | | | 猫(吃,抓老鼠,胎生) 虎(吃,领地,胎生) 蛇(吃,冬眠,卵生) 鳄鱼(吃,潜水,卵生) *a:动物体系是对每个具体事物共性的抽取,子类的共性抽取形成父类 *b:父类:具有所有子类的共性内容 子类:不但有共性还有自身特有的内容 *c:整个继承体系,越向上越抽象,越向下越具体 06继承后子类父类成员变量的特点A:继承后子类父类成员变量的特点 a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu{ //Fu中的成员变量。 int num = 5; } class Zi extends Fu{ //Zi中的成员变量 int num2 = 6; //Zi中的成员方法 public void show() { //访问父类中的num System.out.println(&quot;Fu num=&quot;+num); //访问子类中的num2 System.out.println(&quot;Zi num2=&quot;+num2); } } class Demo{ public static void main(String[] args) { Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 } } b:当子父类中出现了同名成员变量 class Fu{ //Fu中的成员变量。 int num = 5; } class Zi extends Fu{ //Zi中的成员变量 int num = 6; void show(){ //子类的局部变量 int num=7 //直接访问,遵循就近查找原则 System.out.println(num);//7 //子父类中出现了同名的成员变量时 //在子类中需要访问父类中非私有成员变量时，需要使用super关键字 //访问父类中的num System.out.println(&quot;Fu num=&quot;+super.num);//5 //访问子类中的num2 System.out.println(&quot;Zi num2=&quot;+this.num);//6 } } class Demo5 { public static void main(String[] args) { Zi z = new Zi(); //创建子类对象 z.show(); //调用子类中的show方法 } } 07继承后子类父类成员方法的特性_子类重写父类方法A:继承后子类父类成员方法的特性 a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类 class Fu{ public void show(){ System.out.println(&quot;Fu类中的show方法执行&quot;); } } class Zi extends Fu{ public void show2(){ System.out.println(&quot;Zi类中的show2方法执行&quot;); } } public class Test{ public static void main(String[] args) { Zi z = new Zi(); z.show(); //子类中没有show方法，但是可以找到父类方法去执行 z.show2(); } } b:为什么要有重写? class Fu{ public void method(){ //上千行代码 //Fu类中的方法最先存在,那么如果项目需求变了,该方法 //功能不能够满足我们的需求,此时我们也不会去改这个方法 //因为项目中可能有大量的功能已经使用到该方法,如果随意修改可能使调用该方法的功能出现问题 //所以使用重写方式基于原有功能提供更强的功能 } } class Zi extends Fu{ } c:子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖 class Fu{ public void show(){ System.out.println(&quot;Fu show&quot;); } } class Zi extends Fu{ //子类复写了父类的show方法 public void show(){ System.out.println(&quot;Zi show&quot;); } } public class Test{ public static void main(String[] args) { Zi z = new Zi(); z.show(); //Zi show 子类有直接使用子类 } } 08方法覆盖的需求A:方法覆盖的需求 a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能， 后期由于手机需要在来电显示功能中增加显示姓名和头像， 这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。 并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能 b:分析:我们不改装(破坏)原来的手机,而是再买一个新的智能手机,不但有原有的功能,而且还有特有功能 例:厂商发布新手机都是基于原有手机的升级,不会拿着原有的手机在卖,新产一款 1:分析类的构建: 手机类 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码 智能手机类: 属性(成员变量):无 行为(成员方法): 发短信 打电话 来电显示:显示来电号码,显示姓名和头像 手机类和智能手机类有共性内容: 发短信 打电话 显示来电号码 2:继承关系分析: 对于发短信和打电话功能,让智能手机直接沿用(继承)手机的就可以 但是在智能手机中的来电显示不但实现号码,还显示姓名和头像,同样的都是来电显示功能,智能手机的来电显示比手机的功能更加强大,我们考虑使用重写 09方法覆盖的手机案例实现//手机类 class Phone{ public void sendMessage(){ System.out.println(&quot;发短信&quot;); } public void call(){ System.out.println(&quot;打电话&quot;); } public void showNum(){ System.out.println(&quot;来电显示号码&quot;); } } //智能手机类 class NewPhone extends Phone{ //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能 //从现实生活角度考虑沿用原有的showNum方法名便于用户更快熟悉和接受,而不是再起个新的名字 //用户还需要花费大量时间慢慢接受 public void showNum(){ //调用父类已经存在的功能使用super //如果不加super这是调用子类自身的showNum(),自己调用自己,递归 //方法不断入栈导致内存溢出 super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println(&quot;显示来电姓名&quot;); System.out.println(&quot;显示头像&quot;); } } public class Test { public static void main(String[] args) { new NewPhone().showNum();//来电显示 显示来电姓名 显示头像 } } 10方法覆盖的注意事项 A:方法覆盖的注意事项 a:权限:子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 四大权限:public&gt;默认=protected&gt;private class Fu{ void show(){ } public void method(){ } } class Zi() extends Fu{ public void show(){//编译运行没问题 } void method(){//编译错误 } } b:方法定义:子类方法和要重写的父类的方法:方法的方法名和参数列表都要一样。 关于方法的返回值: 如果是基本数据类型,子类的方法和重写的父类的方法返回值类型必须相同 如果是引用数据类型,子类的方法和重写的父类的方法返回值类型可以相同或者子类方法的返回值类型是父类方法返回值类型的子类 class Fu{ int show(){ } public Fu method(){ } public Fu method2(){ } } class Zi() extends Fu{ public int show(){//返回值为基本类型的重写 } public Fu method(){//子类的方法和重写的父类的方法返回值类型可以相同 } public Zi method2(){//子类方法的返回值类型是父类方法返回值类型的子类 } } c:重载与重写对比: 重载: 权限修饰符(public private 默认):无关 方法名:重载的两个方法的方法名必须相同 形参列表: 形参类型的顺序不同 形参的个数不同 形参的类型不同 三者至少满足一个 返回值类型: 重载与返回值类型无关 重写: 权限修饰符(public private 默认): 子类方法的权限&gt;=父类的方法的权限 方法名: 子类方法和父类方法必须相同 形参列表: 子类方法和父类方法的形参列表必须相同 返回值类型: 基本类数据类型: 必须相同 引用数据类型: 子类方法的返回值类型和父类方法的返回值类型相同 或者 子类方法的返回值类型是父类方法的返回值类型的 子类 11抽象类的产生A:抽象类的产生 a:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。 12抽象类的定义格式A:抽象方法定义的格式： a:public abstract 返回值类型 方法名(参数); 抽象类定义的格式： abstract class 类名 { } b:抽象类示例代码： /* * 定义类开发工程师类 * EE开发工程师 : 工作 * Android开发工程师 : 工作 * * 根据共性进行抽取,然后形成一个父类Develop * 定义方法,工作: 怎么工作,具体干什么呀 * * 抽象类,不能实例化对象, 不能new的 * 不能创建对象的原因: 如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行 * 抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象 */ public abstract class Develop { //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白 //就不说, 方法没有主体的方法,必须使用关键字abstract修饰 //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰 public abstract void work(); } 13抽象类的使用方式A:抽象类的使用方式 /* * 定义类,JavaEE的开发人员 * 继承抽象类Develop,重写抽象的方法 */ public class JavaEE extends Develop{ //重写父类的抽象方法 //去掉abstract修饰符,加上方法主体 public void work(){ System.out.println(&quot;JavaEE工程师在开发B/S 软件&quot;); } } /* * 定义Android类,继承开发人员类 * 重写抽象方法 */ public class Android extends Develop{ public void work(){ System.out.println(&quot;Android工程师开发手机软件&quot;); } } /* * 测试抽象类 * 创建他的子类的对象,使用子类的对象调用方法 */ public class Test { public static void main(String[] args) { JavaEE ee = new JavaEE(); ee.work();//&quot;JavaEE工程师在开发B/S 软件&quot; Android and = new Android(); and.work();//&quot;Android工程师开发手机软件&quot; } } 14抽象类特点 A:抽象类的特点 a:抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。 b:抽象类不可以直接创建对象，原因：调用抽象方法没有意义。 c:只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。 之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。 abstract class A{ public abstract void func(); public abstract void func2(); } class A2 extends A{//A2把A中的两个抽象方法都重写掉了 //A2类不再是抽象类 public void func(){} public void func2(){} } abstract class A3 extends A{//含有抽象方法的类一定是抽象类 public void func(){ } //public abstract void func2();//func2相当于被继承下来 } 15抽象类的设计思想 4:40A:抽象类的设计思想 a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法 抽象员工: 规定一个方法,work工作 EE员工,Android员工 Develop类 抽象类 abstract work(); | ------------- | | EE Android //是我开发的一员必须工作 work(){} work(){} 16抽象类的细节 A:抽象类的细节 a:抽象类一定是个父类？ 是的，因为不断抽取而来的。 b:抽象类中是否可以不定义抽象方法? 是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用 (适配器设计模式) /* * 抽象类,可以没有抽象方法,可以定义带有方法体的方法 * 让子类继承后,可以直接使用 */ public abstract class Animal { public void sleep(){ System.out.println(&quot;动物睡觉&quot;); } } public class Cat extends Animal{ } public class Test { public static void main(String[] args) { //Cat c = new Cat(); new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用 } } c:抽象关键字abstract不可以和哪些关键字共存？  1:private：私有的方法子类是无法继承到的，也不存在覆盖， 而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法, 而private修饰子类根本无法得到父类这个方法。互相矛盾。 /* * 抽象类,可以没有抽象方法,可以定义带有方法体的方法 * 让子类继承后,可以直接使用 */ public abstract class Animal { // private abstract void show(); //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写 }  2:final，暂时不关注，后面学 3:static，暂时不关注，后面学 17员工案例分析A:员工案例分析: a:需求描述: 某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。 研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师； 维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。 公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。  工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 b:继承体系: 员工 | -------------------------------------------- | | 研发部员工 维护部员工 | | | | | |JavaEE工程师 Android工程师 网络维护工程师 硬件维护工程师 c:详细描述: 根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。 则，把这些共同的属性与功能抽取到父类中（员工类）， 关于工作的内容由具体的工程师来进行指定。 工作内容  JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站  Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件  网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通  硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机 创建JavaEE工程师对象，完成工作方法的调用 ###18员工案例Employee类的编写 A:员工案例Employee类的编写:按照分析的继承体系来逐个实现 /* * 定义员工类 * 内容,都是所有子类的共性抽取 * 属性: 姓名,工号 * 方法: 工作 */ public abstract class Employee { private String id;// 员工编号 private String name; // 员工姓名 public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } //工作方法（抽象方法） public abstract void work(); } ###19员工案例的子类的编写 B:员工案例的子类的编写: /* * 定义研发员工类 * 属于员工中的一种, 继承员工类 * 抽象类Develop 给自己的员工定义自己有的属性 */ public abstract class Develop extends Employee{ } /* * 描述JavaEE开发工程师类 * 工号,姓名 工作方法 * 其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了 * 是研发部员工的一种,继承研发部类 */ public class JavaEE extends Develop{ //重写他父类的父类的抽象方法 public void work(){ //调用父类的get方法,获取name,id值 System.out.println(&quot;JavaEE的工程师开发淘宝&quot;+ super.getName()+&quot;..&quot;+super.getId()); } } /* *定义Android工程师 继承 研发部员工类，重写工作方法 */ public class Android extends Developer { @Override public void work() { System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;); } } /* * 定义维护员工类,属于员工中的一种 * 继承员工类 * 抽象类Maintainer 给自己的员工定义自己有的属性 */ public abstract class Maintainer extends Employee{ } /* * 描述的是网络维护工程师 * 属于维护部的员工,继承维护部类 */ public class Network extends Maintainer{ public void work(){ System.out.println(&quot;网络工程师在检查网络是否畅通&quot;+super.getName()+&quot;...&quot;+super.getId()); } }  / 定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 */ public class Hardware extends Maintainer { @Override public void work() { System.out.println(“员工号为 “ + getId() + “ 的 “ + getName() + “ 员工，正在修复打印机”); } } ###20总结 把今天的知识点总结一遍。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础7]]></title>
    <url>%2F2016%2F10%2F10%2Fday09%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、面向对象思想2、类与对象的关系3、局部变量和成员变量的关系4、封装思想5、private,this关键字6、随机点名器 面向对象思想面向对象和面向过程的思想* A: 面向过程与面向对象都是我们编程中，编写程序的一种思维方式 * a: 面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。 * b: 面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。 面向对象的思想的生活案例* A: 买电脑（组装机） * a: 面向过程：自己该怎么做 * b: 面向对象：找人帮我们做 面向对象好处* A: 面向对象好处 * a: 面向对象思维方式是一种更符合人们思考习惯的思想 * b: 面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。 * c: 面向对象思维方式将复杂的问题简单化。 大象装进冰箱的代码案例* A: 需求：把大象装冰箱里 * a: 面向过程 * 自己打开冰箱门 * 自己将大象装进去 * 自己关闭冰箱门 * b: 面向对象 * 分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具 备如下功能 * 冰箱打开 * 冰箱存储 * 冰箱关闭 * B: 通过伪代码描述大象和冰箱 * 描述大象： class 大象 { } * 描述冰箱 class冰箱 { void 打开(){} void 存储(大象){} void 关闭(){} } * C: 使用对象： * 1、创建冰箱的对象 * 冰箱 bx = new 冰箱(); * 2、调用冰箱的功能 * 对象.功能()； * bx.打开(); * bx.存储(new 大象()); * bx.关闭(); * D：总结： * 1、先按照名词提炼问题领域中的对象 * 2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能 * 3、通过new的方式就可以创建该事物的具体对象 * 4、通过该对象调用它以后的功能。 类与对象的关系定义小汽车类* A: 分析小汽车的属性和功能 * 属性 * 颜色 * 轮胎个数 * 功能 * 运行 * B: 通过伪代码描述小汽车 * 小汽车{ * 颜色 * 轮胎个数 * 运行(){} * } * C：通过JAVA代码描述小汽车 * public class Car { * String color; * int number; * void run() { * System.out.println(color + &quot;:&quot; + number); * } * } 测试汽车类* A: 创见对象的格式 * a: 类名 变量名 = new 类名(); * B: 测试汽车类 public class CarDemo { public static void main(String[] args) { /* 测试：Car类中的run方法。 */ // 1,创建Car的对象。给对象起个名字。 Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。 // 2,通过已有的对象调用该对象的功能。格式：对象.对象成员; // 3,可以该对象的属性赋值。 c.color = &quot;red&quot;; c.number = 4; c.run(); } } 对象的内存图 类和对象的关系* A: 类和对象的关系 * 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体 * B: 举例 * 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系 局部变量和成员变量的关系成员变量和局部变量的区别 区别一：定义的位置不同 定义在【类】中的变量是【成员变量】 定义在【方法】中或者{}语句里面的变量是【局部变量】 区别二：在内存中的位置不同 【成员变量】存储在【堆内存】的对象中 【局部变量】存储在【栈内存】的方法中（局部变量跟随方法进栈） 区别三：声明周期不同 成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失 局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失 区别四：初始化不同 【成员变量】因为在堆内存中，【所有默认的初始化值】 【局部变量】【没有默认】的初始化值，必须手动的给其赋值才可以使用。 封装思想01方法参数是基本数据类型和引用数据类型* A.基本类型 class Demo { public static void main(String[] args) { int x = 4; show(x); System.out.println(&quot;x=&quot;+x); } public static void show(int x) { x = 5; } } 基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。 * B.引用类型 class Demo { int x ; public static void main(String[] args) { Demo d = new Demo(); d.x = 5; show(d); System.out.println(&quot;x=&quot;+d.x); } public static void show(Demo d) { d.x = 6; } } 当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。 由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。 * C.结论 * 对于基本类型形式参数改变不会影响到实际参数 * 对于引用类型形式参数改变会影响到实际参数 02封装的概述* A.面向对象三大特征 * 封装、继承、多态 * B.封装表现 * 1、方法就是一个最基本封装体 * 2、类其实也是一个封装体 * C.封装的好处 * 1、提高了代码的复用性 * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念 * 3、提高了安全性 03封装的生活中的举例* A.封装的生活中的举例 机箱： 一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。 总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。 * B.总结 * 机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式 private,this关键字private关键字* A.private概述 * private可以修饰成员内容包括成员方法和成员变量 * 被private修饰的内容不能在其他类访问 * B.使用步骤 * 1、通过private修饰属性 * C.完整代码 class Person { private int age; private String name; public void show() { System.out.println(&quot;age=&quot; + age + &quot;,name&quot; + name); } } get和set方法* A.get和set方法 * 年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。 一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。 class Person { // 私有成员变量 private int age; private String name; // 对外提供设置成员变量的方法 public void setAge(int a) { // 由于是设置成员变量的值，这里可以加入数据的验证 if (a &lt; 0 || a &gt; 130) { System.out.println(a + &quot;不符合年龄的数据范围&quot;); return; } age = a; } // 对外提供访问成员变量的方法 public void getAge() { return age; } } * 总结 * 类中不需要对外提供的内容都私有化，包括属性和方法。 以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问 * 注意 * 私有仅仅是封装的体现形式而已 私有化Person类带get,set* 标准代码 package cn.itcast.demo05; /* * 类描述人: * 属性: 姓名和年龄 * 方法: 说话 * * 私有化所有的属性 (成员变量) ,必须写对应的get/set方法 * 凡是自定义的类,自定义成员变量,应该私有化,提供get/set * * this关键字: * 区分成员变量和局部变量同名情况 * 方法中,方位成员变量,写this. */ public class Person { private String name; private int age; // set方法,变量name,age赋值 public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; } // get方法,变量name,age获取值 public int getAge() { return age; } public String getName() { return name; } public void speak() { String name = &quot;哈哈&quot;; int age = 16; System.out.println(&quot;人在说话 &quot; + this.name + &quot;...&quot; + this.age); } } * 标准测试代码 package cn.itcast.demo05; public class PersonTest { public static void main(String[] args) { Person p = new Person(); //调用set方法,对成员变量赋值 p.setAge(18); p.setName(&quot;旺财&quot;); p.speak(); //调用get方法,获取成员变量的值 // System.out.println(p.getName()); // System.out.println(p.getAge()); } } this关键字_区分成员变量和局部变量的同名* A.什么时候用 * 当类中存在成员变量和局部变量同名的时候为了区分，就需要使用this关键字 * B.代码 class Person { private int age; private String name; public void speak() { this.name = &quot;小强&quot;; this.age = 18; System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age); } } class PersonDemo { public static void main(String[] args) { Person p = new Person(); p.speak(); } } this内存图* A.this内存图 this的年龄比较* A.需求：在Person类中定义功能，判断两个人是否是同龄人 * B.代码 class Person { private int age; private String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void speak() { System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age); } // 判断是否为同龄人 public boolean equalsAge(Person p) { // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较 // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替 /* * if(this.age == p.age) { return true; } return false; */ return this.age == p.age; } } 随机点名器随机点名器案例重构* A.需求：随机点名器，即在全班同学中随机的找出一名同学，打印这名同学的个人信息 它具备以下3个内容： 存储所有同学姓名 总览全班同学姓名 随机点名其中一人，打印到控制台 * B.代码 import java.util.ArrayList; import java.util.Random; import java.util.Scanner; /** * 思路： * 第一步：存储全班同学信息 * 第二步：打印全班同学每一个人的信息 * 第三部：随机对学生点名，打印学生信息 */ public class Test { public static void main(String[] args) { ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //1.1创建一个可以存储多个同学名字的容器 //1.存储全班同学信息 addStudent(list); //2.打印全班同学每一个人的信息（姓名、年龄） printStudent(list); //3.随机对学生点名，打印学生信息 randomStudent(list); } public static void addStudent(ArrayList&lt;Student&gt; list) { //键盘输入多个同学名字存储到容器中 Scanner sc = new Scanner(System.in); for (int i = 0; i &lt; 3; i++) { //创建学生 Student s = new Student(); System.out.println(&quot;存储第&quot;+i+&quot;个学生姓名：&quot;); String name = sc.next(); s.setName(name); System.out.println(&quot;存储第&quot;+i+&quot;个学生年龄：&quot;); int age = sc.nextInt(); s.setAge(age); //添加学生到集合 list.add(s); } } /** 2.打印全班同学每一个人的信息（姓名、年龄） */ public static void printStudent (ArrayList&lt;Student&gt; list) { for (int i = 0; i &lt; list.size(); i++) { Student s = list.get(i); System.out.println(&quot;姓名：&quot;+s.getName() +&quot;,年龄：&quot;+s.getAge()); } } /** 3.随机对学生点名，打印学生信息 */ public static void randomStudent (ArrayList&lt;Student&gt; list) { //在班级总人数范围内，随机产生一个随机数 int index = new Random().nextInt(list.size()); //在容器（ArrayList集合）中，查找该随机数所对应的同学信息（姓名、年龄） Student s = list.get(index); System.out.println(&quot;被随机点名的同学：&quot;+s.getName() + &quot;，年龄:&quot; + s.getAge()); } } /** * 学生信息类 */ public class Student { private String name; // 姓名 private int age; // 年龄 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 总结123456789101112131415161718192021222324252627282930313233343536* A.类与对象 * 类，用于描述多个对象的共同特征，它是对象的模板。 * 对象，用于描述现实中的个体，它是类的实例。 * 类的定义：使用关键字class来定义java中的类 * 格式： * class 类名 &#123; * //属性 * 数据类型 变量名; * … * //方法 * 修饰符 返回值类型 方法名(参数)&#123; &#125; * … * &#125; * * B.创建对象： * 格式： * 类名 对象名 = new 类名();* C.封装（private关键字） * 封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式 * 封装的体现： * 变量:使用 private 修饰，这就是变量的封装 * 方法:也是一种封装，封装了多条代码 * 类： 也是一种封装，封装了多个方法* D.private关键字，私有的意思 * 它可以用来修饰类中的成员(成员变量，成员方法) * private的特点： * private修饰的成员只能在当前类中访问，其他类中无法直接访问* E.this关键字 * this关键字，本类对象的引用 * this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用 * this什么时候存在的？当创建对象的时候，this存在的 * this的作用：用来区别同名的成员变量与局部变量（this.成员变量） * public void setName(String name) &#123; * this.name = name; * &#125;]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础6]]></title>
    <url>%2F2016%2F10%2F09%2Fday06%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、自定义类型的定义及使用2、自定义类的内存图3、ArrayList集合的基本功能4、随机点名器案例及库存案例代码优化 01引用数据类型_类* A: 数据类型 * a: java中的数据类型分为：基本类型和引用类型 * B: 引用类型的分类 * a: Java为我们提供好的类，比如说：Scanner,Random等。 * b: 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 02自定义类的概述* A: 自定义类的概述 * java代码映射成现实事物的过程就是定义类的过程。 * 举例： 我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性 * 目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。 03自定义类的格式* A: 自定义类的格式 * a: 使用类的形式,对现实中的事物进行描述。 * b: 事物由方法和属性两部分组成。 * 方法: 这个事物具备的功能。 * 属性: 这个事物具备的特征。 * c: 格式 public class 类名{ 属性定义 修饰符 数据类型 变量名 = 值 方法定义 修饰符 返回值类型 方法名(参数列表){ } } 04自定义的手机类* A: 自定义的手机类 * a: 案例代码 public class Phone{ /* 定义手机的属性 */ String color ; String brand ; double size ; } 05测试手机类导包：我们将所有的类放到同一个文件夹下，可以避免导包。 创建对象：数据类型 变量名 = new 数据类型(); 调用方法：目前我们定义的自定义类不涉及方法，只是属性（自定义类中的方法部分在面向对象部分讲解）访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。) * A: 调用方法执行流程 * a: 实现引用类型的步骤 * 1: 导入包 , 类都是在同一个文件夹,不需要导入包 * 2: 创建引用类型的变量 * 3: 变量.类型中的功能 * b: 案例代码 public class TestPhone{ public static void main(String[] args){ // 2: 创建引用类型的变量 Phone p = new Phone(); //System.out.println(p); //输出内存的地址 //3: 变量.类型中的功能 //变量 p.的方式,调用类中的属性 //属性就是变量 , 赋值和获取值 p.color = &quot;土豪金&quot;; p.brand = &quot;爱立信&quot;; p.size = 5.0; //获取属性值 System.out.println(p.color+&quot; &quot;+p.brand+&quot; &quot;+p.size); } } 06自定义类的内存图_1* A: 自定义类的内存图_1 07自定义类的内存图_2* A: 自定义类的内存图_1 08两个引用类型变量内存图* A: 自定义类的内存图_1 09自定义类的练习* A: 实体类的代码 /* 电饭锅，包含属性（品牌、容量大小、颜色等） 定义类,描述事物,电饭锅 属性: 品牌,大小 ,颜色 定义类,类名字,电饭锅 类的范围,定义三个属性 */ public class DianFanGuo{ //定义三个属性 String brand ; double size ; String color ; } /* 汽车，包含属性（品牌、排量、类型等） 定义类,类名 Car 属性 品牌 排量 类型 */ public class Car{ //定义汽车三个属性 String brand ; double paiLiang ; String type; } /* 学生，包含属性（姓名，年龄，性别等） 定义类,类名Student 三个属性: 姓名,年龄,性别 (char) */ public class Student{ String name; int age ; char sex ; } * B: 测试类的代码 /* 定义的测试类 同时测试,电饭锅,汽车,学生 */ public class Test{ public static void main(String[] args){ //创建电饭锅引用类型 DianFanGuo dfg = new DianFanGuo(); dfg.brand = &quot;特斯拉&quot;; dfg.color = &quot;红色&quot;; dfg.size = 30; System.out.println(dfg.brand+&quot; &quot;+dfg.color+&quot; &quot;+dfg.size); //创建汽车引用类型 Car c = new Car(); c.brand = &quot;巨力&quot;; c.type = &quot;拖拉机&quot;; c.paiLiang = 0.5; System.out.println(c.brand+&quot; &quot;+c.type+&quot; &quot;+c.paiLiang); //创建学生引用类型 Student stu = new Student(); stu.name = &quot;张三&quot;; stu.age = 20; stu.sex = &apos;男&apos;; System.out.println(stu.name+&quot; &quot;+stu.age+&quot; &quot;+stu.sex); } } 10ArrayList创建变量的步骤为了保存这些数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。在这里，我们先介绍ArrayList集合.导包：import java.util.ArrayList; 创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型： 1ArrayList&lt;要存储元素的数据类型&gt; 变量名 = new ArrayList&lt;要存储元素的数据类型&gt;(); * A: ArrayList创建变量的步骤 * a: 导入包 java.util包中 * b: 创建引用类型的变量 数据类型&lt; 集合存储的数据类型&gt; 变量名 = new 数据类型&lt;集合存储的数据类型&gt;(); 集合存储的数据类型: 要将数据存储到集合的容器中 创建集合引用变量的时候,必须要指定好,存储的类型是什么 * c: 变量名.方法 注意: 集合存储的数据,8个基本类型对应8个引用类型 存储引用类型,不存储基本类型 “&lt;要存储元素的数据类型&gt;”中的数据类型必须是【引用数据类型】，不能是基本数据类型；下面给出8种基本数据类型所对应的引用数据类型表示形式: 基本数据类型 对应的引用数据类型表示形式 12345678byte Byteshort ShortInt Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 11ArrayList创建变量举例* A: ArrayList创建变量的示例代码 import java.util.ArrayList; public class ArrayListDemo{ public static void main(String[] args){ //创建集合容器,指定存储的数据类型 //存储字符串 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //创建集合容器,存储整数 ArrayList&lt;Integer&gt; array2 = new ArrayList&lt;Integer&gt;(); //创建集合容器,存储手机类型 ArrayList&lt;Phone&gt; array3 = new ArrayList&lt;Phone&gt;(); } } 12ArrayList的常见方法* A: ArrayList的常见方法 * a: add(参数) 向集合中添加元素 * b: get(int index) 取出集合中的元素,get方法的参数,写入索引 * c: size() 返回集合的长度, 集合存储元素的个数 * B: 案例代码 import java.util.ArrayList; public class ArrayListDemo_1{ public static void main(String[] args){ //定义集合,存储字符串元素 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); //调用集合方法add存储元素 array.add(&quot;abc&quot;); array.add(&quot;itcast&quot;); array.add(&quot;love&quot;); array.add(&quot;java&quot;); //输出集合的长度,调用集合方法size, size方法的返回值类型 int int size = array.size(); System.out.println(size); //获取出集合中的一个元素,获取1索引的元素 //集合的方法get, 获取元素后结果数据类型 String s = array.get(1); System.out.println(s); System.out.println(array.get(0)); System.out.println(array.get(1)); System.out.println(array.get(2)); System.out.println(array.get(3)); } } 13ArrayList集合的遍历* A: 案例代码 /* 集合的遍历 实现思想也是索引思想 集合的索引从0开始,到 size()-1 方法get(int index) */ import java.util.ArrayList; public class ArrayListDemo_2{ public static void main(String[] args){ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(121); array.add(125); array.add(123); array.add(120); array.add(128); //对集合进行遍历 //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++){ System.out.println( array.get(i) ); } } } 14ArrayList补充方法* A: ArrayList补充方法 * a: add(int 索引,存储的元素) 将元素添加到指定的索引上 * b: set(int 索引,修改后的元素) 将指定索引的元素,进行修改 * c: remove(int 索引) 删除指定索引上的元素 * d: clear() 清空集合中的所有元素 * B: 案例代码 import java.util.ArrayList; public class ArrayListDemo_3{ public static void main(String[] args){ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(1); array.add(2); array.add(3); array.add(4); //在索引2上,添加元素7 array.add(2,7); //将0索引上的元素,修改成10 array.set(0,10); //将4索引上的元素,删除 array.remove(4); array.clear(); //使用方法 size+get组合进行遍历 for(int i = 0 ; i &lt; array.size(); i++){ System.out.println( array.get(i) ); } } } 15随机点名器案例分析* A: 随机点名器案例分析 全班同学中随机的找出一名同学，打印这名同学的个人信息。 我们对本案例进行分析，得出如下分析结果： 1.存储全班同学信息（姓名、年龄） 将容器换成集合，集合中存的是Student类型 2.打印全班同学每一个人的信息（姓名、年龄） 遍历集合 3.在班级总人数范围内，随机产生一个随机数，查找该随机数所对应的同学信息（姓名、年龄） 随机点名器明确地分为了三个功能。如果将多个独立功能的代码写到一起，则代码相对冗长，我们可以针对不同的功能可以将其封装到一个方法中，将完整独立的功能分离出来。 而在存储同学姓名时，如果对每一个同学都定义一个变量进行姓名存储，则会出现过多孤立的变量，很难一次性将全部数据持有。此时，我们采用ArrayList集合来解决多个学生信息的存储问题 16随机点名器代码实现* A: 随机点名器案例代码 /* 随机点名器,集合改进 (学生的姓名和年龄) 现实中有学生这个事物,使用定义类的形式,描述学生事物 属性: 姓名,年龄 姓名存储了数组, 将容器换成是集合 String[] s = {&quot;&quot;,&quot;&quot;}; 集合中,存储的是学生的姓名吗? 应该存储Student类型 存储学生: 学生类型,存储到集合中 总览: 遍历集合 随机: 随机数,作为索引,到集合中找到元素 三个功能,共享的数据,集合容器, 定义三个方法,必须参数传递集合 */ import java.util.ArrayList; import java.util.Random; public class CallName{ public static void main(String[] args){ //定义集合,存储的是StudentName类型变量 ArrayList &lt;StudentName&gt; array = new ArrayList&lt;StudentName&gt;(); //调用添加方法 add (array); //调用遍历集合 printArrayList(array); randomStudentName(array); } /* 随机数,当作集合的索引,到集合中找到元素 */ public static void randomStudentName(ArrayList&lt;StudentName&gt; array ){ Random r = new Random(); int number = r.nextInt( array.size()); //随机数,索引,到集合中get StudentName s = array.get(number); System.out.println( s.name +&quot; &quot;+s.age); } /* 总览学生的信息,遍历集合 */ public static void printArrayList(ArrayList&lt;StudentName&gt; array){ for(int i = 0 ; i &lt; array.size();i++){ //存储集合的时候, 集合.add(sn1) sn1 是StudentName类型变量 //获取的时候,集合.get方法,获取出来的是什么, 还是StudentName类型变量 StudentName s = array.get(i); System.out.println(s.name+&quot; &quot;+s.age); } } /* 定义方法,实现存储学生的姓名和年龄 创建StudentName类型变量,存储到集合中 */ public static void add (ArrayList&lt;StudentName&gt; array){ //创建StudentName类型变量 StudentName sn1 = new StudentName(); StudentName sn2 = new StudentName(); StudentName sn3 = new StudentName(); StudentName sn4 = new StudentName(); StudentName sn5 = new StudentName(); sn1.name = &quot;张三1&quot;; sn1.age = 201; sn2.name = &quot;张三2&quot;; sn2.age = 202; sn3.name = &quot;张三3&quot;; sn3.age = 203; sn4.name = &quot;张三4&quot;; sn4.age = 204; sn5.name = &quot;张三5&quot;; sn5.age = 205; //将StudentName变量,存储到集合中 array.add(sn1); array.add(sn2); array.add(sn3); array.add(sn4); array.add(sn5); } } 17库存案例分析加入集合* A: 库存案例分析加入集合 * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG 18库存案例添加商品信息* A: 案例代码 /* 定义,.描述商品的类 商品 4个属性 商品名字 大小 价格 库存 String double double int 定义类,类名Goods 这个类型的变量,存储到集合中 */ public class Goods{ //定义商品名字 String brand ; //大小属性 double size ; // 价格属性 double price ; //库存属性 int count ; } /* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 */ //import java.util.ArrayList; import java.util.*; public class Shopp{ public static void main(String[] args){ //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); } /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array){ //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = &quot;MacBook&quot;; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = &quot;Thinkpad&quot;; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); } } 19库存案例查看库存清单* A: 案例代码 /* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额 */ //import java.util.ArrayList; import java.util.*; public class Shopp{ public static void main(String[] args){ //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); } /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array){ //输出表头 System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++){ //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+&quot; &quot;+g.size+&quot; &quot;+g.price+&quot; &quot;+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array){ //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = &quot;MacBook&quot;; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = &quot;Thinkpad&quot;; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); } } 20库存案例修改库存清单及测试代码的实现* A: 案例代码 /* 实现库存管理案例: 1.存储商品信息 存储商品类型变量 将商品类型的变量,存储到集合中 2.查看库存清单 将集合进行遍历, 获取出集合中存储的Goods类型变量 输出每一个Goods类型的属性 计算求和: 总库存,总金额 3.修改商品的库存 集合遍历 ,获取出集合中存储的Goods类型变量 变量调用Goods类的属性count,值进行修改 (键盘输入) */ //import java.util.ArrayList; import java.util.*; public class Shopp{ public static void main(String[] args){ //创建ArrayList集合,存储Goods类型 ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;(); //调用添加商品信息的方法 addGoods(array); //进入死循环中 while(true){ //调用选择功能的方法,获取到用户输入的功能序号 int number = chooseFunction(); //对序号判断,如果=1 进入查看库存功能 = 2 进入修改库存功能 =3 结束 switch(number){ case 1: //进入查看库存,调用查看库存的方法,传递存储商品信息的集合 printStore(array); break; case 2: //进入修改库存功能,调用修改库存的方法,传递集合 update(array); break; case 3: return ; default: System.out.println(&quot;无此功能&quot;); break; } } } /* 方法定义,修改库存 键盘的输入,将Goods中的属性值,修改 */ public static void update(ArrayList&lt;Goods&gt; array){ Scanner sc = new Scanner(System.in); //遍历集合,获取集合中的每个元素 for(int i = 0 ; i &lt; array.size(); i++){ //集合方法get获取的是集合的元素,元素类型Goods Goods g = array.get(i); System.out.println(&quot;请输入&quot;+g.brand+&quot;的库存数&quot;); //Goods属性,count进行修改 g.count = sc.nextInt(); } } /* 定义方法,实现选择菜单,用户根据功能选择菜单 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); Scanner sc = new Scanner(System.in); int number = sc.nextInt(); return number; } /* 定义方法,查看库存清单,遍历集合 */ public static void printStore(ArrayList&lt;Goods&gt; array){ //输出表头 System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,保存总库存数,和总金额 int totalCount = 0 ; double totalMoney = 0; //遍历集合 for(int i = 0 ; i &lt; array.size(); i++){ //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型 //使用Goods类型变量,接受get方法结果 Goods g = array.get(i); System.out.println(g.brand+&quot; &quot;+g.size+&quot; &quot;+g.price+&quot; &quot;+g.count); totalCount = totalCount+g.count; totalMoney = totalMoney + g.count*g.price; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,将商品的信息存储到集合中 集合是所有方法的共享数据,参数传递 */ public static void addGoods (ArrayList&lt;Goods&gt; array){ //创建商品类型变量 Goods类型的变量 Goods g1 = new Goods(); Goods g2 = new Goods(); g1.brand = &quot;MacBook&quot;; g1.size = 13.3; g1.price = 9999.99; g1.count = 3; g2.brand = &quot;Thinkpad&quot;; g2.size = 15.6; g2.price = 7999.99; g2.count = 1; //Goods类型的变量,存储到集合中 array.add(g1); array.add(g2); } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础5]]></title>
    <url>%2F2016%2F10%2F08%2Fday05%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、方法基础知识2、方法高级内容3、方法案例 01方法的概述* A: 为什么要有方法 * 提高代码的复用性 * B: 什么是方法 * 完成特定功能的代码块。 02方法的定义格式* A: 方法的格式 * 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } * B: 方法的格式说明 * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 * 返回值类型：就是功能结果的数据类型。 * 方法名：符合命名规则即可。方便我们的调用。 * 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 * 参数类型：就是参数的数据类型 * 参数名：就是变量名 * 方法体语句：就是完成功能的代码。 * return：结束方法的。 * 返回值：就是功能的结果，由return带给调用者。 03定义方法计算面积* A: 定义方法计算面积 public class MethodDemo{ public static void main(String[] args){ //调用方法, 方法执行起来 // 在方法main中,调用方法 getArea int area = getArea(5,6); System.out.println(&quot;面积是: &quot;+area); } /* 要求: 计算一个长方形的面积 定义方法解决这个要求 分析方法定义过程: 1.明确方法计算后的结果的数据类型 int 定义格式对应的就是返回值类型 2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int 未知数的变量,定义在方法的小括号内 */ public static int getArea(int w, int h){ //实现方法的功能主体 //int area = w * h; return w * h; } } 04调用方法* A: 调用方法 * a: 在main函数中调用方法，让方法执行起来 * b: 方法的形参 * 方法要什么参数我们就给什么类型的参数。 * c: 方法的返回值 * 方法返回什么类型的值我们就用对应的数据类型的变量来接收 05调用方法执行流程* A: 调用方法执行流程 * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。 * b: 方法的执行，是把实参传递给形参，从而来执行的。 * c: 方法只有被调用才会执行。 06方法调用的内存图 A: 方法调用的内存图 07方法调用的练习* A: 案例代码 /* 方法的定义练习 */ import java.util.Scanner; public class MethodDemo_1{ public static void main(String[] args){ //printRect(); //int number = getNumber(); //System.out.println(getNumber()); //printRect2(3,5); double avg = getAvg(2,2,3); System.out.println(avg); } /* 定义有返回值有参数方法，如求三个数的平均值 明确方法计算后的数据类型, 返回值类型 double 明确方法未知数, 三个未知的整数 */ public static double getAvg(double a, double b,double c){ return (a+b+c)/3; } /* 定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形 明确方法计算后结果,控制台输出图形,没有返回值的 方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int */ public static void printRect2(int m,int n){ for(int i = 0 ; i &lt; m ; i++){ for(int j = 0 ; j &lt; n ; j++){ System.out.print(&quot;*&quot;); } System.out.println(); } } /* 定义有返回值无参数方法，如键盘录入得到一个整数 明确方法计算后结果的数据类型 int 明确有没有未知数,没 */ public static int getNumber(){ Scanner sc = new Scanner(System.in); //int number = sc.nextInt(); return sc.nextInt(); } /* 定义无返回值无参数方法，如打印3行，每行3个*号的矩形 为什么没有返回值: 打印矩形 ,输出效果,不需要将结果返回 明确未知数: 不需要未知数 */ public static void printRect(){ for(int i = 0 ; i &lt; 3 ; i++){ for(int j = 0 ; j &lt; 3 ;j++){ System.out.print(&quot;*&quot;); } System.out.println(); } } } 08方法的定义和使用的注意事项* A: 方法的定义和使用的注意事项 * a: 方法不能定义在另一个方法的里面 * b: 写错方法名字 * c: 写错了参数列表 * d: 方法返回值是void,方法中可以省略return 不写 return 下面不能有代码 * e 方法返回值类型,和return 后面数据类型必须匹配 * f: 方法重复定义问题 * g: 调用方法的时候,返回值是void, 不能写在输出语句中 09方法的重载* A: 方法的重载 * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 * 参数列表不同： * A:参数个数不同 * B:参数类型不同 * C:参数的顺序不同(算重载,但是在开发中不用) * B: 案例代码 public static int getSum(int a,int b){ System.out.println(&quot;两个int参数&quot;); return a+b; } public static int getSum(int a,int b,int c){ System.out.println(&quot;三个int参数&quot;); return a+b+c; } public static double getSum(double a,double b){ System.out.println(&quot;两个double参数&quot;); return a+b; } 10方法重载注意事项* A: 方法重载注意事项 * a: 参数列表必须不同 * b: 重载和参数变量名无关 * c: 重载和返回值类型无关 * d: 重载和修饰符无关 * e: 技巧: 重载看方法名和参数列表 11方法参数是基本数据类型* A: 方法参数是基本数据类型 * a: 方法参数是基本类型时，传递的是值。 * 12方法参数是引用数据类型* A: 方法参数是引用数据类型 * a: 方法参数是引用类型时，传递的是内存地址值。 13随机点名器* A: 案例代码 /* 实现随机点名器 1.存储所有学生姓名 2.预览所有学生姓名,遍历数组 3.随机数作为索引,到数组中找元素 将功能独立出来, 作成方法,调用方法即可 定义三个功能, 用到同一个姓名数据 姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数 */ import java.util.Random; public class CallName{ public static void main(String[] args){ //定义数组,存储学生姓名 String[] names = new String[8]; //调用添加姓名方法 addStudent(names); //调用遍历数组方法 printStudentName(names); //调用随机姓名的方法 String name = randomStudentName(names); System.out.println(name); } /* 定义方法,随机数,做索引,数组中找到学生姓名 返回值? 学生姓名 参数? 数组 */ public static String randomStudentName(String[] names){ Random ran = new Random(); int index = ran.nextInt(names.length); return names[index]; } /* 定义方法,遍历数组 返回值? 没有 参数? 数组 */ public static void printStudentName(String[] names){ for(int i = 0 ; i &lt; names.length ;i++){ System.out.println(names[i]); } } /* 定义方法,实现向数组中添加学生姓名 返回值? 没有, 参数? 参数就是数组 */ public static void addStudent(String[] names){ names[0] = &quot;张三&quot;; names[1] = &quot;李四&quot;; names[2] = &quot;王五&quot;; names[3] = &quot;李蕾&quot;; names[4] = &quot;韩梅梅&quot;; names[5] = &quot;小名&quot;; names[6] = &quot;老王&quot;; names[7] = &quot;小华&quot;; } } 14库存案例代码实现_1* A: 案例代码 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } } 15库存案例代码实现_2* A: 案例代码 /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } 16库存案例代码测试* A: 案例 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ //使用数组,保存商品的信息 //品名,尺寸,价格,库存数, 定义5个数组 String[] brand = {&quot;MacBookAir&quot;,&quot;ThinkpadT450&quot;}; double[] size = {13.3,15.6}; double[] price = {9998.97,6789.56}; int[] count = {0,0}; while(true){ int choose = chooseFunction(); switch(choose){ case 1: //调用查看库存清单方法 printStore(brand,size,price,count); break; case 2: //调用修改库存的方法 update(brand,count); break; case 3: return ; default: System.out.println(&quot;没有这个功能&quot;); break; } } } /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础4]]></title>
    <url>%2F2016%2F10%2F04%2Fday04%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、流程控制语句switch2、数组3、随机点名器案例 01switch语句解构* A:switch语句解构 * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。 * b:格式如下: swtich(表达式){ case 常量1 : 要执行的语句; break; case 常量2 : 要执行的语句; break; case 常量3 : 要执行的语句; break; default: 要执行的语句; break; } * c: 执行流程: 表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束 * d: 关键字: switch case default break * e:举例 如果等于1，则输出星期一 如果等于2，则输出星期二 如果等于3，则输出星期三 如果等于4，则输出星期四 如果等于5，则输出星期五 如果等于6，则输出星期六 如果等于7，则输出星期天 02switch语句的星期判断* A: switch语句的星期判断 * a: 明确需求 需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期. * b: 代码实现 public class SwitchDemo01 { public static void main(String[] args) { int week = 5; switch (week) { case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;输入的数字不正确...&quot;); break; } } } 03switch语句接受的数据类型* A: switch语句接受的数据类型 * a:注意事项 switch语句中的表达式的数据类型,是有要求的 JDK1.0 - 1.4 数据类型接受 byte short int char JDK1.5 数据类型接受 byte short int char enum(枚举) JDK1.7 数据类型接受 byte short int char enum(枚举), String 04case穿透* A:case穿透 * a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。 * b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。 * 注意：case 语句后面 没有break 就会一直穿透下去。 05数组的概述* A: 数组的概述 * a:数组的需求 现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成， 那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦. * b:数组的概述 数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 06数组的定义* A：数组的定义 * b:格式: 数据类型[] 数组名 = new 数据类型[元素个数或数组长度]; * c:举例: int[] x = new int[100]; * c:要点说明 1)数据类型: 数组中存储元素的数据类型 2) [] 表示数组的意思 3) 变量名 自定义标识符 4) new 创建容器关键字 5)数据类型: 数组中存储元素的数据类型 6)[] 表示数组的意思 7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长) 数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号 自动编号,最小值是0, 最大值,长度-1 自动编号专业名次, 索引(index), 下标, 角标 访问数组存储的元素,必须依赖于索引, 公式 数组名[索引] Java提供一个属性,操作索引的 数组的一个属性,就是数组的长度, 属性的名字 length 使用属性: 数组名.length 数据类型 int 数组的最小索引是0, 最大索引数组.length-1 07JVM内存划分* A：内存划分 * JVM对自己的内存划分为5个区域 * a: 寄存器:内存和CUP之间 * b: 本地方法栈: JVM调用了系统中的功能 * c: 方法和数据共享: 运行时期class文件进入的地方 * d: 方法栈:所有的方法运行的时候进入内存 * e: 堆:存储的是容器和对象 08数组的内存* A: 数组的内存 * int[] x; // 声明一个int[]类型的变量 * x = new int[100]; // 创建一个长度为100的数组 * 接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。 * 第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值 * 第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化 * 引用数据类型 存的是变量的地址 09使用索引访问数组的元素* A: 使用索引访问数组的元素 * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。 * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1” 10数组的length属性* A: lenth属性 * a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。 * b 求数组的长度 public class ArrayDemo01 { public static void main(String[] args) { int[] arr; // 声明变量 arr = new int[3]; // 创建数组对象 System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组中的第一个元素 System.out.println(&quot;arr[1]=&quot; + arr[1]); // 访问数组中的第二个元素 System.out.println(&quot;arr[2]=&quot; + arr[2]); // 访问数组中的第三个元素 System.out.println(&quot;数组的长度是：&quot; + arr.length); // 打印数组长度 } } 11为数组的元素赋值* A: 为数组的元素赋值 * a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。 * 赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值 * b: 案例 public class ArrayDemo02 { public static void main(String[] args) { int[] arr = new int[4]; // 定义可以存储4个整数的数组 arr[0] = 1; // 为第1个元素赋值1 arr[1] = 2; // 为第2个元素赋值2 // 下面的代码是打印数组中每个元素的值 System.out.println(&quot;arr[0]=&quot; + arr[0]); System.out.println(&quot;arr[1]=&quot; + arr[1]); System.out.println(&quot;arr[2]=&quot; + arr[2]); System.out.println(&quot;arr[3]=&quot; + arr[3]); } } 12数组的定义_2* A: 定义数组格式2 * a: 数组初始化 动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。 1、类型[] 数组名 = new 类型[长度]; int[] arr = new int[4]; 静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。 2、类型[] 数组名 = new 类型[]{元素，元素，……}; int[] arr = new int[]{1,2,3,4}; 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。 例如： arr = new int[] { 17, 19, 23, 29, 31, 37 }; 3、类型[] 数组名 = {元素，元素，元素，……}; int[] arr = { 1, 2, 3, 4 }; * 数组拷贝 int[] smallPrimes = { 2, 3, 5, 7, 11, 13 }; int[] luckyNumbers = smallPrimes; 如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用 Arrays 类的 copyOf方法： 123int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length) ;//第 2 个参数是新数组的长度。这个方法通常用来增加数组的大小luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 如果数组元素是数值型，那么多余的元素将被赋值为 0 ; 如果数组元素是布尔型， 则将赋值为 false。相反， 如果长度小于原始数组的长度，则只拷贝最前面的数据元素。 13遍历数组* A:遍历数组 * 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历 * B:练习 public class ArrayDemo04 { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组 // 使用for循环遍历数组的元素 for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); // 通过索引访问元素 } } } 上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来 for each 循环 =&gt; 遍历数组for (variable : collection) {statement}例如: for(int element : a) System.out.println(element); 提示：有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串， 这些元素被放置在括号内， 并用逗号分隔， 例如，“ [2, 3, 5,7，11 ，13]”、 要想打印数组， 可以调用System.out.println(Arrays.toString(a)); 14数组中常见的异常* A: 数组操作中,常见的两个异常 数组的索引越界异常 空指针异常 * B: 练习 public class ArrayDemo_4{ public static void main(String[] args){ //数组的索引越界异常 //int[] arr = {5,2,1}; //数组中3个元素,索引 0,1,2 //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3 //空指针异常 int[] arr2 = {1,5,8}; System.out.println(arr2[2]); arr2 = null; // arr2 不在保存数组的地址了 System.out.println(arr2[2]);//java.lang.NullPointerException } } 15数组最值和排序* A: 数组获取最值的原理思想 * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素 * B: 数组排序 * 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法： int[] a = new int[10000]; Arrays.sort(a) 16数组获取最值代码实现* A: 代码实现 public class ArrayDemo05 { public static void main(String[] args) { int[] arr = { 4, 1, 6, 3, 9, 8 }; // 定义一个数组 int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值 // 下面通过一个for循环遍历数组中的元素 for (int x = 1; x &lt; arr.length; x++) { if (arr[x] &gt; max) { // 比较 arr[x]的值是否大于max max = arr[x]; // 条件成立，将arr[x]的值赋给max } } System.out.println(&quot;max=&quot; + max); // 打印最大值 } } 17二维数组的定义* A 二维数组的作用 * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？ * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。 * B 定义格式 * a 第一种定义格式: * int[][] arr = new int[3][4]; * 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组 * b 第二种定义格式 * int[][] arr = new int[3][]; * 第二种方式和第一种类似，只是数组中每个元素的长度不确定 * c 第三种定义格式 * int[][] arr = {{1,2},{3,4,5,6},{7,8,9}}; * 二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9} 18二维数组元素的访问 * A: 二维数组的访问 * 案例: class ArrayDemo08 { public static void main(String[] args){ //定义二维数组的方式 int[][] arr = new int[3][4]; System.out.println( arr ); System.out.println(&quot;二维数组的长度: &quot; + arr.length); //获取二维数组的3个元素 System.out.println( arr[0] ); System.out.println( arr[1] ); System.out.println( arr[2] ); System.out.println(&quot;打印第一个一维数组的元素值&quot;); System.out.println( arr[0][0] ); System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素 System.out.println( arr[0][2] ); System.out.println( arr[0][3] ); System.out.println(&quot;打印第二个一维数组的元素值&quot;); System.out.println( arr[1][0] ); System.out.println( arr[1][1] ); System.out.println( arr[1][2] ); System.out.println( arr[1][3] ); System.out.println(&quot;打印第三个一维数组的元素值&quot;); System.out.println( arr[2][0] ); System.out.println( arr[2][1] ); System.out.println( arr[2][2] ); System.out.println( arr[2][3] ); } } 19二维数组内存图* A: 二维数组内存图 * 举例:int[][] arr = new int[3][2]; * 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值 * 每一个大内存空间里又开辟连续的两个小的内存空间. 20二维数组的定义和访问* A: 二维数组的定义和访问 * 格式1: * int[][] arr = new int[3][]; 不推荐 * 格式2 * int[][] arr = {{1,2,4},{4,7},{0,9,3}}; * * B: 二维数组的访问 举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}}; 想要打印数组中7这个元素需要先找到大的元素索引{5,7} 索引为2 ,在找7在{5,7}中的索引2 那么结果为 arr[2][2] 第一个[2]代表大数组中{5,8,7}这个元素索引 第二个[2]代表{5,8,7}中7元素的索引 21二维数组的遍历* A:二维数组遍历 int[][] arr = {{1,2,4},{4,7},{0,9,3}}; 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素 * B:举例:遍历二维数组 public class ArrayArrayDemo_2{ public static void main(String[] args){ int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} }; //外循环,遍历二维数组 for(int i = 0 ; i &lt; arr.length ;i++){ //内循环,遍历每个一维数组 arr[0] arr[1] arr[i] for(int j = 0 ; j &lt; arr[i].length; j++){ System.out.print(arr[i][j]); } System.out.println(); } } * C:二维数组累加求和 class ArrayDemo09 { public static void main(String[] args){ int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} }; int sum2 = 0; for (int i=0; i&lt;arr2.length; i++) { for (int j=0; j&lt;arr2[i].length; j++) { //System.out.println(arr2[i][j]) sum2 += arr2[i][j]; } } System.out.println(&quot;sum2= &quot;+ sum2); } } for each 循环语句不能自动处理二维数组的每一个元素。它是按照行， 也就是一维数组处理的要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示： 1234for (double [] row : a) for (double value : row) //do something with value System.out.println(value); 提示： 要想快速地打印一个二维数组的数据元素列表， 可以调用：System.out.println(Arrays.deepToString(a)) ;输出格式为：[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]] 22二维数组的求和练习* A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示 * 第一小组销售额为{11, 12}万元 * 第二小组销售额为{21, 22, 23}万元 * 第三小组销售额为{31, 32, 33, 34}万元。 * B 代码实现 public class ArrayDemo10 { public static void main(String[] args) { int[][] arr = new int[3][]; // 定义一个长度为3的二维数组 arr[0] = new int[] { 11, 12 }; // 为数组的元素赋值 arr[1] = new int[] { 21, 22, 23 }; arr[2] = new int[] { 31, 32, 33, 34 }; int sum = 0; // 定义变量记录总销售额 for (int i = 0; i &lt; arr.length; i++) { // 遍历数组元素 int groupSum = 0; // 定义变量记录小组销售总额 for (int j = 0; j &lt; arr[i].length; j++) { // 遍历小组内每个人的销售额 groupSum = groupSum + arr[i][j]; } sum = sum + groupSum; // 累加小组销售额 System.out.println(&quot;第&quot; + (i + 1) + &quot;小组销售额为：&quot; + groupSum + &quot; 万元&quot;); } System.out.println(&quot;总销售额为: &quot; + sum + &quot; 万元&quot;); } } 23随机点名器案例分析* A 随机点名器案例分析 * B: 需求 * 随机点名器，即在全班同学中随机的打印出一名同学名字。 * C:分析: * 1)定义数组存数全班同学 * 2)生成随机数范围0 到 数组长度-1 * 3)根据这个索引找到数组中的同学名称 24随机点名器代码实现* A: 分析 随机点名器: 1 存储姓名 2. 预览所有人的姓名 3. 随机出一个人的姓名 * B 代码实现 import java.util.Random; public class CallName{ public static void main(String[] args){ //存储姓名,姓名存储到数组中 //数组存储姓名,姓名的数据类型,String String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;}; //预览: 遍历数组,打印所有姓名 for(int i = 0 ; i &lt; names.length ; i++){ System.out.println(names[i]); } System.out.println(&quot;=============&quot;); //随机出一个人的名 //利用随机数,生成一个整数,作为索引,到数组中找到对应的元素 Random ran = new Random(); //随机数,范围必须是0-数组的最大索引 int index = ran.nextInt(names.length);//index 就是随机数,作为索引 System.out.println(names[index]); } } 25随机点名器代码实现_2* A 代码优化: import java.util.Random; public class CallName{ public static void main(String[] args){ String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;}; System.out.println(names[new Random().nextInt(names.length)]); } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础3]]></title>
    <url>%2F2016%2F10%2F04%2Fday03%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、引用类型变量的创建及使用2、流程控制语句之选择语句3、流程控制语句之循环语句4、循环高级 01创建引用类型变量公式 A: 创建引用类型变量公式 a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。 b: 引用数据类型的定义格式 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。 数据类型 变量名 = new 数据类型(); c: 引用数据类型的使用 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。 变量名.方法名(); 02Scanner类的使用* A: Scanner类的使用 * a: 导包import java.util.Scanner; * b：创建键盘录入对象 Scanner sc = new Scanner(System.in); * c: 读取键盘录入的一个整数 * int enterNumber = sc.nextInt(); * d: 读取键盘录入的字符串 * String enterString = sc.next(); * B: 案例代码 import java.util.Scanner; public class Demo05Scanner{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); System.out.println(&quot;用户输入的整数为&quot;+enterNumber); String enterString = sc.next(); System.out.println(&quot;用户输入的字符串为&quot;+enterString); } } 03Random随机数类的使用_1* A: Random随机数类的使用_1 * a: 功能 * 生成随机数需要使用到引用类型随机数Random类 * b: 使用方式 * import导包：所属包java.util. Random * 创建实例格式：Random random = new Random (); * 调用方法 * nextInt(int maxValue) 产生[0,maxValue)范围的随机数,包含0不包含maxValue * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextInt(100);//结果为0-99的一个数 * B: 案例代码 import java.util.Random; public class RandomDemo{ public static void main(String[] args){ Random ran = new Random(); // Random类中的,产生随机数的功能 int i = ran.nextInt(100); System.out.println(i); //问题? 产生随机数,范围 1-100之间 // nextInt(100) 0-99 + 1 } } 04Random随机数类的使用_2* A: Random随机数类的使用_2 * a: 调用方法 * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0) 05if语句格式第一种* A: if语句格式第一种 * a: 书写格式 if(比较表达式) { 语句体; } * b：执行流程： * 先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体； * 如果是false，就不执行语句体； * B: 案例代码 public class IfDemo{ public static void main(String[] args){ int i = 5 ; //对变量i进行if判断 if(i &gt; 5){ System.out.println(&quot;if中的条件是true&quot;); i++; } System.out.println(i); } } 06if语句格式第二种* A: if语句格式第二种 * a: 书写格式 if(比较表达式) { 语句体1; }else { 语句体2; } * b：执行流程： * 首先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体1； * 如果是false，就执行语句体2； * B: 案例代码 public class IfElseDemo{ public static void main(String[] args){ int i = 16 ; //判断变量,是奇偶数, 除以2,看余数是0还是1 if( i % 2 == 0 ){ System.out.println(i+&quot; 是偶数&quot;); }else{ System.out.println(i+&quot; 是奇数&quot;); } } } 07if语句格式第三种* A: if语句格式第三种 * a: 书写格式 if(比较表达式1) { 语句体1; }else if(比较表达式2) { 语句体2; }else if(比较表达式3) { 语句体3; } ... else { 语句体n+1; } * b：执行流程： * 首先计算比较表达式1看其返回值是true还是false， * 如果是true，就执行语句体1，if语句结束。 * 如果是false，接着计算比较表达式2看其返回值是true还是false， * 如果是true，就执行语句体2，if语句结束。 * 如果是false，接着计算比较表达式3看其返回值是true还是false， * 如果都是false，就执行语句体n+1。 * B: 案例代码 public class IfElseIfDemo{ public static void main(String[] args){ //成绩判断要求 ,成绩&gt;80 成绩&gt;70 成绩&gt;60 不及格 //定义变量,保存成绩 int grade = 75; //使用if else if 语句对成绩判断 if( grade &gt; 80 ){ System.out.println(grade+&quot; 成绩是优&quot;); }else if ( grade &gt; 70){ System.out.println(grade+&quot; 成绩是良&quot;); }else if ( grade &gt; 60){ System.out.println(grade+&quot; 成绩是中&quot;); }else{ System.out.println(grade+&quot; 成绩是差&quot;); } } } 08if语句和三元运算符的互换* A: 三元运算符 * a: 概念 * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行 * b: 使用格式 * (条件表达式)？表达式1：表达式2； * c: 运算规则 * 1: 判断条件表达式，结果为一个布尔值 * 2: true，运算结果为表达式1 * 3: false，运算结果为表达式2 * B: 案例代码 public class IfElseDemo_1{ public static void main(String[] args){ int j = 6; int i = 15; //使用if语句,判断出最大值 if(i&gt;j){ int j = 6; System.out.println(i+&quot; 是最大值&quot;); }else{ System.out.println(j+&quot; 是最大值&quot;); } //使用三元运算实现 int k = i&gt;j ? i : j; System.out.println(k+&quot; 是最大值&quot;); } } * C: 使用if语句还是三元表达式 * 判断条件多,使用if * 三元,必须有结果的, if 可以没有结果的 09while循环* A: while循环结构 * a: 使用格式 初始化表达式； while(条件){ 循环体 } * b: 执行顺序 当条件是true,就执行循环体,执行完循环体后 程序再次执行while中的条件,如果条件还是true,继续执行循环体 直到条件是false的时候,循环就结束 * B: 案例代码 public class WhileDemo{ public static void main(String[] args){ //输出 1-4之间的整数 //定义变量,整数类型, 循环的条件 int i = 1; while( i &lt; 5 ){ System.out.println(i); i++; } } } 10for循环_1* A: for循环_1 * a: 使用格式 for(初始化变量 ; 条件 ; 增量){ 循环体; } * b: 各模块解释 初始化变量: 定义变量,作用是用来控制循环的次数 条件: 当条件是true,执行循环体,条件是false,结束循环 增量: 变量自增情况 * B: 案例代码 public class ForDemo{ public static void main(String[] args){ //for循环,输出0-10 for(int i = 0 ; i &lt; 11 ; i++){ System.out.println(i); } } } 11for循环_2* A: for循环的执行流程 for（① ; ② ; ③）{ ④ } 第一步，执行① 第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 第三步，执行④ 第四步，执行③，然后重复执行第二步 第五步，退出循环 12for循环_3* A: 案例 * a: 利用for循环,计算1+4的结果 * B: 案例代码 public class ForDemo_1{ public static void main(String[] args){ // 定义变量,记录求和后的数据 int sum = 0; // 利用循环,将变量从1变化到4 for(int i = 1 ; i &lt;= 4 ; i++){ //对变量进行求和 sum = sum + i; } System.out.println(sum); } } 13do_while循环* A: do_while循环 * a: 使用格式 do{ 循环体; }while(条件); * b: 执行顺序 先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体， 如果条件为false，循环结束。 * c: 特点 * 无条件先执行一次 * B: 案例代码 public class DoWhileDemo{ public static void main(String[] args){ int i = 0; do{ System.out.println(i); i++; }while( i &lt; 5); } } 14死循环* A: 死循环概述 * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环 * B: 死循环格式 * while(true){} * for(;;){} 15嵌套for循环_1* A: 嵌套循环的概述 * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环。 * B: 嵌套循环的格式 for(初始化表达式; 循环条件; 操作表达式) { ……… for(初始化表达式; 循环条件; 操作表达式) { 执行语句 ……… } ……… } * C: 各模块解释 * 总的循环次数 = 内循环次数 * 外循环的次数 * 内循环,是外循环的循环体 * 外循环,控制的是行数 * 内循环,控制的是每行的个数 16嵌套for循环_2* A: 案例 * a: 打印正三角形 * B: 案例代码 public class ForForDemo{ public static void main(String[] args){ for(int i = 0 ; i &lt; 9 ; i++){ for(int j = 0; j &lt; i+1 ;j++){ System.out.print(&quot;* &quot;); } System.out.println(); } } } 17break语句* A: break语句 * a: 作用 * 跳出所在的循环体 * b: 书写位置 * 必须出现在循环或选择结构内 * c: 举例 for(int i=0; i&lt;10; i++) { if(i&gt;5) { break; } System.out.println(“我爱Java”+i); } //会从0-5输出6次“我爱Java” * B: break详细解释 * a: 作用 * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中， 可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码， 这些关键字一旦出现就可以跳转语句执行顺序。 * b: 使用方式 * 无法单独使用，必须将break关键字置于switch或循环语句中 * c: 运行规律 * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构 * 只能跳出最近的代码块，不能跨越多级代码块 * C：循环标号 * a: 为什么使用循环标号 * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了. * b: 使用方式 * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。 使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可 * c: 运行规律 * 当外层循环外定义了标号 * 内层使用break，终止内外双层循环。 * 内层使用continue，终止内层循环，继续外层循环。 18continue语句* A: continue语句 * a: 作用 * 提前结束本次循环，继续进行下次循环 * b: 使用方式 * 无法单独使用，必须将continue关键字置于循环语句中 * c：运行规律 * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环 * d：案例代码 public class ContinueDemo{ public static void main(String[] args){ for(int i = 0 ; i &lt; 10 ; i++){ if(i%2==0){ continue; } System.out.println(i); } } } //会把0-9之间所有的奇数打印到控制台上 19猜数字小游戏* A: 猜数字小游戏 * a: 分析 * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现， 但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件 * b: 需求分析 * 后台预先生成一个随机数1-100，用户键盘录入猜数字 * 如果猜对了，打印“恭喜您，答对了” * 如果猜错了 * 猜大了：打印“sorry，您猜大了!” * 猜小了：打印“sorry，您猜小了!” 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” * B: 案例代码 /* 猜数字小游戏 完成猜数字小游戏： 1、产生随机数 后台预先生成一个随机数1-100，用户键盘录入猜数字 2、通过if语句对用户猜的数与随机数进行比较 如果猜对了，打印“恭喜您，答对了” 如果猜错了 猜大了：打印“sorry，您猜大了!” 猜小了：打印“sorry，您猜小了!” 3、通过for循环完成用户猜数的循环 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” */ import java.util.Random; import java.util.Scanner; //通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。 //import java.util.*; public class GuessNumber{ public static void main(String[] args) { //1、产生随机数 //后台预先生成一个随机数1-100，用户键盘录入猜数字 //创建随机数对象 Random random = new Random(); //产生一个1-100的随机数 int randomNumber = random.nextInt(100)+1; //System.out.println(&quot;我产生的随机数是：&quot;+randomNumber+&quot;你猜猜是多少？&quot;); 作弊专用 //产生控制台录入的Scanner对象 Scanner sc = new Scanner(System.in); //3、通过for循环完成用户猜数的循环 //通过for循环完成猜数字逻辑 for(int i=1; i&lt;=5; i++){ //提示用户输入要猜的数，用变量接收 System.out.println(); System.out.println(&quot;请您输入一个1-100的数：&quot;); int guessNumber = sc.nextInt(); //2、通过if语句对用户猜的数与随机数进行比较 //如果猜对了 if(guessNumber==randomNumber) { //打印猜对后的提示 System.out.println(&quot;恭喜您，猜对了！&quot;); //跳出循环，不用再猜了 break; }else {//如果猜错了 //如果猜大了 if(guessNumber&gt;randomNumber) { System.out.println(&quot;sorry，您猜大了!&quot;); }else {//如果猜小了 System.out.println(&quot;sorry，您猜小了!&quot;); } } //如果猜到了最后的第5次仍然没有猜对就跳出循环 if(i==5) { System.out.println(&quot;对不起，点太背，下次再来吧！&quot;); break; } //每次猜错后，都提示还有多少次机会 System.out.println(&quot;请注意，您还有&quot;+(5-i)+&quot;次机会，请慎重作答！&quot;); } } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS环境配置踩坑经历]]></title>
    <url>%2F2016%2F10%2F03%2FAS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[遇到的bugUnable to resolve dependency for &apos;:app@debug/compileClasspath&apos; 这是由于配置文件的依赖是通过Google下载的，然而该下载被墙了！[解决办法]： 在整个工程的build.gradle中添加以下框内代码：1234maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;maven &#123; url 'http://repo1.maven.org/maven2' &#125; app下的build.gradle配置如下:buildToolsVersion 需要和你的sdk安装目录 ~\sdk\build-tools文件里面已有的版本对应123456789101112131415161718android &#123; compileSdkVersion 26 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.example.administrator.myapplication" minSdkVersion 19 targetSdkVersion 22 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; implementation ‘com.android.support:appcompat-v7:26.+’ 中v7:26.+表示使用的sdk版本123456789101112dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.+' implementation 'com.android.support.constraint:constraint-layout:1.0.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:0.4' androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'// androidTestImplementation 'com.android.support.test:runner:1.0.1'// androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'&#125; 若配置后还没解决问题，依然报错打开 C:/Users/(用户名)/.gradle/gradle.properties把http代理的配置注释掉，例如： ## For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. # Default value: -Xmx1024m -XX:MaxPermSize=256m # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 # # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true #Sat Sep 29 23:37:12 CST 2018 #systemProp.http.proxyHost=mirrors.neusoft.edu.cn #systemProp.https.proxyPort=80 #systemProp.https.proxyHost=mirrors.neusoft.edu.cn #systemProp.http.proxyPort=80 More info: 参考该问题的csdn博客]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java入门]]></title>
    <url>%2F2016%2F10%2F02%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[java入门笔记 第一个Java程序Java代码Java程序是大小写敏感的 对格式没有严格要求，但用空格或Tab键缩进会比较好看 Hello.java12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println("Hello, world!");&#125;&#125; 文件名必须是Hello.java，文件名也要注意大小写，必须与程序的类名完全一致，扩展名是.java。 编译切换到Hello.java所在目录：1javac Hello.java 无任何输出表示成功，可查看编译出的Hello.class文件。 执行1java Hello 代码格式：public 和 static 是修饰符static表示静态方法 12345678910public class 类名 &#123; public static void 方法名(参数) &#123; //单行注释 你的程序代码; /* 多行注释 */&#125;&#125;//class定义结束 变量变量概述A: 什么是变量? 12a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。 计算机存储单元A: 计算机中储存和运算的最小单位是?123456789a: 一个字节,也就是一个byte. win+r--cmd--回车 b: 常用储存单位 *1B（字节） = 8bit *1KB = 1024B *1MB = 1024KB *1GB = 1024MB *1TB = 1024GB *1PB = 1024TB Java中数据类型四类八种 A: 数据类型四类八种123456789*四类 八种 字节数 数据表示范围*整型 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483648 long 8 -263～263-1*浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308*字符型 char 2 表示一个字符，如('a'，'A'，'0'，'家')*布尔型 boolean 1 只有两个值true与false 常量和数据类型 A:常量的定义1234* a: 整形常量默认是int类型* b: 小数常量默认是double类型* c: 定义长整形数据如果值超过int取值范围后面要+"L"* d: 定义float类型的数据后面要+"f" 否则默认是double 变量创建的三要素A: 定义变量的语法格式：1234567891011121314数据类型 变量名 = 变量值;* int a = 100; * B:代码:public class Variable &#123; public static void main(String[] args) &#123; int a = 10; double b = 3.14; char c = 'z'; String s = "i love java"; a = 20; System.out.println(a); &#125;&#125; 定义所有的基本数据类型变量 A: 案例演示 a: 八种基本类型数据的创建 定义字符串变量 A：案例演示 创建字符串数据类型变量 String 是引用数据类型变量定义使用注意事项 A：变量使用的注意事项12345678910111213141516* a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。 public static void main(String[] args) &#123; int x; x = 20; //为x赋值20 System.out.println(x);//读取x变量中的值，再打印 &#125; * c: 变量使用时有作用域的限制。 public static void main(String[] args) &#123; int x = 20; &#123; int y = 20; &#125; System.out.println(x);//读取x变量中的值，再打印 System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量 &#125; 数据类型转换_自动转换 A:  自动类型转换12345678* a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换 自动类型转换格式： 范围大的数据类型 变量 = 范围小的数据类型值； 如： double d = 1000; 或 int i = 100; double d2 = i; 数据类型转换_强制转换 A: 强制类型转换12345678*a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换*b: 强制类型转换格式：范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值;如：int i = (int)6.718; //i的值为6或double d = 3.14;int i2 = (int)d; //i2的值为3 运算符算数运算符_1 A: 常见操作 1234567891011运算符 运算规则 范例 结果+ 正号 +3 3+ 加 2+3 5+ 连接字符串 “中”+“国” “中国”- 负号 int a=3;-a -3- 减 3-1 2* 乘 2*3 6/ 除 5/2 2% 取模 5/2 1++ 自增 int a=1;a++/++a 2-- 自减 int b=3;a--/--a 2 B: 注意事项 12345*a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。*b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。 *c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。*d:整数做被除数，0不能做除数，否则报错。*e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN C:代码演示 1234567891011121314151617181920public class OperatorDemo1 &#123; public static void main(String[] args) &#123; /* * 常量使用算数运算符 */ System.out.println(10+20); /* * 变量使用算数运算符 */ int x = 10; int y = 20; //"+"作为加法运算使用 int z = x + y; //"+"作为连接字符串使用 System.out.println("x="+x); System.out.println("y="+y); System.out.println("z="+z);&#125;&#125; 算数运算符_2 算数运算符++、–* A:算数运算符++、--的使用 * a: ++运算符，会在原有值的基础上自增1 * b: --运算符，会在原有值的基础上自减1。 * B:++ -- 位置的使用 * a:++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1； * b:++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。 赋值运算符 A: 赋值运算符的使用 1234567运算符 运算规则 范例 结果= 赋值 int a=2 2+= 加后赋值 int a=2，a+=2 4-= 减后赋值 int a=2，a-=2 0*= 乘后赋值 int a=2，a*=2 4/= 整除后赋值 int a=2，a/=2 1%= 取模后赋值 int a=2，a%=2 0 B：案例演示 123456789101112 * 赋值运算符 * +=, -=, *=, /=, %= ： * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的 * 注意：赋值运算符左边必须是变量public class OperatorDemo2 &#123; public static void main(String[] args) &#123; byte x = 10; x += 20;// 相当于 x = (byte)(x+20); System.out.println(x); &#125;&#125; 比较运算符 A:比较运算符的使用 1234567运算符 运算规则 范例 结果== 相等于 4==3 False!= 不等于 4!=3 True&lt; 小于 4&lt;3 False&gt; 大于 4&gt;3 True&lt;= 小于等于 4&lt;=3 False&gt;= 大于等于 4&gt;=3 True 逻辑运算符A: 逻辑运算符的使用 123456789101112运算符 运算规则 范例 结果&amp; 与 false&amp;true False| 或 false|true True^ 异或 true^flase True! 非 !true Flase&amp;&amp; 短路与 false&amp;&amp;true False|| 短路或 false||true True规律小结: 短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false； 短路或||:参与运算的两边数据，有true，则运算结果为true； 逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。 三元运算符 A: 格式: (条件表达式)？表达式1：表达式2； B: 代码案例 方式一： System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印 方式二： int a = 3; int b = 4; String result = (a==b) ? “相等” : “不相等”; //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result 方式三： int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200; //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n 运算符优先级1234567891011121314151617优先级 描述 运算符1 括号 ()、[]2 正负号 +、-3 自增自减，非 ++、--、!4 乘除，取余 *、/、%5 加减 +、-6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;7 大小关系 &gt;、&gt;=、&lt;、&lt;=8 相等关系 ==、!=9 按位与 &amp;10 按位异或 ^11 按位或 |12 逻辑与 &amp;&amp;13 逻辑或 ||14 条件运算 ?:15 赋值运算 =、+=、-=、*=、/=、%=16 位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 商场库存清单案例A: 案例分析. a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部） b:清单顶部为固定的数据，直接打印即可 c:清单中部为商品，为变化的数据，需要记录商品信息后，打印经过观察，我们确定一项商品应该有如下几个属性：品牌型号: 即商品名称，String型尺寸：物品大小，double型价格：物品单价，double型配置：这一项为每种商品的配置信息，String型库存数：这一项为每种商品的库存个数，int型 d:清单底部包含了统计操作，需经过计算后，打印我们发现两个单独的可变化量总库存数：所有商品总个数，int型库存商品总金额：所有商品金额，double型 B: 案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142//步骤一: 创建Demo01库存清单.java文件，编写main主方法public class Demo01库存清单 &#123; public static void main(String[] args) &#123; &#125;&#125;//步骤二: 记录每种库存商品信息//苹果笔记本电脑String macBrand = "MacBookAir";double macSize = 13.3;double macPrice = 6988.88;int macCount = 5;//联想Thinkpad笔记本电脑String thinkpadBrand = "ThinkpadT450";double thinkpadSize = 14.0;double thinkpadPrice = 5999.99;int thinkpadCount = 10;//华硕ASUS笔记本电脑String ASUSBrand = "ASUS-FL5800";double ASUSSize = 15.6;double ASUSPrice = 4999.50;int ASUSCount = 18;//步骤三: 统计库存总个数、库存总金额int totalCount = macCount + thinkpadCount + ASUSCount;double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);//步骤四: 列表顶部System.out.println("------------------------------商城库存清单-----------------------------");System.out.println("品牌型号 尺寸 价格 库存数");步骤四:打印库存清单中部信息//列表中部System.out.println(macBrand+" "+macSize+" "+macPrice+" "+macCount);System.out.println(thinkpadBrand+" "+thinkpadSize+" "+thinkpadPrice+" "+thinkpadCount);System.out.println(ASUSBrand+" "+ASUSSize+" "+ASUSPrice+" "ASUSCount);打印库存清单底部信息//列表底部System.out.println("-----------------------------------------------------------------------");System.out.println("总库存数："+totalCount); System.out.println("库存商品总金额："+totalMoney);]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
