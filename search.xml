<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2017%2F10%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[只是单纯地发个图片 hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 hexo deploy Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>first test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础5]]></title>
    <url>%2F2016%2F10%2F08%2Fday05%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、方法基础知识2、方法高级内容3、方法案例 01方法的概述* A: 为什么要有方法 * 提高代码的复用性 * B: 什么是方法 * 完成特定功能的代码块。 02方法的定义格式* A: 方法的格式 * 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } * B: 方法的格式说明 * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 * 返回值类型：就是功能结果的数据类型。 * 方法名：符合命名规则即可。方便我们的调用。 * 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 * 参数类型：就是参数的数据类型 * 参数名：就是变量名 * 方法体语句：就是完成功能的代码。 * return：结束方法的。 * 返回值：就是功能的结果，由return带给调用者。 03定义方法计算面积* A: 定义方法计算面积 public class MethodDemo{ public static void main(String[] args){ //调用方法, 方法执行起来 // 在方法main中,调用方法 getArea int area = getArea(5,6); System.out.println(&quot;面积是: &quot;+area); } /* 要求: 计算一个长方形的面积 定义方法解决这个要求 分析方法定义过程: 1.明确方法计算后的结果的数据类型 int 定义格式对应的就是返回值类型 2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int 未知数的变量,定义在方法的小括号内 */ public static int getArea(int w, int h){ //实现方法的功能主体 //int area = w * h; return w * h; } } 04调用方法* A: 调用方法 * a: 在main函数中调用方法，让方法执行起来 * b: 方法的形参 * 方法要什么参数我们就给什么类型的参数。 * c: 方法的返回值 * 方法返回什么类型的值我们就用对应的数据类型的变量来接收 05调用方法执行流程* A: 调用方法执行流程 * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。 * b: 方法的执行，是把实参传递给形参，从而来执行的。 * c: 方法只有被调用才会执行。 06方法调用的内存图* A: 方法调用的内存图 * a: 参见\day05\day05(Java基础语法)\day05_source\方法内存图.JPG 07方法调用的练习* A: 案例代码 /* 方法的定义练习 */ import java.util.Scanner; public class MethodDemo_1{ public static void main(String[] args){ //printRect(); //int number = getNumber(); //System.out.println(getNumber()); //printRect2(3,5); double avg = getAvg(2,2,3); System.out.println(avg); } /* 定义有返回值有参数方法，如求三个数的平均值 明确方法计算后的数据类型, 返回值类型 double 明确方法未知数, 三个未知的整数 */ public static double getAvg(double a, double b,double c){ return (a+b+c)/3; } /* 定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形 明确方法计算后结果,控制台输出图形,没有返回值的 方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int */ public static void printRect2(int m,int n){ for(int i = 0 ; i &lt; m ; i++){ for(int j = 0 ; j &lt; n ; j++){ System.out.print(&quot;*&quot;); } System.out.println(); } } /* 定义有返回值无参数方法，如键盘录入得到一个整数 明确方法计算后结果的数据类型 int 明确有没有未知数,没 */ public static int getNumber(){ Scanner sc = new Scanner(System.in); //int number = sc.nextInt(); return sc.nextInt(); } /* 定义无返回值无参数方法，如打印3行，每行3个*号的矩形 为什么没有返回值: 打印矩形 ,输出效果,不需要将结果返回 明确未知数: 不需要未知数 */ public static void printRect(){ for(int i = 0 ; i &lt; 3 ; i++){ for(int j = 0 ; j &lt; 3 ;j++){ System.out.print(&quot;*&quot;); } System.out.println(); } } } 08方法的定义和使用的注意事项* A: 方法的定义和使用的注意事项 * a: 方法不能定义在另一个方法的里面 * b: 写错方法名字 * c: 写错了参数列表 * d: 方法返回值是void,方法中可以省略return 不写 return 下面不能有代码 * e 方法返回值类型,和return 后面数据类型必须匹配 * f: 方法重复定义问题 * g: 调用方法的时候,返回值是void, 不能写在输出语句中 09方法的重载* A: 方法的重载 * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 * 参数列表不同： * A:参数个数不同 * B:参数类型不同 * C:参数的顺序不同(算重载,但是在开发中不用) * B: 案例代码 public static int getSum(int a,int b){ System.out.println(&quot;两个int参数&quot;); return a+b; } public static int getSum(int a,int b,int c){ System.out.println(&quot;三个int参数&quot;); return a+b+c; } public static double getSum(double a,double b){ System.out.println(&quot;两个double参数&quot;); return a+b; } 10方法重载注意事项* A: 方法重载注意事项 * a: 参数列表必须不同 * b: 重载和参数变量名无关 * c: 重载和返回值类型无关 * d: 重载和修饰符无关 * e: 技巧: 重载看方法名和参数列表 11方法参数是基本数据类型* A: 方法参数是基本数据类型 * a: 方法参数是基本类型时，传递的是值。 12方法参数是引用数据类型* A: 方法参数是引用数据类型 * a: 方法参数是引用类型时，传递的是内存地址值。 13随机点名器* A: 案例代码 /* 实现随机点名器 1.存储所有学生姓名 2.预览所有学生姓名,遍历数组 3.随机数作为索引,到数组中找元素 将功能独立出来, 作成方法,调用方法即可 定义三个功能, 用到同一个姓名数据 姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数 */ import java.util.Random; public class CallName{ public static void main(String[] args){ //定义数组,存储学生姓名 String[] names = new String[8]; //调用添加姓名方法 addStudent(names); //调用遍历数组方法 printStudentName(names); //调用随机姓名的方法 String name = randomStudentName(names); System.out.println(name); } /* 定义方法,随机数,做索引,数组中找到学生姓名 返回值? 学生姓名 参数? 数组 */ public static String randomStudentName(String[] names){ Random ran = new Random(); int index = ran.nextInt(names.length); return names[index]; } /* 定义方法,遍历数组 返回值? 没有 参数? 数组 */ public static void printStudentName(String[] names){ for(int i = 0 ; i &lt; names.length ;i++){ System.out.println(names[i]); } } /* 定义方法,实现向数组中添加学生姓名 返回值? 没有, 参数? 参数就是数组 */ public static void addStudent(String[] names){ names[0] = &quot;张三&quot;; names[1] = &quot;李四&quot;; names[2] = &quot;王五&quot;; names[3] = &quot;李蕾&quot;; names[4] = &quot;韩梅梅&quot;; names[5] = &quot;小名&quot;; names[6] = &quot;老王&quot;; names[7] = &quot;小华&quot;; } } 14库存案例代码实现_1* A: 案例代码 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } } 15库存案例代码实现_2* A: 案例代码 /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } 16库存案例代码测试* A: 案例 /* 实现商品的库存管理 功能: 1.展示用户选择功能清单 2.根据选择的功能编号,进行不同的操作 A. 展示所有库存 B. 修改库存数量 分析: 1.展示用户清单: 输出语句, 用户输入, 选择功能序号 2.根据选择,调用不同的方法 switch语句 case 1 2 3 A 展示库存 将存储商品的数组,遍历 B 修改库存 修改所有的库存数量 */ import java.util.Scanner; public class Shopp{ public static void main(String[] args){ //使用数组,保存商品的信息 //品名,尺寸,价格,库存数, 定义5个数组 String[] brand = {&quot;MacBookAir&quot;,&quot;ThinkpadT450&quot;}; double[] size = {13.3,15.6}; double[] price = {9998.97,6789.56}; int[] count = {0,0}; while(true){ int choose = chooseFunction(); switch(choose){ case 1: //调用查看库存清单方法 printStore(brand,size,price,count); break; case 2: //调用修改库存的方法 update(brand,count); break; case 3: return ; default: System.out.println(&quot;没有这个功能&quot;); break; } } } /* 定义方法,修改所有商品的库存 用户输入1个,修改1个 返回值,没有 参数, 库存数的数组, 品名数组 */ public static void update(String[] brand, int[] count){ //遍历数组,遍历到一个,修改一个 //接受键盘输入 Scanner sc = new Scanner(System.in); //遍历数组 for(int i = 0; i &lt; brand.length ; i++){ System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;); //键盘输入,录入库存, 存储到库存的数组中 int newCount = sc.nextInt(); count[i] = newCount; } //int chooseNumber = sc.nextInt(); } /* 定义方法,展示所有的库存清单,遍历 返回值,没有 参数, 数组 */ public static void printStore(String[] brand,double[] size,double[] price,int[] count){ System.out.println(&quot;----------商场库存清单----------&quot;); System.out.println(&quot;品牌型号 尺寸 价格 库存数&quot;); //定义变量,计算总库存数,和总价格 int totalCount = 0; int totalMoney = 0; //遍历数组,将数组中所有的商品信息打印出来 for(int i = 0 ; i &lt; brand.length ; i++){ System.out.println(brand[i]+&quot; &quot;+size[i]+&quot; &quot;+price[i]+&quot; &quot;+count[i]); totalCount += count[i]; totalMoney += count[i]*price[i]; } System.out.println(&quot;总库存数: &quot;+totalCount); System.out.println(&quot;商品库存总金额: &quot;+totalMoney); } /* 定义方法,实现用户的选择功能,功能的需要返回来 返回值, int 参数, 没有 */ public static int chooseFunction(){ System.out.println(&quot;-------------库存管理------------&quot;); System.out.println(&quot;1.查看库存清单&quot;); System.out.println(&quot;2.修改商品库存数量&quot;); System.out.println(&quot;3.退出&quot;); System.out.println(&quot;请输入要执行的操作序号：&quot;); //接受键盘输入 Scanner sc = new Scanner(System.in); int chooseNumber = sc.nextInt(); return chooseNumber; } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础4]]></title>
    <url>%2F2016%2F10%2F04%2Fday04%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、流程控制语句switch2、数组3、随机点名器案例 01switch语句解构* A:switch语句解构 * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。 * b:格式如下: swtich(表达式){ case 常量1 : 要执行的语句; break; case 常量2 : 要执行的语句; break; case 常量3 : 要执行的语句; break; default: 要执行的语句; break; } * c: 执行流程: 表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束 * d: 关键字: switch case default break * e:举例 如果等于1，则输出星期一 如果等于2，则输出星期二 如果等于3，则输出星期三 如果等于4，则输出星期四 如果等于5，则输出星期五 如果等于6，则输出星期六 如果等于7，则输出星期天 02switch语句的星期判断* A: switch语句的星期判断 * a: 明确需求 需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期. * b: 代码实现 public class SwitchDemo01 { public static void main(String[] args) { int week = 5; switch (week) { case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;输入的数字不正确...&quot;); break; } } } 03switch语句接受的数据类型* A: switch语句接受的数据类型 * a:注意事项 switch语句中的表达式的数据类型,是有要求的 JDK1.0 - 1.4 数据类型接受 byte short int char JDK1.5 数据类型接受 byte short int char enum(枚举) JDK1.7 数据类型接受 byte short int char enum(枚举), String 04case穿透* A:case穿透 * a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。 * b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。 * 注意：case 语句后面 没有break 就会一直穿透下去。 05数组的概述* A: 数组的概述 * a:数组的需求 现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成， 那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦. * b:数组的概述 数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。 06数组的定义* A：数组的定义 * b:格式: 数据类型[] 数组名 = new 数据类型[元素个数或数组长度]; * c:举例: int[] x = new int[100]; * c:要点说明 1)数据类型: 数组中存储元素的数据类型 2) [] 表示数组的意思 3) 变量名 自定义标识符 4) new 创建容器关键字 5)数据类型: 数组中存储元素的数据类型 6)[] 表示数组的意思 7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长) 数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号 自动编号,最小值是0, 最大值,长度-1 自动编号专业名次, 索引(index), 下标, 角标 访问数组存储的元素,必须依赖于索引, 公式 数组名[索引] Java提供一个属性,操作索引的 数组的一个属性,就是数组的长度, 属性的名字 length 使用属性: 数组名.length 数据类型 int 数组的最小索引是0, 最大索引数组.length-1 07JVM内存划分* A：内存划分 * JVM对自己的内存划分为5个区域 * a: 寄存器:内存和CUP之间 * b: 本地方法栈: JVM调用了系统中的功能 * c: 方法和数据共享: 运行时期class文件进入的地方 * d: 方法栈:所有的方法运行的时候进入内存 * e: 堆:存储的是容器和对象 08数组的内存* A: 数组的内存 * int[] x; // 声明一个int[]类型的变量 * x = new int[100]; // 创建一个长度为100的数组 * 接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。 * 第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值 * 第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化 * 引用数据类型 存的是变量的地址 09使用索引访问数组的元素* A: 使用索引访问数组的元素 * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。 * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1” 10数组的length属性* A: lenth属性 * a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。 * b 求数组的长度 public class ArrayDemo01 { public static void main(String[] args) { int[] arr; // 声明变量 arr = new int[3]; // 创建数组对象 System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组中的第一个元素 System.out.println(&quot;arr[1]=&quot; + arr[1]); // 访问数组中的第二个元素 System.out.println(&quot;arr[2]=&quot; + arr[2]); // 访问数组中的第三个元素 System.out.println(&quot;数组的长度是：&quot; + arr.length); // 打印数组长度 } } 11为数组的元素赋值* A: 为数组的元素赋值 * a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。 * 赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值 * b: 案例 public class ArrayDemo02 { public static void main(String[] args) { int[] arr = new int[4]; // 定义可以存储4个整数的数组 arr[0] = 1; // 为第1个元素赋值1 arr[1] = 2; // 为第2个元素赋值2 // 下面的代码是打印数组中每个元素的值 System.out.println(&quot;arr[0]=&quot; + arr[0]); System.out.println(&quot;arr[1]=&quot; + arr[1]); System.out.println(&quot;arr[2]=&quot; + arr[2]); System.out.println(&quot;arr[3]=&quot; + arr[3]); } } 12数组的定义_2* A: 定义数组格式2 * a: 数组初始化 动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。 1、类型[] 数组名 = new 类型[长度]; int[] arr = new int[4]; 静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。 2、类型[] 数组名 = new 类型[]{元素，元素，……}; int[] arr = new int[]{1,2,3,4}; 3、类型[] 数组名 = {元素，元素，元素，……}; int[] arr = { 1, 2, 3, 4 }; 13遍历数组* A:遍历数组 * 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历 * B:练习 public class ArrayDemo04 { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组 // 使用for循环遍历数组的元素 for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); // 通过索引访问元素 } } } 上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来 14数组中常见的异常* A: 数组操作中,常见的两个异常 数组的索引越界异常 空指针异常 * B: 练习 public class ArrayDemo_4{ public static void main(String[] args){ //数组的索引越界异常 //int[] arr = {5,2,1}; //数组中3个元素,索引 0,1,2 //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3 //空指针异常 int[] arr2 = {1,5,8}; System.out.println(arr2[2]); arr2 = null; // arr2 不在保存数组的地址了 System.out.println(arr2[2]);//java.lang.NullPointerException } } 15数组最值* A: 数组获取最值的原理思想 * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素 16数组获取最值代码实现* A: 代码实现 public class ArrayDemo05 { public static void main(String[] args) { int[] arr = { 4, 1, 6, 3, 9, 8 }; // 定义一个数组 int max = arr[0]; // 定义变量max用于记住最大数，首先假设第一个元素为最大值 // 下面通过一个for循环遍历数组中的元素 for (int x = 1; x &lt; arr.length; x++) { if (arr[x] &gt; max) { // 比较 arr[x]的值是否大于max max = arr[x]; // 条件成立，将arr[x]的值赋给max } } System.out.println(&quot;max=&quot; + max); // 打印最大值 } } 17二维数组的定义* A 二维数组的作用 * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？ * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。 * B 定义格式 * a 第一种定义格式: * int[][] arr = new int[3][4]; * 上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组 * b 第二种定义格式 * int[][] arr = new int[3][]; * 第二种方式和第一种类似，只是数组中每个元素的长度不确定 * c 第三种定义格式 * int[][] arr = {{1,2},{3,4,5,6},{7,8,9}}; * 二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9} 18二维数组元素的访问 * A: 二维数组的访问 * 案例: class ArrayDemo08 { public static void main(String[] args){ //定义二维数组的方式 int[][] arr = new int[3][4]; System.out.println( arr ); System.out.println(&quot;二维数组的长度: &quot; + arr.length); //获取二维数组的3个元素 System.out.println( arr[0] ); System.out.println( arr[1] ); System.out.println( arr[2] ); System.out.println(&quot;打印第一个一维数组的元素值&quot;); System.out.println( arr[0][0] ); System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素 System.out.println( arr[0][2] ); System.out.println( arr[0][3] ); System.out.println(&quot;打印第二个一维数组的元素值&quot;); System.out.println( arr[1][0] ); System.out.println( arr[1][1] ); System.out.println( arr[1][2] ); System.out.println( arr[1][3] ); System.out.println(&quot;打印第三个一维数组的元素值&quot;); System.out.println( arr[2][0] ); System.out.println( arr[2][1] ); System.out.println( arr[2][2] ); System.out.println( arr[2][3] ); } } 19二维数组内存图* A: 二维数组内存图 * 举例:int[][] arr = new int[3][2]; * 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值 * 每一个大内存空间里又开辟连续的两个小的内存空间. 20二维数组的定义和访问* A: 二维数组的定义和访问 * 格式1: * int[][] arr = new int[3][]; 不推荐 * 格式2 * int[][] arr = {{1,2,4},{4,7},{0,9,3}}; * * B: 二维数组的访问 举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}}; 想要打印数组中7这个元素需要先找到大的元素索引{5,7} 索引为2 ,在找7在{5,7}中的索引2 那么结果为 arr[2][2] 第一个[2]代表大数组中{5,8,7}这个元素索引 第二个[2]代表{5,8,7}中7元素的索引 21二维数组的遍历* A:二维数组遍历 int[][] arr = {{1,2,4},{4,7},{0,9,3}}; 先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组 再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素 * B:举例:遍历二维数组 public class ArrayArrayDemo_2{ public static void main(String[] args){ int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} }; //外循环,遍历二维数组 for(int i = 0 ; i &lt; arr.length ;i++){ //内循环,遍历每个一维数组 arr[0] arr[1] arr[i] for(int j = 0 ; j &lt; arr[i].length; j++){ System.out.print(arr[i][j]); } System.out.println(); } } * C:二维数组累加求和 class ArrayDemo09 { public static void main(String[] args){ int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} }; int sum2 = 0; for (int i=0; i&lt;arr2.length; i++) { for (int j=0; j&lt;arr2[i].length; j++) { //System.out.println(arr2[i][j]) sum2 += arr2[i][j]; } } System.out.println(&quot;sum2= &quot;+ sum2); } } 22二维数组的求和练习* A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示 * 第一小组销售额为{11, 12}万元 * 第二小组销售额为{21, 22, 23}万元 * 第三小组销售额为{31, 32, 33, 34}万元。 * B 代码实现 public class ArrayDemo10 { public static void main(String[] args) { int[][] arr = new int[3][]; // 定义一个长度为3的二维数组 arr[0] = new int[] { 11, 12 }; // 为数组的元素赋值 arr[1] = new int[] { 21, 22, 23 }; arr[2] = new int[] { 31, 32, 33, 34 }; int sum = 0; // 定义变量记录总销售额 for (int i = 0; i &lt; arr.length; i++) { // 遍历数组元素 int groupSum = 0; // 定义变量记录小组销售总额 for (int j = 0; j &lt; arr[i].length; j++) { // 遍历小组内每个人的销售额 groupSum = groupSum + arr[i][j]; } sum = sum + groupSum; // 累加小组销售额 System.out.println(&quot;第&quot; + (i + 1) + &quot;小组销售额为：&quot; + groupSum + &quot; 万元&quot;); } System.out.println(&quot;总销售额为: &quot; + sum + &quot; 万元&quot;); } } 23随机点名器案例分析* A 随机点名器案例分析 * B: 需求 * 随机点名器，即在全班同学中随机的打印出一名同学名字。 * C:分析: * 1)定义数组存数全班同学 * 2)生成随机数范围0 到 数组长度-1 * 3)根据这个索引找到数组中的同学名称 24随机点名器代码实现* A: 分析 随机点名器: 1 存储姓名 2. 预览所有人的姓名 3. 随机出一个人的姓名 * B 代码实现 import java.util.Random; public class CallName{ public static void main(String[] args){ //存储姓名,姓名存储到数组中 //数组存储姓名,姓名的数据类型,String String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;}; //预览: 遍历数组,打印所有姓名 for(int i = 0 ; i &lt; names.length ; i++){ System.out.println(names[i]); } System.out.println(&quot;=============&quot;); //随机出一个人的名 //利用随机数,生成一个整数,作为索引,到数组中找到对应的元素 Random ran = new Random(); //随机数,范围必须是0-数组的最大索引 int index = ran.nextInt(names.length);//index 就是随机数,作为索引 System.out.println(names[index]); } } 25随机点名器代码实现_2* A 代码优化: import java.util.Random; public class CallName{ public static void main(String[] args){ String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;}; System.out.println(names[new Random().nextInt(names.length)]); } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习笔记——基础3]]></title>
    <url>%2F2016%2F10%2F04%2Fday03%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、引用类型变量的创建及使用2、流程控制语句之选择语句3、流程控制语句之循环语句4、循环高级 01创建引用类型变量公式 A: 创建引用类型变量公式 a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。 b: 引用数据类型的定义格式 与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。 数据类型 变量名 = new 数据类型(); c: 引用数据类型的使用 每种引用数据类型都有其功能，我们可以调用该类型实例的功能。 变量名.方法名(); 02Scanner类的使用* A: Scanner类的使用 * a: 导包import java.util.Scanner; * b：创建键盘录入对象 Scanner sc = new Scanner(System.in); * c: 读取键盘录入的一个整数 * int enterNumber = sc.nextInt(); * d: 读取键盘录入的字符串 * String enterString = sc.next(); * B: 案例代码 import java.util.Scanner; public class Demo05Scanner{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); int enterNumber = sc.nextInt(); System.out.println(&quot;用户输入的整数为&quot;+enterNumber); String enterString = sc.next(); System.out.println(&quot;用户输入的字符串为&quot;+enterString); } } 03Random随机数类的使用_1* A: Random随机数类的使用_1 * a: 功能 * 生成随机数需要使用到引用类型随机数Random类 * b: 使用方式 * import导包：所属包java.util. Random * 创建实例格式：Random random = new Random (); * 调用方法 * nextInt(int maxValue) 产生[0,maxValue)范围的随机数,包含0不包含maxValue * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextInt(100);//结果为0-99的一个数 * B: 案例代码 import java.util.Random; public class RandomDemo{ public static void main(String[] args){ Random ran = new Random(); // Random类中的,产生随机数的功能 int i = ran.nextInt(100); System.out.println(i); //问题? 产生随机数,范围 1-100之间 // nextInt(100) 0-99 + 1 } } 04Random随机数类的使用_2* A: Random随机数类的使用_2 * a: 调用方法 * nextDouble() 产生[0,1)范围的随机数 如： Random random = new Random (); int myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0) 05if语句格式第一种* A: if语句格式第一种 * a: 书写格式 if(比较表达式) { 语句体; } * b：执行流程： * 先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体； * 如果是false，就不执行语句体； * B: 案例代码 public class IfDemo{ public static void main(String[] args){ int i = 5 ; //对变量i进行if判断 if(i &gt; 5){ System.out.println(&quot;if中的条件是true&quot;); i++; } System.out.println(i); } } 06if语句格式第二种* A: if语句格式第二种 * a: 书写格式 if(比较表达式) { 语句体1; }else { 语句体2; } * b：执行流程： * 首先计算比较表达式的值，看其返回值是true还是false。 * 如果是true，就执行语句体1； * 如果是false，就执行语句体2； * B: 案例代码 public class IfElseDemo{ public static void main(String[] args){ int i = 16 ; //判断变量,是奇偶数, 除以2,看余数是0还是1 if( i % 2 == 0 ){ System.out.println(i+&quot; 是偶数&quot;); }else{ System.out.println(i+&quot; 是奇数&quot;); } } } 07if语句格式第三种* A: if语句格式第三种 * a: 书写格式 if(比较表达式1) { 语句体1; }else if(比较表达式2) { 语句体2; }else if(比较表达式3) { 语句体3; } ... else { 语句体n+1; } * b：执行流程： * 首先计算比较表达式1看其返回值是true还是false， * 如果是true，就执行语句体1，if语句结束。 * 如果是false，接着计算比较表达式2看其返回值是true还是false， * 如果是true，就执行语句体2，if语句结束。 * 如果是false，接着计算比较表达式3看其返回值是true还是false， * 如果都是false，就执行语句体n+1。 * B: 案例代码 public class IfElseIfDemo{ public static void main(String[] args){ //成绩判断要求 ,成绩&gt;80 成绩&gt;70 成绩&gt;60 不及格 //定义变量,保存成绩 int grade = 75; //使用if else if 语句对成绩判断 if( grade &gt; 80 ){ System.out.println(grade+&quot; 成绩是优&quot;); }else if ( grade &gt; 70){ System.out.println(grade+&quot; 成绩是良&quot;); }else if ( grade &gt; 60){ System.out.println(grade+&quot; 成绩是中&quot;); }else{ System.out.println(grade+&quot; 成绩是差&quot;); } } } 08if语句和三元运算符的互换* A: 三元运算符 * a: 概念 * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行 * b: 使用格式 * (条件表达式)？表达式1：表达式2； * c: 运算规则 * 1: 判断条件表达式，结果为一个布尔值 * 2: true，运算结果为表达式1 * 3: false，运算结果为表达式2 * B: 案例代码 public class IfElseDemo_1{ public static void main(String[] args){ int j = 6; int i = 15; //使用if语句,判断出最大值 if(i&gt;j){ int j = 6; System.out.println(i+&quot; 是最大值&quot;); }else{ System.out.println(j+&quot; 是最大值&quot;); } //使用三元运算实现 int k = i&gt;j ? i : j; System.out.println(k+&quot; 是最大值&quot;); } } * C: 使用if语句还是三元表达式 * 判断条件多,使用if * 三元,必须有结果的, if 可以没有结果的 09while循环* A: while循环结构 * a: 使用格式 初始化表达式； while(条件){ 循环体 } * b: 执行顺序 当条件是true,就执行循环体,执行完循环体后 程序再次执行while中的条件,如果条件还是true,继续执行循环体 直到条件是false的时候,循环就结束 * B: 案例代码 public class WhileDemo{ public static void main(String[] args){ //输出 1-4之间的整数 //定义变量,整数类型, 循环的条件 int i = 1; while( i &lt; 5 ){ System.out.println(i); i++; } } } 10for循环_1* A: for循环_1 * a: 使用格式 for(初始化变量 ; 条件 ; 增量){ 循环体; } * b: 各模块解释 初始化变量: 定义变量,作用是用来控制循环的次数 条件: 当条件是true,执行循环体,条件是false,结束循环 增量: 变量自增情况 * B: 案例代码 public class ForDemo{ public static void main(String[] args){ //for循环,输出0-10 for(int i = 0 ; i &lt; 11 ; i++){ System.out.println(i); } } } 11for循环_2* A: for循环的执行流程 for（① ; ② ; ③）{ ④ } 第一步，执行① 第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 第三步，执行④ 第四步，执行③，然后重复执行第二步 第五步，退出循环 12for循环_3* A: 案例 * a: 利用for循环,计算1+4的结果 * B: 案例代码 public class ForDemo_1{ public static void main(String[] args){ // 定义变量,记录求和后的数据 int sum = 0; // 利用循环,将变量从1变化到4 for(int i = 1 ; i &lt;= 4 ; i++){ //对变量进行求和 sum = sum + i; } System.out.println(sum); } } 13do_while循环* A: do_while循环 * a: 使用格式 do{ 循环体; }while(条件); * b: 执行顺序 先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体， 如果条件为false，循环结束。 * c: 特点 * 无条件先执行一次 * B: 案例代码 public class DoWhileDemo{ public static void main(String[] args){ int i = 0; do{ System.out.println(i); i++; }while( i &lt; 5); } } 14死循环* A: 死循环概述 * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环 * B: 死循环格式 * while(true){} * for(;;){} 15嵌套for循环_1* A: 嵌套循环的概述 * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环。 * B: 嵌套循环的格式 for(初始化表达式; 循环条件; 操作表达式) { ……… for(初始化表达式; 循环条件; 操作表达式) { 执行语句 ……… } ……… } * C: 各模块解释 * 总的循环次数 = 内循环次数 * 外循环的次数 * 内循环,是外循环的循环体 * 外循环,控制的是行数 * 内循环,控制的是每行的个数 16嵌套for循环_2* A: 案例 * a: 打印正三角形 * B: 案例代码 public class ForForDemo{ public static void main(String[] args){ for(int i = 0 ; i &lt; 9 ; i++){ for(int j = 0; j &lt; i+1 ;j++){ System.out.print(&quot;* &quot;); } System.out.println(); } } } 17break语句* A: break语句 * a: 作用 * 跳出所在的循环体 * b: 书写位置 * 必须出现在循环或选择结构内 * c: 举例 for(int i=0; i&lt;10; i++) { if(i&gt;5) { break; } System.out.println(“我爱Java”+i); } //会从0-5输出6次“我爱Java” * B: break详细解释 * a: 作用 * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中， 可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码， 这些关键字一旦出现就可以跳转语句执行顺序。 * b: 使用方式 * 无法单独使用，必须将break关键字置于switch或循环语句中 * c: 运行规律 * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构 * 只能跳出最近的代码块，不能跨越多级代码块 * C：循环标号 * a: 为什么使用循环标号 * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了. * b: 使用方式 * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。 使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可 * c: 运行规律 * 当外层循环外定义了标号 * 内层使用break，终止内外双层循环。 * 内层使用continue，终止内层循环，继续外层循环。 18continue语句* A: continue语句 * a: 作用 * 提前结束本次循环，继续进行下次循环 * b: 使用方式 * 无法单独使用，必须将continue关键字置于循环语句中 * c：运行规律 * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环 * d：案例代码 public class ContinueDemo{ public static void main(String[] args){ for(int i = 0 ; i &lt; 10 ; i++){ if(i%2==0){ continue; } System.out.println(i); } } } //会把0-9之间所有的奇数打印到控制台上 19猜数字小游戏* A: 猜数字小游戏 * a: 分析 * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现， 但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件 * b: 需求分析 * 后台预先生成一个随机数1-100，用户键盘录入猜数字 * 如果猜对了，打印“恭喜您，答对了” * 如果猜错了 * 猜大了：打印“sorry，您猜大了!” * 猜小了：打印“sorry，您猜小了!” 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” * B: 案例代码 /* 猜数字小游戏 完成猜数字小游戏： 1、产生随机数 后台预先生成一个随机数1-100，用户键盘录入猜数字 2、通过if语句对用户猜的数与随机数进行比较 如果猜对了，打印“恭喜您，答对了” 如果猜错了 猜大了：打印“sorry，您猜大了!” 猜小了：打印“sorry，您猜小了!” 3、通过for循环完成用户猜数的循环 直到数字猜到为止 最多只能猜5次，否则提示“sorry，您没有机会了!” */ import java.util.Random; import java.util.Scanner; //通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。 //import java.util.*; public class GuessNumber{ public static void main(String[] args) { //1、产生随机数 //后台预先生成一个随机数1-100，用户键盘录入猜数字 //创建随机数对象 Random random = new Random(); //产生一个1-100的随机数 int randomNumber = random.nextInt(100)+1; //System.out.println(&quot;我产生的随机数是：&quot;+randomNumber+&quot;你猜猜是多少？&quot;); 作弊专用 //产生控制台录入的Scanner对象 Scanner sc = new Scanner(System.in); //3、通过for循环完成用户猜数的循环 //通过for循环完成猜数字逻辑 for(int i=1; i&lt;=5; i++){ //提示用户输入要猜的数，用变量接收 System.out.println(); System.out.println(&quot;请您输入一个1-100的数：&quot;); int guessNumber = sc.nextInt(); //2、通过if语句对用户猜的数与随机数进行比较 //如果猜对了 if(guessNumber==randomNumber) { //打印猜对后的提示 System.out.println(&quot;恭喜您，猜对了！&quot;); //跳出循环，不用再猜了 break; }else {//如果猜错了 //如果猜大了 if(guessNumber&gt;randomNumber) { System.out.println(&quot;sorry，您猜大了!&quot;); }else {//如果猜小了 System.out.println(&quot;sorry，您猜小了!&quot;); } } //如果猜到了最后的第5次仍然没有猜对就跳出循环 if(i==5) { System.out.println(&quot;对不起，点太背，下次再来吧！&quot;); break; } //每次猜错后，都提示还有多少次机会 System.out.println(&quot;请注意，您还有&quot;+(5-i)+&quot;次机会，请慎重作答！&quot;); } } }]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS环境配置踩坑经历]]></title>
    <url>%2F2016%2F10%2F03%2FAS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[遇到的bugUnable to resolve dependency for &apos;:app@debug/compileClasspath&apos; 这是由于配置文件的依赖是通过Google下载的，然而该下载被墙了！[解决办法]： 在整个工程的build.gradle中添加以下框内代码：1234maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;maven &#123; url 'http://repo1.maven.org/maven2' &#125; app下的build.gradle配置如下:buildToolsVersion 需要和你的sdk安装目录 ~\sdk\build-tools文件里面已有的版本对应123456789101112131415161718android &#123; compileSdkVersion 26 buildToolsVersion '27.0.3' defaultConfig &#123; applicationId "com.example.administrator.myapplication" minSdkVersion 19 targetSdkVersion 22 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; implementation ‘com.android.support:appcompat-v7:26.+’ 中v7:26.+表示使用的sdk版本123456789101112dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.+' implementation 'com.android.support.constraint:constraint-layout:1.0.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:0.4' androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'// androidTestImplementation 'com.android.support.test:runner:1.0.1'// androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'&#125; 若配置后还没解决问题，依然报错打开 C:/Users/(用户名)/.gradle/gradle.properties把http代理的配置注释掉，例如： ## For more details on how to configure your build environment visit # http://www.gradle.org/docs/current/userguide/build_environment.html # # Specifies the JVM arguments used for the daemon process. # The setting is particularly useful for tweaking memory settings. # Default value: -Xmx1024m -XX:MaxPermSize=256m # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 # # When configured, Gradle will run in incubating parallel mode. # This option should only be used with decoupled projects. More details, visit # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects # org.gradle.parallel=true #Sat Sep 29 23:37:12 CST 2018 #systemProp.http.proxyHost=mirrors.neusoft.edu.cn #systemProp.https.proxyPort=80 #systemProp.https.proxyHost=mirrors.neusoft.edu.cn #systemProp.http.proxyPort=80 More info: 参考该问题的csdn博客]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java入门]]></title>
    <url>%2F2016%2F10%2F02%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[java入门笔记 第一个Java程序Java代码Java程序是大小写敏感的 对格式没有严格要求，但用空格或Tab键缩进会比较好看 Hello.java12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println("Hello, world!");&#125;&#125; 文件名必须是Hello.java，文件名也要注意大小写，必须与程序的类名完全一致，扩展名是.java。 编译切换到Hello.java所在目录：1javac Hello.java 无任何输出表示成功，可查看编译出的Hello.class文件。 执行1java Hello 代码格式：public 和 static 是修饰符static表示静态方法 12345678910public class 类名 &#123; public static void 方法名(参数) &#123; //单行注释 你的程序代码; /* 多行注释 */&#125;&#125;//class定义结束 变量变量概述A: 什么是变量? 12a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。 计算机存储单元A: 计算机中储存和运算的最小单位是?123456789a: 一个字节,也就是一个byte. win+r--cmd--回车 b: 常用储存单位 *1B（字节） = 8bit *1KB = 1024B *1MB = 1024KB *1GB = 1024MB *1TB = 1024GB *1PB = 1024TB Java中数据类型四类八种 A: 数据类型四类八种123456789*四类 八种 字节数 数据表示范围*整型 byte 1 -128～127 short 2 -32768～32767 int 4 -2147483648～2147483648 long 8 -263～263-1*浮点型 float 4 -3.403E38～3.403E38 double 8 -1.798E308～1.798E308*字符型 char 2 表示一个字符，如('a'，'A'，'0'，'家')*布尔型 boolean 1 只有两个值true与false 常量和数据类型 A:常量的定义1234* a: 整形常量默认是int类型* b: 小数常量默认是double类型* c: 定义长整形数据如果值超过int取值范围后面要+"L"* d: 定义float类型的数据后面要+"f" 否则默认是double 变量创建的三要素A: 定义变量的语法格式：1234567891011121314数据类型 变量名 = 变量值;* int a = 100; * B:代码:public class Variable &#123; public static void main(String[] args) &#123; int a = 10; double b = 3.14; char c = 'z'; String s = "i love java"; a = 20; System.out.println(a); &#125;&#125; 定义所有的基本数据类型变量 A: 案例演示 a: 八种基本类型数据的创建 定义字符串变量 A：案例演示 创建字符串数据类型变量 String 是引用数据类型变量定义使用注意事项 A：变量使用的注意事项12345678910111213141516* a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。 public static void main(String[] args) &#123; int x; x = 20; //为x赋值20 System.out.println(x);//读取x变量中的值，再打印 &#125; * c: 变量使用时有作用域的限制。 public static void main(String[] args) &#123; int x = 20; &#123; int y = 20; &#125; System.out.println(x);//读取x变量中的值，再打印 System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量 &#125; 数据类型转换_自动转换 A:  自动类型转换12345678* a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换 自动类型转换格式： 范围大的数据类型 变量 = 范围小的数据类型值； 如： double d = 1000; 或 int i = 100; double d2 = i; 数据类型转换_强制转换 A: 强制类型转换12345678*a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换*b: 强制类型转换格式：范围小的数据类型 变量 = (范围小的数据类型) 范围大的数据类型值;如：int i = (int)6.718; //i的值为6或double d = 3.14;int i2 = (int)d; //i2的值为3 运算符算数运算符_1 A: 常见操作 1234567891011运算符 运算规则 范例 结果+ 正号 +3 3+ 加 2+3 5+ 连接字符串 “中”+“国” “中国”- 负号 int a=3;-a -3- 减 3-1 2* 乘 2*3 6/ 除 5/2 2% 取模 5/2 1++ 自增 int a=1;a++/++a 2-- 自减 int b=3;a--/--a 2 B: 注意事项 12345*a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。*b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。 *c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。*d:整数做被除数，0不能做除数，否则报错。*e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN C:代码演示 1234567891011121314151617181920public class OperatorDemo1 &#123; public static void main(String[] args) &#123; /* * 常量使用算数运算符 */ System.out.println(10+20); /* * 变量使用算数运算符 */ int x = 10; int y = 20; //"+"作为加法运算使用 int z = x + y; //"+"作为连接字符串使用 System.out.println("x="+x); System.out.println("y="+y); System.out.println("z="+z);&#125;&#125; 算数运算符_2 算数运算符++、–* A:算数运算符++、--的使用 * a: ++运算符，会在原有值的基础上自增1 * b: --运算符，会在原有值的基础上自减1。 * B:++ -- 位置的使用 * a:++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1； * b:++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。 赋值运算符 A: 赋值运算符的使用 1234567运算符 运算规则 范例 结果= 赋值 int a=2 2+= 加后赋值 int a=2，a+=2 4-= 减后赋值 int a=2，a-=2 0*= 乘后赋值 int a=2，a*=2 4/= 整除后赋值 int a=2，a/=2 1%= 取模后赋值 int a=2，a%=2 0 B：案例演示 123456789101112 * 赋值运算符 * +=, -=, *=, /=, %= ： * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的 * 注意：赋值运算符左边必须是变量public class OperatorDemo2 &#123; public static void main(String[] args) &#123; byte x = 10; x += 20;// 相当于 x = (byte)(x+20); System.out.println(x); &#125;&#125; 比较运算符 A:比较运算符的使用 1234567运算符 运算规则 范例 结果== 相等于 4==3 False!= 不等于 4!=3 True&lt; 小于 4&lt;3 False&gt; 大于 4&gt;3 True&lt;= 小于等于 4&lt;=3 False&gt;= 大于等于 4&gt;=3 True 逻辑运算符A: 逻辑运算符的使用 123456789101112运算符 运算规则 范例 结果&amp; 与 false&amp;true False| 或 false|true True^ 异或 true^flase True! 非 !true Flase&amp;&amp; 短路与 false&amp;&amp;true False|| 短路或 false||true True规律小结: 短路与&amp;&amp;:参与运算的两边数据，有false，则运算结果为false； 短路或||:参与运算的两边数据，有true，则运算结果为true； 逻辑非! : 参与运算的数据，原先是true则变成false，原先是false则变成true。 三元运算符 A: 格式: (条件表达式)？表达式1：表达式2； B: 代码案例 方式一： System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印 方式二： int a = 3; int b = 4; String result = (a==b) ? “相等” : “不相等”; //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result 方式三： int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200; //三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n 运算符优先级1234567891011121314151617优先级 描述 运算符1 括号 ()、[]2 正负号 +、-3 自增自减，非 ++、--、!4 乘除，取余 *、/、%5 加减 +、-6 移位运算 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt;7 大小关系 &gt;、&gt;=、&lt;、&lt;=8 相等关系 ==、!=9 按位与 &amp;10 按位异或 ^11 按位或 |12 逻辑与 &amp;&amp;13 逻辑或 ||14 条件运算 ?:15 赋值运算 =、+=、-=、*=、/=、%=16 位赋值运算 &amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;= 商场库存清单案例A: 案例分析. a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部） b:清单顶部为固定的数据，直接打印即可 c:清单中部为商品，为变化的数据，需要记录商品信息后，打印经过观察，我们确定一项商品应该有如下几个属性：品牌型号: 即商品名称，String型尺寸：物品大小，double型价格：物品单价，double型配置：这一项为每种商品的配置信息，String型库存数：这一项为每种商品的库存个数，int型 d:清单底部包含了统计操作，需经过计算后，打印我们发现两个单独的可变化量总库存数：所有商品总个数，int型库存商品总金额：所有商品金额，double型 B: 案例代码实现123456789101112131415161718192021222324252627282930313233343536373839404142//步骤一: 创建Demo01库存清单.java文件，编写main主方法public class Demo01库存清单 &#123; public static void main(String[] args) &#123; &#125;&#125;//步骤二: 记录每种库存商品信息//苹果笔记本电脑String macBrand = "MacBookAir";double macSize = 13.3;double macPrice = 6988.88;int macCount = 5;//联想Thinkpad笔记本电脑String thinkpadBrand = "ThinkpadT450";double thinkpadSize = 14.0;double thinkpadPrice = 5999.99;int thinkpadCount = 10;//华硕ASUS笔记本电脑String ASUSBrand = "ASUS-FL5800";double ASUSSize = 15.6;double ASUSPrice = 4999.50;int ASUSCount = 18;//步骤三: 统计库存总个数、库存总金额int totalCount = macCount + thinkpadCount + ASUSCount;double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);//步骤四: 列表顶部System.out.println("------------------------------商城库存清单-----------------------------");System.out.println("品牌型号 尺寸 价格 库存数");步骤四:打印库存清单中部信息//列表中部System.out.println(macBrand+" "+macSize+" "+macPrice+" "+macCount);System.out.println(thinkpadBrand+" "+thinkpadSize+" "+thinkpadPrice+" "+thinkpadCount);System.out.println(ASUSBrand+" "+ASUSSize+" "+ASUSPrice+" "ASUSCount);打印库存清单底部信息//列表底部System.out.println("-----------------------------------------------------------------------");System.out.println("总库存数："+totalCount); System.out.println("库存商品总金额："+totalMoney);]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
