<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QJun</title>
  
  <subtitle>QJun&#39;s Homepage</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leesen998.github.io/"/>
  <updated>2018-10-23T07:40:31.112Z</updated>
  <id>https://leesen998.github.io/</id>
  
  <author>
    <name>QJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello</title>
    <link href="https://leesen998.github.io/2017/10/03/hello-world/"/>
    <id>https://leesen998.github.io/2017/10/03/hello-world/</id>
    <published>2017-10-03T02:41:53.000Z</published>
    <updated>2018-10-23T07:40:31.112Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://source.unsplash.com/random/1700x900" alt="" style="width:100%"><br>只是单纯地发个图片<br><a id="more"></a></p><pre><code>hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111hexo deploy</code></pre><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://source.unsplash.com/random/1700x900&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;br&gt;只是单纯地发个图片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="first test" scheme="https://leesen998.github.io/categories/first-test/"/>
    
    
      <category term="test" scheme="https://leesen998.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础9</title>
    <link href="https://leesen998.github.io/2016/10/12/day11%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/12/day11笔记/</id>
    <published>2016-10-12T14:21:55.000Z</published>
    <updated>2018-11-05T02:59:32.507Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541385820/samples/test/photo-1539580709660-0505d36fa6e7.jpg" alt="" style="width:100%"></p><p>1、接口<br>2、多态</p><a id="more"></a><h3 id="01接口的概念"><a href="#01接口的概念" class="headerlink" title="01接口的概念"></a>01接口的概念</h3><pre><code>* A:接口的概念    接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。    接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。    请记住：一切事物均有功能，即一切事物均有接口。</code></pre><h3 id="02接口的定义"><a href="#02接口的定义" class="headerlink" title="02接口的定义"></a>02接口的定义</h3><pre><code>* A: 接口的定义        与定义类的class不同，接口定义时需要使用interface关键字。        定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。* B : 定义格式        public interface 接口名 {            抽象方法1;            抽象方法2;            抽象方法3;        }* C: 定义步骤        使用interface代替了原来的class，其他步骤与定义类相同：        接口中的方法均为公共访问的抽象方法        接口中无法定义普通的成员变量</code></pre><h3 id="03接口的实现类"><a href="#03接口的实现类" class="headerlink" title="03接口的实现类"></a>03接口的实现类</h3><pre><code>* A: 类与接口的关系        类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关键字不同，实现使用implements。        其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然需要重写方法以实现具体的功能。* B: 类实现接口的格式        class 类 implements 接口 {            重写接口中方法        } * C:注意事项         在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写该抽象方法，完成具体的逻辑。        接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该具备该方法，是功能的声明。        在具体实现类中重写方法，实现功能，是方法的具体实现。</code></pre><h3 id="04接口中成员变量的特点"><a href="#04接口中成员变量的特点" class="headerlink" title="04接口中成员变量的特点"></a>04接口中成员变量的特点</h3><pre><code>* A:成员变量特点     * a 接口中可以定义变量，但是变量必须有固定的修饰符修饰，public static final 所以接口中的变量也称之为常量，其值不能改变。后面我们会讲解static与final关键字* B:案例        interface Demo { ///定义一个名称为Demo的接口。            public static final int NUM = 3;// NUM的值不能改变        }</code></pre><h3 id="05接口中成员方法的特点"><a href="#05接口中成员方法的特点" class="headerlink" title="05接口中成员方法的特点"></a>05接口中成员方法的特点</h3><pre><code>* A: 成员方法特点    * a 接口中可以定义方法，方法也有固定的修饰符，public abstract    * b 子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。* B: 案例        interface Demo { ///定义一个名称为Demo的接口。            public abstract void show1();            public abstract void show2();        }        //定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 implements        class DemoImpl implements Demo { //子类实现Demo接口。            //重写接口中的方法。            public void show1(){}            public void show2(){}        }</code></pre><h3 id="06实现类还是一个抽象类"><a href="#06实现类还是一个抽象类" class="headerlink" title="06实现类还是一个抽象类"></a>06实现类还是一个抽象类</h3><pre><code>A: 接口的实现类   一个类如果实现类接口,有两种操作方法:   第一:实现类是非抽象类,就需要重写接口中所有的抽象方法.   第二:实现类也声明为抽象类,那么实现类可以不重写接口中的抽象方法。</code></pre><h3 id="07类和接口的多实现"><a href="#07类和接口的多实现" class="headerlink" title="07类和接口的多实现"></a>07类和接口的多实现</h3><pre><code>* A：接口的多实现    了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，接口到底有啥用呢？    接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完成了。* B 多实现的优点    * 怎么解决多继承的弊端呢？    * 弊端：多继承时，当多个父类中有相同功能时，子类调用会产生不确定性。    * 其实核心原因就是在于多继承父类中功能有主体，而导致调用运行时，不确定运行哪个主体内容。    * 为什么多实现能解决了呢？    * 因为接口中的功能都没有方法体，由子类来明确。* C :案例演示    interface Fu2{        void show2();    }    class Zi implements Fu1,Fu2 {    // 多实现。同时实现多个接口。        public void show1(){}        public void show2(){}    }</code></pre><h3 id="08类在继承类的同时实现多接口"><a href="#08类在继承类的同时实现多接口" class="headerlink" title="08类在继承类的同时实现多接口"></a>08类在继承类的同时实现多接口</h3><pre><code>* A: 继承的同时实现接口    * 接口和类之间可以通过实现产生关系，同时也学习了类与类之间可以通过继承产生关系。当一个类已经继承了一个父类，它又需要扩展额外的功能，这时接口就派上用场了。    * 子类通过继承父类扩展功能，通过继承扩展的功能都是子类应该具备的基础功能。如果子类想要继续扩展其他类中的功能呢？这时通过实现接口来完成。    * 接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。* B: 代码演示    class Fu {        public void show(){}    }    interface Inter {        pulbic abstract void show1();    }    class Zi extends Fu implements Inter {        public void show1() {        }    }    接口的出现避免了单继承的局限性。父类中定义的事物的基本功能。接口中定义的事物的扩展功能。</code></pre><h3 id="09接口的多继承"><a href="#09接口的多继承" class="headerlink" title="09接口的多继承"></a>09接口的多继承</h3><pre><code>* A: 接口的多继承    * 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以通过实现产生关系，那么接口与接口之间会有什么关系。    * 多个接口之间可以使用extends进行继承。* B 代码演示     interface Fu1{        void show();    }    interface Fu2{        void show1();    }    interface Fu3{        void show2();    }    interface Zi extends Fu1,Fu2,Fu3{        void show3();    }    在开发中如果多个接口中存在相同方法，这时若有个类实现了这些接口，那么就要实现接口中的方法，由于接口中的方法是抽象方法，子类实现后也不会发生调用的不确定性。</code></pre><h3 id="10接口思想"><a href="#10接口思想" class="headerlink" title="10接口思想"></a>10接口思想</h3><pre><code>* A:接口的思想    * 前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。    * 举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？    * 主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。* B: 接口的好处        * 总结：接口在开发中的它好处    * 1、接口的出现扩展了功能。    * 2、接口其实就是暴漏出来的规则。    * 3、接口的出现降低了耦合性，即设备与设备之间实现了解耦。    * 接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</code></pre><h3 id="11接口和抽象类的区别"><a href="#11接口和抽象类的区别" class="headerlink" title="11接口和抽象类的区别"></a>11接口和抽象类的区别</h3><pre><code>* A: 明白了接口思想和接口的用法后，接口和抽象类的区别是什么呢？接口在生活体现也基本掌握，那在程序中接口是如何体现的呢？    通过实例进行分析和代码演示抽象类和接口的用法。* B: 举例：    *    犬：            行为：            吼叫；            吃饭；    * 缉毒犬：            行为：            吼叫；            吃饭；            缉毒；* C:思考：    * 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。    * 当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。    * 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。* D: 代码演示    interface 缉毒{        public abstract void 缉毒();    }    //定义犬科的这个提醒的共性功能    abstract class 犬科{    public abstract void 吃饭();    public abstract void 吼叫();    }    // 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，    //由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能    class 缉毒犬 extends 犬科 implements 缉毒{        public void 缉毒() {        }        void 吃饭() {        }        void 吼叫() {        }    }    class 缉毒猪 implements 缉毒{        public void 缉毒() {        }    }* E: 接口和抽象类区别总结     相同点:        都位于继承的顶端,用于被其他类实现或继承;        都不能直接实例化对象;        都包含抽象方法,其子类都必须覆写这些抽象方法;    区别:        抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;        一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)        抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系        接口是这个事物中的额外内容,继承体系是一种 like..a关系    二者的选用:        优先选用接口,尽量少用抽象类;        需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</code></pre><h3 id="12多态概述"><a href="#12多态概述" class="headerlink" title="12多态概述"></a>12多态概述</h3><pre><code>* A: 多态概述    多态是继封装、继承之后，面向对象的第三大特性。    现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。        Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。    Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。    如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。    最终多态体现为父类引用变量可以指向子类对象。    多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。    在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</code></pre><h3 id="13多态调用的三种格式"><a href="#13多态调用的三种格式" class="headerlink" title="13多态调用的三种格式"></a>13多态调用的三种格式</h3><pre><code>* A:多态的定义格式：    * 就是父类的引用变量指向子类对象         父类类型  变量名 = new 子类类型();         变量名.方法名();* B: 普通类多态定义的格式        父类 变量名 = new 子类();        举例：                class Fu {}            class Zi extends Fu {}            //类的多态使用            Fu f = new Zi();* C: 抽象类多态定义格式                    抽象类 变量名 = new 抽象类子类();        举例：            abstract class Fu {                 public abstract void method();                 }        class Zi extends Fu {        public void method(){                      System.out.println(“重写父类抽象方法”);        }        }        //类的多态使用        Fu fu= new Zi();* D: 接口多态定义的格式        接口 变量名 = new 接口实现类();        如： interface Fu {                     public abstract void method();        }        class Zi implements Fu {                     public void method(){                      System.out.println(“重写接口抽象方法”);        }        }        //接口的多态使用        Fu fu = new Zi();* E: 注意事项        同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。        如 Person p1 = new Student();           Person p2 = new Teacher();           p1.work(); //p1会调用Student类中重写的work方法           p2.work(); //p2会调用Teacher类中重写的work方法        当变量名指向不同的子类对象时，由于每个子类重写父类方法的内容不同，所以会调用不同的方法。</code></pre><h3 id="14多态成员方法的特点"><a href="#14多态成员方法的特点" class="headerlink" title="14多态成员方法的特点"></a>14多态成员方法的特点</h3><pre><code>* A: 掌握了多态的基本使用后，那么多态出现后类的成员有啥变化呢？前面学习继承时，我们知道子父类之间成员变量有了自己的特定变化，    * 那么当多态出现后，成员变量在使用上有没有变化呢？    * 多态出现后会导致子父类中的成员变量有微弱的变化* B: 代码演示    class Fu {        int num = 4;    }    class Zi extends Fu {        int num = 5;    }    class Demo {        public static void main(String[] args)     {            Fu f = new Zi();            System.out.println(f.num);            Zi z = new Zi();            System.out.println(z.num);        }    }* C: 多态成员变量    当子父类中出现同名的成员变量时，多态调用该变量时：    编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。    运行时期：也是调用引用型变量所属的类中的成员变量。    简单记：编译和运行都参考等号的左边。编译运行看左边。* D: 多态出现后会导致子父类中的成员方法有微弱的变化。看如下代码    class Fu {        int num = 4;        void show()    {            System.out.println(&quot;Fu show num&quot;);        }    }    class Zi extends Fu {        int num = 5;        void show()    {            System.out.println(&quot;Zi show num&quot;);        }    }    class Demo {        public static void main(String[] args)     {            Fu f = new Zi();            f.show();        }    }* E: 多态成员方法    编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。    运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。    简而言之：编译看左边，运行看右边。</code></pre><h3 id="15instanceof关键字"><a href="#15instanceof关键字" class="headerlink" title="15instanceof关键字"></a>15instanceof关键字</h3><pre><code>* A: 作用     可以通过instanceof关键字来判断某个对象是否属于某种数据类型。如学生的对象属于学生类，学生的对象也属于人类* 格式:    boolean  b  = 对象  instanceof  数据类型;* 举例:    Person p1 = new Student(); // 前提条件，学生类已经继承了人类    boolean flag = p1 instanceof Student; //flag结果为true    boolean flag2 = p2 instanceof Teacher; //flag结果为false</code></pre><h3 id="16多态-向上转型"><a href="#16多态-向上转型" class="headerlink" title="16多态-向上转型"></a>16多态-向上转型</h3><pre><code>* A: 多态的转型分为向上转型与向下转型两种：* B: 向上转型：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。    使用格式：    父类类型  变量名 = new 子类类型();    如：Person p = new Student();</code></pre><h3 id="17多态-向下转型"><a href="#17多态-向下转型" class="headerlink" title="17多态-向下转型"></a>17多态-向下转型</h3><pre><code>* A: 向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！    使用格式：    子类类型 变量名 = (子类类型) 父类类型的变量;    如:Student stu = (Student) p;  //变量p 实际上指向Student对象</code></pre><h3 id="18多态的好处和弊端"><a href="#18多态的好处和弊端" class="headerlink" title="18多态的好处和弊端"></a>18多态的好处和弊端</h3><pre><code>* A: 多态的好处和弊端    * 当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。      向上转型的好处是隐藏了子类类型，提高了代码的扩展性。    * 但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。* B: 看如下代码    //描述动物类，并抽取共性eat方法    abstract class Animal {        abstract void eat();    }    // 描述狗类，继承动物类，重写eat方法，增加lookHome方法    class Dog extends Animal {        void eat() {            System.out.println(&quot;啃骨头&quot;);        }        void lookHome() {            System.out.println(&quot;看家&quot;);        }    }    // 描述猫类，继承动物类，重写eat方法，增加catchMouse方法    class Cat extends Animal {        void eat() {            System.out.println(&quot;吃鱼&quot;);        }        void catchMouse() {            System.out.println(&quot;抓老鼠&quot;);        }    }    public class Test {        public static void main(String[] args) {            Animal a = new Dog(); //多态形式，创建一个狗对象            a.eat(); // 调用对象中的方法，会执行狗类中的eat方法            // a.lookHome();//使用Dog类特有的方法，需要向下转型，不能直接使用            // 为了使用狗类的lookHome方法，需要向下转型    // 向下转型过程中，可能会发生类型转换的错误，即ClassCastException异常            // 那么，在转之前需要做健壮性判断             if( !a instanceof Dog){ // 判断当前对象是否是Dog类型                     System.out.println(&quot;类型不匹配，不能转换&quot;);                      return;             }             Dog d = (Dog) a; //向下转型            d.lookHome();//调用狗类的lookHome方法        }    }* C 多态总结:    什么时候使用向上转型：        当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。        如：Animal a = new Dog();            a.eat();    什么时候使用向下转型        当要使用子类特有功能时，就需要使用向下转型。            如：Dog d = (Dog) a; //向下转型                d.lookHome();//调用狗类的lookHome方法            向下转型的好处：可以使用子类特有功能。            弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。        如：if( !a instanceof Dog){…}</code></pre><h3 id="19多态举例"><a href="#19多态举例" class="headerlink" title="19多态举例"></a>19多态举例</h3><pre><code>* A: 毕老师和毕姥爷的故事* 案例: /*   描述毕老师和毕姥爷，   毕老师拥有讲课和看电影功能   毕姥爷拥有讲课和钓鱼功能 */   class 毕姥爷 {       void 讲课() {           System.out.println(&quot;政治&quot;);       }       void 钓鱼() {           System.out.println(&quot;钓鱼&quot;);       }   }   // 毕老师继承了毕姥爷，就有拥有了毕姥爷的讲课和钓鱼的功能，   // 但毕老师和毕姥爷的讲课内容不一样，因此毕老师要覆盖毕姥爷的讲课功能   class 毕老师 extends 毕姥爷 {       void 讲课() {           System.out.println(&quot;Java&quot;);       }       void 看电影() {           System.out.println(&quot;看电影&quot;);       }   }   public class Test {       public static void main(String[] args) {           // 多态形式           毕姥爷 a = new 毕老师(); // 向上转型           a.讲课(); // 这里表象是毕姥爷，其实真正讲课的仍然是毕老师，因此调用的也是毕老师的讲课功能           a.钓鱼(); // 这里表象是毕姥爷，但对象其实是毕老师，而毕老师继承了毕姥爷，即毕老师也具有钓鱼功能           // 当要调用毕老师特有的看电影功能时，就必须进行类型转换           毕老师 b = (毕老师) a; // 向下转型           b.看电影();       }</code></pre><h3 id="20笔记本电脑案例"><a href="#20笔记本电脑案例" class="headerlink" title="20笔记本电脑案例"></a>20笔记本电脑案例</h3><pre><code> * A:案例介绍     * 定义USB接口（具备开启功能、关闭功能），笔记本要使用USB设备，即笔记本在生产时需要预留可以插入USB设备的USB接口，即就是笔记本具备使用USB设备的功能，     * 但具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用    * 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘        USB接口，包含开启功能、关闭功能        笔记本类，包含运行功能、关机功能、使用USB设备功能        鼠标类，要符合USB接口        键盘类，要符合USB接口* B: 案例分析    * 阶段一：        使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能    * 阶段二：        想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。    * 阶段三：        还想使用一个键盘 ，又要多一个功能和一个对象    * 问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。        降低鼠标、键盘等外围设备和笔记本电脑的耦合性。</code></pre><h3 id="21笔记本电脑案例代码实现"><a href="#21笔记本电脑案例代码实现" class="headerlink" title="21笔记本电脑案例代码实现"></a>21笔记本电脑案例代码实现</h3><pre><code>* A: 代码实现   定义鼠标、键盘，笔记本三者之间应该遵守的规则   interface USB {       void open();// 开启功能       void close();// 关闭功能   }       鼠标实现USB规则   class Mouse implements USB {       public void open() {           System.out.println(&quot;鼠标开启&quot;);       }       public void close() {           System.out.println(&quot;鼠标关闭&quot;);       }   }       键盘实现USB规则   class KeyBoard implements USB {       public void open() {           System.out.println(&quot;键盘开启&quot;);       }       public void close() {           System.out.println(&quot;键盘关闭&quot;);       }   }       定义笔记本   class NoteBook {       // 笔记本开启运行功能       public void run() {           System.out.println(&quot;笔记本运行&quot;);       }       // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备       public void useUSB(USB usb) {           // 判断是否有USB设备           if (usb != null) {               usb.open();               usb.close();           }       }       public void shutDown() {           System.out.println(&quot;笔记本关闭&quot;);       }   }   public class Test {       public static void main(String[] args) {           // 创建笔记本实体对象           NoteBook nb = new NoteBook();           // 笔记本开启           nb.run();           // 创建鼠标实体对象           Mouse m = new Mouse();           // 笔记本使用鼠标           nb.useUSB(m);           // 创建键盘实体对象           KeyBoard kb = new KeyBoard();           // 笔记本使用键盘           nb.useUSB(kb);           // 笔记本关闭           nb.shutDown();       }   }</code></pre><h3 id="22小结"><a href="#22小结" class="headerlink" title="22小结"></a>22小结</h3><p>接口：理解为是一个特殊的抽象类，但它不是类，是一个接口<br>——————————————————————————————————————————————————————————<br>接口的特点：</p><pre><code>1，定义一个接口用interface关键字        interface Inter{}    2，一个类实现一个接口，实现implements关键字        class Demo implements Inter{}    3, 接口不能直接创建对象       通过多态的方式，由子类来创建对象，接口多态    </code></pre><p>——————————————————————————————————————————————————————————<br>接口中的成员特点：</p><pre><code>成员变量：    只能是final 修饰的常量    默认修饰符： public static final构造方法：    无成员方法：    只能是抽象方法    默认修饰符: public abstract </code></pre><p>——————————————————————————————————————————————————————————<br>类与类，类与接口，接口与接口之间的关系</p><pre><code>类与类之间：继承关系，单继承，可以是多层继承类与接口之间: 实现关系，单实现，也可以多实现接口与接口之间：继承关系，单继承，也可以是多继承            Java中的类可以继承一个父类的同时，实现多个接口</code></pre><p>——————————————————————————————————————————————————————————<br>多态：理解为同一种物质的多种形态<br>多态使用的前提：</p><pre><code>        1，有继承或者实现关系        2，要方法重写        3，父类引用指向子类对象——————————————————————————————————————————————————————————多态的成员访问特点：        方法的运行看右边，其他都看左边多态的好处：            提高了程序的扩展性——————————————————————————————————————————————————————————多态的弊端：        不能访问子类的特有功能——————————————————————————————————————————————————————————多态的分类</code></pre><p>——————————————————————————————————————————————————————————<br>类的多态</p><pre><code>abstract class Fu {                  public abstract void method();}class Zi extends Fu {public void method(){                     System.out.println(“重写父类抽象方法”);}}//类的多态使用Fu fu= new Zi();</code></pre><p>——————————————————————————————————————————————————————————<br>接口的多态</p><pre><code>interface Fu {    public abstract void method();}class Zi implements Fu {    public void method(){        System.out.println(“重写接口抽象方法”);}}//接口的多态使用Fu fu = new Zi();</code></pre><p>——————————————————————————————————————————————————————————<br>instanceof 关键字</p><pre><code>格式： 对象名 instanceof 类名返回值： true, false作用： 判断指定的对象 是否为 给定类创建的对象</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1541385820/samples/test/photo-1539580709660-0505d36fa6e7.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、接口&lt;br&gt;2、多态&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础8</title>
    <link href="https://leesen998.github.io/2016/10/11/day10%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/11/day10笔记/</id>
    <published>2016-10-11T02:21:53.000Z</published>
    <updated>2018-11-04T14:15:50.233Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541167132/samples/java%20files/photo-1539452851739-c57dee0c0859.jpg" alt="" style="width:100%"></p><p>1、继承<br>2、抽象类<br>3、综合案例—员工类系列定义</p><a id="more"></a><h3 id="01继承的概述"><a href="#01继承的概述" class="headerlink" title="01继承的概述"></a>01继承的概述</h3><pre><code>*A:继承的概念   *a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系   *b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，       构建出来的新类被称作子类，现有类被称作父类 *B:继承关系的子类特点     *a:子类会自动拥有父类所有非private修饰的属性和方法</code></pre><h3 id="02继承的定义格式和使用"><a href="#02继承的定义格式和使用" class="headerlink" title="02继承的定义格式和使用"></a>02继承的定义格式和使用</h3><pre><code>*A:继承的格式   class 子类 extends 父类 {}*B:雇员(Employee)与研发部员工(Developer)案例:   *cn.itcast.demo01包下:   *Employee.java:        /*        * 定义员工类Employee        */       class Employee {           String name; // 定义name属性           public void work() {// 定义员工的工作方法               System.out.println(&quot;尽心尽力地工作&quot;);           }       }   *Developer.java:       /*        * 定义研发部员工类Developer 继承 员工类Employee        * 继承了父类中所有非private修饰的成员变量        */       class Developer extends Employee {           // 定义一个打印name的方法           public void printName() {               System.out.println(&quot;name=&quot; + name);           }       }   *测试员工类与研发部员工类:       /*         * 定义测试类        */       public class Example01 {           public static void main(String[] args) {               Developer d = new Developer(); // 创建一个研发部员工类对象               d.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值               d.printName(); // 调用该员工的printName()方法               d.work(); // 调用Developer类继承来的work()方法           }       }   *通过子类对象既可以调用自身的非private修饰的成员,也可以调用父类的非private修饰的成员</code></pre><h3 id="03继承的好处"><a href="#03继承的好处" class="headerlink" title="03继承的好处"></a>03继承的好处</h3><pre><code>*A:继承的好处：    *1、继承的出现提高了代码的复用性，提高软件开发效率。    *2、继承的出现让类与类之间产生了关系，提供了多态的前提。</code></pre><h3 id="04继承的注意事项"><a href="#04继承的注意事项" class="headerlink" title="04继承的注意事项"></a>04继承的注意事项</h3><pre><code> *A:继承的注意事项      *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。         class A{}          class B{}         class C extends A,B{}  // C类不可以同时继承A类和B类      假如支持多继承例如:         class A{             int a=3;            public void method(){            }         }          class B{             int a=5;             public void method(){             }         }         class C extends A,B{         }          class Demo{             public static void main(String[] args){                 C c=new C();                 System.out.println(c.a);//到底是调用A的还是B的成员变量??无法确定                 c.method();//到底是调用A的还是B的成员方法??无法确定             }             }         *b:多个类可以继承一个父类，例如下面这种情况是允许的(就像你爹可以多个儿子,但是这些儿子都只有一个爹)         class A{}         class B extends A{}         class C extends A{}   // 类B和类C都可以继承类A          *c:在Java中，多层继承是可以的，        即一个类的父类可以再去继承另外的父类，        例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。         class A{}         class B extends A{}   // 类B继承类A，类B是类A的子类         class C extends B{}   // 类C继承类B，类C是类B的子类，同时也是类A的子类               *d:在Java中，子类和父类是一种相对概念，        也就是说一个类是某个类父类的同时，也可以是另一个类的子类。        例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。</code></pre><h3 id="05继承的体系"><a href="#05继承的体系" class="headerlink" title="05继承的体系"></a>05继承的体系</h3><p>   *A:继承的体系:</p><pre><code>                                  动物(吃)                                    |                           -------------------------                           |                        |                        猫科动物(吃,胎生)      爬行动物(吃,卵生)                           |                            |         -------------------------------        -----------------               |                             |        |                |        猫(吃,抓老鼠,胎生)   虎(吃,领地,胎生)  蛇(吃,冬眠,卵生)  鳄鱼(吃,潜水,卵生)*a:动物体系是对每个具体事物共性的抽取,子类的共性抽取形成父类*b:父类:具有所有子类的共性内容   子类:不但有共性还有自身特有的内容*c:整个继承体系,越向上越抽象,越向下越具体</code></pre><h3 id="06继承后子类父类成员变量的特点"><a href="#06继承后子类父类成员变量的特点" class="headerlink" title="06继承后子类父类成员变量的特点"></a>06继承后子类父类成员变量的特点</h3><pre><code>A:继承后子类父类成员变量的特点  a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父类      class Fu{           //Fu中的成员变量。           int num = 5;       }       class Zi extends Fu{           //Zi中的成员变量           int num2 = 6;           //Zi中的成员方法           public void show()           {               //访问父类中的num               System.out.println(&quot;Fu num=&quot;+num);               //访问子类中的num2               System.out.println(&quot;Zi num2=&quot;+num2);           }       }       class Demo{           public static void main(String[] args)            {               Zi z = new Zi(); //创建子类对象               z.show(); //调用子类中的show方法           }       }b:当子父类中出现了同名成员变量    class Fu{       //Fu中的成员变量。       int num = 5;   }   class Zi extends Fu{       //Zi中的成员变量       int num = 6;       void show(){              //子类的局部变量           int num=7           //直接访问,遵循就近查找原则           System.out.println(num);//7           //子父类中出现了同名的成员变量时           //在子类中需要访问父类中非私有成员变量时，需要使用super关键字           //访问父类中的num           System.out.println(&quot;Fu num=&quot;+super.num);//5           //访问子类中的num2           System.out.println(&quot;Zi num2=&quot;+this.num);//6       }   }   class Demo5 {       public static void main(String[] args)        {           Zi z = new Zi(); //创建子类对象           z.show(); //调用子类中的show方法       }   }</code></pre><h3 id="07继承后子类父类成员方法的特性-子类重写父类方法"><a href="#07继承后子类父类成员方法的特性-子类重写父类方法" class="headerlink" title="07继承后子类父类成员方法的特性_子类重写父类方法"></a>07继承后子类父类成员方法的特性_子类重写父类方法</h3><pre><code>A:继承后子类父类成员方法的特性  a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类    class Fu{        public void show(){            System.out.println(&quot;Fu类中的show方法执行&quot;);        }    }    class Zi extends Fu{        public void show2(){            System.out.println(&quot;Zi类中的show2方法执行&quot;);        }    }    public  class Test{        public static void main(String[] args) {            Zi z = new Zi();            z.show(); //子类中没有show方法，但是可以找到父类方法去执行            z.show2();        }    }   b:为什么要有重写?     class Fu{         public void method(){             //上千行代码            //Fu类中的方法最先存在,那么如果项目需求变了,该方法            //功能不能够满足我们的需求,此时我们也不会去改这个方法            //因为项目中可能有大量的功能已经使用到该方法,如果随意修改可能使调用该方法的功能出现问题            //所以使用重写方式基于原有功能提供更强的功能         }        }     class Zi extends Fu{     } c:子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖   class Fu{        public void show(){            System.out.println(&quot;Fu show&quot;);        }   }   class Zi extends Fu{        //子类复写了父类的show方法        public void show(){            System.out.println(&quot;Zi show&quot;);        }    }   public  class Test{        public static void main(String[] args) {            Zi z = new Zi();            z.show(); //Zi show 子类有直接使用子类        }    }  </code></pre><h3 id="08方法覆盖的需求"><a href="#08方法覆盖的需求" class="headerlink" title="08方法覆盖的需求"></a>08方法覆盖的需求</h3><pre><code>A:方法覆盖的需求     a:案例:比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，    后期由于手机需要在来电显示功能中增加显示姓名和头像，    这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。    并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能    b:分析:我们不改装(破坏)原来的手机,而是再买一个新的智能手机,不但有原有的功能,而且还有特有功能           例:厂商发布新手机都是基于原有手机的升级,不会拿着原有的手机在卖,新产一款       1:分析类的构建:           手机类            属性(成员变量):无            行为(成员方法):               发短信               打电话               来电显示:显示来电号码          智能手机类:            属性(成员变量):无            行为(成员方法):              发短信              打电话              来电显示:显示来电号码,显示姓名和头像          手机类和智能手机类有共性内容:              发短信              打电话              显示来电号码      2:继承关系分析:        对于发短信和打电话功能,让智能手机直接沿用(继承)手机的就可以        但是在智能手机中的来电显示不但实现号码,还显示姓名和头像,同样的都是来电显示功能,智能手机的来电显示比手机的功能更加强大,我们考虑使用重写</code></pre><h3 id="09方法覆盖的手机案例实现"><a href="#09方法覆盖的手机案例实现" class="headerlink" title="09方法覆盖的手机案例实现"></a>09方法覆盖的手机案例实现</h3><pre><code>//手机类class Phone{    public void sendMessage(){        System.out.println(&quot;发短信&quot;);    }    public void call(){        System.out.println(&quot;打电话&quot;);    }    public void showNum(){        System.out.println(&quot;来电显示号码&quot;);    }}//智能手机类class NewPhone extends Phone{    //覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能    //从现实生活角度考虑沿用原有的showNum方法名便于用户更快熟悉和接受,而不是再起个新的名字    //用户还需要花费大量时间慢慢接受    public void showNum(){        //调用父类已经存在的功能使用super        //如果不加super这是调用子类自身的showNum(),自己调用自己,递归        //方法不断入栈导致内存溢出        super.showNum();        //增加自己特有显示姓名和图片功能        System.out.println(&quot;显示来电姓名&quot;);        System.out.println(&quot;显示头像&quot;);    }}public class Test {    public static void main(String[] args) {        new NewPhone().showNum();//来电显示  显示来电姓名 显示头像    }}</code></pre><h3 id="10方法覆盖的注意事项"><a href="#10方法覆盖的注意事项" class="headerlink" title="10方法覆盖的注意事项"></a>10方法覆盖的注意事项</h3><p>   A:方法覆盖的注意事项<br>    a:权限:子类方法覆盖父类方法，必须要保证权限大于等于父类权限。<br>      四大权限:public&gt;默认=protected&gt;private</p><pre><code>  class Fu{           void show(){       }       public void method(){       }   }   class Zi() extends Fu{       public void show(){//编译运行没问题       }         void method(){//编译错误       }        }b:方法定义:子类方法和要重写的父类的方法:方法的方法名和参数列表都要一样。  关于方法的返回值:    如果是基本数据类型,子类的方法和重写的父类的方法返回值类型必须相同    如果是引用数据类型,子类的方法和重写的父类的方法返回值类型可以相同或者子类方法的返回值类型是父类方法返回值类型的子类    class Fu{           int show(){       }       public Fu method(){       }       public Fu method2(){       }   }   class Zi() extends Fu{       public int show(){//返回值为基本类型的重写       }         public Fu method(){//子类的方法和重写的父类的方法返回值类型可以相同       }            public Zi method2(){//子类方法的返回值类型是父类方法返回值类型的子类       }        }c:重载与重写对比:   重载:       权限修饰符(public private 默认):无关       方法名:重载的两个方法的方法名必须相同       形参列表:         形参类型的顺序不同         形参的个数不同         形参的类型不同         三者至少满足一个       返回值类型:         重载与返回值类型无关   重写:       权限修饰符(public private 默认):          子类方法的权限&gt;=父类的方法的权限       方法名:          子类方法和父类方法必须相同       形参列表:           子类方法和父类方法的形参列表必须相同       返回值类型:         基本类数据类型:           必须相同         引用数据类型:          子类方法的返回值类型和父类方法的返回值类型相同          或者          子类方法的返回值类型是父类方法的返回值类型的 子类</code></pre><h3 id="11抽象类的产生"><a href="#11抽象类的产生" class="headerlink" title="11抽象类的产生"></a>11抽象类的产生</h3><pre><code>A:抽象类的产生  a:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</code></pre><h3 id="12抽象类的定义格式"><a href="#12抽象类的定义格式" class="headerlink" title="12抽象类的定义格式"></a>12抽象类的定义格式</h3><pre><code>A:抽象方法定义的格式：  a:public abstract 返回值类型 方法名(参数);    抽象类定义的格式：    abstract class 类名 {     }   b:抽象类示例代码：      /*        *  定义类开发工程师类        *    EE开发工程师 :  工作        *    Android开发工程师 : 工作        *            *    根据共性进行抽取,然后形成一个父类Develop        *    定义方法,工作: 怎么工作,具体干什么呀        *            *    抽象类,不能实例化对象, 不能new的        *    不能创建对象的原因:  如果真的让你new了, 对象.调用抽象方法,抽象方法没有主体,根本就不能运行        *    抽象类使用: 定义类继承抽象类,将抽象方法进行重写,创建子类的对象        */       public abstract class Develop {          //定义方法工作方法,但是怎么工作,说不清楚了,讲不明白           //就不说, 方法没有主体的方法,必须使用关键字abstract修饰           //抽象的方法,必须存在于抽象的类中,类也必须用abstract修饰           public abstract void work();       }</code></pre><h3 id="13抽象类的使用方式"><a href="#13抽象类的使用方式" class="headerlink" title="13抽象类的使用方式"></a>13抽象类的使用方式</h3><pre><code>A:抽象类的使用方式 /* *  定义类,JavaEE的开发人员 *  继承抽象类Develop,重写抽象的方法 */public class JavaEE extends Develop{    //重写父类的抽象方法    //去掉abstract修饰符,加上方法主体    public void work(){        System.out.println(&quot;JavaEE工程师在开发B/S 软件&quot;);    }}/* *  定义Android类,继承开发人员类 *  重写抽象方法 */public class Android extends Develop{     public void work(){         System.out.println(&quot;Android工程师开发手机软件&quot;);     }}/* *  测试抽象类 *    创建他的子类的对象,使用子类的对象调用方法 */public class Test {    public static void main(String[] args) {         JavaEE ee = new JavaEE();         ee.work();//&quot;JavaEE工程师在开发B/S 软件&quot;         Android and = new Android();         and.work();//&quot;Android工程师开发手机软件&quot;    }}</code></pre><h3 id="14抽象类特点"><a href="#14抽象类特点" class="headerlink" title="14抽象类特点"></a>14抽象类特点</h3> <font color="#D66" size=""><br>A:抽象类的特点<br><strong>a:抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。<br>b:抽象类不可以直接创建对象，原因：调用抽象方法没有意义。<br>c:【只有覆盖了抽象类中所有的抽象方法后】，其子类才可以创建对象。否则该子类还是一个抽象类。</strong><br>之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。<br>  abstract class A{<br>      public abstract void func();<br>      public abstract void func2();<br>  }<br>  class A2 extends A{//A2把A中的两个抽象方法都重写掉了<br>                       //A2类不再是抽象类<br>       public void func(){}<br>       public void func2(){}<br>  }<br><br>  abstract class A3 extends A{//含有抽象方法的类一定是抽象类<br>       public void func(){<br><br>       }<br>       //public abstract void func2();//func2相当于被继承下来<br>  }<br></font><h3 id="15抽象类的设计思想"><a href="#15抽象类的设计思想" class="headerlink" title="15抽象类的设计思想"></a>15抽象类的设计思想</h3><pre><code>A:抽象类的设计思想  a:抽象类的作用:继承的体系抽象类,强制子类重写抽象的方法    抽象员工:      规定一个方法,work工作      EE员工,Android员工        Develop类 抽象类       abstract work();           |    -------------   |             |  EE            Android  //是我开发的一员必须工作  work(){}       work(){}</code></pre><h3 id="16抽象类的细节"><a href="#16抽象类的细节" class="headerlink" title="16抽象类的细节"></a>16抽象类的细节</h3><p>   A:抽象类的细节</p><p> a:抽象类一定是个父类？</p><pre><code>是的，因为不断抽取而来的。</code></pre><p> b:抽象类中是否可以不定义抽象方法?</p><pre><code>是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用(适配器设计模式) /*  *   抽象类,可以没有抽象方法,可以定义带有方法体的方法  *   让子类继承后,可以直接使用  */ public  abstract class Animal {      public void sleep(){          System.out.println(&quot;动物睡觉&quot;);      } } public class Cat extends Animal{ }      public class Test {     public static void main(String[] args) {         //Cat c = new Cat();         new Cat().sleep();//不让该类创建对象,方法可以直接让子类去使用     } }</code></pre><p> c:抽象关键字abstract不可以和哪些关键字共存？    </p><pre><code> 1:private：私有的方法子类是无法继承到的，也不存在覆盖，            而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法,            而private修饰子类根本无法得到父类这个方法。互相矛盾。    /*    *   抽象类,可以没有抽象方法,可以定义带有方法体的方法    *   让子类继承后,可以直接使用    */   public  abstract class Animal {        // private abstract void show();        //抽象方法,需要子类重写, 如果父类方法是私有的,子类继承不了,也就没有了重写   }2:final，，后面学3:static，后面学</code></pre><h3 id="17员工案例分析"><a href="#17员工案例分析" class="headerlink" title="17员工案例分析"></a>17员工案例分析</h3><p>A:员工案例分析:<br>  a:需求描述:</p><pre><code>某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。  研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；  维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。    工作内容    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机</code></pre><p>  b:继承体系:</p><pre><code>                        员工                         |       --------------------------------------------       |                                          |     研发部员工                                 维护部员工       |                                          |   -------------                              -----------   |            |                             |         |JavaEE工程师   Android工程师         网络维护工程师    硬件维护工程师</code></pre><p>  c:详细描述:</p><pre><code>    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。     则，把这些共同的属性与功能抽取到父类中（员工类），     关于工作的内容由具体的工程师来进行指定。    工作内容        JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站        Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件        网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通        硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机    创建JavaEE工程师对象，完成工作方法的调用</code></pre><h3 id="18员工案例Employee类的编写"><a href="#18员工案例Employee类的编写" class="headerlink" title="18员工案例Employee类的编写"></a>18员工案例Employee类的编写</h3><p>   A:员工案例Employee类的编写:按照分析的继承体系来逐个实现</p><pre><code>    /*    *  定义员工类    *    内容,都是所有子类的共性抽取    *      属性: 姓名,工号    *      方法: 工作    */  public abstract class Employee {       private String id;// 员工编号       private String name; // 员工姓名       public String getId() {           return id;       }       public void setId(String id) {           this.id = id;       }       public String getName() {           return name;       }       public void setName(String name) {           this.name = name;       }       //工作方法（抽象方法）       public abstract void work(); }</code></pre><h3 id="19员工案例的子类的编写"><a href="#19员工案例的子类的编写" class="headerlink" title="19员工案例的子类的编写"></a>19员工案例的子类的编写</h3><p>   B:员工案例的子类的编写:</p><pre><code> /* *  定义研发员工类 *    属于员工中的一种, 继承员工类  *    抽象类Develop 给自己的员工定义自己有的属性 */public abstract class Develop extends Employee{}/* *  描述JavaEE开发工程师类 *    工号,姓名 工作方法 *  其他的员工,也具备这些共性,抽取到父类中,自己就不需要定义了 *  是研发部员工的一种,继承研发部类 */public class JavaEE extends Develop{    //重写他父类的父类的抽象方法    public void work(){        //调用父类的get方法,获取name,id值        System.out.println(&quot;JavaEE的工程师开发淘宝&quot;+ super.getName()+&quot;..&quot;+super.getId());    }}    /*    *定义Android工程师 继承 研发部员工类，重写工作方法    */public class Android extends Developer {  @Override   public void work() {    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);  }}/* *   定义维护员工类,属于员工中的一种 *   继承员工类 *   抽象类Maintainer 给自己的员工定义自己有的属性 */public abstract class Maintainer extends Employee{}/* *  描述的是网络维护工程师 *  属于维护部的员工,继承维护部类 */public class Network extends Maintainer{    public void work(){        System.out.println(&quot;网络工程师在检查网络是否畅通&quot;+super.getName()+&quot;...&quot;+super.getId());    }}/* *定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法 */public class Hardware extends Maintainer {    @Override    public void work() {        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;);    }}</code></pre><h3 id="20小结"><a href="#20小结" class="headerlink" title="20小结"></a>20小结</h3><p>（1）    继承：是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有<br>继承的好处：可继承的属性和方法。</p><pre><code>提高了代表的可维护性提高了代码的复用性让类与类之间产生了继承关系</code></pre><p>继承的弊端：</p><pre><code>类与类之间的耦合度过高</code></pre><p>继承特点：</p><pre><code>java中类只能够单继承，不能多继承，可以多层继承    class Yy extends Object {}    class Fu extends Yy{}    class Zi extends Fu {}所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类</code></pre><p>继承的注意事项：</p><pre><code>1，使用关键字 extends 让类与类之间 产生继承关系2, 父类私有的成员，子类不能继承，因为根本看不到3，不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系    苹果 is a 水果    男人 is a 人    狗   is a 人 ， 这种情况就不能继承了</code></pre><p>继承中的成员变量关系：</p><pre><code>  不同名的变量：      子类直接继承使用  同名的变量：默认访问的是子类自己的成员变量(this.成员变量), 想访问父类中的同名变量，请使用 (super.成员变量);</code></pre><p>继承中的成员方法关系：</p><pre><code>不同名的方法：子类直接继承使用同名的方法：默认访问的是子类自己的成员方法，想访问父类中的同名方法，请使用 super.成员方法();super:用来表示当前对象中包含的父类对象空间的引用调用父类的成员变量：super.成员变量;调用方法的成员方法:super.成员方法();</code></pre><p>(2)方法重写(override)：指 在子父类中，出现了方法声明相同的情况，也叫做方法覆盖，方法复写<br>方法重写的注意事项：</p><pre><code>1，子类的方法声明要与父类相同2, 子类要重写方法的方法，方法的权限修饰符不能比父类的更低3, 父类私有的方法，子类不能够进行方法重写</code></pre><p>(3)方法重载(overload)：指 在同一个类中，多个方法名称相同，它们的参数列表不同(个数不同，数据类型不同)</p><p>(4)抽象</p><pre><code>抽象方法： 方法只有声明部分，没有方法体,即 public abstract void method();抽象类： 包含抽象方法的类，一定是抽象类  使用 abstract 修饰的类，是抽象类</code></pre><p>抽象类的特点：</p><pre><code>1，抽象类与抽象方法都必须使用 abstract来修饰             2，抽象类不能直接创建对象    3，抽象类中可以有抽象方法，也可以没有抽象方法    4，抽象类的子类        a，实现了抽象方法的具体类        b，抽象类</code></pre><p>抽象类面试题：</p><pre><code>    1，抽象类中是否可以没有抽象方法？如果可以，那么，该类还定义成抽象类有意义吗？为什么？可以没有抽象方法，有意义，不会让其他人直接创建该类对象</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1541167132/samples/java%20files/photo-1539452851739-c57dee0c0859.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、继承&lt;br&gt;2、抽象类&lt;br&gt;3、综合案例—员工类系列定义&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础7</title>
    <link href="https://leesen998.github.io/2016/10/10/day09%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/10/day09笔记/</id>
    <published>2016-10-10T13:21:53.000Z</published>
    <updated>2018-11-01T13:01:55.695Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058368/java/photo-1538831539254-abe4ffd1a812.jpg" alt="" style="width:100%"></p><p>1、面向对象思想<br>2、类与对象的关系<br>3、局部变量和成员变量的关系<br>4、封装思想<br>5、private,this关键字<br>6、随机点名器</p><a id="more"></a><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><h3 id="面向对象和面向过程的思想"><a href="#面向对象和面向过程的思想" class="headerlink" title="面向对象和面向过程的思想"></a>面向对象和面向过程的思想</h3><pre><code>* A: 面向过程与面向对象都是我们编程中，编写程序的一种思维方式    * a: 面向过程的程序设计方式，是遇到一件事时，思考“我该怎么做”，然后一步步实现的过程。    * b: 面向对象的程序设计方式，是遇到一件事时，思考“我该让谁来做”，然后那个“谁”就是对象，他要怎么做这件事是他自己的事，反正最后一群对象合力能把事就好就行了。</code></pre><h3 id="面向对象的思想的生活案例"><a href="#面向对象的思想的生活案例" class="headerlink" title="面向对象的思想的生活案例"></a>面向对象的思想的生活案例</h3><pre><code>* A: 买电脑（组装机）    * a: 面向过程：自己该怎么做    * b: 面向对象：找人帮我们做</code></pre><h3 id="面向对象好处"><a href="#面向对象好处" class="headerlink" title="面向对象好处"></a>面向对象好处</h3><pre><code>* A: 面向对象好处    * a: 面向对象思维方式是一种更符合人们思考习惯的思想    * b: 面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情）。    * c: 面向对象思维方式将复杂的问题简单化。</code></pre><h3 id="大象装进冰箱的代码案例"><a href="#大象装进冰箱的代码案例" class="headerlink" title="大象装进冰箱的代码案例"></a>大象装进冰箱的代码案例</h3><pre><code>* A: 需求：把大象装冰箱里    * a: 面向过程                 * 自己打开冰箱门        * 自己将大象装进去        * 自己关闭冰箱门        * b: 面向对象        * 分析发现打开、装、关闭都是冰箱的功能。即冰箱对象具    备如下功能        * 冰箱打开        * 冰箱存储        * 冰箱关闭* B: 通过伪代码描述大象和冰箱    * 描述大象：        class 大象        {        }    * 描述冰箱        class冰箱        {            void 打开(){}            void 存储(大象){}            void 关闭(){}        }* C: 使用对象：    * 1、创建冰箱的对象        * 冰箱 bx = new 冰箱();      * 2、调用冰箱的功能        * 对象.功能()；        * bx.打开();        * bx.存储(new 大象());        * bx.关闭();* D：总结：    * 1、先按照名词提炼问题领域中的对象    * 2、对对象进行描述，其实就是在明确对象中应该具备的属性和功能    * 3、通过new的方式就可以创建该事物的具体对象    * 4、通过该对象调用它以后的功能。</code></pre><h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><h3 id="定义小汽车类"><a href="#定义小汽车类" class="headerlink" title="定义小汽车类"></a>定义小汽车类</h3><pre><code>* A: 分析小汽车的属性和功能    * 属性        * 颜色        * 轮胎个数    * 功能        * 运行    * B: 通过伪代码描述小汽车    * 小汽车{        * 颜色        * 轮胎个数        * 运行(){}    * }* C：通过JAVA代码描述小汽车    * public class Car {        * String color;        * int number;        * void run() {            * System.out.println(color + &quot;:&quot; + number);        * }    * }</code></pre><h3 id="测试汽车类"><a href="#测试汽车类" class="headerlink" title="测试汽车类"></a>测试汽车类</h3><pre><code>* A: 创见对象的格式    * a: 类名 变量名 = new 类名();* B: 测试汽车类    public class CarDemo {        public static void main(String[] args) {             /*             测试：Car类中的run方法。             */            // 1,创建Car的对象。给对象起个名字。            Car c = new Car();// c是类类型的变量。c指向了一个具体的Car类型的对象。            // 2,通过已有的对象调用该对象的功能。格式：对象.对象成员;            // 3,可以该对象的属性赋值。            c.color = &quot;red&quot;;            c.number = 4;            c.run();        }    }</code></pre><h3 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h3><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058377/java/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="方法调用的内存图"></p><h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><pre><code>* A: 类和对象的关系    * 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体* B: 举例    * 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具之间的关系便可以看出类与对象之间的关系</code></pre><h2 id="局部变量和成员变量的关系"><a href="#局部变量和成员变量的关系" class="headerlink" title="局部变量和成员变量的关系"></a>局部变量和成员变量的关系</h2><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul><li>区别一：定义的位置不同<ul><li>定义在【类】中的变量是【成员变量】</li><li>定义在【方法】中或者{}语句里面的变量是【局部变量】</li></ul></li><li>区别二：在内存中的位置不同<ul><li>【成员变量】存储在【堆内存】的对象中</li><li>【局部变量】存储在【栈内存】的方法中（局部变量跟随方法进栈）</li></ul></li><li>区别三：声明周期不同<ul><li>成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失</li><li>局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失</li></ul></li><li>区别四：初始化不同<ul><li>【成员变量】因为在堆内存中，【所有默认的初始化值】</li><li>【局部变量】【没有默认】的初始化值，必须手动的给其赋值才可以使用。</li></ul></li></ul><h2 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h2><h3 id="01方法参数是基本数据类型和引用数据类型"><a href="#01方法参数是基本数据类型和引用数据类型" class="headerlink" title="01方法参数是基本数据类型和引用数据类型"></a>01方法参数是基本数据类型和引用数据类型</h3><pre><code>* A.基本类型    class Demo    {        public static void main(String[] args)        {            int x = 4;            show(x);            System.out.println(&quot;x=&quot;+x);        }        public static void show(int x)        {            x = 5;        }    }         基本类型作为参数传递时，其实就是将基本类型变量x空间中的值复制了一份传递给调用的方法show()，当在show()方法中x接受到了复制的值，再在show()方法中对x变量进行操作，这时只会影响到show中的x。当show方法执行完成，弹栈后，程序又回到main方法执行，main方法中的x值还是原来的值。* B.引用类型    class Demo     {        int x ;        public static void main(String[] args)         {            Demo d = new Demo();            d.x = 5;            show(d);            System.out.println(&quot;x=&quot;+d.x);        }        public static void show(Demo d)        {            d.x = 6;        }    }         当引用变量作为参数传递时，这时其实是将引用变量空间中的内存地址(引用)复制了一份传递给了show方法的d引用变量。这时会有两个引用同时指向堆中的同一个对象。当执行show方法中的d.x=6时，会根据d所持有的引用找到堆中的对象，并将其x属性的值改为6.show方法弹栈。    由于是两个引用指向同一个对象，不管是哪一个引用改变了引用的所指向的对象的中的值，其他引用再次使用都是改变后的值。* C.结论    * 对于基本类型形式参数改变不会影响到实际参数    * 对于引用类型形式参数改变会影响到实际参数 </code></pre><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058377/java/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" alt="方法调用的内存图"></p><h3 id="02封装的概述"><a href="#02封装的概述" class="headerlink" title="02封装的概述"></a>02封装的概述</h3><pre><code>* A.面向对象三大特征    * 封装、继承、多态* B.封装表现    * 1、方法就是一个最基本封装体    * 2、类其实也是一个封装体    * C.封装的好处    * 1、提高了代码的复用性    * 2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念    * 3、提高了安全性     </code></pre><h3 id="03封装的生活中的举例"><a href="#03封装的生活中的举例" class="headerlink" title="03封装的生活中的举例"></a>03封装的生活中的举例</h3><pre><code>* A.封装的生活中的举例    机箱：    一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在外面，很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。    总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式。* B.总结    * 机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问内部细节的方式</code></pre><h2 id="private-this关键字"><a href="#private-this关键字" class="headerlink" title="private,this关键字"></a>private,this关键字</h2><h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><pre><code>* A.private概述    * private可以修饰成员内容包括成员方法和成员变量    * 被private修饰的内容不能在其他类访问* B.使用步骤    * 1、通过private修饰属性* C.完整代码     class Person {        private int age;        private String name;        public void show() {            System.out.println(&quot;age=&quot; + age + &quot;,name&quot; + name);        }    }</code></pre><h3 id="get和set方法"><a href="#get和set方法" class="headerlink" title="get和set方法"></a>get和set方法</h3><pre><code>* A.get和set方法    * 年龄已被私有，错误的值无法赋值，可是正确的值也赋值不了，这样还是不行，那肿么办呢？按照之前所学习的封装的原理，隐藏后，还需要提供访问方式。只要对外提供可以访问的方法，让其他程序访问这些方法。同时在方法中可以对数据进行验证。</code></pre><p>一般对成员属性的访问动作：赋值(设置 set)，取值(获取 get)，因此对私有的变量访问的方式可以提供对应的 setXxx或者getXxx的方法。</p><pre><code>class Person {    // 私有成员变量    private int age;    private String name;    // 对外提供设置成员变量的方法    public void setAge(int a) {        // 由于是设置成员变量的值，这里可以加入数据的验证        if (a &lt; 0 || a &gt; 130) {            System.out.println(a + &quot;不符合年龄的数据范围&quot;);            return;        }        age = a;     }    // 对外提供访问成员变量的方法    public void getAge() {        return age;    }}* 总结    * 类中不需要对外提供的内容都私有化，包括属性和方法。</code></pre><p>以后再描述事物，属性都私有化，并提供setXxx getXxx方法对其进行访问</p><pre><code>* 注意    * 私有仅仅是封装的体现形式而已</code></pre><h3 id="私有化Person类带get-set"><a href="#私有化Person类带get-set" class="headerlink" title="私有化Person类带get,set"></a>私有化Person类带get,set</h3><pre><code>* 标准代码    package cn.itcast.demo05;    /*     *   类描述人:     *     属性: 姓名和年龄     *     方法: 说话     *        *   私有化所有的属性 (成员变量) ,必须写对应的get/set方法     *   凡是自定义的类,自定义成员变量,应该私有化,提供get/set     *        *   this关键字:     *     区分成员变量和局部变量同名情况     *     方法中,方位成员变量,写this.     */    public class Person {        private String name;        private int age;        // set方法,变量name,age赋值        public void setAge(int age) {            this.age = age;        }        public void setName(String name) {            this.name = name;        }        // get方法,变量name,age获取值        public int getAge() {            return age;        }        public String getName() {            return name;        }        public void speak() {            String  name = &quot;哈哈&quot;;            int age = 16;            System.out.println(&quot;人在说话  &quot; + this.name + &quot;...&quot; + this.age);        }    }* 标准测试代码    package cn.itcast.demo05;    public class PersonTest {        public static void main(String[] args) {            Person p = new Person();            //调用set方法,对成员变量赋值            p.setAge(18);            p.setName(&quot;旺财&quot;);            p.speak();            //调用get方法,获取成员变量的值    //        System.out.println(p.getName());    //        System.out.println(p.getAge());        }    }</code></pre><h3 id="this关键字-区分成员变量和局部变量的同名"><a href="#this关键字-区分成员变量和局部变量的同名" class="headerlink" title="this关键字_区分成员变量和局部变量的同名"></a>this关键字_区分成员变量和局部变量的同名</h3><pre><code>* A.什么时候用    * 当类中存在成员变量和局部变量同名的时候为了区分，就需要使用this关键字* B.代码    class Person {        private int age;        private String name;        public void speak() {            this.name = &quot;小强&quot;;            this.age = 18;            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);        }    }    class PersonDemo {        public static void main(String[] args) {            Person p = new Person();            p.speak();        }    }</code></pre><h3 id="this内存图"><a href="#this内存图" class="headerlink" title="this内存图"></a>this内存图</h3><pre><code>* A.this内存图</code></pre><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058375/java/this%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="方法调用的内存图"></p><h3 id="this的年龄比较"><a href="#this的年龄比较" class="headerlink" title="this的年龄比较"></a>this的年龄比较</h3><pre><code>* A.需求：在Person类中定义功能，判断两个人是否是同龄人* B.代码    class Person {        private int age;        private String name;        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public void speak() {            System.out.println(&quot;name=&quot; + this.name + &quot;,age=&quot; + this.age);        }        // 判断是否为同龄人        public boolean equalsAge(Person p) {            // 使用当前调用该equalsAge方法对象的age和传递进来p的age进行比较            // 由于无法确定具体是哪一个对象调用equalsAge方法，这里就可以使用this来代替            /*             * if(this.age == p.age) { return true; } return false;             */            return this.age == p.age;        }    }</code></pre><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058375/java/this%E4%BD%BF%E7%94%A8-%E5%B9%B4%E9%BE%84%E6%AF%94%E8%BE%83.jpg" alt="方法调用的内存图 "></p><h2 id="随机点名器"><a href="#随机点名器" class="headerlink" title="随机点名器"></a>随机点名器</h2><h3 id="随机点名器案例重构"><a href="#随机点名器案例重构" class="headerlink" title="随机点名器案例重构"></a>随机点名器案例重构</h3><pre><code>* A.需求：随机点名器，即在全班同学中随机的找出一名同学，打印这名同学的个人信息    它具备以下3个内容：    存储所有同学姓名    总览全班同学姓名    随机点名其中一人，打印到控制台* B.代码    import java.util.ArrayList;    import java.util.Random;    import java.util.Scanner;    /**     * 思路：     * 第一步：存储全班同学信息     * 第二步：打印全班同学每一个人的信息     * 第三部：随机对学生点名，打印学生信息     */    public class Test {        public static void main(String[] args) {            ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); //1.1创建一个可以存储多个同学名字的容器             //1.存储全班同学信息            addStudent(list);             //2.打印全班同学每一个人的信息（姓名、年龄）            printStudent(list);             //3.随机对学生点名，打印学生信息            randomStudent(list);        }        public static void addStudent(ArrayList&lt;Student&gt; list) {            //键盘输入多个同学名字存储到容器中            Scanner sc = new Scanner(System.in);            for (int i = 0; i &lt; 3; i++) {                //创建学生                Student s = new Student();                System.out.println(&quot;存储第&quot;+i+&quot;个学生姓名：&quot;);                String name = sc.next();                s.setName(name);                System.out.println(&quot;存储第&quot;+i+&quot;个学生年龄：&quot;);                int age = sc.nextInt();                s.setAge(age);                //添加学生到集合                list.add(s);            }        }        /**         2.打印全班同学每一个人的信息（姓名、年龄）         */        public static void printStudent (ArrayList&lt;Student&gt; list) {            for (int i = 0; i &lt; list.size(); i++) {                Student s = list.get(i);                System.out.println(&quot;姓名：&quot;+s.getName() +&quot;,年龄：&quot;+s.getAge());            }        }        /**         3.随机对学生点名，打印学生信息         */        public static void randomStudent (ArrayList&lt;Student&gt; list) {            //在班级总人数范围内，随机产生一个随机数            int index = new Random().nextInt(list.size());            //在容器（ArrayList集合）中，查找该随机数所对应的同学信息（姓名、年龄）            Student s = list.get(index);            System.out.println(&quot;被随机点名的同学：&quot;+s.getName() + &quot;，年龄:&quot; + s.getAge());        }    }    /**     * 学生信息类     */    public class Student {        private String name; // 姓名        private int age; // 年龄        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }    }    </code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* A.类与对象</span><br><span class="line">* 类，用于描述多个对象的共同特征，它是对象的模板。</span><br><span class="line">* 对象，用于描述现实中的个体，它是类的实例。</span><br><span class="line">* 类的定义：使用关键字class来定义java中的类</span><br><span class="line">* 格式：</span><br><span class="line">*class 类名 &#123;</span><br><span class="line">*//属性</span><br><span class="line">*数据类型 变量名;</span><br><span class="line">*…</span><br><span class="line">*//方法</span><br><span class="line">*修饰符 返回值类型 方法名(参数)&#123;   &#125;</span><br><span class="line">*…</span><br><span class="line">*&#125;</span><br><span class="line">*</span><br><span class="line">* B.创建对象：</span><br><span class="line">* 格式：</span><br><span class="line">* 类名 对象名 = new 类名();</span><br><span class="line"></span><br><span class="line">* C.封装（private关键字）</span><br><span class="line">* 封装，把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式</span><br><span class="line">* 封装的体现：</span><br><span class="line">* 变量:使用 private 修饰，这就是变量的封装</span><br><span class="line">* 方法:也是一种封装，封装了多条代码</span><br><span class="line">* 类： 也是一种封装，封装了多个方法</span><br><span class="line">* D.private关键字，私有的意思</span><br><span class="line">* 它可以用来修饰类中的成员(成员变量，成员方法)</span><br><span class="line">* private的特点：</span><br><span class="line">* private修饰的成员只能在当前类中访问，其他类中无法直接访问</span><br><span class="line">* E.this关键字</span><br><span class="line">* this关键字，本类对象的引用</span><br><span class="line">* this是在方法中使用的，哪个对象调用了该方法，那么，this就代表调用该方法的对象引用</span><br><span class="line">* this什么时候存在的？当创建对象的时候，this存在的</span><br><span class="line">* this的作用：用来区别同名的成员变量与局部变量（this.成员变量）</span><br><span class="line">* public void setName(String name) &#123;</span><br><span class="line">* this.name = name;</span><br><span class="line">* &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1541058368/java/photo-1538831539254-abe4ffd1a812.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、面向对象思想&lt;br&gt;2、类与对象的关系&lt;br&gt;3、局部变量和成员变量的关系&lt;br&gt;4、封装思想&lt;br&gt;5、private,this关键字&lt;br&gt;6、随机点名器&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础6</title>
    <link href="https://leesen998.github.io/2016/10/09/day06%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/09/day06笔记/</id>
    <published>2016-10-09T13:41:53.000Z</published>
    <updated>2018-10-30T02:07:09.919Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1540864054/java/photo-1540543144-2570163afee1.jpg" alt="" style="width:100%"></p><p>1、自定义类型的定义及使用<br>2、自定义类的内存图<br>3、ArrayList集合的基本功能<br>4、随机点名器案例及库存案例代码优化</p><a id="more"></a><h3 id="01引用数据类型-类"><a href="#01引用数据类型-类" class="headerlink" title="01引用数据类型_类"></a>01引用数据类型_类</h3><pre><code>* A: 数据类型    * a: java中的数据类型分为：基本类型和引用类型* B: 引用类型的分类    * a: Java为我们提供好的类，比如说：Scanner,Random等。    * b: 我们自己创建的类，按照类的定义标准，可以在类中包含多个方法与属性，来供我们使用。 </code></pre><h3 id="02自定义类的概述"><a href="#02自定义类的概述" class="headerlink" title="02自定义类的概述"></a>02自定义类的概述</h3><pre><code>* A: 自定义类的概述    * java代码映射成现实事物的过程就是定义类的过程。    * 举例：        我们就拿一部手机进行分析，它能用来做什么呢？它可以打电话，上网，聊微信等，这些就是手机所提供的功能，也就是方法；手机也有它的特征，如颜色、尺寸大小、品牌型号等，这些就是手机的特征，也就是属性    * 目前，我们只关注类中的属性，类中的方法在面向对象部分再进行学习。</code></pre><h3 id="03自定义类的格式"><a href="#03自定义类的格式" class="headerlink" title="03自定义类的格式"></a>03自定义类的格式</h3><pre><code>* A: 自定义类的格式    * a: 使用类的形式,对现实中的事物进行描述。    * b: 事物由方法和属性两部分组成。        * 方法: 这个事物具备的功能。        * 属性: 这个事物具备的特征。    * c: 格式        public class 类名{            属性定义              修饰符 数据类型 变量名 = 值            方法定义              修饰符 返回值类型  方法名(参数列表){              }        }</code></pre><h3 id="04自定义的手机类"><a href="#04自定义的手机类" class="headerlink" title="04自定义的手机类"></a>04自定义的手机类</h3><pre><code>* A: 自定义的手机类    * a: 案例代码        public class Phone{            /*                定义手机的属性            */            String color ;            String brand ;            double size ;         }</code></pre><h3 id="05测试手机类"><a href="#05测试手机类" class="headerlink" title="05测试手机类"></a>05测试手机类</h3><p>导包：我们将所有的类放到同一个文件夹下，可以避免导包。</p><p>创建对象：数据类型  变量名 = new 数据类型();</p><p>调用方法：目前我们定义的自定义类不涉及方法，只是属性（自定义类中的方法部分在面向对象部分讲解）<br>访问属性：变量名.属性 (这是当前的方式，后期会采取调用方法的方式替代掉直接访问的方式来完成对属性的访问。)</p><pre><code>* A: 调用方法执行流程    * a: 实现引用类型的步骤        * 1: 导入包 , 类都是在同一个文件夹,不需要导入包        * 2: 创建引用类型的变量        * 3: 变量.类型中的功能    * b: 案例代码        public class TestPhone{            public static void main(String[] args){                // 2: 创建引用类型的变量                Phone p = new Phone();                //System.out.println(p);  //输出内存的地址                 //3: 变量.类型中的功能                //变量 p.的方式,调用类中的属性                //属性就是变量 , 赋值和获取值                p.color = &quot;土豪金&quot;;                p.brand = &quot;爱立信&quot;;                p.size = 5.0;                //获取属性值                System.out.println(p.color+&quot;  &quot;+p.brand+&quot;  &quot;+p.size);            }        }</code></pre><h3 id="06自定义类的内存图-1"><a href="#06自定义类的内存图-1" class="headerlink" title="06自定义类的内存图_1"></a>06自定义类的内存图_1</h3><pre><code>* A: 自定义类的内存图_1</code></pre><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1540864297/java/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="方法调用的内存图"></p><h3 id="07自定义类的内存图-2"><a href="#07自定义类的内存图-2" class="headerlink" title="07自定义类的内存图_2"></a>07自定义类的内存图_2</h3><pre><code>* A: 自定义类的内存图_1</code></pre><h3 id="08两个引用类型变量内存图"><a href="#08两个引用类型变量内存图" class="headerlink" title="08两个引用类型变量内存图"></a>08两个引用类型变量内存图</h3><pre><code>* A: 自定义类的内存图_1</code></pre><p>   <img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1540864298/java/%E4%B8%A4%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="方法调用的内存图"></p><h3 id="09自定义类的练习"><a href="#09自定义类的练习" class="headerlink" title="09自定义类的练习"></a>09自定义类的练习</h3><pre><code>* A: 实体类的代码    /*        电饭锅，包含属性（品牌、容量大小、颜色等）        定义类,描述事物,电饭锅          属性: 品牌,大小 ,颜色        定义类,类名字,电饭锅        类的范围,定义三个属性    */    public class DianFanGuo{        //定义三个属性        String brand ;        double size ;        String color ;    }    /*       汽车，包含属性（品牌、排量、类型等）       定义类,类名 Car         属性 品牌 排量 类型     */    public class Car{        //定义汽车三个属性        String brand ;        double paiLiang ;        String type;    }     /*       学生，包含属性（姓名，年龄，性别等）       定义类,类名Student         三个属性: 姓名,年龄,性别 (char)    */    public class Student{        String name;        int age ;        char sex ;    }* B: 测试类的代码    /*       定义的测试类       同时测试,电饭锅,汽车,学生    */    public class Test{        public static void main(String[] args){            //创建电饭锅引用类型            DianFanGuo dfg = new DianFanGuo();            dfg.brand = &quot;特斯拉&quot;;            dfg.color = &quot;红色&quot;;            dfg.size = 30;            System.out.println(dfg.brand+&quot;  &quot;+dfg.color+&quot;  &quot;+dfg.size);            //创建汽车引用类型            Car c = new Car();            c.brand = &quot;巨力&quot;;            c.type = &quot;拖拉机&quot;;            c.paiLiang = 0.5;            System.out.println(c.brand+&quot;  &quot;+c.type+&quot;  &quot;+c.paiLiang);            //创建学生引用类型            Student stu = new Student();            stu.name = &quot;张三&quot;;            stu.age = 20;            stu.sex = &apos;男&apos;;            System.out.println(stu.name+&quot;  &quot;+stu.age+&quot;  &quot;+stu.sex);        }    }</code></pre><h3 id="10ArrayList创建变量的步骤"><a href="#10ArrayList创建变量的步骤" class="headerlink" title="10ArrayList创建变量的步骤"></a>10ArrayList创建变量的步骤</h3><p>为了保存这些数目不确定的元素，JDK中提供了一系列特殊的类，这些类可以存储任意类型的元素，并且长度可变，统称为集合。在这里，我们先介绍ArrayList集合.<br>导包：import java.util.ArrayList;</p><p><font color="#DD66" size=""> 创建对象：与其他普通的引用数据类型创建方式完全相同，但是要指定容器中存储的数据类型：</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;要存储元素的数据类型&gt;  变量名  =  new  ArrayList&lt;要存储元素的数据类型&gt;();</span><br></pre></td></tr></table></figure><pre><code>* A: ArrayList创建变量的步骤    * a: 导入包 java.util包中    * b: 创建引用类型的变量        数据类型&lt; 集合存储的数据类型&gt;  变量名 = new 数据类型&lt;集合存储的数据类型&gt;();           集合存储的数据类型: 要将数据存储到集合的容器中           创建集合引用变量的时候,必须要指定好,存储的类型是什么    * c: 变量名.方法         注意: 集合存储的数据,8个基本类型对应8个引用类型         存储引用类型,不存储基本类型</code></pre><p><font color="#DD66" size=""><br>“&lt;要存储元素的数据类型&gt;”中的数据类型必须是【引用数据类型】，不能是基本数据类型；<br></font><br>下面给出8种基本数据类型所对应的引用数据类型表示形式:</p><pre><code>基本数据类型        对应的引用数据类型表示形式</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byteByte</span><br><span class="line">shortShort</span><br><span class="line">IntInteger</span><br><span class="line">longLong</span><br><span class="line"><span class="built_in">float</span>Float</span><br><span class="line">doubleDouble</span><br><span class="line">charCharacter</span><br><span class="line">booleanBoolean</span><br></pre></td></tr></table></figure><h3 id="11ArrayList创建变量举例"><a href="#11ArrayList创建变量举例" class="headerlink" title="11ArrayList创建变量举例"></a>11ArrayList创建变量举例</h3><pre><code>* A: ArrayList创建变量的示例代码    import java.util.ArrayList;    public class ArrayListDemo{        public static void main(String[] args){            //创建集合容器,指定存储的数据类型            //存储字符串            ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();            //创建集合容器,存储整数            ArrayList&lt;Integer&gt; array2 = new ArrayList&lt;Integer&gt;();            //创建集合容器,存储手机类型            ArrayList&lt;Phone&gt; array3 = new ArrayList&lt;Phone&gt;();        }    }</code></pre><h3 id="12ArrayList的常见方法"><a href="#12ArrayList的常见方法" class="headerlink" title="12ArrayList的常见方法"></a>12ArrayList的常见方法</h3><pre><code>* A: ArrayList的常见方法    * a: add(参数) 向集合中添加元素    * b: get(int index) 取出集合中的元素,get方法的参数,写入索引    * c: size() 返回集合的长度, 集合存储元素的个数* B: 案例代码    import java.util.ArrayList;    public class ArrayListDemo_1{        public static void main(String[] args){            //定义集合,存储字符串元素            ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();            //调用集合方法add存储元素            array.add(&quot;abc&quot;);            array.add(&quot;itcast&quot;);            array.add(&quot;love&quot;);            array.add(&quot;java&quot;);            //输出集合的长度,调用集合方法size, size方法的返回值类型 int            int size = array.size();            System.out.println(size);            //获取出集合中的一个元素,获取1索引的元素            //集合的方法get, 获取元素后结果数据类型            String s = array.get(1);            System.out.println(s);            System.out.println(array.get(0));            System.out.println(array.get(1));            System.out.println(array.get(2));            System.out.println(array.get(3));        }    }</code></pre><h3 id="13ArrayList集合的遍历"><a href="#13ArrayList集合的遍历" class="headerlink" title="13ArrayList集合的遍历"></a>13ArrayList集合的遍历</h3><pre><code>* A: 案例代码    /*       集合的遍历       实现思想也是索引思想       集合的索引从0开始,到 size()-1       方法get(int index)    */    import java.util.ArrayList;    public class ArrayListDemo_2{        public static void main(String[] args){            ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();            array.add(121);            array.add(125);            array.add(123);            array.add(120);            array.add(128);            //对集合进行遍历            //使用方法 size+get组合进行遍历            for(int i = 0 ; i &lt; array.size(); i++){                System.out.println( array.get(i) );            }        }    }</code></pre><h3 id="14ArrayList补充方法"><a href="#14ArrayList补充方法" class="headerlink" title="14ArrayList补充方法"></a>14ArrayList补充方法</h3><pre><code>* A: ArrayList补充方法    * a: add(int 索引,存储的元素)     将元素添加到指定的索引上    * b: set(int 索引,修改后的元素)     将指定索引的元素,进行修改    * c: remove(int 索引)             删除指定索引上的元素    * d: clear()                     清空集合中的所有元素* B: 案例代码    import java.util.ArrayList;    public class ArrayListDemo_3{        public static void main(String[] args){            ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();            array.add(1);            array.add(2);            array.add(3);            array.add(4);            //在索引2上,添加元素7            array.add(2,7);            //将0索引上的元素,修改成10            array.set(0,10);            //将4索引上的元素,删除            array.remove(4);            array.clear();            //使用方法 size+get组合进行遍历            for(int i = 0 ; i &lt; array.size(); i++){                System.out.println( array.get(i) );            }        }    }</code></pre><h3 id="15随机点名器案例分析"><a href="#15随机点名器案例分析" class="headerlink" title="15随机点名器案例分析"></a>15随机点名器案例分析</h3><pre><code>* A: 随机点名器案例分析    全班同学中随机的找出一名同学，打印这名同学的个人信息。    我们对本案例进行分析，得出如下分析结果：        1.存储全班同学信息（姓名、年龄）            将容器换成集合，集合中存的是Student类型        2.打印全班同学每一个人的信息（姓名、年龄）             遍历集合        3.在班级总人数范围内，随机产生一个随机数，查找该随机数所对应的同学信息（姓名、年龄）        随机点名器明确地分为了三个功能。如果将多个独立功能的代码写到一起，则代码相对冗长，我们可以针对不同的功能可以将其封装到一个方法中，将完整独立的功能分离出来。        而在存储同学姓名时，如果对每一个同学都定义一个变量进行姓名存储，则会出现过多孤立的变量，很难一次性将全部数据持有。此时，我们采用ArrayList集合来解决多个学生信息的存储问题</code></pre><h3 id="16随机点名器代码实现"><a href="#16随机点名器代码实现" class="headerlink" title="16随机点名器代码实现"></a>16随机点名器代码实现</h3><pre><code>* A: 随机点名器案例代码    /*       随机点名器,集合改进 (学生的姓名和年龄)       现实中有学生这个事物,使用定义类的形式,描述学生事物       属性: 姓名,年龄       姓名存储了数组, 将容器换成是集合       String[] s = {&quot;&quot;,&quot;&quot;};       集合中,存储的是学生的姓名吗?  应该存储Student类型       存储学生:          学生类型,存储到集合中       总览: 遍历集合       随机: 随机数,作为索引,到集合中找到元素       三个功能,共享的数据,集合容器,       定义三个方法,必须参数传递集合    */    import java.util.ArrayList;    import java.util.Random;    public class CallName{        public static void main(String[] args){            //定义集合,存储的是StudentName类型变量            ArrayList &lt;StudentName&gt; array = new ArrayList&lt;StudentName&gt;();            //调用添加方法            add (array);            //调用遍历集合            printArrayList(array);            randomStudentName(array);        }        /*          随机数,当作集合的索引,到集合中找到元素        */        public static void randomStudentName(ArrayList&lt;StudentName&gt; array ){            Random r = new Random();            int number = r.nextInt( array.size());            //随机数,索引,到集合中get            StudentName s = array.get(number);            System.out.println( s.name +&quot;  &quot;+s.age);        }        /*            总览学生的信息,遍历集合        */        public static void printArrayList(ArrayList&lt;StudentName&gt; array){            for(int i = 0 ; i &lt; array.size();i++){                //存储集合的时候, 集合.add(sn1)  sn1 是StudentName类型变量                //获取的时候,集合.get方法,获取出来的是什么, 还是StudentName类型变量                StudentName s = array.get(i);                System.out.println(s.name+&quot;  &quot;+s.age);            }        }        /*           定义方法,实现存储学生的姓名和年龄           创建StudentName类型变量,存储到集合中        */        public static void add (ArrayList&lt;StudentName&gt; array){            //创建StudentName类型变量            StudentName sn1 = new StudentName();            StudentName sn2 = new StudentName();            StudentName sn3 = new StudentName();            StudentName sn4 = new StudentName();            StudentName sn5 = new StudentName();            sn1.name = &quot;张三1&quot;;            sn1.age = 201;            sn2.name = &quot;张三2&quot;;            sn2.age = 202;            sn3.name = &quot;张三3&quot;;            sn3.age = 203;            sn4.name = &quot;张三4&quot;;            sn4.age = 204;            sn5.name = &quot;张三5&quot;;            sn5.age = 205;            //将StudentName变量,存储到集合中            array.add(sn1);            array.add(sn2);            array.add(sn3);            array.add(sn4);            array.add(sn5);        }    }</code></pre><h3 id="17库存案例分析加入集合"><a href="#17库存案例分析加入集合" class="headerlink" title="17库存案例分析加入集合"></a>17库存案例分析加入集合</h3><pre><code>* A: 库存案例分析加入集合    * a: 参见\day06\day06(面向对象\day06_source\对象内存图.JPG</code></pre><h3 id="18库存案例添加商品信息"><a href="#18库存案例添加商品信息" class="headerlink" title="18库存案例添加商品信息"></a>18库存案例添加商品信息</h3><pre><code>* A: 案例代码    /*       定义,.描述商品的类       商品 4个属性         商品名字  大小     价格    库存          String    double   double  int        定义类,类名Goods        这个类型的变量,存储到集合中    */    public class Goods{        //定义商品名字        String brand ;        //大小属性        double size ;        // 价格属性        double price ;        //库存属性        int count ;    }    /*        实现库存管理案例:          1.存储商品信息            存储商品类型变量            将商品类型的变量,存储到集合中    */    //import java.util.ArrayList;    import java.util.*;    public class Shopp{        public static void main(String[] args){            //创建ArrayList集合,存储Goods类型            ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();            //调用添加商品信息的方法            addGoods(array);        }        /*           定义方法,将商品的信息存储到集合中           集合是所有方法的共享数据,参数传递        */        public static void addGoods (ArrayList&lt;Goods&gt; array){            //创建商品类型变量 Goods类型的变量            Goods g1 = new Goods();            Goods g2 = new Goods();            g1.brand = &quot;MacBook&quot;;            g1.size = 13.3;            g1.price = 9999.99;            g1.count = 3;            g2.brand = &quot;Thinkpad&quot;;            g2.size = 15.6;            g2.price = 7999.99;            g2.count = 1;            //Goods类型的变量,存储到集合中            array.add(g1);            array.add(g2);        }    }</code></pre><h3 id="19库存案例查看库存清单"><a href="#19库存案例查看库存清单" class="headerlink" title="19库存案例查看库存清单"></a>19库存案例查看库存清单</h3><pre><code>* A: 案例代码    /*        实现库存管理案例:          1.存储商品信息            存储商品类型变量            将商品类型的变量,存储到集合中          2.查看库存清单            将集合进行遍历, 获取出集合中存储的Goods类型变量            输出每一个Goods类型的属性            计算求和: 总库存,总金额    */    //import java.util.ArrayList;    import java.util.*;    public class Shopp{        public static void main(String[] args){            //创建ArrayList集合,存储Goods类型            ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();            //调用添加商品信息的方法            addGoods(array);        }        /*           定义方法,查看库存清单,遍历集合        */        public static void printStore(ArrayList&lt;Goods&gt; array){            //输出表头            System.out.println(&quot;----------商场库存清单----------&quot;);            System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);            //定义变量,保存总库存数,和总金额            int totalCount = 0 ;            double totalMoney = 0;            //遍历集合            for(int i = 0 ; i &lt; array.size(); i++){                //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型                //使用Goods类型变量,接受get方法结果                Goods g = array.get(i);                System.out.println(g.brand+&quot;   &quot;+g.size+&quot;    &quot;+g.price+&quot;    &quot;+g.count);                totalCount = totalCount+g.count;                totalMoney = totalMoney + g.count*g.price;            }            System.out.println(&quot;总库存数: &quot;+totalCount);            System.out.println(&quot;商品库存总金额: &quot;+totalMoney);        }        /*           定义方法,将商品的信息存储到集合中           集合是所有方法的共享数据,参数传递        */        public static void addGoods (ArrayList&lt;Goods&gt; array){            //创建商品类型变量 Goods类型的变量            Goods g1 = new Goods();            Goods g2 = new Goods();            g1.brand = &quot;MacBook&quot;;            g1.size = 13.3;            g1.price = 9999.99;            g1.count = 3;            g2.brand = &quot;Thinkpad&quot;;            g2.size = 15.6;            g2.price = 7999.99;            g2.count = 1;            //Goods类型的变量,存储到集合中            array.add(g1);            array.add(g2);        }    }</code></pre><h3 id="20库存案例修改库存清单及测试代码的实现"><a href="#20库存案例修改库存清单及测试代码的实现" class="headerlink" title="20库存案例修改库存清单及测试代码的实现"></a>20库存案例修改库存清单及测试代码的实现</h3><pre><code>* A: 案例代码    /*        实现库存管理案例:          1.存储商品信息            存储商品类型变量            将商品类型的变量,存储到集合中          2.查看库存清单            将集合进行遍历, 获取出集合中存储的Goods类型变量            输出每一个Goods类型的属性            计算求和: 总库存,总金额         3.修改商品的库存            集合遍历 ,获取出集合中存储的Goods类型变量            变量调用Goods类的属性count,值进行修改 (键盘输入)    */    //import java.util.ArrayList;    import java.util.*;    public class Shopp{        public static void main(String[] args){            //创建ArrayList集合,存储Goods类型            ArrayList&lt;Goods&gt; array = new ArrayList&lt;Goods&gt;();            //调用添加商品信息的方法            addGoods(array);            //进入死循环中            while(true){                //调用选择功能的方法,获取到用户输入的功能序号                int number = chooseFunction();                //对序号判断,如果=1 进入查看库存功能  = 2 进入修改库存功能  =3 结束                switch(number){                    case 1:                    //进入查看库存,调用查看库存的方法,传递存储商品信息的集合                    printStore(array);                    break;                    case 2:                    //进入修改库存功能,调用修改库存的方法,传递集合                    update(array);                    break;                    case 3:                    return ;                    default:                     System.out.println(&quot;无此功能&quot;);                     break;                }            }        }        /*          方法定义,修改库存          键盘的输入,将Goods中的属性值,修改        */        public static void update(ArrayList&lt;Goods&gt; array){            Scanner sc = new Scanner(System.in);            //遍历集合,获取集合中的每个元素            for(int i = 0 ;  i &lt; array.size(); i++){                //集合方法get获取的是集合的元素,元素类型Goods                Goods g = array.get(i);                System.out.println(&quot;请输入&quot;+g.brand+&quot;的库存数&quot;);                //Goods属性,count进行修改                g.count = sc.nextInt();            }        }        /*           定义方法,实现选择菜单,用户根据功能选择菜单        */        public static int chooseFunction(){            System.out.println(&quot;-------------库存管理------------&quot;);            System.out.println(&quot;1.查看库存清单&quot;);            System.out.println(&quot;2.修改商品库存数量&quot;);            System.out.println(&quot;3.退出&quot;);            System.out.println(&quot;请输入要执行的操作序号：&quot;);            Scanner sc = new Scanner(System.in);            int number = sc.nextInt();            return number;        }        /*           定义方法,查看库存清单,遍历集合        */        public static void printStore(ArrayList&lt;Goods&gt; array){            //输出表头            System.out.println(&quot;----------商场库存清单----------&quot;);            System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);            //定义变量,保存总库存数,和总金额            int totalCount = 0 ;            double totalMoney = 0;            //遍历集合            for(int i = 0 ; i &lt; array.size(); i++){                //get(索引)获取出集合中的元素,存储的是Goods类,获取的也是Goods类型                //使用Goods类型变量,接受get方法结果                Goods g = array.get(i);                System.out.println(g.brand+&quot;   &quot;+g.size+&quot;    &quot;+g.price+&quot;    &quot;+g.count);                totalCount = totalCount+g.count;                totalMoney = totalMoney + g.count*g.price;            }            System.out.println(&quot;总库存数: &quot;+totalCount);            System.out.println(&quot;商品库存总金额: &quot;+totalMoney);        }        /*           定义方法,将商品的信息存储到集合中           集合是所有方法的共享数据,参数传递        */        public static void addGoods (ArrayList&lt;Goods&gt; array){            //创建商品类型变量 Goods类型的变量            Goods g1 = new Goods();            Goods g2 = new Goods();            g1.brand = &quot;MacBook&quot;;            g1.size = 13.3;            g1.price = 9999.99;            g1.count = 3;            g2.brand = &quot;Thinkpad&quot;;            g2.size = 15.6;            g2.price = 7999.99;            g2.count = 1;            //Goods类型的变量,存储到集合中            array.add(g1);            array.add(g2);        }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1540864054/java/photo-1540543144-2570163afee1.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、自定义类型的定义及使用&lt;br&gt;2、自定义类的内存图&lt;br&gt;3、ArrayList集合的基本功能&lt;br&gt;4、随机点名器案例及库存案例代码优化&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础5</title>
    <link href="https://leesen998.github.io/2016/10/08/day05%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/08/day05笔记/</id>
    <published>2016-10-08T13:41:53.000Z</published>
    <updated>2018-10-24T07:49:00.325Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540280034/samples/java%20files/ChMkJ1or0PmIahOGABoj0mukBisAAi_rwBK9FkAGiPq398.jpg" alt="" style="width:100%"></p><p>1、方法基础知识<br>2、方法高级内容<br>3、方法案例</p><a id="more"></a><h3 id="01方法的概述"><a href="#01方法的概述" class="headerlink" title="01方法的概述"></a>01方法的概述</h3><pre><code>* A: 为什么要有方法    * 提高代码的复用性 * B: 什么是方法    * 完成特定功能的代码块。 </code></pre><h3 id="02方法的定义格式"><a href="#02方法的定义格式" class="headerlink" title="02方法的定义格式"></a>02方法的定义格式</h3><pre><code>* A: 方法的格式*         修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {            方法体语句;            return 返回值;         } * B: 方法的格式说明    * 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。    * 返回值类型：就是功能结果的数据类型。    * 方法名：符合命名规则即可。方便我们的调用。    * 参数：        * 实际参数：就是实际参与运算的。        * 形式参数；就是方法定义上的，用于接收实际参数的。    * 参数类型：就是参数的数据类型    * 参数名：就是变量名    * 方法体语句：就是完成功能的代码。    * return：结束方法的。    * 返回值：就是功能的结果，由return带给调用者。 </code></pre><h3 id="03定义方法计算面积"><a href="#03定义方法计算面积" class="headerlink" title="03定义方法计算面积"></a>03定义方法计算面积</h3><pre><code>* A: 定义方法计算面积    public class MethodDemo{        public static void main(String[] args){             //调用方法, 方法执行起来             // 在方法main中,调用方法 getArea             int area = getArea(5,6);             System.out.println(&quot;面积是: &quot;+area);        }        /*           要求: 计算一个长方形的面积           定义方法解决这个要求           分析方法定义过程:              1.明确方法计算后的结果的数据类型 int  定义格式对应的就是返回值类型              2.方法计算过程中,有没有未知的数据, 宽和长, 未知数据的数据类型 int                  未知数的变量,定义在方法的小括号内        */        public static int  getArea(int w, int h){            //实现方法的功能主体            //int area = w * h;            return w * h;        }    }</code></pre><h3 id="04调用方法"><a href="#04调用方法" class="headerlink" title="04调用方法"></a>04调用方法</h3><pre><code>* A: 调用方法    * a: 在main函数中调用方法，让方法执行起来    * b: 方法的形参        * 方法要什么参数我们就给什么类型的参数。    * c: 方法的返回值        * 方法返回什么类型的值我们就用对应的数据类型的变量来接收</code></pre><h3 id="05调用方法执行流程"><a href="#05调用方法执行流程" class="headerlink" title="05调用方法执行流程"></a>05调用方法执行流程</h3><pre><code>* A: 调用方法执行流程    * a: 方法的定义是没有顺序的，写在main函数的上边或者下边都可以。    * b: 方法的执行，是把实参传递给形参，从而来执行的。    * c: 方法只有被调用才会执行。</code></pre><h3 id="06方法调用的内存图"><a href="#06方法调用的内存图" class="headerlink" title="06方法调用的内存图"></a>06方法调用的内存图</h3><ul><li>A: 方法调用的内存图<br><img src="https://res.cloudinary.com/leesen/image/upload/v1540350598/samples/java%20files/day05/%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="方法调用的内存图"></li></ul><h3 id="07方法调用的练习"><a href="#07方法调用的练习" class="headerlink" title="07方法调用的练习"></a>07方法调用的练习</h3><pre><code>* A: 案例代码    /*       方法的定义练习    */    import java.util.Scanner;    public class MethodDemo_1{        public static void main(String[] args){            //printRect();            //int number = getNumber();            //System.out.println(getNumber());            //printRect2(3,5);            double avg = getAvg(2,2,3);            System.out.println(avg);        }        /*           定义有返回值有参数方法，如求三个数的平均值           明确方法计算后的数据类型, 返回值类型 double           明确方法未知数, 三个未知的整数        */        public static double getAvg(double a, double b,double c){             return (a+b+c)/3;        }        /*            定义无返回值有参数方法，如打印指定M行，每行N个*号的矩形            明确方法计算后结果,控制台输出图形,没有返回值的            方法中有没有未知数,图形行数,和列数,是未知的, 数据类型整数int        */        public static void printRect2(int m,int n){            for(int i = 0 ; i &lt; m ; i++){                for(int j = 0 ; j &lt; n ;  j++){                    System.out.print(&quot;*&quot;);                }                System.out.println();            }        }        /*           定义有返回值无参数方法，如键盘录入得到一个整数           明确方法计算后结果的数据类型 int           明确有没有未知数,没        */        public static int getNumber(){            Scanner sc = new Scanner(System.in);            //int number = sc.nextInt();            return sc.nextInt();        }        /*           定义无返回值无参数方法，如打印3行，每行3个*号的矩形           为什么没有返回值:               打印矩形 ,输出效果,不需要将结果返回               明确未知数: 不需要未知数        */        public static void printRect(){            for(int i = 0 ; i &lt; 3 ; i++){                for(int j = 0 ; j &lt; 3 ;j++){                    System.out.print(&quot;*&quot;);                }                System.out.println();            }        }    }</code></pre><h3 id="08方法的定义和使用的注意事项"><a href="#08方法的定义和使用的注意事项" class="headerlink" title="08方法的定义和使用的注意事项"></a>08方法的定义和使用的注意事项</h3><pre><code>* A: 方法的定义和使用的注意事项    * a: 方法不能定义在另一个方法的里面     * b: 写错方法名字    * c: 写错了参数列表    * d: 方法返回值是void,方法中可以省略return 不写         return 下面不能有代码    * e 方法返回值类型,和return 后面数据类型必须匹配    * f: 方法重复定义问题    * g: 调用方法的时候,返回值是void, 不能写在输出语句中</code></pre><h3 id="09方法的重载"><a href="#09方法的重载" class="headerlink" title="09方法的重载"></a>09方法的重载</h3><pre><code>* A: 方法的重载    * 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。    * 参数列表不同：        * A:参数个数不同        * B:参数类型不同        * C:参数的顺序不同(算重载,但是在开发中不用)* B: 案例代码    public static int getSum(int a,int b){        System.out.println(&quot;两个int参数&quot;);        return a+b;    }    public static int getSum(int a,int b,int c){        System.out.println(&quot;三个int参数&quot;);        return a+b+c;    }    public static double getSum(double a,double b){        System.out.println(&quot;两个double参数&quot;);        return a+b;    }</code></pre><h3 id="10方法重载注意事项"><a href="#10方法重载注意事项" class="headerlink" title="10方法重载注意事项"></a>10方法重载注意事项</h3><pre><code>* A: 方法重载注意事项    * a: 参数列表必须不同    * b: 重载和参数变量名无关    * c: 重载和返回值类型无关    * d: 重载和修饰符无关    * e: 技巧: 重载看方法名和参数列表</code></pre><h3 id="11方法参数是基本数据类型"><a href="#11方法参数是基本数据类型" class="headerlink" title="11方法参数是基本数据类型"></a>11方法参数是基本数据类型</h3><pre><code>* A: 方法参数是基本数据类型    * a: 方法参数是基本类型时，传递的是值。    * </code></pre><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540350597/samples/java%20files/day05/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%98%AF%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" alt="基本数据类型"></p><h3 id="12方法参数是引用数据类型"><a href="#12方法参数是引用数据类型" class="headerlink" title="12方法参数是引用数据类型"></a>12方法参数是引用数据类型</h3><pre><code>* A: 方法参数是引用数据类型    * a: 方法参数是引用类型时，传递的是内存地址值。</code></pre><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540350598/samples/java%20files/day05/%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" alt="引用数据类型">        </p><h3 id="13随机点名器"><a href="#13随机点名器" class="headerlink" title="13随机点名器"></a>13随机点名器</h3><pre><code>* A: 案例代码    /*       实现随机点名器         1.存储所有学生姓名         2.预览所有学生姓名,遍历数组         3.随机数作为索引,到数组中找元素        将功能独立出来, 作成方法,调用方法即可        定义三个功能, 用到同一个姓名数据        姓名存储到数组中,三个方法,使用一个数组中的数据, 方法传递参数    */    import java.util.Random;    public class CallName{        public static void main(String[] args){            //定义数组,存储学生姓名            String[] names = new String[8];            //调用添加姓名方法            addStudent(names);            //调用遍历数组方法            printStudentName(names);            //调用随机姓名的方法            String name = randomStudentName(names);            System.out.println(name);        }        /*          定义方法,随机数,做索引,数组中找到学生姓名          返回值?  学生姓名          参数?  数组        */        public static String randomStudentName(String[] names){            Random ran = new Random();            int index = ran.nextInt(names.length);            return names[index];        }        /*           定义方法,遍历数组           返回值? 没有           参数? 数组        */        public static void printStudentName(String[] names){            for(int i = 0 ; i &lt; names.length ;i++){                System.out.println(names[i]);            }        }        /*           定义方法,实现向数组中添加学生姓名           返回值? 没有,           参数?  参数就是数组        */        public static void addStudent(String[] names){            names[0] = &quot;张三&quot;;            names[1] = &quot;李四&quot;;            names[2] = &quot;王五&quot;;            names[3] = &quot;李蕾&quot;;            names[4] = &quot;韩梅梅&quot;;            names[5] = &quot;小名&quot;;            names[6] = &quot;老王&quot;;            names[7] = &quot;小华&quot;;        }    }</code></pre><h3 id="14库存案例代码实现-1"><a href="#14库存案例代码实现-1" class="headerlink" title="14库存案例代码实现_1"></a>14库存案例代码实现_1</h3><pre><code>* A: 案例代码    /*       实现商品的库存管理         功能:            1.展示用户选择功能清单            2.根据选择的功能编号,进行不同的操作               A. 展示所有库存               B. 修改库存数量          分析:            1.展示用户清单:               输出语句, 用户输入, 选择功能序号            2.根据选择,调用不同的方法                switch语句                  case 1 2 3               A  展示库存                 将存储商品的数组,遍历               B  修改库存                  修改所有的库存数量    */    import java.util.Scanner;    public class Shopp{        public static void main(String[] args){        }        /*           定义方法,展示所有的库存清单,遍历           返回值,没有           参数, 数组        */        public static void printStore(String[] brand,double[] size,double[] price,int[] count){            System.out.println(&quot;----------商场库存清单----------&quot;);            System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);            //定义变量,计算总库存数,和总价格            int totalCount = 0;            int totalMoney = 0;            //遍历数组,将数组中所有的商品信息打印出来            for(int i = 0 ; i &lt; brand.length ; i++){                System.out.println(brand[i]+&quot;   &quot;+size[i]+&quot;    &quot;+price[i]+&quot;   &quot;+count[i]);                totalCount += count[i];                totalMoney += count[i]*price[i];            }            System.out.println(&quot;总库存数: &quot;+totalCount);            System.out.println(&quot;商品库存总金额: &quot;+totalMoney);        }        /*          定义方法,实现用户的选择功能,功能的需要返回来          返回值, int          参数, 没有        */        public static int chooseFunction(){            System.out.println(&quot;-------------库存管理------------&quot;);            System.out.println(&quot;1.查看库存清单&quot;);            System.out.println(&quot;2.修改商品库存数量&quot;);            System.out.println(&quot;3.退出&quot;);            System.out.println(&quot;请输入要执行的操作序号：&quot;);            //接受键盘输入            Scanner sc = new Scanner(System.in);            int chooseNumber = sc.nextInt();            return chooseNumber;        }    }</code></pre><h3 id="15库存案例代码实现-2"><a href="#15库存案例代码实现-2" class="headerlink" title="15库存案例代码实现_2"></a>15库存案例代码实现_2</h3><pre><code>* A: 案例代码    /*      定义方法,修改所有商品的库存        用户输入1个,修改1个        返回值,没有        参数, 库存数的数组, 品名数组    */    public static void update(String[] brand, int[] count){        //遍历数组,遍历到一个,修改一个        //接受键盘输入        Scanner sc = new Scanner(System.in);        //遍历数组        for(int i = 0; i &lt; brand.length ; i++){            System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;);            //键盘输入,录入库存, 存储到库存的数组中            int newCount = sc.nextInt();            count[i] = newCount;        }        //int chooseNumber = sc.nextInt();    }</code></pre><h3 id="16库存案例代码测试"><a href="#16库存案例代码测试" class="headerlink" title="16库存案例代码测试"></a>16库存案例代码测试</h3><pre><code>* A: 案例    /*       实现商品的库存管理         功能:            1.展示用户选择功能清单            2.根据选择的功能编号,进行不同的操作               A. 展示所有库存               B. 修改库存数量          分析:            1.展示用户清单:               输出语句, 用户输入, 选择功能序号            2.根据选择,调用不同的方法                switch语句                  case 1 2 3               A  展示库存                 将存储商品的数组,遍历               B  修改库存                  修改所有的库存数量    */    import java.util.Scanner;    public class Shopp{        public static void main(String[] args){            //使用数组,保存商品的信息            //品名,尺寸,价格,库存数, 定义5个数组            String[] brand = {&quot;MacBookAir&quot;,&quot;ThinkpadT450&quot;};            double[] size = {13.3,15.6};            double[] price = {9998.97,6789.56};            int[] count = {0,0};            while(true){                int choose = chooseFunction();                switch(choose){                    case 1:                      //调用查看库存清单方法                      printStore(brand,size,price,count);                    break;                    case 2:                      //调用修改库存的方法                      update(brand,count);                    break;                    case 3:                     return ;                    default:                      System.out.println(&quot;没有这个功能&quot;);                    break;                }            }        }        /*          定义方法,修改所有商品的库存            用户输入1个,修改1个            返回值,没有            参数, 库存数的数组, 品名数组        */        public static void update(String[] brand, int[] count){            //遍历数组,遍历到一个,修改一个            //接受键盘输入            Scanner sc = new Scanner(System.in);            //遍历数组            for(int i = 0; i &lt; brand.length ; i++){                System.out.println(&quot;请输入&quot;+brand[i]+&quot;的库存数&quot;);                //键盘输入,录入库存, 存储到库存的数组中                int newCount = sc.nextInt();                count[i] = newCount;            }            //int chooseNumber = sc.nextInt();        }        /*           定义方法,展示所有的库存清单,遍历           返回值,没有           参数, 数组        */        public static void printStore(String[] brand,double[] size,double[] price,int[] count){            System.out.println(&quot;----------商场库存清单----------&quot;);            System.out.println(&quot;品牌型号     尺寸    价格    库存数&quot;);            //定义变量,计算总库存数,和总价格            int totalCount = 0;            int totalMoney = 0;            //遍历数组,将数组中所有的商品信息打印出来            for(int i = 0 ; i &lt; brand.length ; i++){                System.out.println(brand[i]+&quot;   &quot;+size[i]+&quot;    &quot;+price[i]+&quot;   &quot;+count[i]);                totalCount += count[i];                totalMoney += count[i]*price[i];            }            System.out.println(&quot;总库存数: &quot;+totalCount);            System.out.println(&quot;商品库存总金额: &quot;+totalMoney);        }        /*          定义方法,实现用户的选择功能,功能的需要返回来          返回值, int          参数, 没有        */        public static int chooseFunction(){            System.out.println(&quot;-------------库存管理------------&quot;);            System.out.println(&quot;1.查看库存清单&quot;);            System.out.println(&quot;2.修改商品库存数量&quot;);            System.out.println(&quot;3.退出&quot;);            System.out.println(&quot;请输入要执行的操作序号：&quot;);            //接受键盘输入            Scanner sc = new Scanner(System.in);            int chooseNumber = sc.nextInt();            return chooseNumber;        }    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/leesen/image/upload/v1540280034/samples/java%20files/ChMkJ1or0PmIahOGABoj0mukBisAAi_rwBK9FkAGiPq398.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、方法基础知识&lt;br&gt;2、方法高级内容&lt;br&gt;3、方法案例&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础4</title>
    <link href="https://leesen998.github.io/2016/10/04/day04%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/04/day04笔记/</id>
    <published>2016-10-04T08:41:53.000Z</published>
    <updated>2018-10-24T03:01:52.648Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540280255/samples/java%20files/photo-1537967371577-a17d31d7035f.jpg" alt="" style="width:100%"></p><p>1、流程控制语句switch<br>2、数组<br>3、随机点名器案例</p><a id="more"></a><h3 id="01switch语句解构"><a href="#01switch语句解构" class="headerlink" title="01switch语句解构"></a>01switch语句解构</h3><pre><code>* A:switch语句解构      * a:switch只能针对某个表达式的值作出判断，从而决定程序执行哪一段代码。    * b:格式如下:          swtich(表达式){              case 常量1 :                要执行的语句;              break;              case 常量2 :                要执行的语句;              break;              case 常量3 :                要执行的语句;              break;              default:                要执行的语句;              break;          }    * c: 执行流程:  表达式,和case后面的常量进行比较和哪个case后的常量相同,就执行哪个case后面的程序,遇到break,就全结束    * d: 关键字: switch case default break      * e:举例        如果等于1，则输出星期一        如果等于2，则输出星期二        如果等于3，则输出星期三        如果等于4，则输出星期四        如果等于5，则输出星期五        如果等于6，则输出星期六        如果等于7，则输出星期天</code></pre><h3 id="02switch语句的星期判断"><a href="#02switch语句的星期判断" class="headerlink" title="02switch语句的星期判断"></a>02switch语句的星期判断</h3><pre><code>* A: switch语句的星期判断    * a: 明确需求        需求:初始化int类型变量(1-7)代表星期几,使用switch语句进行判断,并打印出该整数对应的星期.    * b: 代码实现         public class SwitchDemo01 {            public static void main(String[] args) {                int week = 5;                switch (week) {                case 1:                    System.out.println(&quot;星期一&quot;);                    break;                case 2:                    System.out.println(&quot;星期二&quot;);                    break;                case 3:                    System.out.println(&quot;星期三&quot;);                    break;                case 4:                    System.out.println(&quot;星期四&quot;);                    break;                case 5:                    System.out.println(&quot;星期五&quot;);                    break;                case 6:                    System.out.println(&quot;星期六&quot;);                    break;                case 7:                    System.out.println(&quot;星期天&quot;);                    break;                default:                    System.out.println(&quot;输入的数字不正确...&quot;);                    break;                }            }        }</code></pre><h3 id="03switch语句接受的数据类型"><a href="#03switch语句接受的数据类型" class="headerlink" title="03switch语句接受的数据类型"></a>03switch语句接受的数据类型</h3><pre><code>* A: switch语句接受的数据类型    * a:注意事项        switch语句中的表达式的数据类型,是有要求的        JDK1.0 - 1.4  数据类型接受 byte short int char        JDK1.5   数据类型接受 byte short int char enum(枚举)        JDK1.7   数据类型接受 byte short int char enum(枚举), String    </code></pre><h3 id="04case穿透"><a href="#04case穿透" class="headerlink" title="04case穿透"></a>04case穿透</h3><pre><code>* A:case穿透    * a: 在使用switch语句的过程中，如果多个case条件后面的执行语句是一样的，则该执行语句只需书写一次即可，这是一种简写的方式。    * b: 例如，要判断一周中的某一天是否为工作日，同样使用数字1~7来表示星期一到星期天，当输入的数字为1、2、3、4、5时就视为工作日，否则就视为休息日。    * 注意：case 语句后面 没有break 就会一直穿透下去。</code></pre><h3 id="05数组的概述"><a href="#05数组的概述" class="headerlink" title="05数组的概述"></a>05数组的概述</h3><pre><code>* A: 数组的概述    * a:数组的需求        现在需要统计某公司员工的工资情况，例如计算平均工资、最高工资等。假设该公司有50名员工，用前面所学的知识完成，        那么程序首先需要声明50个变量来分别记住每位员工的工资，这样做会显得很麻烦.     * b:数组的概述         数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。</code></pre><h3 id="06数组的定义"><a href="#06数组的定义" class="headerlink" title="06数组的定义"></a>06数组的定义</h3><pre><code>* A：数组的定义* b:格式:         数据类型[] 数组名 = new 数据类型[元素个数或数组长度];    * c:举例:        int[] x = new int[100];* c:要点说明      1)数据类型: 数组中存储元素的数据类型    2) [] 表示数组的意思    3) 变量名  自定义标识符      4) new  创建容器关键字    5)数据类型: 数组中存储元素的数据类型    6)[]  表示数组的意思    7)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长)    数组是一个容器: 存储到数组中的每个元素,都有自己的自动编号    自动编号,最小值是0, 最大值,长度-1    自动编号专业名次, 索引(index), 下标, 角标    访问数组存储的元素,必须依赖于索引, 公式 数组名[索引]    Java提供一个属性,操作索引的    数组的一个属性,就是数组的长度, 属性的名字 length    使用属性:  数组名.length  数据类型 int    数组的最小索引是0, 最大索引数组.length-1</code></pre><h3 id="07JVM内存划分"><a href="#07JVM内存划分" class="headerlink" title="07JVM内存划分"></a>07JVM内存划分</h3><pre><code>* A：内存划分* JVM对自己的内存划分为5个区域      * a: 寄存器:内存和CUP之间      * b: 本地方法栈: JVM调用了系统中的功能      * c: 方法和数据共享: 运行时期class文件进入的地方      * d: 方法栈:所有的方法运行的时候进入内存      * e: 堆:存储的是容器和对象</code></pre><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540278233/samples/java%20files/JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.jpg" alt="&quot;JVM内存划分&quot;"></p><h3 id="08数组的内存"><a href="#08数组的内存" class="headerlink" title="08数组的内存"></a>08数组的内存</h3><pre><code>* A: 数组的内存* int[] x;                    // 声明一个int[]类型的变量*    x = new int[100];        // 创建一个长度为100的数组*    接下来，通过两张内存图来详细地说明数组在创建过程中内存的分配情况。*    第一行代码 int[] x; 声明了一个变量x，该变量的类型为int[]，即一个int类型的数组。变量x会占用一块内存单元，它没有被分配初始值*    第二行代码 x = new int[100]; 创建了一个数组，将数组的地址赋值给变量x。在程序运行期间可以使用变量x来引用数组，这时内存中的状态会发生变化*    引用数据类型 存的是变量的地址</code></pre><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540278233/samples/java%20files/%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="数组的内存"></p><h3 id="09使用索引访问数组的元素"><a href="#09使用索引访问数组的元素" class="headerlink" title="09使用索引访问数组的元素"></a>09使用索引访问数组的元素</h3><pre><code>* A: 使用索引访问数组的元素    * 组中有100个元素，初始值都为0。数组中的每个元素都有一个索引(也可称为角标)，要想访问数组中的元素可以通过“x[0]、x[1]、……、x[98]、x[99]”的形式。    * 需要注意的是，数组中最小的索引是0，最大的索引是“数组的长度-1”</code></pre><h3 id="10数组的length属性"><a href="#10数组的length属性" class="headerlink" title="10数组的length属性"></a>10数组的length属性</h3><pre><code>* A: lenth属性    * a 在Java中，为了方便我们获得数组的长度，提供了一个length属性，在程序中可以通过“数组名.length”的方式来获得数组的长度，即元素的个数。    * b 求数组的长度        public class ArrayDemo01 {             public static void main(String[] args) {                 int[] arr; // 声明变量                 arr = new int[3]; // 创建数组对象                 System.out.println(&quot;arr[0]=&quot; + arr[0]); // 访问数组中的第一个元素                 System.out.println(&quot;arr[1]=&quot; + arr[1]); // 访问数组中的第二个元素                 System.out.println(&quot;arr[2]=&quot; + arr[2]); // 访问数组中的第三个元素                 System.out.println(&quot;数组的长度是：&quot; + arr.length); // 打印数组长度             }         }</code></pre><h3 id="11为数组的元素赋值"><a href="#11为数组的元素赋值" class="headerlink" title="11为数组的元素赋值"></a>11为数组的元素赋值</h3><pre><code>* A: 为数组的元素赋值    * a: 如果在使用数组时，不想使用这些默认初始值，也可以显式地为这些元素赋值。    *     赋值过的元素已经变为新的数值,没有赋值的元素默认初始化的数值    * b: 案例         public class ArrayDemo02 {             public static void main(String[] args) {                 int[] arr = new int[4]; // 定义可以存储4个整数的数组                 arr[0] = 1; // 为第1个元素赋值1                 arr[1] = 2; // 为第2个元素赋值2                 // 下面的代码是打印数组中每个元素的值                 System.out.println(&quot;arr[0]=&quot; + arr[0]);                 System.out.println(&quot;arr[1]=&quot; + arr[1]);                 System.out.println(&quot;arr[2]=&quot; + arr[2]);                System.out.println(&quot;arr[3]=&quot; + arr[3]);             }         }</code></pre><h3 id="12数组的定义-2"><a href="#12数组的定义-2" class="headerlink" title="12数组的定义_2"></a>12数组的定义_2</h3><pre><code>* A: 定义数组格式2    * a: 数组初始化        动态初始化 : 在定义数组时只指定数组的长度，由系统自动为元素赋初值的方式称作动态初始化。        1、类型[] 数组名 = new 类型[长度];        int[] arr = new int[4];        静态初始化: 在初始化数组时还有一种方式叫做静态初始化，就是在定义数组的同时就为数组的每个元素赋值。        2、类型[] 数组名 = new 类型[]{元素，元素，……};        int[] arr = new int[]{1,2,3,4};        使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。 例如：        arr = new int[] { 17, 19, 23, 29, 31, 37 };        3、类型[] 数组名 = {元素，元素，元素，……};             int[] arr = { 1, 2, 3, 4 };    * 数组拷贝        int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };        int[] luckyNumbers = smallPrimes;</code></pre><font color="#DD66" size=""><br>如果希望将一个数组的所有值拷贝到一个新的数组中去，<br>就要使用 Arrays 类的 copyOf方法：<br></font>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length) ;</span><br><span class="line">//第 2 个参数是新数组的长度。这个方法通常用来增加数组的大小</span><br><span class="line">luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);</span><br></pre></td></tr></table></figure><font color="#DD66" size=""><br>如果数组元素是数值型，那么多余的元素将被赋值为 0 ; 如果数组元素是布尔型， 则将赋值<br>为 false。相反， 如果长度小于原始数组的长度，则只拷贝最前面的数据元素。<br></font>    <h3 id="13遍历数组"><a href="#13遍历数组" class="headerlink" title="13遍历数组"></a>13遍历数组</h3><pre><code>* A:遍历数组    * 在操作数组时，经常需要依次访问数组中的每个元素，这种操作称作数组的遍历* B:练习    public class ArrayDemo04 {        public static void main(String[] args) {            int[] arr = { 1, 2, 3, 4, 5 }; // 定义数组            // 使用for循环遍历数组的元素            for (int i = 0; i &lt; arr.length; i++) {                System.out.println(arr[i]); // 通过索引访问元素            }        }    }    上述代码中，定义一个长度为5的数组arr，数组的角标为0~4。由于for循环中定义的变量i的值在循环过程中为0~4，因此可以作为索引，依次去访问数组中的元素，并将元素的值打印出来</code></pre><p>for each 循环 =&gt; 遍历数组<br>for (variable : collection) {statement}<br>例如:</p><pre><code>for(int element : a)   System.out.println(element);</code></pre><font color="#DD66" size=""><br>提示：有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调用 Arrays.toString(a), 返回一个包含数组元素的字符串， 这些元素被放置在括号内， 并用逗号分隔， 例如，“ [2, 3, 5,7，11 ，13]”、 要想打印数组， 可以调用<br>System.out.println(Arrays.toString(a));<br></font><h3 id="14数组中常见的异常"><a href="#14数组中常见的异常" class="headerlink" title="14数组中常见的异常"></a>14数组中常见的异常</h3><pre><code>* A: 数组操作中,常见的两个异常     数组的索引越界异常      空指针异常* B: 练习    public class ArrayDemo_4{        public static void main(String[] args){            //数组的索引越界异常            //int[] arr = {5,2,1};            //数组中3个元素,索引 0,1,2            //System.out.println(arr[3]);//java.lang.ArrayIndexOutOfBoundsException: 3            //空指针异常            int[] arr2 = {1,5,8};            System.out.println(arr2[2]);            arr2 = null; // arr2 不在保存数组的地址了            System.out.println(arr2[2]);//java.lang.NullPointerException        }    }</code></pre><h3 id="15数组最值和排序"><a href="#15数组最值和排序" class="headerlink" title="15数组最值和排序"></a>15数组最值和排序</h3><pre><code>* A: 数组获取最值的原理思想    * 定义数组的第一个元素arr[0]为最大值;循环arr数组,判断如果有比arr[0] 大的就交换,直到arr数组遍历完毕,那么arr[0]中就保存了最大的元素* B: 数组排序    * 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法：    int[] a = new int[10000];    Arrays.sort(a)</code></pre><h3 id="16数组获取最值代码实现"><a href="#16数组获取最值代码实现" class="headerlink" title="16数组获取最值代码实现"></a>16数组获取最值代码实现</h3><pre><code>* A: 代码实现    public class ArrayDemo05 {        public static void main(String[] args) {            int[] arr = { 4, 1, 6, 3, 9, 8 };     // 定义一个数组            int max = arr[0];                     // 定义变量max用于记住最大数，首先假设第一个元素为最大值            // 下面通过一个for循环遍历数组中的元素            for (int x = 1; x &lt; arr.length; x++) {                if (arr[x] &gt; max) {             // 比较 arr[x]的值是否大于max                    max = arr[x];                 // 条件成立，将arr[x]的值赋给max                }            }            System.out.println(&quot;max=&quot; + max);     // 打印最大值        }    }</code></pre><h3 id="17二维数组的定义"><a href="#17二维数组的定义" class="headerlink" title="17二维数组的定义"></a>17二维数组的定义</h3><pre><code>* A 二维数组的作用    * 要统计一个学校各个班级学生的考试成绩，又该如何实现呢？    * 这时就需要用到多维数组，多维数组可以简单地理解为在数组中嵌套数组。* B 定义格式    * a 第一种定义格式:        *  int[][] arr = new int[3][4];        *  上面的代码相当于定义了一个3*4的二维数组，即二维数组的长度为3，二维数组中的每个元素又是一个长度为4的数组    * b 第二种定义格式        *  int[][] arr = new int[3][];        *  第二种方式和第一种类似，只是数组中每个元素的长度不确定    * c 第三种定义格式        *      int[][] arr = {{1,2},{3,4,5,6},{7,8,9}};        *      二维数组中定义了三个元素，这三个元素都是数组，分别为{1,2}、{3,4,5,6}、{7,8,9}</code></pre><h3 id="18二维数组元素的访问"><a href="#18二维数组元素的访问" class="headerlink" title="18二维数组元素的访问"></a>18二维数组元素的访问</h3><pre><code> * A: 二维数组的访问 * 案例:  class ArrayDemo08 {    public static void main(String[] args){        //定义二维数组的方式        int[][] arr = new int[3][4];        System.out.println( arr );        System.out.println(&quot;二维数组的长度: &quot; + arr.length);        //获取二维数组的3个元素        System.out.println( arr[0] );        System.out.println( arr[1] );        System.out.println( arr[2] );        System.out.println(&quot;打印第一个一维数组的元素值&quot;);        System.out.println( arr[0][0] );        System.out.println( arr[0][1] );//访问的为二维数组中第1个一维数组的第2个元素        System.out.println( arr[0][2] );        System.out.println( arr[0][3] );        System.out.println(&quot;打印第二个一维数组的元素值&quot;);        System.out.println( arr[1][0] );        System.out.println( arr[1][1] );        System.out.println( arr[1][2] );        System.out.println( arr[1][3] );        System.out.println(&quot;打印第三个一维数组的元素值&quot;);        System.out.println( arr[2][0] );        System.out.println( arr[2][1] );        System.out.println( arr[2][2] );        System.out.println( arr[2][3] );    }}</code></pre><h3 id="19二维数组内存图"><a href="#19二维数组内存图" class="headerlink" title="19二维数组内存图"></a>19二维数组内存图</h3><pre><code>* A: 二维数组内存图* 举例:int[][] arr = new int[3][2];* 外层数组长在内存开辟连续的3个大的内存空间,每一个内存空间都对应的有地址值* 每一个大内存空间里又开辟连续的两个小的内存空间.</code></pre><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540278233/samples/java%20files/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.jpg" alt="数组的内存"></p><h3 id="20二维数组的定义和访问"><a href="#20二维数组的定义和访问" class="headerlink" title="20二维数组的定义和访问"></a>20二维数组的定义和访问</h3><pre><code>* A: 二维数组的定义和访问    * 格式1:     *     int[][] arr = new int[3][]; 不推荐    * 格式2    *  int[][] arr = {{1,2,4},{4,7},{0,9,3}};    *  * B: 二维数组的访问     举例:int[][] arr = {{1,2,4},{5,8,7},{0,9,3}};       想要打印数组中7这个元素需要先找到大的元素索引{5,7} 索引为2 ,在找7在{5,7}中的索引2     那么结果为 arr[2][2]  第一个[2]代表大数组中{5,8,7}这个元素索引     第二个[2]代表{5,8,7}中7元素的索引</code></pre><h3 id="21二维数组的遍历"><a href="#21二维数组的遍历" class="headerlink" title="21二维数组的遍历"></a>21二维数组的遍历</h3><pre><code>* A:二维数组遍历   int[][] arr = {{1,2,4},{4,7},{0,9,3}};     先使用for循环遍历arr这个二维数组,得到每一个元素为arr[i]为一维数组   再外层for循环中嵌套一个for循环遍历每一个一维数组arr[i],得到每一元素*    B:举例:遍历二维数组  public class ArrayArrayDemo_2{      public static void main(String[] args){          int[][] arr = { {1,2,3},{4,5},{6,7,8,9},{0} };          //外循环,遍历二维数组          for(int i = 0 ; i &lt; arr.length ;i++){              //内循环,遍历每个一维数组 arr[0] arr[1] arr[i]              for(int j = 0 ; j &lt; arr[i].length; j++){                  System.out.print(arr[i][j]);              }              System.out.println();          }      }* C:二维数组累加求和 class ArrayDemo09 {      public static void main(String[] args){            int[][] arr2 = { {1,2},{3,4,5},{6,7,8,9,10} };          int sum2 = 0;          for (int i=0; i&lt;arr2.length; i++) {              for (int j=0; j&lt;arr2[i].length; j++) {                   //System.out.println(arr2[i][j])                  sum2 += arr2[i][j];              }          }          System.out.println(&quot;sum2= &quot;+ sum2);      }  }</code></pre><font color="#DD66" size=""><br>for each 循环语句不能自动处理二维数组的每一个元素。它是按照行， 也就是一维数组处理的要想访问二维教组 a 的所有元素， 需要使用两个嵌套的循环， 如下所示：<br></font><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (double [] row : a)</span><br><span class="line"><span class="keyword">for</span> (double value : row)</span><br><span class="line">//<span class="keyword">do</span> something with value</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure><font color="#DD66" size=""><br>提示： 要想快速地打印一个二维数组的数据元素列表， 可以调用：<br>System.out.println(Arrays.deepToString(a)) ;<br>输出格式为：<br>[[16, B, 2, 13], [5, 10, 11, 8], [9, 6, 7, 12], [4, 15, 14, 1]]<br></font><h3 id="22二维数组的求和练习"><a href="#22二维数组的求和练习" class="headerlink" title="22二维数组的求和练习"></a>22二维数组的求和练习</h3><pre><code>* A 例如要统计一个公司三个销售小组中每个小组的总销售额以及整个公司的销售额。如下所示   * 第一小组销售额为{11, 12}万元   * 第二小组销售额为{21, 22, 23}万元   * 第三小组销售额为{31, 32, 33, 34}万元。 * B 代码实现      public class ArrayDemo10 {        public static void main(String[] args) {            int[][] arr = new int[3][];             // 定义一个长度为3的二维数组           arr[0] = new int[] { 11, 12 };             // 为数组的元素赋值            arr[1] = new int[] { 21, 22, 23 };            arr[2] = new int[] { 31, 32, 33, 34 };                    int sum = 0;                             // 定义变量记录总销售额            for (int i = 0; i &lt; arr.length; i++) { // 遍历数组元素                int groupSum = 0; // 定义变量记录小组销售总额            for (int j = 0; j &lt; arr[i].length; j++) { // 遍历小组内每个人的销售额                    groupSum = groupSum + arr[i][j];            }                sum = sum + groupSum;             // 累加小组销售额                System.out.println(&quot;第&quot; + (i + 1) + &quot;小组销售额为：&quot; + groupSum + &quot; 万元&quot;);            }            System.out.println(&quot;总销售额为: &quot; + sum + &quot; 万元&quot;);        }    }</code></pre><h3 id="23随机点名器案例分析"><a href="#23随机点名器案例分析" class="headerlink" title="23随机点名器案例分析"></a>23随机点名器案例分析</h3><pre><code>* A 随机点名器案例分析* B: 需求    * 随机点名器，即在全班同学中随机的打印出一名同学名字。* C:分析:    * 1)定义数组存数全班同学    * 2)生成随机数范围0 到 数组长度-1    * 3)根据这个索引找到数组中的同学名称</code></pre><h3 id="24随机点名器代码实现"><a href="#24随机点名器代码实现" class="headerlink" title="24随机点名器代码实现"></a>24随机点名器代码实现</h3><pre><code>* A: 分析       随机点名器:    1  存储姓名    2. 预览所有人的姓名    3. 随机出一个人的姓名* B 代码实现   import java.util.Random;   public class CallName{       public static void main(String[] args){           //存储姓名,姓名存储到数组中           //数组存储姓名,姓名的数据类型,String           String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;};           //预览: 遍历数组,打印所有姓名           for(int i = 0 ; i &lt; names.length ; i++){               System.out.println(names[i]);           }           System.out.println(&quot;=============&quot;);           //随机出一个人的名           //利用随机数,生成一个整数,作为索引,到数组中找到对应的元素           Random ran = new Random();           //随机数,范围必须是0-数组的最大索引           int index = ran.nextInt(names.length);//index 就是随机数,作为索引           System.out.println(names[index]);       }   }</code></pre><h3 id="25随机点名器代码实现-2"><a href="#25随机点名器代码实现-2" class="headerlink" title="25随机点名器代码实现_2"></a>25随机点名器代码实现_2</h3><pre><code>* A 代码优化:import java.util.Random;public class CallName{    public static void main(String[] args){        String[] names = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;李蕾&quot;,&quot;韩梅梅&quot;,&quot;小名&quot;,&quot;老王&quot;,&quot;小华&quot;,&quot;约翰逊&quot;,&quot;爱丽丝&quot;};        System.out.println(names[new Random().nextInt(names.length)]);    }}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/leesen/image/upload/v1540280255/samples/java%20files/photo-1537967371577-a17d31d7035f.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、流程控制语句switch&lt;br&gt;2、数组&lt;br&gt;3、随机点名器案例&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础3</title>
    <link href="https://leesen998.github.io/2016/10/04/day03%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/04/day03笔记/</id>
    <published>2016-10-04T02:41:53.000Z</published>
    <updated>2018-10-23T07:39:12.423Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540280253/samples/java%20files/photo-1539609413529-1166774c3954.jpg" alt="" style="width:100%"></p><p>1、引用类型变量的创建及使用<br>2、流程控制语句之选择语句<br>3、流程控制语句之循环语句<br>4、循环高级<br><a id="more"></a></p><h3 id="01创建引用类型变量公式"><a href="#01创建引用类型变量公式" class="headerlink" title="01创建引用类型变量公式"></a>01创建引用类型变量公式</h3><ul><li>A: 创建引用类型变量公式</li><li>a: 我们要学的Scanner类是属于引用数据类型，我们先了解下引用数据类型。</li><li><p>b: 引用数据类型的定义格式</p><ul><li>与定义基本数据类型变量不同，引用数据类型的变量定义及赋值有一个相对固定的步骤或格式。</li><li><font color="#D66" size="">数据类型  变量名  =  new 数据类型();</font></li></ul></li><li><p>c: 引用数据类型的使用</p><ul><li>每种引用数据类型都有其功能，我们可以调用该类型实例的功能。</li><li><font color="#D66" size="">变量名.方法名();</font></li></ul></li></ul><h3 id="02Scanner类的使用"><a href="#02Scanner类的使用" class="headerlink" title="02Scanner类的使用"></a>02Scanner类的使用</h3><pre><code>* A: Scanner类的使用    * a: 导包import java.util.Scanner;    * b：创建键盘录入对象 Scanner sc = new Scanner(System.in);    * c: 读取键盘录入的一个整数        * int enterNumber = sc.nextInt();    * d: 读取键盘录入的字符串        * String enterString = sc.next();* B: 案例代码    import java.util.Scanner;    public class Demo05Scanner{        public static void main(String[] args)         {            Scanner sc = new Scanner(System.in);            int enterNumber = sc.nextInt();            System.out.println(&quot;用户输入的整数为&quot;+enterNumber);            String enterString = sc.next();            System.out.println(&quot;用户输入的字符串为&quot;+enterString);        }    }</code></pre><h3 id="03Random随机数类的使用-1"><a href="#03Random随机数类的使用-1" class="headerlink" title="03Random随机数类的使用_1"></a>03Random随机数类的使用_1</h3><pre><code>* A: Random随机数类的使用_1    * a: 功能        * 生成随机数需要使用到引用类型随机数Random类    * b: 使用方式        * import导包：所属包java.util. Random        * 创建实例格式：Random  random = new Random ();        * 调用方法            * nextInt(int maxValue)    产生[0,maxValue)范围的随机数,包含0不包含maxValue            * nextDouble()  产生[0,1)范围的随机数            如：                Random  random = new Random ();                int  myNumber = random.nextInt(100);//结果为0-99的一个数* B: 案例代码    import java.util.Random;    public class RandomDemo{        public static void main(String[] args){           Random ran = new Random();           // Random类中的,产生随机数的功能           int i = ran.nextInt(100);           System.out.println(i);           //问题? 产生随机数,范围 1-100之间           // nextInt(100) 0-99 + 1        }    }</code></pre><h3 id="04Random随机数类的使用-2"><a href="#04Random随机数类的使用-2" class="headerlink" title="04Random随机数类的使用_2"></a>04Random随机数类的使用_2</h3><pre><code>* A: Random随机数类的使用_2    * a: 调用方法        * nextDouble()  产生[0,1)范围的随机数        如：            Random  random = new Random ();            int  myNumber = random.nextDouble();//结果为0.0-1.0之间的数(包括0.0不包括1.0)</code></pre><h3 id="05if语句格式第一种"><a href="#05if语句格式第一种" class="headerlink" title="05if语句格式第一种"></a>05if语句格式第一种</h3><pre><code>* A: if语句格式第一种    * a: 书写格式        if(比较表达式) {            语句体;        }    * b：执行流程：        * 先计算比较表达式的值，看其返回值是true还是false。        * 如果是true，就执行语句体；        * 如果是false，就不执行语句体；* B: 案例代码    public class IfDemo{        public static void main(String[] args){              int i = 5 ;              //对变量i进行if判断              if(i &gt; 5){                  System.out.println(&quot;if中的条件是true&quot;);                  i++;              }              System.out.println(i);        }    }</code></pre><h3 id="06if语句格式第二种"><a href="#06if语句格式第二种" class="headerlink" title="06if语句格式第二种"></a>06if语句格式第二种</h3><pre><code>* A: if语句格式第二种    * a: 书写格式        if(比较表达式) {            语句体1;        }else {            语句体2;        }    * b：执行流程：        * 首先计算比较表达式的值，看其返回值是true还是false。        * 如果是true，就执行语句体1；        * 如果是false，就执行语句体2；* B: 案例代码    public class IfElseDemo{        public static void main(String[] args){             int i = 16 ;             //判断变量,是奇偶数, 除以2,看余数是0还是1             if( i % 2 == 0 ){                 System.out.println(i+&quot; 是偶数&quot;);             }else{                 System.out.println(i+&quot; 是奇数&quot;);             }        }    }</code></pre><h3 id="07if语句格式第三种"><a href="#07if语句格式第三种" class="headerlink" title="07if语句格式第三种"></a>07if语句格式第三种</h3><pre><code>* A: if语句格式第三种    * a: 书写格式            if(比较表达式1) {                语句体1;            }else if(比较表达式2) {                语句体2;            }else if(比较表达式3) {                语句体3;            }            ...            else {                语句体n+1;            }    * b：执行流程：        * 首先计算比较表达式1看其返回值是true还是false，        * 如果是true，就执行语句体1，if语句结束。        * 如果是false，接着计算比较表达式2看其返回值是true还是false，        * 如果是true，就执行语句体2，if语句结束。        * 如果是false，接着计算比较表达式3看其返回值是true还是false，        * 如果都是false，就执行语句体n+1。* B: 案例代码    public class IfElseIfDemo{        public static void main(String[] args){            //成绩判断要求 ,成绩&gt;80  成绩&gt;70  成绩&gt;60  不及格            //定义变量,保存成绩            int grade = 75;            //使用if else if 语句对成绩判断            if( grade &gt; 80 ){                System.out.println(grade+&quot; 成绩是优&quot;);            }else if ( grade &gt; 70){                System.out.println(grade+&quot; 成绩是良&quot;);            }else if ( grade &gt; 60){                System.out.println(grade+&quot; 成绩是中&quot;);            }else{                System.out.println(grade+&quot; 成绩是差&quot;);            }        }    }</code></pre><h3 id="08if语句和三元运算符的互换"><a href="#08if语句和三元运算符的互换" class="headerlink" title="08if语句和三元运算符的互换"></a>08if语句和三元运算符的互换</h3><pre><code>* A: 三元运算符    * a: 概念        * 用来完成简单的选择逻辑，即根据条件判断，从两个选择中选择一种执行    * b: 使用格式        * (条件表达式)？表达式1：表达式2；    * c: 运算规则        * 1: 判断条件表达式，结果为一个布尔值        * 2: true，运算结果为表达式1        * 3: false，运算结果为表达式2* B: 案例代码    public class IfElseDemo_1{        public static void main(String[] args){            int j = 6;            int i = 15;            //使用if语句,判断出最大值            if(i&gt;j){            int j = 6;                System.out.println(i+&quot; 是最大值&quot;);            }else{                System.out.println(j+&quot; 是最大值&quot;);            }            //使用三元运算实现            int k = i&gt;j ? i : j;            System.out.println(k+&quot; 是最大值&quot;);        }    }* C: 使用if语句还是三元表达式    * 判断条件多,使用if     * 三元,必须有结果的, if 可以没有结果的</code></pre><h3 id="09while循环"><a href="#09while循环" class="headerlink" title="09while循环"></a>09while循环</h3><pre><code>* A: while循环结构    * a: 使用格式        初始化表达式；        while(条件){            循环体        }    * b: 执行顺序          当条件是true,就执行循环体,执行完循环体后          程序再次执行while中的条件,如果条件还是true,继续执行循环体          直到条件是false的时候,循环就结束* B: 案例代码    public class WhileDemo{        public static void main(String[] args){            //输出 1-4之间的整数            //定义变量,整数类型, 循环的条件            int i = 1;            while( i &lt; 5 ){                System.out.println(i);                i++;            }        }    }</code></pre><h3 id="10for循环-1"><a href="#10for循环-1" class="headerlink" title="10for循环_1"></a>10for循环_1</h3><pre><code>* A: for循环_1    * a: 使用格式         for(初始化变量 ; 条件 ; 增量){             循环体;         }    * b: 各模块解释        初始化变量: 定义变量,作用是用来控制循环的次数        条件: 当条件是true,执行循环体,条件是false,结束循环        增量: 变量自增情况 * B: 案例代码    public class ForDemo{        public static void main(String[] args){            //for循环,输出0-10            for(int i = 0 ; i &lt; 11 ; i++){                System.out.println(i);            }        }    }</code></pre><h3 id="11for循环-2"><a href="#11for循环-2" class="headerlink" title="11for循环_2"></a>11for循环_2</h3><pre><code>* A: for循环的执行流程    for（① ; ② ; ③）{        ④    }    第一步，执行①    第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步    第三步，执行④    第四步，执行③，然后重复执行第二步    第五步，退出循环</code></pre><h3 id="12for循环-3"><a href="#12for循环-3" class="headerlink" title="12for循环_3"></a>12for循环_3</h3><pre><code>* A: 案例    * a: 利用for循环,计算1+4的结果* B: 案例代码    public class ForDemo_1{        public static void main(String[] args){            // 定义变量,记录求和后的数据            int sum = 0;            // 利用循环,将变量从1变化到4            for(int i = 1 ; i &lt;= 4 ; i++){                //对变量进行求和                sum = sum + i;            }            System.out.println(sum);        }    }</code></pre><h3 id="13do-while循环"><a href="#13do-while循环" class="headerlink" title="13do_while循环"></a>13do_while循环</h3><pre><code>* A: do_while循环    * a: 使用格式        do{           循环体;        }while(条件);    * b: 执行顺序        先执行一次循环体，然后再判断条件，如果条件为true，继续执行循环体，        如果条件为false，循环结束。    * c: 特点        * 无条件先执行一次* B: 案例代码    public class DoWhileDemo{        public static void main(String[] args){            int i = 0;             do{                System.out.println(i);                i++;            }while( i &lt;  5);        }    }</code></pre><h3 id="14死循环"><a href="#14死循环" class="headerlink" title="14死循环"></a>14死循环</h3><pre><code>* A: 死循环概述    * 无限循环存在的原因是并不知道循环多少次，而是根据某些条件，来控制循环* B: 死循环格式    * while(true){}    * for(;;){}</code></pre><h3 id="15嵌套for循环-1"><a href="#15嵌套for循环-1" class="headerlink" title="15嵌套for循环_1"></a>15嵌套for循环_1</h3><pre><code>* A: 嵌套循环的概述    * 嵌套循环是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套，如最常见的在for循环中嵌套for循环。* B: 嵌套循环的格式    for(初始化表达式; 循环条件; 操作表达式) {        ………        for(初始化表达式; 循环条件; 操作表达式) {            执行语句            ………        }        ………    }* C: 各模块解释    * 总的循环次数 =  内循环次数 * 外循环的次数    * 内循环,是外循环的循环体    * 外循环,控制的是行数    * 内循环,控制的是每行的个数</code></pre><h3 id="16嵌套for循环-2"><a href="#16嵌套for循环-2" class="headerlink" title="16嵌套for循环_2"></a>16嵌套for循环_2</h3><pre><code>* A: 案例    * a: 打印正三角形* B: 案例代码    public class ForForDemo{        public static void main(String[] args){            for(int i = 0 ; i &lt; 9 ; i++){                for(int j = 0; j &lt; i+1 ;j++){                    System.out.print(&quot;* &quot;);                }                System.out.println();            }        }    }</code></pre><h3 id="17break语句"><a href="#17break语句" class="headerlink" title="17break语句"></a>17break语句</h3><pre><code>* A: break语句    * a: 作用        * 跳出所在的循环体    * b: 书写位置        * 必须出现在循环或选择结构内    * c: 举例        for(int i=0; i&lt;10; i++) {            if(i&gt;5) {            break;        }            System.out.println(“我爱Java”+i);        }        //会从0-5输出6次“我爱Java”* B: break详细解释    * a: 作用        * 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执行对应的代码，然而在这些逻辑过程中，            可以使用一些关键字直接跳出正在执行的代码，去执行后边或者指定位置的代码，            这些关键字一旦出现就可以跳转语句执行顺序。    * b: 使用方式        * 无法单独使用，必须将break关键字置于switch或循环语句中    * c: 运行规律        * 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构        * 只能跳出最近的代码块，不能跨越多级代码块* C：循环标号    * a: 为什么使用循环标号        * 当在双层循环或者循环内有switch选择语句时，我们发现，使用break或者continue所作用的对象均是内层语句，无法直接跳出外层循环，这时就需要使用标号语句跳转了.    * b: 使用方式        * 在外层循环外的某行前边，使用后边跟有冒号”:”的标识符，即定义完毕。          使用时当在内层循环使用break或continue时后边紧跟之前定义的标号即可    * c: 运行规律        * 当外层循环外定义了标号        * 内层使用break，终止内外双层循环。        * 内层使用continue，终止内层循环，继续外层循环。</code></pre><h3 id="18continue语句"><a href="#18continue语句" class="headerlink" title="18continue语句"></a>18continue语句</h3><pre><code>* A: continue语句    * a: 作用        * 提前结束本次循环，继续进行下次循环    * b: 使用方式        * 无法单独使用，必须将continue关键字置于循环语句中    * c：运行规律        * 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环    * d：案例代码        public class ContinueDemo{            public static void main(String[] args){                for(int i = 0 ; i &lt; 10 ; i++){                    if(i%2==0){                        continue;                    }                    System.out.println(i);                }            }        }        //会把0-9之间所有的奇数打印到控制台上</code></pre><h3 id="19猜数字小游戏"><a href="#19猜数字小游戏" class="headerlink" title="19猜数字小游戏"></a>19猜数字小游戏</h3><pre><code>* A: 猜数字小游戏            * a: 分析        * 用户给的数可能大于、小于、或等于被猜的数，这样就会出现三种情况，用前面讲的三元运算符可以实现，            但是得用三元运算符的嵌套，比较麻烦！可以用更简单的方式if条件判断，可以有三个以上的条件    * b: 需求分析        * 后台预先生成一个随机数1-100，用户键盘录入猜数字        * 如果猜对了，打印“恭喜您，答对了”        * 如果猜错了        * 猜大了：打印“sorry，您猜大了!”        * 猜小了：打印“sorry，您猜小了!”                直到数字猜到为止                最多只能猜5次，否则提示“sorry，您没有机会了!”* B: 案例代码    /*        猜数字小游戏        完成猜数字小游戏：        1、产生随机数        后台预先生成一个随机数1-100，用户键盘录入猜数字        2、通过if语句对用户猜的数与随机数进行比较        如果猜对了，打印“恭喜您，答对了”        如果猜错了        猜大了：打印“sorry，您猜大了!”        猜小了：打印“sorry，您猜小了!”        3、通过for循环完成用户猜数的循环        直到数字猜到为止        最多只能猜5次，否则提示“sorry，您没有机会了!”    */    import java.util.Random;    import java.util.Scanner;    //通过*的方式可以一次导入该包下所有的类，但是不建议使用。建议使用哪个导哪个。    //import java.util.*;    public class GuessNumber{        public static void main(String[] args) {            //1、产生随机数            //后台预先生成一个随机数1-100，用户键盘录入猜数字            //创建随机数对象            Random random = new Random();            //产生一个1-100的随机数            int randomNumber = random.nextInt(100)+1;            //System.out.println(&quot;我产生的随机数是：&quot;+randomNumber+&quot;你猜猜是多少？&quot;);  作弊专用            //产生控制台录入的Scanner对象            Scanner sc = new Scanner(System.in);            //3、通过for循环完成用户猜数的循环            //通过for循环完成猜数字逻辑            for(int i=1; i&lt;=5; i++){                //提示用户输入要猜的数，用变量接收                System.out.println();                System.out.println(&quot;请您输入一个1-100的数：&quot;);                int guessNumber = sc.nextInt();                //2、通过if语句对用户猜的数与随机数进行比较                //如果猜对了                if(guessNumber==randomNumber) {                    //打印猜对后的提示                    System.out.println(&quot;恭喜您，猜对了！&quot;);                    //跳出循环，不用再猜了                    break;                }else {//如果猜错了                    //如果猜大了                    if(guessNumber&gt;randomNumber) {                        System.out.println(&quot;sorry，您猜大了!&quot;);                    }else {//如果猜小了                        System.out.println(&quot;sorry，您猜小了!&quot;);                    }                }                //如果猜到了最后的第5次仍然没有猜对就跳出循环                if(i==5) {                    System.out.println(&quot;对不起，点太背，下次再来吧！&quot;);                    break;                }                //每次猜错后，都提示还有多少次机会                System.out.println(&quot;请注意，您还有&quot;+(5-i)+&quot;次机会，请慎重作答！&quot;);            }        }    }</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/leesen/image/upload/v1540280253/samples/java%20files/photo-1539609413529-1166774c3954.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、引用类型变量的创建及使用&lt;br&gt;2、流程控制语句之选择语句&lt;br&gt;3、流程控制语句之循环语句&lt;br&gt;4、循环高级&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>AS环境配置踩坑经历</title>
    <link href="https://leesen998.github.io/2016/10/03/AS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    <id>https://leesen998.github.io/2016/10/03/AS环境配置踩坑经历/</id>
    <published>2016-10-03T02:41:53.000Z</published>
    <updated>2018-10-23T07:41:31.702Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/leesen/image/upload/v1540280253/samples/java%20files/photo-1538150096488-cda7e455f3ee.jpg" alt="" style="width:100%"></p><a id="more"></a><h2 id="遇到的bug"><a href="#遇到的bug" class="headerlink" title="遇到的bug"></a><font color="#551A8B" size="">遇到的bug</font></h2><pre><code>Unable to resolve dependency for &apos;:app@debug/compileClasspath&apos;</code></pre><p>这是由于配置文件的依赖是通过Google下载的，然而该下载被墙了！<br>[解决办法]：</p><h3 id="在整个工程的build-gradle中添加以下框内代码："><a href="#在整个工程的build-gradle中添加以下框内代码：" class="headerlink" title="在整个工程的build.gradle中添加以下框内代码："></a>在整个工程的build.gradle中添加以下框内代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">        url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public/'</span></span><br><span class="line">        &#125;</span><br><span class="line">maven &#123; url <span class="string">'http://repo1.maven.org/maven2'</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="app下的build-gradle配置如下"><a href="#app下的build-gradle配置如下" class="headerlink" title="app下的build.gradle配置如下:"></a>app下的build.gradle配置如下:</h3><p>buildToolsVersion 需要和你的sdk安装目录 ~\sdk\build-tools文件里面已有的版本对应<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 26</span><br><span class="line">    buildToolsVersion <span class="string">'27.0.3'</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.administrator.myapplication"</span></span><br><span class="line">        minSdkVersion 19</span><br><span class="line">        targetSdkVersion 22</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>implementation ‘com.android.support:appcompat-v7:26.+’ 中v7:26.+表示使用的sdk版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation <span class="string">'com.android.support:appcompat-v7:26.+'</span></span><br><span class="line">    implementation <span class="string">'com.android.support.constraint:constraint-layout:1.0.2'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test:runner:0.4'</span></span><br><span class="line">    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span></span><br><span class="line">//    androidTestImplementation <span class="string">'com.android.support.test:runner:1.0.1'</span></span><br><span class="line">//    androidTestImplementation <span class="string">'com.android.support.test.espresso:espresso-core:3.0.1'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="若配置后还没解决问题，依然报错"><a href="#若配置后还没解决问题，依然报错" class="headerlink" title="若配置后还没解决问题，依然报错"></a>若配置后还没解决问题，依然报错</h3><p><font color="#FF00FF" size="">打开 C:/Users/(用户名)/.gradle/gradle.properties</font><br>把http代理的配置注释掉，例如：</p><pre><code>## For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html## Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx1024m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8## When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true#Sat Sep 29 23:37:12 CST 2018#systemProp.http.proxyHost=mirrors.neusoft.edu.cn#systemProp.https.proxyPort=80#systemProp.https.proxyHost=mirrors.neusoft.edu.cn#systemProp.http.proxyPort=80</code></pre><p>More info: <a href="https://blog.csdn.net/magicbaby810/article/details/79848425" target="_blank" rel="noopener">参考该问题的csdn博客</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/leesen/image/upload/v1540280253/samples/java%20files/photo-1538150096488-cda7e455f3ee.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件安装" scheme="https://leesen998.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="AS" scheme="https://leesen998.github.io/tags/AS/"/>
    
  </entry>
  
  <entry>
    <title>java入门</title>
    <link href="https://leesen998.github.io/2016/10/02/java%E5%85%A5%E9%97%A8/"/>
    <id>https://leesen998.github.io/2016/10/02/java入门/</id>
    <published>2016-10-02T03:59:18.000Z</published>
    <updated>2018-10-08T09:03:21.126Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://desk-fd.zol-img.com.cn/t_s1920x1080c5/g5/M00/00/0C/ChMkJ1gF5IyIVpQZAAfWfSNJAuoAAXABwHjE1wAB9aV014.jpg" alt="" style="width:100%"><br>java入门笔记<br><a id="more"></a></p><h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a><font color="#551A8B" size="">第一个Java程序</font></h2><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a><font color="#00CD66" size="">Java代码</font></h3><p>Java程序是大小写敏感的 对格式没有严格要求，但用空格或Tab键缩进会比较好看</p><h3 id="Hello-java"><a href="#Hello-java" class="headerlink" title="Hello.java"></a><font color="#D66" size="">Hello.java</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名必须是Hello.java，文件名也要注意大小写，必须与程序的类名完全一致，扩展名是.java。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a><font color="#DD66" size="">编译</font></h3><p>切换到Hello.java所在目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java</span><br></pre></td></tr></table></figure></p><p>无任何输出表示成功，可查看编译出的Hello.class文件。</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a><font color="#3D66" size="">执行</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Hello</span><br></pre></td></tr></table></figure><p>代码格式：public 和 static 是修饰符static表示静态方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class 类名 &#123;</span><br><span class="line">public static void 方法名(参数) &#123;</span><br><span class="line">//单行注释</span><br><span class="line">你的程序代码;</span><br><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//class定义结束</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><font color="#551A8B" size="">变量</font></h2><h3 id="变量概述"><a href="#变量概述" class="headerlink" title="变量概述"></a>变量概述</h3><p>A: 什么是变量?<br>        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: 变量是一个内存中的小盒子（小容器），容器是什么？生活中也有很多容器，例如水杯是容器，用来装载水；你家里的大衣柜是容器，用来装载衣裤；饭盒是容器，用来装载饭菜。那么变量是装载什么的呢？</span><br><span class="line">答案是数据！结论：变量是内存中装载数据的小盒子，你只能用它来存数据和取数据。</span><br></pre></td></tr></table></figure></p><h3 id="计算机存储单元"><a href="#计算机存储单元" class="headerlink" title="计算机存储单元"></a>计算机存储单元</h3><p>A: 计算机中储存和运算的最小单位是?<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a: 一个字节,也就是一个byte.</span><br><span class="line"> win+r--cmd--回车</span><br><span class="line">b: 常用储存单位</span><br><span class="line">*1B（字节） = 8bit</span><br><span class="line">*1KB = 1024B</span><br><span class="line">*1MB = 1024KB</span><br><span class="line">*1GB = 1024MB</span><br><span class="line">*1TB = 1024GB</span><br><span class="line">*1PB = 1024TB</span><br></pre></td></tr></table></figure></p><h3 id="Java中数据类型四类八种"><a href="#Java中数据类型四类八种" class="headerlink" title="Java中数据类型四类八种"></a>Java中数据类型四类八种</h3><p> A: 数据类型四类八种<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*四类八种字节数数据表示范围</span><br><span class="line">*整型byte1-128～127</span><br><span class="line">short2-32768～32767</span><br><span class="line">int4-2147483648～2147483648</span><br><span class="line">long8-263～263-1</span><br><span class="line">*浮点型<span class="built_in">float</span>4-3.403E38～3.403E38</span><br><span class="line">double8-1.798E308～1.798E308</span><br><span class="line">*字符型char2表示一个字符，如(<span class="string">'a'</span>，<span class="string">'A'</span>，<span class="string">'0'</span>，<span class="string">'家'</span>)</span><br><span class="line">*布尔型boolean1只有两个值<span class="literal">true</span>与<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="常量和数据类型"><a href="#常量和数据类型" class="headerlink" title="常量和数据类型"></a>常量和数据类型</h3><p> A:常量的定义<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* a: 整形常量默认是int类型</span><br><span class="line">* b: 小数常量默认是double类型</span><br><span class="line">* c: 定义长整形数据如果值超过int取值范围后面要+<span class="string">"L"</span></span><br><span class="line">* d: 定义<span class="built_in">float</span>类型的数据后面要+<span class="string">"f"</span> 否则默认是double</span><br></pre></td></tr></table></figure></p><h3 id="变量创建的三要素"><a href="#变量创建的三要素" class="headerlink" title="变量创建的三要素"></a>变量创建的三要素</h3><p>A: 定义变量的语法格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数据类型  变量名  =  变量值;</span><br><span class="line">* int         a    =  100;</span><br><span class="line">      * B:代码:</span><br><span class="line">public class Variable &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 10;</span><br><span class="line">double b = 3.14;</span><br><span class="line">char c = <span class="string">'z'</span>;</span><br><span class="line">String s = <span class="string">"i love java"</span>;</span><br><span class="line"></span><br><span class="line">a = 20;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="定义所有的基本数据类型变量"><a href="#定义所有的基本数据类型变量" class="headerlink" title="定义所有的基本数据类型变量"></a>定义所有的基本数据类型变量</h3><ul><li><p>A: 案例演示</p><ul><li>a: 八种基本类型数据的创建</li></ul></li></ul><h3 id="定义字符串变量"><a href="#定义字符串变量" class="headerlink" title="定义字符串变量"></a>定义字符串变量</h3><ul><li>A：案例演示<ul><li>创建字符串数据类型变量</li><li>String 是引用数据类型<h3 id="变量定义使用注意事项"><a href="#变量定义使用注意事项" class="headerlink" title="变量定义使用注意事项"></a>变量定义使用注意事项</h3></li></ul></li><li>A：变量使用的注意事项<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* a: 变量定义后可以不赋值，使用时再赋值。不赋值不能使用。</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int x;</span><br><span class="line">x = 20; //为x赋值20</span><br><span class="line">System.out.println(x);//读取x变量中的值，再打印</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* c:变量使用时有作用域的限制。</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int x = 20;</span><br><span class="line">&#123;</span><br><span class="line">    int y = 20;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(x);//读取x变量中的值，再打印</span><br><span class="line">System.out.println(y);//读取y变量中的值失败，失败原因，找不到y变量，因为超出了y变量作用范围，所以不能使用y变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型转换-自动转换"><a href="#数据类型转换-自动转换" class="headerlink" title="数据类型转换_自动转换"></a>数据类型转换_自动转换</h3><ul><li>A:     自动类型转换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* a:表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换</span><br><span class="line">自动类型转换格式：</span><br><span class="line">范围大的数据类型 变量 = 范围小的数据类型值；</span><br><span class="line">如：</span><br><span class="line">    double d = 1000;</span><br><span class="line">或</span><br><span class="line">    int i = 100;</span><br><span class="line">    double d2 = i;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型转换-强制转换"><a href="#数据类型转换-强制转换" class="headerlink" title="数据类型转换_强制转换"></a>数据类型转换_强制转换</h3><ul><li>A: 强制类型转换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*a: 表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换</span><br><span class="line">*b: 强制类型转换格式：</span><br><span class="line">范围小的数据类型  变量 = (范围小的数据类型) 范围大的数据类型值;</span><br><span class="line">如：</span><br><span class="line">int  i = (int)6.718;   //i的值为6</span><br><span class="line">或</span><br><span class="line">double  d = 3.14;</span><br><span class="line">int  i2 = (int)d;     //i2的值为3</span><br></pre></td></tr></table></figure></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><font color="#551A8B" size="">运算符</font></h2><h3 id="算数运算符-1"><a href="#算数运算符-1" class="headerlink" title="算数运算符_1"></a>算数运算符_1</h3><ul><li><p>A: 常见操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运算符运算规则范例结果</span><br><span class="line">+正号+33</span><br><span class="line">+加2+35</span><br><span class="line">+连接字符串“中”+“国”“中国”</span><br><span class="line">-负号int a=3;-a-3</span><br><span class="line">-减3-12</span><br><span class="line">*乘2*36</span><br><span class="line">/除5/22</span><br><span class="line">%取模5/21</span><br><span class="line">++自增int a=1;a++/++a2</span><br><span class="line">--自减int b=3;a--/--a2</span><br></pre></td></tr></table></figure></li><li><p>B: 注意事项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*a:加法运算符在连接字符串时要注意，只有直接与字符串相加才会转成字符串。</span><br><span class="line">*b:除法“/”当两边为整数时，取整数部分，舍余数。当其中一边为浮点型时，按正常规则相除。 </span><br><span class="line">*c:“%”为整除取余符号，小数取余没有意义。结果符号与被取余符号相同。</span><br><span class="line">*d:整数做被除数，0不能做除数，否则报错。</span><br><span class="line">*e:小数做被除数，整除0结果为Infinity，对0取模结果为NaN</span><br></pre></td></tr></table></figure></li><li><p>C:代码演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class OperatorDemo1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*</span><br><span class="line"> * 常量使用算数运算符</span><br><span class="line"> */</span><br><span class="line">System.out.println(10+20);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 变量使用算数运算符</span><br><span class="line"> */</span><br><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line">//<span class="string">"+"</span>作为加法运算使用</span><br><span class="line">int z = x + y; </span><br><span class="line">//<span class="string">"+"</span>作为连接字符串使用</span><br><span class="line">System.out.println(<span class="string">"x="</span>+x);</span><br><span class="line">System.out.println(<span class="string">"y="</span>+y);</span><br><span class="line">System.out.println(<span class="string">"z="</span>+z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="算数运算符-2"><a href="#算数运算符-2" class="headerlink" title="算数运算符_2"></a>算数运算符_2</h3><ul><li>算数运算符++、–<pre><code>* A:算数运算符++、--的使用    * a: ++运算符，会在原有值的基础上自增1    * b: --运算符，会在原有值的基础上自减1。* B:++  -- 位置的使用    * a:++,--运算符后置时，先使用变量a原有值参与运算操作，运算操作完成后，变量a的值自增1或者自减1；    * b:++，--运算符前置时，先将变量a的值自增1或者自减1，然后使用更新后的新值参与运算操作。</code></pre></li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li><p>A: 赋值运算符的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算符 运算规则范例结果</span><br><span class="line">=赋值int a=22</span><br><span class="line">+=加后赋值int a=2，a+=24</span><br><span class="line">-=减后赋值int a=2，a-=20</span><br><span class="line">*=乘后赋值int a=2，a*=24</span><br><span class="line">/=整除后赋值int a=2，a/=21</span><br><span class="line">%=取模后赋值int a=2，a%=20</span><br></pre></td></tr></table></figure></li><li><p>B：案例演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> * 赋值运算符</span><br><span class="line"> * +=, -=, *=, /=, %= ： </span><br><span class="line"> * 上面的运算符作用：将等号左右两边计算，会将结果自动强转成等号左边的数据类型,再赋值给等号左边的</span><br><span class="line"> * 注意：赋值运算符左边必须是变量</span><br><span class="line"></span><br><span class="line">public class OperatorDemo2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte x = 10;</span><br><span class="line">x += 20;// 相当于 x = (byte)(x+20);</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li>A:比较运算符的使用</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算符运算规则范例结果</span><br><span class="line">==相等于4==3False</span><br><span class="line">!=不等于4!=3True</span><br><span class="line">&lt;小于4&lt;3False</span><br><span class="line">&gt;大于4&gt;3True</span><br><span class="line">&lt;=小于等于4&lt;=3False</span><br><span class="line">&gt;=大于等于        4&gt;=3True</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>A: 逻辑运算符的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">运算符运算规则范例结果</span><br><span class="line">&amp;与<span class="literal">false</span>&amp;<span class="literal">true</span>False</span><br><span class="line">|或<span class="literal">false</span>|<span class="literal">true</span>True</span><br><span class="line">^异或<span class="literal">true</span>^flaseTrue</span><br><span class="line">!非!<span class="literal">true</span>Flase</span><br><span class="line">&amp;&amp;短路与<span class="literal">false</span>&amp;&amp;<span class="literal">true</span>False</span><br><span class="line">||短路或<span class="literal">false</span>||<span class="literal">true</span>True</span><br><span class="line"></span><br><span class="line">规律小结:</span><br><span class="line">短路与&amp;&amp;:参与运算的两边数据，有<span class="literal">false</span>，则运算结果为<span class="literal">false</span>；</span><br><span class="line">短路或||:参与运算的两边数据，有<span class="literal">true</span>，则运算结果为<span class="literal">true</span>；</span><br><span class="line">逻辑非! : 参与运算的数据，原先是<span class="literal">true</span>则变成<span class="literal">false</span>，原先是<span class="literal">false</span>则变成<span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ul><li>A: 格式:</li><li><pre><code>(条件表达式)？表达式1：表达式2；</code></pre></li><li><p>B: 代码案例</p><pre><code>方式一：System.out.println( 3&gt;2 ? “正确” : “错误” ); // 三元运算符运算后的结果为true，运算结果为表达式1的值“正确”，然后将结果“正确”，在控制台输出打印方式二：int a = 3;int b = 4;String result = (a==b) ? “相等” : “不相等”;  //三元运算符运算后的结果为false，运算结果为表达式2的值“不相等”，然后将结果赋值给了变量result方式三：int n = (3&gt;2 &amp;&amp; 4&gt;6) ? 100 : 200;//三元运算符运算后的结果为false，运算结果为表达式2的值200,然后将结果200赋值给了变量n</code></pre></li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">优先级描述运算符</span><br><span class="line">1括号()、[]</span><br><span class="line">2正负号+、-</span><br><span class="line">3自增自减，非++、--、!</span><br><span class="line">4乘除，取余*、/、%</span><br><span class="line">5加减+、-</span><br><span class="line">6移位运算&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</span><br><span class="line">7大小关系&gt;、&gt;=、&lt;、&lt;=</span><br><span class="line">8相等关系==、!=</span><br><span class="line">9按位与&amp;</span><br><span class="line">10按位异或^</span><br><span class="line">11按位或|</span><br><span class="line">12逻辑与&amp;&amp;</span><br><span class="line">13逻辑或||</span><br><span class="line">14条件运算?:</span><br><span class="line">15赋值运算=、+=、-=、*=、/=、%=</span><br><span class="line">16位赋值运算&amp;=、|=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</span><br></pre></td></tr></table></figure><h3 id="商场库存清单案例"><a href="#商场库存清单案例" class="headerlink" title="商场库存清单案例"></a>商场库存清单案例</h3><p>A: 案例分析.</p><ul><li>a:观察清单后，可将清单分解为三个部分（清单顶部、清单中部、清单底部）</li><li>b:清单顶部为固定的数据，直接打印即可</li><li><p>c:清单中部为商品，为变化的数据，需要记录商品信息后，打印<br>经过观察，我们确定一项商品应该有如下几个属性：<br>品牌型号: 即商品名称，String型<br>尺寸：物品大小，double型<br>价格：物品单价，double型<br>配置：这一项为每种商品的配置信息，String型<br>库存数：这一项为每种商品的库存个数，int型</p></li><li><p>d:清单底部包含了统计操作，需经过计算后，打印<br>我们发现两个单独的可变化量<br>总库存数：所有商品总个数，int型<br>库存商品总金额：所有商品金额，double型</p></li></ul><p>B: 案例代码实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//步骤一:  创建Demo01库存清单.java文件，编写main主方法</span><br><span class="line">public class Demo01库存清单 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//步骤二:  记录每种库存商品信息</span><br><span class="line">//苹果笔记本电脑</span><br><span class="line">String macBrand = <span class="string">"MacBookAir"</span>;</span><br><span class="line">double macSize = 13.3;</span><br><span class="line">double macPrice = 6988.88;</span><br><span class="line">int macCount = 5;</span><br><span class="line"></span><br><span class="line">//联想Thinkpad笔记本电脑</span><br><span class="line">String thinkpadBrand = <span class="string">"ThinkpadT450"</span>;</span><br><span class="line">double thinkpadSize = 14.0;</span><br><span class="line">double thinkpadPrice = 5999.99;</span><br><span class="line">int thinkpadCount = 10;</span><br><span class="line"></span><br><span class="line">//华硕ASUS笔记本电脑</span><br><span class="line">String ASUSBrand = <span class="string">"ASUS-FL5800"</span>;</span><br><span class="line">double ASUSSize = 15.6;</span><br><span class="line">double ASUSPrice = 4999.50;</span><br><span class="line">int ASUSCount = 18;</span><br><span class="line"></span><br><span class="line">//步骤三: 统计库存总个数、库存总金额</span><br><span class="line">int totalCount = macCount + thinkpadCount + ASUSCount;</span><br><span class="line">double totalMoney = (macCount * macPrice) + (thinkpadCount * thinkpadPrice) + (ASUSCount * ASUSPrice);</span><br><span class="line"></span><br><span class="line">//步骤四: 列表顶部</span><br><span class="line">System.out.println(<span class="string">"------------------------------商城库存清单-----------------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"品牌型号尺寸价格库存数"</span>);</span><br><span class="line"></span><br><span class="line">步骤四:打印库存清单中部信息</span><br><span class="line">//列表中部</span><br><span class="line">System.out.println(macBrand+<span class="string">""</span>+macSize+<span class="string">""</span>+macPrice+<span class="string">""</span>+macCount);</span><br><span class="line">System.out.println(thinkpadBrand+<span class="string">""</span>+thinkpadSize+<span class="string">""</span>+thinkpadPrice+<span class="string">""</span>+thinkpadCount);</span><br><span class="line">System.out.println(ASUSBrand+<span class="string">""</span>+ASUSSize+<span class="string">""</span>+ASUSPrice+<span class="string">""</span>ASUSCount);</span><br><span class="line">打印库存清单底部信息</span><br><span class="line">//列表底部</span><br><span class="line">System.out.println(<span class="string">"-----------------------------------------------------------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"总库存数："</span>+totalCount); </span><br><span class="line">System.out.println(<span class="string">"库存商品总金额："</span>+totalMoney);</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://desk-fd.zol-img.com.cn/t_s1920x1080c5/g5/M00/00/0C/ChMkJ1gF5IyIVpQZAAfWfSNJAuoAAXABwHjE1wAB9aV014.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;br&gt;java入门笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
</feed>
