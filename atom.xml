<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QJun</title>
  
  <subtitle>QJun&#39;s Homepage</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leesen998.github.io/"/>
  <updated>2018-10-23T07:40:31.112Z</updated>
  <id>https://leesen998.github.io/</id>
  
  <author>
    <name>QJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello</title>
    <link href="https://leesen998.github.io/2017/10/03/hello-world/"/>
    <id>https://leesen998.github.io/2017/10/03/hello-world/</id>
    <published>2017-10-03T02:41:53.000Z</published>
    <updated>2018-10-23T07:40:31.112Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://source.unsplash.com/random/1700x900" alt="" style="width:100%"><br>只是单纯地发个图片<br><a id="more"></a></p><pre><code>hexo deploy11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111hexo deploy</code></pre><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://source.unsplash.com/random/1700x900&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;br&gt;只是单纯地发个图片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="first test" scheme="https://leesen998.github.io/categories/first-test/"/>
    
    
      <category term="test" scheme="https://leesen998.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法基础1())</title>
    <link href="https://leesen998.github.io/2016/12/08/chapter1%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/12/08/chapter1笔记/</id>
    <published>2016-12-08T11:48:29.000Z</published>
    <updated>2018-12-19T12:59:49.207Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544254144/samples/java%20files/photo-1542312455-e31bb150371c.jpg" alt="" style="width:100%"></p><p>1、<br>2、<br>3、<br>4、<br>5、<br>6、</p><a id="more"></a><h3 id="01算法复杂度"><a href="#01算法复杂度" class="headerlink" title="01算法复杂度"></a>01算法复杂度</h3><h4 id="大O记号"><a href="#大O记号" class="headerlink" title="大O记号"></a>大O记号</h4><p>同样地出于保守的估计，我们首先关注T(n)的渐进上界。为此可引入所谓“大O记号”（big-O notation） 。<br>具体地，若存在正的常数c和函数f(n)，使得对任何n &gt;&gt; 2都有<br>T(n) &lt;= c∙f(n)则可认为在n足够大之后， f(n)给出了T(n)增长速度的一个<strong>渐进上界</strong>。此时，记之为：<br>T(n) = O(f(n))<br>由这一定义，可导出大O记号的以下性质：<br>(1) 对于任一常数c &gt; 0，有O(f(n)) = O(c∙f(n))<br>(2) 对于任意常数a &gt; b &gt; 0，有O(n^a + n^b) = O(n^a)</p><h4 id="大Ω记号"><a href="#大Ω记号" class="headerlink" title="大Ω记号"></a>大Ω记号</h4><p>为了对算法的复杂度最好情况做出估计，需要借助另一个记号。如果存在正的常数c和函数g(n)，使得对于任何n &gt;&gt; 2都有T(n)  c∙g(n)<br>就可以认为，在n足够大之后， g(n)给出了T(n)的一个<strong>渐进下界</strong>。此时，我们记之为：<br>T(n) = Ω(g(n))<br>这里的Ω称作“大Ω记号” （big-Ω notation）。<br>与大O记号恰好相反，大Ω记号是对算法执行效率的乐观估计—对于规模为n的任意输入，算法的运行时间都不低于Ω(g(n))。比如，即便在最好情况下，起泡排序也至少需要T(n) = Ω(n)的计算时间。</p><h4 id="大Θ记号"><a href="#大Θ记号" class="headerlink" title="大Θ记号"></a>大Θ记号</h4><p>借助大O记号、大Ω记号，可以对算法的时间复杂度作出定量的界定，亦即，从渐进的趋势<br>看， T(n)介于Ω(g(n))与O(f(n))之间。若恰巧出现g(n) = f(n)的情况，则可以使用另一记号来表示。<br>如果存在正的常数c1 &lt; c2和函数h(n)，使得对于任何n &gt;&gt; 2都有<br> c1∙h(n) &lt;= T(n) &lt;= c2∙h(n)<br>就可以认为在n足够大之后， h(n)给出了T(n)的一个<strong>确界</strong>。此时，我们记之为：<br>T(n) = Θ(h(n))<br>这里的Θ称作“大Θ记号” （big-Θ notation） ，它是对算法复杂度的准确估计</p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544775642/samples/java%20files/118.jpg" alt=""></p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><h5 id="常数O-1"><a href="#常数O-1" class="headerlink" title="常数O(1)"></a>常数O(1)</h5><p> 问题与算法<br>首先考查如下问题：任给一个整数子集S, |S| = n ≥ 3，从中找出一个元素a ∈ S，使得<br>a ≠ max(S)且a ≠ min(S)。亦即，在最大、最小者之外任取一个元素，称作“非极端元素” 或“平常元素” 。<br>任取三个元素x, y, z ∈ S; //既然S是集合，返三个元素必于异<br>通过比较对它们做排序; //设排序结枅为：min{x, y, z}, median(x, y, z), max{x, y, z}<br>输出median(x, y, z);</p><h5 id="对数O-logn"><a href="#对数O-logn" class="headerlink" title="对数O(logn)"></a>对数O(logn)</h5><p> 问题与算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">1</span>,n=<span class="number">1000</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line"></span><br><span class="line">            i*=<span class="number">2</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>每次i乘以2，也就是说，至多经过1 + log2（n）次循环， i必然超过n，从而算法终止<br><strong>由大O记号定义，在用函数logrn界定渐进复杂度时，常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn</strong>。<br>比如，尽管此处底数为常数2，却可直接记作O(logn)。<br>此类算法称作具有“对数时间复杂度”</p><h5 id="线性O-n"><a href="#线性O-n" class="headerlink" title="线性O(n)"></a>线性O(n)</h5><p> 问题与算法<br>考查如下问题：计算给定n个整数的总和。 该问题可由代码1.3中的算法sumI()解决。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumI</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//数组求和算法（迭代版）</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//初始化累计器，O(1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//对全部共O(n)个元素，逐一</span></span><br><span class="line">sum += A[i]; <span class="comment">//累计，O(1)</span></span><br><span class="line"><span class="keyword">return</span> sum; <span class="comment">//返回回累计值，O(1)</span></span><br><span class="line">&#125; <span class="comment">//O(1) + O(n)*O(1) + O(1) = O(n+2) = O(n)</span></span><br></pre></td></tr></table></figure></p><p>首先，对s的初始化需要O(1)时间。算法的主体部分是一个循环，每一轮循环中只需进行一次累加运算，这属于基本操作，可在O(1)时间内完成。<br>每经过一轮循环，都将一个元素累加至s，故总共需要做n轮循环， 于是该算法的运行时间应为：<br>O(1) + O(1)×n = O(n+1) = O(n)</p><h5 id="多项式O-polynomial-n"><a href="#多项式O-polynomial-n" class="headerlink" title="多项式O(polynomial(n))"></a>多项式O(polynomial(n))</h5><p>若运行时间可以表示和度量为T(n) = O(f(n))的形式，而且f(x)为多项式，则对应的算法称作“多项式时间复杂度算法” （polynomial-time algorithm)。<br>所实现起泡排序bubblesort()算法的时间复杂度应为T(n) = O(n^2)， 故该算法即属于此类。<br>当然， 以上所介绍的线性时间复杂度算法， 也属于多项式时间复杂度算法的特例，其中线性多项式f(n) = n的次数为1<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544778262/samples/java%20files/121.jpg" alt=""></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544778262/samples/java%20files/122.jpg" alt=""></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544778262/samples/java%20files/123.jpg" alt=""></p><h5 id="复杂度层次"><a href="#复杂度层次" class="headerlink" title="复杂度层次"></a>复杂度层次</h5><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544777430/samples/java%20files/119.jpg" alt=""><br>常用的<strong>时间复杂度</strong>所耗费的时间<strong>从小到大</strong>依次是：<br><strong>O(1) &lt; O(logn) &lt; (n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p><h3 id="02递归"><a href="#02递归" class="headerlink" title="02递归"></a>02递归</h3><h4 id="线性递归"><a href="#线性递归" class="headerlink" title="线性递归"></a>线性递归</h4><p>数组求和<br>以下仍以下数组求和问题为例，采用线性递归模式设计另一算法。首先注意到，若n =0则总和必为0，这也是最终的平凡情况。否则一般地，数组的总和可理解为前n-1个整数（即A[0,n-2]）之和，再加上A[]的最后一个元素（即A[n-1]）。 按这一思路，可设计出sum()算法如代码1.5所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性递归,数组求和</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = func(arr,arr.length);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> []  arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&lt;<span class="number">1</span>) ? <span class="number">0</span>:func(arr,n-<span class="number">1</span>)+arr[n-<span class="number">1</span>];</span><br><span class="line"><span class="comment">// n &lt; 1平凡情况，递归基</span></span><br><span class="line"><span class="comment">//return 0; //直接（非递归式）计算</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此实例可看出递归算法保证有穷性的基本技巧。 具体地，<strong>首先必须判断并处理n = 0之类的平凡情况，以免因无限递归而导致系统溢出。这类平凡情况统称“递归基”（base case ofrecursion）</strong>。<strong> 可能有多种平凡情况</strong>，但至少要有一种，且这类情况迟早必出现。比如，算法sum()的递归基只包含一种情况，只需简单地判断n是否已经减小到0</p><p>算法sum()是通过更深一层的自我调用来实现的，而且该函数的每一实例对自身的调用至多一次。于是，<strong>在每一层次上至多只有一个实例，且它们构成一个线性的次序关系。此类递归模式因而称作“线性递归” （linear recursion）</strong> ，它也是递归的最基本形式<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544754637/samples/java%20files/010.jpg" alt=""><br>该图清晰地给出了算法执行的整个过程：首先对参数n进行调用，再转向对参数n-1的调用，再转向对参数n-2的调用， …，直至最终的参数0。<br>在抵达递归基后不再递归，而是将平凡的解（长度为0数组的总和0）返回给对参数1的调用；累加上A[0]之后，再返回给对参数2的调用；<br>累加上A[1]之后，继续返回给对参数3的调用； …；如此依次返回，直到最终返回给对参数n的调用，此时，只需累加A[n-1]即得到整个数组的总和</p><p><strong>时间复杂度：</strong><br>具体地， 就以上的sum()算法而言，每一递归实例中非递归部分所涉及的计算无非三类（判断n是否为0、累加sum(n-1)与A[n-1]、返回当前总和） ，而且它们至多各执行一次。<br>鉴于它们均属于常数时间成本的基本操作，每个递归实例实际所需的计算时间都应为常数O(3)。由图还可以看出， <strong>对于长度为n的输入数组，递归深度应为n+1，故整个sum()算法共需运行(n+1) * O(3) = O(n)时间</strong></p><p><strong>空间复杂度：</strong><br>在创建了最后一个递归实例（即到达递归基）时，占用的空间量达到最大——准确地说，<strong>等于所有递归实例各自所占空间量的总和</strong>。<br>这里每一递归实例所需存放的数据，无非是<strong>调用参数（数组A的起始地址和长度n）以及用于累加总和的临时变量</strong>。<br>这些数据各自只需<strong>常数规模</strong>的空间，其总量也应为常数。<br>故此可知，<strong>sum()算法的空间复杂度线性正比于其递归的深度， 亦即O(n)</strong></p><p><strong>递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N).</strong></p><h5 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h5><p>线性递归模式往往对应于所谓<strong>减而治之（decrease-and-conquer）</strong> 的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。<br>按照减而治之策略，此处随着递归的深入，调用参数将单调地线性递减。因此无论最初输入的n有多大，递归调用的总次数都是有限的， 故算法的执行迟早会终止，即满足有穷性。<strong>当抵达递归基时，算法将执行非递归的计算（这里是返回0）</strong><br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544755213/samples/java%20files/112.jpg" alt=""></p><h5 id="递推方程"><a href="#递推方程" class="headerlink" title="递推方程"></a>递推方程</h5><p>该方法无需绘出具体的调用过程，而是通过对递归模式的数学归纳，导出关<br>于复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度分析的任务转化为递归方程（组）的求解</p><p>仍以代码线性递归版sum()算法为例， 将该算法处理长度为n的数组所需的时间成本记作T(n)。<br>我们将该算法的思路重新表述如下：为解决问题sum(A, n)，需递归地解决问题sum(A,n-1)，然后累加上A[n-1]。<br>按照这一新的理解，求解sum(A, n)所需的时间，应该等于求解sum(A,n-1)所需的时间，另加一次整数加法运算所需的时间。</p><p>根据以上分析，可以得到关于T(n)的如下一般性的递推关系：<br>T(n) = T(n-1) + O(1) = T(n-1) + c1，其中c1为常数<br>另一方面，当递归过程抵达递归基时，求解平凡问题sum(A, 0)只需（用于直接返回0的）常数时间。<br>如此，即可获得如下边界条件：<br>T(0) = O(1) = c2， 其中c2为常数<br>联立以上两个方程， 最终可以解得：<br><strong>T(n) = c1n + c2 = O(n)</strong></p><p><strong>递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N).</strong></p><p><strong>线性递归版sum()算法共需O(n)的附加空间</strong></p><h5 id="多递归基"><a href="#多递归基" class="headerlink" title="多递归基"></a>多递归基</h5><p>为保证有穷性， 所有递归算法都首先必须设有递归基，且确保对应的语句总能执行到。<br>实际上， 针对算法中可能出现的每一类平凡情况，都需要设置对应的递归基，因此同一算法的递归基可能（显式或隐式地）不止一个。<br>以下考察数组倒置问题， 也就是将数组中各元素的次序前后翻转。 比如，若输入数组为：<br>A[] = {3, 1, 4, 1, 5, 9, 2, 6}<br>则倒置后为：<br>A[] = {6, 2, 9, 5, 1, 4, 1, 3}<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544756811/samples/java%20files/113.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多递归基，数组倒置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reserse</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&gt;=a.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp =a[left];</span><br><span class="line">            a[left] =a[right];</span><br><span class="line">            a[right] = temp;</span><br><span class="line">            reserse(a,left+<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">////else隐含了两种递归基</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见，每深入递归一层，待倒置区间的长度 left - right + 1都缩短2个单元。因此， 所有递归实例所对应区间长度的奇偶性一致。<br><strong>需要特别留意的是， 此处递归基实际上分为两种情况： left = right（原数组长度为奇数）或left = right + 1（原数组长度为偶数）。当然，无论如何reverse()算法都必然会终止于这两种平凡情况之一，因此递归的深度应为：<br>[(n + 1) / 2] = O(n)</strong><br>在算法终止之前，递归每深入一层都会通过一次对换使得当前的A[left]与A[right]就位，因此该算法的时间复杂度也应线性正比于递归深度，即O(n)。</p><h4 id="二分递归"><a href="#二分递归" class="headerlink" title="二分递归"></a>二分递归</h4><h5 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h5><p>面对输入规模庞大的应用问题，每每感慨于头绪纷杂而无从下手的你，不妨从先哲孙子的名言中获取灵感“凡治众如治寡，分数是也” 。是的，解决此类问题的有效方法之一，就是将其<strong>分解为若干规模更小的子问题</strong>， 再通过递归机制分别求解。 这种分解持续进行，直到子问题规模缩减至平凡情况。这也就是所谓的分而治之（divide-and-conquer） 策略<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544757921/samples/java%20files/115.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分递归，数组求和</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&gt;=a.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> medium = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> sum(a,left,medium) + sum(a,medium+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544760574/samples/java%20files/117.jpg" alt=""></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544760532/samples/java%20files/1169.jpg" alt=""><br>针对n = 8的情况给出了sum(A, 0, 7)执行过程的递归跟踪。其中各方框都标注有对应的lo和hi值， 即子数组区间的起、止单元。<br>可见，按照调用的关系及次序，<strong>该方法的所有实例构成一个层次结构（即二叉树）</strong>。<br>沿着这个层次结构每下降一层，每个递归实例sum(lo, hi)都分裂为一对更小的实例sum(lo, mi)和sum(mi+1, hi)——准确地说，<strong>每经过一次递归调用， 子问题对应的数组区间长度hi-lo+1都将减半</strong>。</p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544794354/samples/java%20files/124.jpg" alt=""><br>算法启动后经连续m = log2n次递归调用，数组区间的长度从最初的n首次缩减至1，并到达第一个递归基。<br><strong>实际上，刚到达任一递归基时，已执行的递归调用总是比递归返回多m = log2n次。<br>更一般地，到达区间长度为2^k的任一递归实例之前，已执行的递归调用总是比递归返回多m-k次。</strong><br>因此，<strong>递归深度（即任一时刻的活跃递归实例的总数）不会超过m+1</strong>。<br>鉴于每个递归实例仅需常数空间， 故除数组本身所占的空间，该<strong>算法只需要O(m+1) = O(logn)的附加空间。</strong><br>我们还记得， 代码1.5 中线性递归版sum()算法共需O(n)的附加空间，就这一点而言，新的二分递归版sum()算法有很大改进</p><h3 id="02异常的继续体系和错误的区别"><a href="#02异常的继续体系和错误的区别" class="headerlink" title="02异常的继续体系和错误的区别"></a>02异常的继续体系和错误的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* A: 异常的继承体系</span><br><span class="line">Throwable: 它是所有错误与异常的超类（祖宗类）</span><br><span class="line">|- Error 错误</span><br><span class="line">|- Exception 编译期异常,进行编译JAVA程序时出现的问题</span><br><span class="line">|- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</span><br><span class="line">* B：异常与错误的区别</span><br><span class="line">* a：<span class="string">"异常Exception"</span></span><br><span class="line">* 指程序在<span class="string">"编译、运行期间"</span>发生了某种<span class="string">"异常(XxxException)"</span>，我们可以对异常进行具体的处理。</span><br><span class="line">* 若不处理异常，程序将会结束运行。</span><br><span class="line">* 案例演示：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，</span></span><br><span class="line"><span class="comment">// 由于没有处理异常，导致程序无法继续执行，程序结束。</span></span><br><span class="line">System.out.println(<span class="string">"over"</span>); <span class="comment">// 由于上面代码发生了异常，此句代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* b：<span class="string">"错误Error"</span></span><br><span class="line">* 指程序在<span class="string">"运行期间"</span>发生了某种<span class="string">"错误(XxxError)"</span>，Error错误通常<span class="string">"没有具体的处理方式"</span>，程序将会结束运行。</span><br><span class="line">* Error错误的发生往往都是<span class="string">"系统级别"</span>的问题，都是<span class="string">"jvm所在系统"</span>发生的，并反馈给jvm的。</span><br><span class="line">* 我们无法针对处理，<span class="string">"只能修正代码"</span>。</span><br><span class="line">* 案例演示：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line"><span class="comment">//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，</span></span><br><span class="line"><span class="comment">//导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03异常对象的产生原因和处理方式"><a href="#03异常对象的产生原因和处理方式" class="headerlink" title="03异常对象的产生原因和处理方式"></a>03异常对象的产生原因和处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* A: 异常对象的产生原因</span><br><span class="line">* 案例代码：</span><br><span class="line">* 工具类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span></span>&#123;</span><br><span class="line"><span class="comment">//对给定的数组通过给定的角标获取元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> element = arr[index];</span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* 测试类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(arr,<span class="number">4</span>)</span><br><span class="line">System.out.println(<span class="string">"num="</span>+num);</span><br><span class="line">System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* 原因分析：</span><br><span class="line">* a: 由于没找到<span class="number">4</span>索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。</span><br><span class="line">这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。</span><br><span class="line">java将这些信息直接封装到异常对象中。<span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="number">4</span>);</span><br><span class="line">* b：<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="number">4</span>);产生异常对象。JVM将产生的异常抛给调用者main()方法。</span><br><span class="line">* c：main()方法接收到了数组索引越界异常对象。</span><br><span class="line">由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。</span><br><span class="line">当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。</span><br><span class="line">* B：异常的处理方式</span><br><span class="line">* a：JVM的默认处理方式</span><br><span class="line">* 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。</span><br><span class="line">* 一旦有异常发生，其后来的代码不能继续执行。</span><br><span class="line">* b：解决程序中异常的手动方式</span><br><span class="line">* a)：编写处理代码 <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">* b)：抛出 <span class="keyword">throws</span></span><br><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="04方法内部抛出对象throw关键字"><a href="#04方法内部抛出对象throw关键字" class="headerlink" title="04方法内部抛出对象throw关键字"></a>04方法内部抛出对象throw关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在java中，提供了一个<span class="keyword">throw</span>关键字，它用来抛出一个指定的异常对象。</span><br><span class="line">* A: 什么时候使用<span class="keyword">throw</span>关键字？</span><br><span class="line">* 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，</span><br><span class="line">  数据若不合法，就应该告诉调用者，传递合法的数据进来。</span><br><span class="line">  这时需要使用抛出异常的方式来告诉调用者。</span><br><span class="line">* B: 使用<span class="keyword">throw</span>关键字具体操作</span><br><span class="line">* a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。</span><br><span class="line">* b: 通过关键字<span class="keyword">throw</span>将这个异常对象告知给调用者。<span class="keyword">throw</span> 异常对象；</span><br><span class="line"><span class="keyword">throw</span> 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</span><br><span class="line">* C: <span class="keyword">throw</span>关键字使用格式</span><br><span class="line">* <span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br><span class="line">* 例如：</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br><span class="line">* D：案例演示</span><br><span class="line">* <span class="keyword">throw</span>的使用</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="05方法声明异常关键字throws"><a href="#05方法声明异常关键字throws" class="headerlink" title="05方法声明异常关键字throws"></a>05方法声明异常关键字throws</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">* A: 声明</span><br><span class="line">* 将问题标识出来，报告给调用者。如果方法内通过<span class="keyword">throw</span>抛出了编译时异常，</span><br><span class="line">而<span class="string">"没有捕获处理"</span>（稍后讲解该方式），那么<span class="string">"必须通过"</span><span class="keyword">throws</span>进行声明，让<span class="string">"调用者去处理"</span>。</span><br><span class="line">* B: 声明异常格式</span><br><span class="line">* 修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>… &#123;   &#125;</span><br><span class="line">* C：注意事项：</span><br><span class="line">* <span class="keyword">throws</span>用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在<span class="keyword">throws</span>后面可以写多个异常类，用逗号隔开。</span><br><span class="line">* D：代码演示：</span><br><span class="line">* 多个异常的处理</span><br><span class="line"></span><br><span class="line"><span class="string">"//方法声明异常关键字"</span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//        func(arr);</span></span><br><span class="line">        func(trt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06try…catch异常处理"><a href="#06try…catch异常处理" class="headerlink" title="06try…catch异常处理"></a>06try…catch异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* A: 捕获</span><br><span class="line">* Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理</span><br><span class="line">* B: 捕获异常格式</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="string">"//需要被检测的语句。"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line"><span class="string">"//异常的处理语句。"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="string">"//一定会被执行的语句。"</span></span><br><span class="line">&#125;</span><br><span class="line">* C: 格式说明</span><br><span class="line"> * a: <span class="keyword">try</span></span><br><span class="line">* 该代码块中编写可能产生异常的代码。</span><br><span class="line"> * b: <span class="keyword">catch</span></span><br><span class="line">* 用来进行某种异常的捕获，实现对捕获到的异常进行处理。</span><br><span class="line"> * c: <span class="keyword">finally</span>：</span><br><span class="line">* <span class="string">"有一些特定的代码无论异常是否发生，都需要执行"</span>。</span><br><span class="line">* 另外，因为<span class="string">"异常会引发程序【跳转】到"</span><span class="keyword">catch</span>语句处，<span class="string">"导致有些语句执行不到"</span>。</span><br><span class="line">* 而<span class="keyword">finally</span>就是解决这个问题的，在<span class="keyword">finally</span>代码块中存放的<span class="string">"代码都是【一定】会被执行"</span>的。</span><br><span class="line"> * d：<span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="string">"处理掉异常后，程序可以继续执行"</span></span><br><span class="line">* D：案例演示</span><br><span class="line">* 捕获异常格式</span><br><span class="line"></span><br><span class="line"><span class="string">"//try…catch异常处理"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> result = func(arr);<span class="string">"//异常发生后后，程序将发生跳转到catch处执行"</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="string">"//try异常后面的语句不会执行"</span></span><br><span class="line">            System.out.println(<span class="string">"result: "</span>+ result);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序继续执行..."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="07多catch处理"><a href="#07多catch处理" class="headerlink" title="07多catch处理"></a>07多catch处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">* A：一个<span class="keyword">try</span> 多个<span class="keyword">catch</span>组合 </span><br><span class="line">* 对代码进行异常检测，并对检测的异常传递给<span class="keyword">catch</span>处理。对每种异常信息进行不同的捕获处理。</span><br><span class="line">* B：多<span class="keyword">catch</span>处理的格式</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个<span class="keyword">catch</span>中异常变量名为e。</span><br><span class="line"></span><br><span class="line"><span class="string">"//多catch处理"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> result = func(arr);<span class="comment">//异常发生后后，程序将发生跳转到catch出执行</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="comment">//try异常后面的语句不会执行</span></span><br><span class="line"><span class="comment">//            System.out.println("result: "+ result);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(NullPointerException nullex)&#123;</span><br><span class="line">            System.out.println(nullex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException outboundex)&#123;</span><br><span class="line">            System.out.println(outboundex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"程序继续执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> NullPointerException,ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08多catch处理细节"><a href="#08多catch处理细节" class="headerlink" title="08多catch处理细节"></a>08多catch处理细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A：细节：多个<span class="keyword">catch</span>小括号中，写的是异常类的类名，有没有顺序的概念？</span><br><span class="line">* 有顺序关系。</span><br><span class="line">* B：<span class="string">"平级异常"</span>：</span><br><span class="line">* 抛出的<span class="string">"异常类之间"</span>,<span class="string">"没有"</span><span class="string">"继承关系"</span>,<span class="string">"没有顺序"</span></span><br><span class="line">NullPointerException extends RuntimeException</span><br><span class="line">NoSuchElementException extends RuntimeException</span><br><span class="line">ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException</span><br><span class="line">* C：<span class="string">"上下级关系(继承关系)的异常"</span></span><br><span class="line">* 越高级的<span class="string">"父类"</span>,越<span class="string">"写在下面"</span>，《考虑多态的影响》</span><br><span class="line">NullPointerException extends RuntimeException extends Exception</span><br></pre></td></tr></table></figure><h3 id="09finally代码块"><a href="#09finally代码块" class="headerlink" title="09finally代码块"></a>09finally代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="keyword">finally</span>的特点</span><br><span class="line">  * <span class="string">"无论"</span><span class="keyword">try</span>...<span class="keyword">catch</span>语句<span class="string">"有没有异常出现"</span>，被<span class="keyword">finally</span>控制的<span class="string">"语句体"</span>一定<span class="string">"会执行"</span>，</span><br><span class="line">  * <span class="string">"除非"</span>发生<span class="string">"异常时"</span>在<span class="keyword">catch</span>语句中 有 <span class="string">"System.exit(0)"</span> 或者 <span class="keyword">try</span>语句外部<span class="string">"前面"</span><span class="string">"有异常"</span>出现;</span><br><span class="line">* B：<span class="keyword">finally</span>的作用</span><br><span class="line">  * <span class="keyword">finally</span>,无论程序是否有异常出现,程序必须执行释放资源在</span><br><span class="line">  如：IO流操作和数据库操作中会见到</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int result = func(arr);//异常发生后后，程序将发生跳转到catch处执行</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="comment">//try异常后面的语句不会执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"无论有无异常，这里的代码均会执行..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09finally代码块中有return语句"><a href="#09finally代码块中有return语句" class="headerlink" title="09finally代码块中有return语句"></a>09finally代码块中有return语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">警告： 当 <span class="keyword">finally</span> 子句包含 <span class="keyword">return</span> 语句时， 将会出现一种意想不到的结果。</span><br><span class="line">假设利用 <span class="keyword">return</span>语句从 <span class="keyword">try</span>语句块中退出。在<span class="string">"方法返回前"</span>，<span class="keyword">finally</span> 子句的内容<span class="string">"将【先被】执行"</span>。</span><br><span class="line">如果 <span class="keyword">finally</span> 子句中也有一个 <span class="keyword">return</span> 语句， 这个<span class="string">"返回值"</span>将会<span class="string">"【覆盖】"</span><span class="string">"原始的返回值"</span>。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = n * n;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">如果调用 f(<span class="number">2</span>), 那么 <span class="keyword">try</span> 语句块的计算结果为 r = <span class="number">4</span>, 并执行 <span class="keyword">return</span> 语句然而，在方法真</span><br><span class="line">正返回前</span><br><span class="line">，还要执行 <span class="keyword">finally</span> 子句。<span class="keyword">finally</span> 子句将使得方法返回 <span class="number">0</span>, 这个返回值覆盖了原</span><br><span class="line">始的返回值 <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="10try…catch…finally代码块详解"><a href="#10try…catch…finally代码块详解" class="headerlink" title="10try…catch…finally代码块详解"></a>10try…catch…finally代码块详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchFinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"//1"</span></span><br><span class="line"><span class="string">"code that might throw exceptions"</span></span><br><span class="line"><span class="string">"//2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"// 3"</span></span><br><span class="line"><span class="string">"show error message"</span></span><br><span class="line"><span class="string">"// 4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"// 5"</span></span><br><span class="line">in.close()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//6"</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在上面这段代码中，有下列 <span class="number">3</span> 种情况会执行 <span class="keyword">finally</span> 子句：</span><br><span class="line"><span class="number">1</span> ) <span class="string">"代码【没有】抛出异常"</span>。 在这种情况下， 程序首先执行 <span class="keyword">try</span> 语句块中的<span class="string">"全部代码"</span>，</span><br><span class="line">然后执行 <span class="keyword">finally</span> 子句中的代码 。随后， 继续执行 <span class="keyword">try</span>...<span class="keyword">finally</span>  语句块之<span class="string">"后的"</span>第一条<span class="string">"语句"</span>。</span><br><span class="line">也就是说，执行标注的 <span class="number">1</span>、 <span class="number">2</span>、 <span class="number">5</span>、 <span class="number">6</span> 处。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ) <span class="string">"抛出"</span>一个在 <span class="keyword">catch</span> 子句中<span class="string">"捕获的异常"</span>。在上面的示例中就是 IOException 异常。在这种</span><br><span class="line">情况下，程序将执行 <span class="keyword">try</span>语句块中的所有代码，<span class="string">"直到发生异常为止"</span>。此时，将<span class="string">"跳过"</span> <span class="keyword">try</span>语句块中</span><br><span class="line">的<span class="string">"剩余代码"</span>， 转去<span class="string">"执行与该异常匹配"</span>的 <span class="keyword">catch</span> 子句中的代码， 最后执行 <span class="keyword">finally</span> 子句中的代码。</span><br><span class="line">【分为以下<span class="number">2</span>种情况】：</span><br><span class="line">  A:如果 <span class="keyword">catch</span> 子句<span class="string">"没有抛出异常"</span>， 程序将执行 <span class="keyword">try</span> 语句块之后的第一条语句。</span><br><span class="line">  在这里，执行标注 <span class="number">1</span>、 <span class="number">3</span>、 <span class="number">4</span>、<span class="number">5</span>、 <span class="number">6</span> 处的语句。</span><br><span class="line"></span><br><span class="line">  B:如果 <span class="keyword">catch</span> 子句<span class="string">"抛出了一个异常"</span>， <span class="string">"异常"</span>将被<span class="string">"抛回"</span>这个方法的<span class="string">"调用者"</span>。</span><br><span class="line">  在这里， 执行标注<span class="number">1</span>、 <span class="number">3</span>、 <span class="number">5</span> 处的语句，<span class="string">"注意"</span>语句<span class="number">6</span><span class="string">"将不再执行"</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> ) 代码<span class="string">"抛出了一个异常"</span>， <span class="string">"但这个异常【不是】"</span>由 <span class="keyword">catch</span> 子句<span class="string">"捕获"</span>的。在这种情况下， 程序将</span><br><span class="line">执行 <span class="keyword">try</span> 语句块中的所有语句，<span class="string">"直到有异常被抛出为止"</span>。此时， 将<span class="string">"跳过"</span> <span class="keyword">try</span> 语句块中的<span class="string">"剩余代码"</span>， </span><br><span class="line">然后执行 <span class="keyword">finally</span>子句中的语句， 并将异常抛给这个方法的调用者。</span><br><span class="line">在这里， 执行标注 <span class="number">1</span>、<span class="number">5</span> 处的语句。<span class="string">"注意"</span>语句<span class="number">6</span><span class="string">"将不再执行"</span>。</span><br><span class="line"></span><br><span class="line">即：<span class="keyword">try</span>语句<span class="string">"抛出异常"</span>，但是<span class="keyword">catch</span><span class="string">"没有捕获"</span>的<span class="string">"异常"</span>或者 <span class="keyword">catch</span>语句<span class="string">"自身出现异常"</span>，<span class="number">6</span>处的代码<span class="string">"不会执行"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> 语句<span class="string">"可以只有"</span> <span class="keyword">finally</span> 子句，而<span class="string">"没有"</span><span class="keyword">catch</span> 子句。例如，下面这条 <span class="keyword">try</span> 语句：</span><br><span class="line">InputStream in = ...；</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">in.close()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10调用抛出异常方法try和throws处理方式"><a href="#10调用抛出异常方法try和throws处理方式" class="headerlink" title="10调用抛出异常方法try和throws处理方式"></a>10调用抛出异常方法try和throws处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* A: 在实际开发中使用哪种异常处理方式呢，</span><br><span class="line">* 继续向上<span class="keyword">throws</span> Exception 还是用 <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span>处理异常 ？</span><br><span class="line">* 能自己处理的尽量自己处理。(建议用<span class="keyword">try</span>...<span class="keyword">catch</span>)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span></span><br><span class="line"><span class="function">从给定字符串的开始解析文本，以生成一个日期。该方法不使用给定字符串的整个文本。 </span></span><br><span class="line"><span class="function">该方法本身会 <span class="keyword">throws</span> <span class="title">ParseException</span>  <span class="params">(声明可能抛出的异常)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class TryCatch_ThowsDemo </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ParseException ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date dd = sdf.parse(<span class="string">"2088-8-8"</span>);</span><br><span class="line">        System.out.println(dd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11运行时期异常RuntimeException的特点"><a href="#11运行时期异常RuntimeException的特点" class="headerlink" title="11运行时期异常RuntimeException的特点"></a>11运行时期异常RuntimeException的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 运行时期异常的概述: </span><br><span class="line"> * RuntimeException和<span class="string">"他的所有子类异常"</span>,都属于<span class="string">"运行时期异常"</span>。</span><br><span class="line"> 如常见的 NullPointerException,ArrayIndexOutOfBoundsException 等都属于运行时期异常.</span><br><span class="line">* B：运行时期异常的特点</span><br><span class="line"> * a：方法中<span class="string">"抛出运行时期异常"</span>,方法定义中<span class="string">"无需"</span><span class="keyword">throws</span><span class="string">"声明"</span>,调用者也<span class="string">"无需处理此异常"</span>。</span><br><span class="line"> * b：<span class="string">"运行时期异常一旦发生,【一定】是源代码发生了错误，需要程序人员【修改】【源代码】"</span>。</span><br><span class="line">设计原因:</span><br><span class="line">运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码</span><br><span class="line">运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 抛出<span class="string">"Exception"</span>，<span class="string">"必须要"</span><span class="keyword">throws</span><span class="string">"声明"</span>，</span><br><span class="line">一声明就<span class="string">"告知"</span><span class="string">"调用者"</span>进行<span class="string">"捕获"</span>，一旦<span class="string">"问题处理了"</span>调用者的<span class="string">"程序会继续执行"</span>。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 抛出<span class="string">"RuntimeExcpetion"</span>,<span class="string">"不需要"</span><span class="keyword">throws</span><span class="string">"声明"</span>的，</span><br><span class="line">这时调用是<span class="string">"不需要编写捕获代码"</span>的，因为调用者根本就不知道有问题。</span><br><span class="line">一旦发生RuntimeException，<span class="string">"调用者程序会停掉"</span>，</span><br><span class="line">并有jvm将信息显示到屏幕，让调用者看到问题，<span class="string">"修正代码"</span>。</span><br></pre></td></tr></table></figure><h3 id="12运行异常的案例"><a href="#12运行异常的案例" class="headerlink" title="12运行异常的案例"></a>12运行异常的案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* A: 计算圆的面积案例</span><br><span class="line">定义方法,计算圆形的面积</span><br><span class="line">传递参数<span class="number">0</span>,或者负数,计算的时候没有问题</span><br><span class="line">但是,违反了真实情况</span><br><span class="line">参数小于=<span class="number">0</span>, 停止程序,不要在计算了</span><br><span class="line">* B：数组索引越界案例</span><br><span class="line">使用数组中不存在的索引</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeExceptionDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = getArea(<span class="number">1</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,计算圆形的面积</span></span><br><span class="line"><span class="comment"> *  传递参数0,或者负数,计算的时候没有问题</span></span><br><span class="line"><span class="comment"> *  但是,违反了真实情况</span></span><br><span class="line"><span class="comment"> *  参数小于=0, 停止程序,不要在计算了</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 方法中<span class="string">"抛出运行时期异常"</span>,方法定义中<span class="string">"无需"</span><span class="keyword">throws</span><span class="string">"声明"</span>,调用者也<span class="string">"无需处理此异常"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"圆形不存在"</span>);</span><br><span class="line"><span class="keyword">return</span> r*r*Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//对数组的5索引进行判断,如果5索引大于100,请将3索引上的数据/2,否则除以3</span></span><br><span class="line"><span class="comment">//索引根本就没有</span></span><br><span class="line"><span class="keyword">if</span>(arr[<span class="number">3</span>] &gt; <span class="number">100</span>)&#123;</span><br><span class="line">arr[<span class="number">3</span>] = arr[<span class="number">3</span>]/<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[<span class="number">3</span>] = arr[<span class="number">3</span>]/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13方法重写时候异常的处理"><a href="#13方法重写时候异常的处理" class="headerlink" title="13方法重写时候异常的处理"></a>13方法重写时候异常的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* A：方法重写时候异常的处理</span><br><span class="line">* a：<span class="string">"子类"</span>覆盖<span class="string">"父类"</span>方法时，</span><br><span class="line">*   如果<span class="string">"父类"</span>的<span class="string">"方法"</span><span class="string">"声明异常"</span>，<span class="string">"子类"</span><span class="string">"只能"</span>声明<span class="string">"父类异常"</span>或者<span class="string">"父类异常的子类"</span>，或者<span class="string">"不声明"</span>。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123; &#125;  <span class="string">"//抛出父类一样的异常"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="string">"//抛出父类异常的子类"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125; <span class="string">"//不声明异常"</span></span><br><span class="line">&#125;</span><br><span class="line">* b：当<span class="string">"父类方法"</span>声明<span class="string">"多个异常"</span>时，<span class="string">"子类"</span><span class="string">"覆盖"</span>时<span class="string">"只能"</span>声明<span class="string">"多个异常"</span>的<span class="string">"子集"</span>(注意是<span class="string">"子集"</span>)。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="string">"//抛出父类异常中的一部分"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException </span>&#123; &#125; <span class="string">"//抛出父类异常中的一部分"</span></span><br><span class="line">&#125;</span><br><span class="line">* c：当<span class="string">"父类"</span>被覆盖的<span class="string">"方法"</span><span class="string">"没有"</span><span class="string">"异常声明"</span>时，<span class="string">"子类"</span>覆盖时<span class="string">"不能"</span><span class="string">"声明异常"</span>。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; &#125; ！！！error /<span class="string">"错误的方式"</span></span><br><span class="line">&#125;</span><br><span class="line">* B：问题：父类中会存在下列这种情况，接口也有这种情况。</span><br><span class="line">接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</span><br><span class="line">回答：无法进行<span class="keyword">throws</span>声明，只能<span class="keyword">catch</span>的捕获。</span><br><span class="line">万一问题处理不了呢？<span class="keyword">catch</span>中继续<span class="keyword">throw</span>抛出，但是只能将异常转换成RuntimeException子类抛出。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; <span class="comment">//无法声明 throws Exception</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//只能捕获处理</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"哥们，你定义的数组arr是空的!"</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"父方法中没有异常抛出，子类中不能抛出Exception异常"</span>);</span><br><span class="line">    <span class="comment">//我们把异常对象e，采用RuntimeException异常方式抛出</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14Throwable类方法"><a href="#14Throwable类方法" class="headerlink" title="14Throwable类方法"></a>14Throwable类方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">* A: 常见方法</span><br><span class="line">* a：<span class="string">"getMessage()方法"</span></span><br><span class="line">返回该异常的详细信息字符串，即<span class="string">"异常提示信息"</span></span><br><span class="line"></span><br><span class="line">* b：<span class="string">"toString()方法"</span></span><br><span class="line">返回该<span class="string">"异常的名称"</span>与<span class="string">"详细信息字符串"</span></span><br><span class="line"></span><br><span class="line">* c：<span class="string">"printStackTrace()方法"</span></span><br><span class="line">在控制台输出<span class="string">"该异常的名称"</span>与<span class="string">"详细信息字符串"</span>、<span class="string">"异常出现的代码【位置】"</span></span><br><span class="line">* B：案例演示</span><br><span class="line">异常的常用方法代码演示</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p= <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(“出现空指针异常了，请检查对象是否为<span class="keyword">null</span>”);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">String message = e.getMesage();</span><br><span class="line">System.out.println(message ); </span><br><span class="line"></span><br><span class="line">String result = e.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"--------------------------------------------1"</span>);</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"--------------------------------------------2"</span>);</span><br><span class="line">            System.out.println(ex.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"---------------------------------------------3"</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=arr.length)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组长度是"</span>+ arr.length +<span class="string">", 数组越界了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15自定义异常类"><a href="#15自定义异常类" class="headerlink" title="15自定义异常类"></a>15自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">* A: 自定义异常的定义</span><br><span class="line">例如NullPointerException异常类源代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="string">"//调用父类构造方法"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);<span class="string">"//调用父类具有异常信息的构造方法"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* a：通过阅读源码，发现规律：</span><br><span class="line">  每个异常中都<span class="string">"调用了父类的构造方法"</span>，把<span class="string">"异常描述信息"</span><span class="string">"传递"</span>给了<span class="string">"父类"</span>，</span><br><span class="line">  让<span class="string">"父类"</span>帮我们<span class="string">"进行异常信息的封装"</span>。</span><br><span class="line">* b：<span class="string">"格式"</span>：</span><br><span class="line">Class 异常名 extends Exception&#123; <span class="string">"//或继承RuntimeException"</span></span><br><span class="line"><span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 异常名(String s)&#123; </span><br><span class="line"><span class="keyword">super</span>(s); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* c：自定义异常<span class="string">"继承Exception"</span>演示</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="comment">// 如果自定义异常需要异常信息，</span></span><br><span class="line"><span class="comment">//可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* d：自定义异常<span class="string">"继承RuntimeException"</span>演示</span><br><span class="line">* <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyException()&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">MyException(String message)&#123;</span><br><span class="line"><span class="comment">// 如果自定义异常需要异常信息，</span></span><br><span class="line"><span class="comment">//可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">* B：自定义异常的练习</span><br><span class="line">在Person类的有参数构造方法中，进行年龄范围的判断，</span><br><span class="line">若年龄为负数或大于<span class="number">200</span>岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。</span><br><span class="line">要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。</span><br><span class="line"></span><br><span class="line"><span class="string">"//自定义异常类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//Person类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> AgeException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeException(<span class="string">"年龄输入有误:"</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">        <span class="keyword">this</span>.age =age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名： "</span>+ name + <span class="string">" |年龄: "</span>+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//测试类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person p= <span class="keyword">new</span> Person(<span class="string">"张楠"</span>, <span class="number">209</span>);</span><br><span class="line">            System.out.println(p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(AgeException aex)&#123;</span><br><span class="line">            aex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">* C：关于构造方法<span class="string">"抛出异常总结"</span></span><br><span class="line">(<span class="number">1</span>) 抛出<span class="string">"Exception"</span>，<span class="string">"必须要"</span><span class="keyword">throws</span><span class="string">"声明"</span>，</span><br><span class="line">一声明就<span class="string">"告知"</span><span class="string">"调用者"</span>进行<span class="string">"捕获"</span>，一旦<span class="string">"问题处理了"</span>调用者的<span class="string">"程序会继续执行"</span>。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 抛出<span class="string">"RuntimeExcpetion"</span>,<span class="string">"不需要"</span><span class="keyword">throws</span><span class="string">"声明"</span>的，</span><br><span class="line">这时调用是<span class="string">"不需要编写捕获代码"</span>的，因为调用者根本就不知道有问题。</span><br><span class="line">一旦发生RuntimeException，<span class="string">"调用者程序会停掉"</span>，</span><br><span class="line">并有jvm将信息显示到屏幕，让调用者看到问题，<span class="string">"修正代码"</span>。</span><br></pre></td></tr></table></figure><h3 id="16总结"><a href="#16总结" class="headerlink" title="16总结"></a>16总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> 异常：就是程序中出现的不正常的现象(错误与异常)</span><br><span class="line"> 异常的继承体系:</span><br><span class="line">Throwable: 它是所有错误与异常的超类（祖宗类）</span><br><span class="line">|- Error 错误，修改java源代码</span><br><span class="line">|- Exception 编译期异常, javac.exe进行编译的时候报错</span><br><span class="line">|- RuntimeException 运行期异常, java出现运行过程中出现的问题</span><br><span class="line"></span><br><span class="line"> 异常处理的两种方式：</span><br><span class="line"> <span class="number">1</span>，出现问题，自己解决 <span class="keyword">try</span>…<span class="keyword">catch</span>…<span class="keyword">finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能出现异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名  对象名)&#123;</span><br><span class="line">    异常处理代码 </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">异常操作中一定要执行的代码</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">2</span>，出现问题，别人解决 <span class="keyword">throws</span></span><br><span class="line">格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>,...&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"> 异常分类</span><br><span class="line">异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。</span><br><span class="line"> 严重错误Error，无法通过处理的错误</span><br><span class="line"> 编译时异常Exception，编译时无法编译通过。如日期格式化异常</span><br><span class="line"> 运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如空指针异常</span><br><span class="line"></span><br><span class="line"> 异常基本操作</span><br><span class="line"> 创建异常对象</span><br><span class="line"> 抛出异常</span><br><span class="line"> 处理异常：</span><br><span class="line"> 捕获处理，将异常获取，使用<span class="keyword">try</span>/<span class="keyword">catch</span>做分支处理</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">需要检测的异常；</span><br><span class="line">&#125;  <span class="keyword">catch</span>(异常对象) &#123;</span><br><span class="line">通常我们只使用一个方法：printStackTrace打印异常信息</span><br><span class="line">&#125;</span><br><span class="line"> <span class="string">"声明抛出处理"</span>，<span class="string">"出现异常后不处理"</span>，<span class="string">"声明抛出给调用者处理"</span>。</span><br><span class="line">  方法声明上加<span class="keyword">throws</span>  异常类名</span><br><span class="line"> <span class="string">"注意"</span>：异常的处理，指处理<span class="string">"异常"</span>的<span class="string">"一种可能性"</span>，即有了异常处理的代码，<span class="string">"不一定"</span>会<span class="string">"产生异常"</span>。</span><br><span class="line">如果没有产生异常，则代码正常执行，如果产生了异常，则中断当前执行代码，执行异常处理代码。</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"> 异常注意事项</span><br><span class="line"> 多异常处理</span><br><span class="line">捕获处理：</span><br><span class="line">        <span class="number">1</span>多个异常可以分别处理</span><br><span class="line"><span class="number">2</span>多个异常一次捕获多次处理</span><br><span class="line"><span class="number">3</span>多个异常一次捕获，采用同一种方式处理</span><br><span class="line">声明抛出异常：</span><br><span class="line">声明上使用,一次声明多个异常</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"> <span class="string">"运行时异常"</span>被抛出可以<span class="string">"不处理"</span>。<span class="string">"即不捕获"</span><span class="string">"也不声明抛出"</span></span><br><span class="line"></span><br><span class="line"> 如果<span class="string">"父类"</span>抛出了<span class="string">"多个异常"</span>,<span class="string">"子类覆盖父类方法"</span>时,<span class="string">"只能"</span>抛出相同的异常或者是他的<span class="string">"子集"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"父类"</span>方法<span class="string">"没有"</span>抛出异常，<span class="string">"子类覆盖父类该方法"</span>时也<span class="string">"不可抛出异常"</span>。</span><br><span class="line">  此时子类产生该异常，只能捕获处理，不能声明抛出</span><br><span class="line"></span><br><span class="line"> 当<span class="string">"多"</span><span class="keyword">catch</span>异常处理时，捕获处理，<span class="string">"前边的类"</span><span class="string">"不能"</span>是<span class="string">"后边类"</span>的<span class="string">"父类"</span></span><br><span class="line"></span><br><span class="line"> 自定义异常</span><br><span class="line">如果Java没有提供你需要的异常，则可以自定义异常类。</span><br><span class="line">定义方法：编译时异常继承Exception，运行时异常继承RuntimeException。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1544254144/samples/java%20files/photo-1542312455-e31bb150371c.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;br&gt;2、&lt;br&gt;3、&lt;br&gt;4、&lt;br&gt;5、&lt;br&gt;6、&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://leesen998.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://leesen998.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础31()</title>
    <link href="https://leesen998.github.io/2016/12/02/day33%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/12/02/day33笔记/</id>
    <published>2016-12-02T11:48:29.000Z</published>
    <updated>2019-01-12T13:00:28.273Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297948/samples/java%20files/photo-1544728344-7efa025e5603.jpg" alt="" style="width:100%"></p><p>1、类加载器<br>2、反射构造方法<br>3、反射成员变量<br>4、反射成员方法<br>5、反射配置文件运行类中的方法 </p><a id="more"></a><h3 id="01类加载器"><a href="#01类加载器" class="headerlink" title="01类加载器"></a>01类加载器</h3><pre><code>* A.类的加载    当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。    * a 加载         * 就是指将class文件读入内存，并为之创建一个Class对象。        * 任何类被使用时系统都会建立一个Class对象    * b 连接        * 验证 是否有正确的内部结构，并和其他类协调一致        * 准备 负责为类的静态成员分配内存，并设置默认初始化值        * 解析 将类的二进制数据中的符号引用替换为直接引用    * c 初始化         * 就是我们以前讲过的初始化步骤（new 对象）    * 注：简单的说就是：把.class文件加载到内存里，并把这个.class文件封装成一个Class类型的对象。* B.类的加载时机    以下的情况，会加载这个类。    * a. 创建类的实例    * b. 类的静态变量，或者为静态变量赋值    * c. 类的静态方法    * d. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象    * e. 初始化某个类的子类    * f. 直接使用java.exe命令来运行某个主类* C: 类加载器(了解)    负责将.class文件加载到内在中，并为之生成对应的Class对象。    * a. Bootstrap ClassLoader 根类加载器        * 也被称为引导类加载器，负责Java核心类的加载        * 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中</code></pre><p>        * b. Extension ClassLoader 扩展类加载器</p><pre><code>* 负责JRE的扩展目录中jar包的加载。* 在JDK中JRE的lib目录下ext目录</code></pre><p>        * c. System ClassLoader 系统类加载器</p><pre><code>* 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。* 我们用的是System ClassLoader 系统类加载器</code></pre><h3 id="02-反射定义"><a href="#02-反射定义" class="headerlink" title="02 反射定义"></a>02 反射定义</h3><pre><code>* a. JAVA反射机制是在运行状态中，        对于任意一个类，都能够知道这个类的所有属性和方法；        对于任意一个对象，都能够调用它的任意一个方法和属性；    这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。* b.反射技术    条件：运行状态    已知：一个类或一个对象(根本是已知.class文件)    结果：得到这个类或对象的所有方法和属性* 注: 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。</code></pre><h3 id="B-Class类"><a href="#B-Class类" class="headerlink" title="* B. Class类"></a>* B. Class类</h3><pre><code>* a. Class类及Class对象的了解    要想解剖一个类，必须先了解Class对象。    阅读API的Class类得知，Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。* b. 得到Class对象    * 1. 有三个方法        方式一: 通过Object类中的getClass()方法            Person person = new Person();            Class clazz = person.getClass();        方式二: 通过 类名.class 获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。            Class clazz = Person.class;        方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。            Class c3 = Class.forName(&quot;Person&quot;);        注：第三种和前两种的区别是：                前两种你必须明确Person类型.                后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了    * 2. 得到Class对象的三个方法代码演示：        代码演示        /*         * 获取.class字节码文件对象的方式         *         1：通过Object类中的getObject()方法         *         2: 通过 类名.class 获取到字节码文件对象         *         3: 反射中的方法,         *             public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException         *             返回与带有给定字符串名的类或接口相关联的 Class 对象          */        public class ReflectDemo {            public static void main(String[] args) throws ClassNotFoundException {                // 1： 通过Object类中的getObject()方法                // Person p1 = new Person();                // Class c1 = p1.getClass();                // System.out.println(&quot;c1 = &quot;+ c1);                // 2: 通过 类名.class 获取到字节码文件对象                // Class c2 = Person.class;                // System.out.println(&quot;c2 = &quot;+ c2);                // 3: 反射中的方法                Class c3 = Class.forName(&quot;cn.itcast_01_Reflect.Person&quot;);// 包名.类名                System.out.println(&quot;c3 = &quot; + c3);            }        }</code></pre><p>                Person类<br>                package cn.itcast_01_Reflect;<br>                public class Person {<br>                    //成员变量<br>                    public String name;<br>                    public int age;<br>                    private String address;</p><pre><code>        //构造方法        public Person() {            System.out.println(&quot;空参数构造方法&quot;);        }        public Person(String name) {            this.name = name;            System.out.println(&quot;带有String的构造方法&quot;);        }        //私有的构造方法        private Person(String name, int age){            this.name = name;            this.age = age;            System.out.println(&quot;带有String，int的构造方法&quot;);        }        public Person(String name, int age, String address){            this.name = name;            this.age = age;            this.address = address;            System.out.println(&quot;带有String, int, String的构造方法&quot;);        }        //成员方法        //没有返回值没有参数的方法        public void method1(){            System.out.println(&quot;没有返回值没有参数的方法&quot;);        }        //没有返回值，有参数的方法        public void method2(String name){            System.out.println(&quot;没有返回值，有参数的方法 name= &quot;+ name);        }        //有返回值，没有参数        public int method3(){            System.out.println(&quot;有返回值，没有参数的方法&quot;);            return 123;        }        //有返回值，有参数的方法        public String method4(String name){            System.out.println(&quot;有返回值，有参数的方法&quot;);            return &quot;哈哈&quot; + name;        }        //私有方法        private void method5(){            System.out.println(&quot;私有方法&quot;);        }        @Override        public String toString() {            return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address+ &quot;]&quot;;        }    }* 注: Class类型的唯一性    因为一个.class文件在内存里只生成一个Class对象，所以无论那一种方法得到Class对象，得到的都是同一个对象。</code></pre><h3 id="C-通过反射获取无参构造方法并使用"><a href="#C-通过反射获取无参构造方法并使用" class="headerlink" title="* C.通过反射获取无参构造方法并使用"></a>* C.通过反射获取无参构造方法并使用</h3><pre><code>* a. 得到无参构造方法    public Constructor&lt;?&gt;[] getConstructors()         获取所有的public 修饰的构造方法。        选择无参构造方法，不建议使用。    public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)         获取public修饰, 指定参数类型所对应的构造方法。        不传参数得到无参构造方法。* b. 运行无参构造方法    public T newInstance(Object... initargs)         使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。         因为是无参构造，所以不传参数。* c. 通过反射获取无参构造方法并使用的代码演示：        package cn.itcast.demo1;        import java.lang.reflect.Constructor;        /*         *  通过反射获取class文件中的构造方法,运行构造方法         *  运行构造方法,创建对象         *    获取class文件对象         *    从class文件对象中,获取需要的成员         *             *  Constructor 描述构造方法对象类         */        public class ReflectDemo1 {            public static void main(String[] args) throws Exception {                Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);                //使用class文件对象,获取类中的构造方法                //  Constructor[]  getConstructors() 获取class文件对象中的所有公共的构造方法                /*Constructor[] cons = c.getConstructors();                for(Constructor con : cons){                    System.out.println(con);                }*/                //获取指定的构造方法,空参数的构造方法                Constructor con =  c.getConstructor();                //运行空参数构造方法,Constructor类方法 newInstance()运行获取到的构造方法                Object obj = con.newInstance();                System.out.println(obj.toString());            }        }</code></pre><h3 id="D-通过反射获取有参构造方法并使用"><a href="#D-通过反射获取有参构造方法并使用" class="headerlink" title="* D. 通过反射获取有参构造方法并使用"></a>* D. 通过反射获取有参构造方法并使用</h3><pre><code>* a. 得到有参的构造方法    public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)         获取public修饰, 指定参数类型所对应的构造方法。        传相应的参数类型得到有参构造方法。* b. 运行无参构造方法    public T newInstance(Object... initargs)         使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。         因为是有参构造，所以传相应的参数值。* c. 通过反射获取有参构造方法并使用的代码演示：    package cn.itcast.demo1;    import java.lang.reflect.Constructor;    /*     *  通过反射,获取有参数的构造方法并运行     *  方法getConstructor,传递可以构造方法相对应的参数列表即可     */    public class ReflectDemo2 {        public static void main(String[] args)throws Exception {            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            //获取带有,String和int参数的构造方法            //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)              //Class&lt;?&gt;... parameterTypes 传递要获取的构造方法的参数列表            Constructor con = c.getConstructor(String.class,int.class);            //运行构造方法            // T newInstance(Object... initargs)              //Object... initargs 运行构造方法后,传递的实际参数            Object obj = con.newInstance(&quot;张三&quot;,20);            System.out.println(obj);        }    }</code></pre><h3 id="E-通过反射获取有参构造方法并使用快捷方式"><a href="#E-通过反射获取有参构造方法并使用快捷方式" class="headerlink" title="* E. 通过反射获取有参构造方法并使用快捷方式"></a>* E. 通过反射获取有参构造方法并使用快捷方式</h3><pre><code>* a. 使用的前提    类有空参的公共构造方法。（如果是同包，默认权限也可以）* b. 使用的基础    Class类的 public T newInstance() 方法         创建此 Class 对象所表示的类的一个新实例。* c. 通过反射获取有参构造方法并使用快捷方式的代码演示：    package cn.itcast.demo1;    /*     * 反射获取构造方法并运行,有快捷点的方式     * 有前提:     *   被反射的类,必须具有空参数构造方法     *   构造方法权限必须public     */    public class ReflectDemo3 {        public static void main(String[] args) throws Exception {            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            // Class类中定义方法, T newInstance() 直接创建被反射类的对象实例            Object obj = c.newInstance();            System.out.println(obj);        }    }</code></pre><h3 id="F-通过反射获取私有构造方法并使用"><a href="#F-通过反射获取私有构造方法并使用" class="headerlink" title="* F. 通过反射获取私有构造方法并使用"></a>* F. 通过反射获取私有构造方法并使用</h3><pre><code>* a. 得到私有的构造方法    public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)         获取指定参数类型所对应的构造方法(包含私有的)。    public Constructor&lt;?&gt;[] getDeclaredConstructors()         获取所有的构造方法(包含私有的)。* b. 运行私有构造方法    public void setAccessible(boolean flag)        将此对象的 accessible 标志设置为指示的布尔值。        设置为true,这个方法保证我们得到的私有构造方法的运行。（取消运行时期的权限检查。）    public T newInstance(Object... initargs)         使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 * c. 通过反射获取私有构造方法并使用的代码演示：    package cn.itcast.demo1;    import java.lang.reflect.Constructor;    /*     *  反射获取私有的构造方法运行     *  不推荐,破坏了程序的封装性,安全性     *  暴力反射     */    public class ReflectDemo4 {        public static void main(String[] args) throws Exception{            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            //Constructor[] getDeclaredConstructors()获取所有的构造方法,包括私有的            /*Constructor[] cons = c.getDeclaredConstructors();            for(Constructor con : cons){                System.out.println(con);            }*/            //Constructor getDeclaredConstructor(Class...c)获取到指定参数列表的构造方法            Constructor con = c.getDeclaredConstructor(int.class,String.class);            //Constructor类,父类AccessibleObject,定义方法setAccessible(boolean b)            con.setAccessible(true);            Object obj = con.newInstance(18,&quot;lisi&quot;);            System.out.println(obj);        }    }* 注：不推荐，破坏了程序的封装性,安全性。</code></pre><h3 id="G-反射获取成员变量并改值"><a href="#G-反射获取成员变量并改值" class="headerlink" title="* G. 反射获取成员变量并改值"></a>* G. 反射获取成员变量并改值</h3><pre><code>* a. 获取成员变量    * 得到公共的成员变量        public Field getField(String name)             返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。         public Field[] getFields()             返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。     * 得到所有的成员变量(包括私有的，如果要进行修改私有成员变量，要先进行public void setAccessible(boolean flag) 设置。)        public Field getDeclaredField(String name)             返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。         public Field[] getDeclaredFields()             返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。 * b. 修改成员变量(Field)的值    * 修改公共的成员变量        public void set(Object obj, Object value)             将指定对象变量上此 Field 对象表示的字段设置为指定的新值。             obj指的是修改的是那个对象的这个成员变量值。* c. 反射获取成员变量并改值的代码演示    package cn.itcast.demo1;    import java.lang.reflect.Field;    /*     *  反射获取成员变量,并修改值     *  Person类中的成员String name     */    public class ReflectDemo5 {        public static void main(String[] args) throws Exception{            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            Object obj = c.newInstance();            //获取成员变量 Class类的方法 getFields() class文件中的所有公共的成员变量            //返回值是Field[]    Field类描述成员变量对象的类            /*Field[] fields = c.getFields();            for(Field f : fields){                System.out.println(f);            }*/            //获取指定的成员变量 String name            //Class类的方法  Field getField(传递字符串类型的变量名) 获取指定的成员变量            Field field = c.getField(&quot;name&quot;);            //Field类的方法 void set(Object obj, Object value) ,修改成员变量的值            //Object obj 必须有对象的支持,  Object value 修改后的值            field.set(obj,&quot;王五&quot;);            System.out.println(obj);        }    }</code></pre><h3 id="H-反射获取空参数成员方法并运行"><a href="#H-反射获取空参数成员方法并运行" class="headerlink" title="* H. 反射获取空参数成员方法并运行"></a>* H. 反射获取空参数成员方法并运行</h3><pre><code>* a. 获取空参数成员方法    * 得到公共的成员方法        public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)             返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。         public Method[] getMethods()            返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。    * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)        public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)             返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。         public Method[] getDeclaredMethods()             返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 * b. 使用Method方法对象    public Object invoke(Object obj, Object... args)         对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。         obj 指的是调这个方法的对象。        args 指的是调用这个方法所要用到的参数列表。        返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.* c. 反射获取空参数成员方法并运行代码演示    package cn.itcast.demo1;    import java.lang.reflect.Method;    /*     *  反射获取成员方法并运行     *  public void eat(){}     */    public class ReflectDemo6 {        public static void main(String[] args) throws Exception{            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            Object obj = c.newInstance();            //获取class对象中的成员方法            // Method[] getMethods()获取的是class文件中的所有公共成员方法,包括继承的            // Method类是描述成员方法的对象            /*Method[] methods = c.getMethods();            for(Method m : methods){                System.out.println(m);            }*/            //获取指定的方法eat运行            // Method getMethod(String methodName,Class...c)            // methodName获取的方法名  c 方法的参数列表            Method method = c.getMethod(&quot;eat&quot;);            //使用Method类中的方法,运行获取到的方法eat            //Object invoke(Object obj, Object...o)            method.invoke(obj);        }    }</code></pre><h3 id="I-反射获取有参数成员方法并运行"><a href="#I-反射获取有参数成员方法并运行" class="headerlink" title="* I. 反射获取有参数成员方法并运行"></a>* I. 反射获取有参数成员方法并运行</h3><pre><code>* a. 获取有参数成员方法    * 得到公共的成员方法        public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)             返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。         public Method[] getMethods()            返回一个包含某些 Method 对象的数组，这些对象反映此 Class对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。    * 得到全部的成员方法(包括私有的，如果要使用私有成员方法，要先进行public void setAccessible(boolean flag) 设置。)        public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)             返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。         public Method[] getDeclaredMethods()             返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 * b. 使用Method方法对象    public Object invoke(Object obj, Object... args)         对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。         obj 指的是调这个方法的对象。        args 指的是调用这个方法所要用到的参数列表。        返回值Object就是方法的返回对象。如果方法没有返回值 ，返回的是null.* c. 反射获取有参数成员方法并运行代码演示    package cn.itcast.demo1;    import java.lang.reflect.Method;    /*     *  反射获取有参数的成员方法并执行     *  public void sleep(String,int,double){}     */    public class ReflectDemo7 {        public static void main(String[] args) throws Exception{            Class c = Class.forName(&quot;cn.itcast.demo1.Person&quot;);            Object obj = c.newInstance();            //调用Class类的方法getMethod获取指定的方法sleep            Method method = c.getMethod(&quot;sleep&quot;, String.class,int.class,double.class);            //调用Method类的方法invoke运行sleep方法            method.invoke(obj, &quot;休眠&quot;,100,888.99);        }    }</code></pre><h3 id="J-反射泛型擦除"><a href="#J-反射泛型擦除" class="headerlink" title="* J. 反射泛型擦除"></a>* J. 反射泛型擦除</h3><pre><code>* a. 使用情况    例如：在泛型为String的集合里，添加Integer的数据    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();    list.add(100);* b. 能用泛型擦除的理论    伪泛型：在编译后的.class文件里面是没有泛型的。类型为Object。    用反射的方法绕过编译，得到Class文件对象，直接调用add方法。* c. 反射泛型擦除的代码演示    package cn.itcast.demo2;    import java.lang.reflect.Method;    import java.util.ArrayList;    /*     *   定义集合类,泛型String     *   要求向集合中添加Integer类型     *        *   反射方式,获取出集合ArrayList类的class文件对象     *   通过class文件对象,调用add方法     *        *   对反射调用方法是否理解     */    public class ReflectTest {        public static void main(String[] args)throws Exception {            ArrayList&lt;String&gt; array  = new ArrayList&lt;String&gt;();            array.add(&quot;a&quot;);            //反射方式,获取出集合ArrayList类的class文件对象            Class c = array.getClass();            //获取ArrayList.class文件中的方法add            Method method = c.getMethod(&quot;add&quot;,Object.class);            //使用invoke运行ArrayList方法add            method.invoke(array, 150);            method.invoke(array, 1500);            method.invoke(array, 15000);            System.out.println(array);        }    }</code></pre><h3 id="K-反射通过配置文件来决定运行的步骤"><a href="#K-反射通过配置文件来决定运行的步骤" class="headerlink" title="* K. 反射通过配置文件来决定运行的步骤"></a>* K. 反射通过配置文件来决定运行的步骤</h3><pre><code>* a. 操作依据        通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法* b. 实现步骤:     *    1. 准备配置文件,键值对     *    2. IO流读取配置文件  Reader     *    3. 文件中的键值对存储到集合中 Properties     *        集合保存的键值对,就是类名和方法名     *    4. 反射获取指定类的class文件对象     *    5. class文件对象,获取指定的方法     *    6. 运行方法* c. 代码演示    代码：    package cn.itcast.demo3;    import java.io.FileReader;    import java.lang.reflect.Method;    import java.util.Properties;    /*     *  调用Person方法,调用Student方法,调用Worker方法     *  类不清楚,方法也不清楚     *  通过配置文件实现此功能     *    运行的类名和方法名字,以键值对的形式,写在文本中     *    运行哪个类,读取配置文件即可     *  实现步骤:     *    1. 准备配置文件,键值对     *    2. IO流读取配置文件  Reader     *    3. 文件中的键值对存储到集合中 Properties     *        集合保存的键值对,就是类名和方法名     *    4. 反射获取指定类的class文件对象     *    5. class文件对象,获取指定的方法     *    6. 运行方法     */    public class Test {        public static void main(String[] args) throws Exception{            //IO流读取配置文件            FileReader r = new FileReader(&quot;config.properties&quot;);            //创建集合对象            Properties pro = new Properties();            //调用集合方法load,传递流对象            pro.load(r);            r.close();            //通过键获取值            String className = pro.getProperty(&quot;className&quot;);            String methodName = pro.getProperty(&quot;methodName&quot;);            //反射获取指定类的class文件对象            Class c = Class.forName(className);            Object obj = c.newInstance();            //获取指定的方法名            Method method = c.getMethod(methodName);            method.invoke(obj);        }    }    配置文件：    #className=cn.itcast.demo3.Student    #methodName=study    className=cn.itcast.demo3.Person    methodName=eat    #className=cn.itcast.demo3.Worker    #methodName=job</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297948/samples/java%20files/photo-1544728344-7efa025e5603.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、类加载器&lt;br&gt;2、反射构造方法&lt;br&gt;3、反射成员变量&lt;br&gt;4、反射成员方法&lt;br&gt;5、反射配置文件运行类中的方法 &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础30()</title>
    <link href="https://leesen998.github.io/2016/12/01/day32%E7%AC%94%E8%AE%B0%20/"/>
    <id>https://leesen998.github.io/2016/12/01/day32笔记 /</id>
    <published>2016-12-01T11:48:29.000Z</published>
    <updated>2019-01-12T12:59:35.424Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297959/samples/java%20files/photo-1544833021-2f0c8afb7fd6.jpg" alt="" style="width:100%"></p><p>1、网络三要素及传输协议<br>2、实现UDP协议的发送端和接收端<br>3、实现TCP协议的客户端和服务器<br>4、TCP上传文件案例</p><a id="more"></a><h3 id="01网络模型"><a href="#01网络模型" class="headerlink" title="01网络模型"></a>01网络模型</h3><p>  *A:网络模型<br>     TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<br>       链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>       网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>       传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>       应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h3 id="02IP地址"><a href="#02IP地址" class="headerlink" title="02IP地址"></a>02IP地址</h3><p> *A:IP地址<br>      在TCP/IP协议中，这个标识号就是IP地址，它可以唯一标识一台计算机，<br>      目前，IP地址广泛使用的版本是IPv4，它是由4个字节大小的二进制数来表示，如：00001010000000000000000000000001。<br>      由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，<br>      每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”<br>      127.0.0.1 为本地主机地址(本地回环地址)</p><h3 id="03端口号"><a href="#03端口号" class="headerlink" title="03端口号"></a>03端口号</h3><p> *A:端口号<br>    通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。<br>    在计算机中，不同的应用程序是通过端口号区分的。<br>    端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535，<br>    其中，0~1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用</p><h3 id="04InetAddress类"><a href="#04InetAddress类" class="headerlink" title="04InetAddress类"></a>04InetAddress类</h3><p>  <em>A:InetAddress类<br>     /</em></p><pre><code> *  表示互联网中的IP地址 *    java.net.InetAddress *  静态方法 *    static InetAddress  getLocalHost()   LocalHost本地主机 *    返回本地主机,返回值InetAddress对象 *     *    static InetAddress getByName(String hostName)传递主机名,获取IP地址对象 *     *  非静态方法 *     String getHoustAddress()获取主机IP地址 *     String getHoustName()获取主机名 *     */public class InetAddressDemo { public static void main(String[] args)throws UnknownHostException {   function_1(); } /*  * static InetAddress getByName(String hostName)传递主机名,获取IP地址对象  */ public static void function_1()throws UnknownHostException {   InetAddress inet = InetAddress.getByName(&quot;www.baidu.com&quot;);   System.out.println(inet); } /*  *  static InetAddress  getLocalHost()   LocalHost本地主机  */ public static void function() throws UnknownHostException{   InetAddress inet = InetAddress.getLocalHost();   //输出结果就是主机名,和 IP地址   System.out.println(inet.toString());   String ip = inet.getHostAddress();   String name = inet.getHostName();   System.out.println(ip+&quot;   &quot;+name);   /*String host = inet.toString();   String[] str = host.split(&quot;/&quot;);   for(String s : str){     System.out.println(s);   }*/ }}</code></pre><h3 id="05UDP协议"><a href="#05UDP协议" class="headerlink" title="05UDP协议"></a>05UDP协议</h3><p>   A:UDP协议<br>     a:UDP协议概述:<br>      UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。<br>      简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。<br>     b:UDP协议特点:<br>      由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，<br>      因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><h3 id="06TCP协议"><a href="#06TCP协议" class="headerlink" title="06TCP协议"></a>06TCP协议</h3><p>  *A:TCP协议<br>    TCP协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。<br>    在TCP连接中必须要明确客户端与服务器端，<br>      由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。<br>      第一次握手，客户端向服务器端发出连接请求，等待服务器确认<br>      第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求<br>      第三次握手，客户端再次向服务器端发送确认信息，确认连接</p><h3 id="07数据包和发送对象介绍"><a href="#07数据包和发送对象介绍" class="headerlink" title="07数据包和发送对象介绍"></a>07数据包和发送对象介绍</h3><p>  *A:数据包和发送对象介绍:<br>    DatagramPacket数据包的作用就如同是“集装箱”，<br>       可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。<br>       在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。<br>       DatagramSocket类的作用就类似于码头，使用这个类的实例对象就可以发送和接收DatagramPacket数据包<br>    DatagramPacket:封装数据<br>    DatagramSocket:发送DatagramPacket</p><h3 id="08UDP发送端"><a href="#08UDP发送端" class="headerlink" title="08UDP发送端"></a>08UDP发送端</h3><p>   <em>A:UDP发送端<br>         /</em></p><pre><code> *  实现UDP协议的发送端: *    实现封装数据的类 java.net.DatagramPacket  将你的数据包装 *    实现数据传输的类 java.net.DatagramSocket  将数据包发出去 *     *  实现步骤: *    1. 创建DatagramPacket对象,封装数据, 接收的地址和端口 *    2. 创建DatagramSocket *    3. 调用DatagramSocket类方法send,发送数据包 *    4. 关闭资源 *     *    DatagramPacket构造方法: *      DatagramPacket(byte[] buf, int length, InetAddress address, int port)  *       *    DatagramSocket构造方法: *      DatagramSocket()空参数 *      方法: send(DatagramPacket d) *       */public class UDPSend { public static void main(String[] args) throws IOException{   //创建数据包对象,封装要发送的数据,接收端IP,端口   byte[] date = &quot;你好UDP&quot;.getBytes();   //创建InetAddress对象,封装自己的IP地址   InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;);   DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);   //创建DatagramSocket对象,数据包的发送和接收对象   DatagramSocket ds = new DatagramSocket();   //调用ds对象的方法send,发送数据包   ds.send(dp);   //关闭资源   ds.close(); }}</code></pre><h3 id="09UDP接收端"><a href="#09UDP接收端" class="headerlink" title="09UDP接收端"></a>09UDP接收端</h3><p>   <em>A:UDP接收端<br>       /</em></p><pre><code> *  实现UDP接收端 *    实现封装数据包 java.net.DatagramPacket 将数据接收 *    实现输出传输     java.net.DatagramSocket 接收数据包 *     *  实现步骤: *     1. 创建DatagramSocket对象,绑定端口号 *         要和发送端端口号一致 *     2. 创建字节数组,接收发来的数据 *     3. 创建数据包对象DatagramPacket *     4. 调用DatagramSocket对象方法 *        receive(DatagramPacket dp)接收数据,数据放在数据包中 *     5. 拆包 *          发送的IP地址 *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象 *            返回值是InetAddress对象 *          接收到的字节个数 *            数据包对象DatagramPacket方法 getLength() *          发送方的端口号 *            数据包对象DatagramPacket方法 getPort()发送端口 *     6. 关闭资源 */public class UDPReceive { public static void main(String[] args)throws IOException {   //创建数据包传输对象DatagramSocket 绑定端口号   DatagramSocket ds = new DatagramSocket(6000);   //创建字节数组   byte[] data = new byte[1024];   //创建数据包对象,传递字节数组   DatagramPacket dp = new DatagramPacket(data, data.length);   //调用ds对象的方法receive传递数据包   ds.receive(dp); }}</code></pre><h3 id="10UDP接收端的拆包"><a href="#10UDP接收端的拆包" class="headerlink" title="10UDP接收端的拆包"></a>10UDP接收端的拆包</h3><p>   *A:UDP接收端的拆包 </p><pre><code>/* *  实现UDP接收端 *    实现封装数据包 java.net.DatagramPacket 将数据接收 *    实现输出传输     java.net.DatagramSocket 接收数据包 *     *  实现步骤: *     1. 创建DatagramSocket对象,绑定端口号 *         要和发送端端口号一致 *     2. 创建字节数组,接收发来的数据 *     3. 创建数据包对象DatagramPacket *     4. 调用DatagramSocket对象方法 *        receive(DatagramPacket dp)接收数据,数据放在数据包中 *     5. 拆包 *          发送的IP地址 *            数据包对象DatagramPacket方法getAddress()获取的是发送端的IP地址对象 *            返回值是InetAddress对象 *          接收到的字节个数 *            数据包对象DatagramPacket方法 getLength() *          发送方的端口号 *            数据包对象DatagramPacket方法 getPort()发送端口 *     6. 关闭资源 */public class UDPReceive {  public static void main(String[] args)throws IOException {    //创建数据包传输对象DatagramSocket 绑定端口号    DatagramSocket ds = new DatagramSocket(6000);    //创建字节数组    byte[] data = new byte[1024];    //创建数据包对象,传递字节数组    DatagramPacket dp = new DatagramPacket(data, data.length);    //调用ds对象的方法receive传递数据包    ds.receive(dp);    //获取发送端的IP地址对象    String ip=dp.getAddress().getHostAddress();    //获取发送的端口号    int port = dp.getPort();    //获取接收到的字节个数    int length = dp.getLength();    System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);    ds.close();  }}</code></pre><h3 id="11键盘输入的聊天"><a href="#11键盘输入的聊天" class="headerlink" title="11键盘输入的聊天"></a>11键盘输入的聊天</h3><p>   <em>A:键盘输入的聊天    </em>a:发送端:<br>      /*</p><pre><code> * 实现UDP发送,键盘输入的形式 * 输入完毕,发送给接收端       */public class UDPSend {  public static void main(String[] args) throws IOException{    Scanner sc = new Scanner(System.in);    DatagramSocket ds = new DatagramSocket();    InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;);    while(true){    String message = sc.nextLine();    /*if(&quot;886&quot;.equals(message)){      break;    }*/    byte[] date = message.getBytes();    DatagramPacket dp = new DatagramPacket(date, date.length, inet,6000);    ds.send(dp);    }  //  ds.close();  }} /*  *  实现UDP接收端  *  永不停歇的接收端  */ public class UDPReceive {  public static void main(String[] args)throws IOException {    //创建数据包传输对象DatagramSocket 绑定端口号    DatagramSocket ds = new DatagramSocket(6000);    //创建字节数组    byte[] data = new byte[1024];    //创建数据包对象,传递字节数组    while(true){    DatagramPacket dp = new DatagramPacket(data, data.length);    //调用ds对象的方法receive传递数据包    ds.receive(dp);    //获取发送端的IP地址对象    String ip=dp.getAddress().getHostAddress();    //获取发送的端口号    int port = dp.getPort();    //获取接收到的字节个数    int length = dp.getLength();    System.out.println(new String(data,0,length)+&quot;...&quot;+ip+&quot;:&quot;+port);    }    //ds.close();  } }</code></pre><h3 id="12TCP的客户端和服务器"><a href="#12TCP的客户端和服务器" class="headerlink" title="12TCP的客户端和服务器"></a>12TCP的客户端和服务器</h3><p>   *A:TCP的客户端和服务器<br>      TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。<br>      区别在于，UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。<br>      而TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，<br>      服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。<br>      在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。<br>      通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</p><h3 id="13TCP的客户端程序"><a href="#13TCP的客户端程序" class="headerlink" title="13TCP的客户端程序"></a>13TCP的客户端程序</h3><p>  <em>A:TCP的客户端程序<br>   /</em></p><pre><code>*  实现TCP客户端,连接到服务器*  和服务器实现数据交换*  实现TCP客户端程序的类 java.net.Socket*  *  构造方法:*      Socket(String host, int port)  传递服务器IP和端口号*      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常*      *    OutputStream  getOutputStream() 返回套接字的输出流*      作用: 将数据输出,输出到服务器*      *    InputStream getInputStream() 返回套接字的输入流*      作用: 从服务器端读取数据*      *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行*/</code></pre><p>   public class TCPClient {<br>    public static void main(String[] args)throws IOException {<br>      //创建Socket对象,连接服务器<br>      Socket socket = new Socket(“127.0.0.1”, 8888);<br>      //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器<br>      OutputStream out = socket.getOutputStream();<br>      out.write(“服务器OK”.getBytes());</p><pre><code>  socket.close();}</code></pre><p>   }</p><h3 id="14TCP的服务器程序accept方法"><a href="#14TCP的服务器程序accept方法" class="headerlink" title="14TCP的服务器程序accept方法"></a>14TCP的服务器程序accept方法</h3><p>   A:TCP的服务器程序accept方法<br>     /*</p><pre><code> *  实现TCP服务器程序 *  表示服务器程序的类 java.net.ServerSocket *  构造方法: *    ServerSocket(int port) 传递端口号 *   *  很重要的事情: 必须要获得客户端的套接字对象Socket *    Socket  accept() */public class TCPServer { public static void main(String[] args) throws IOException{   ServerSocket server = new ServerSocket(8888);   //调用服务器套接字对象中的方法accept() 获取客户端套接字对象   Socket socket = server.accept();   //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据   InputStream in = socket.getInputStream();   byte[] data = new byte[1024];   int len = in.read(data);   System.out.println(new String(data,0,len));   socket.close();   server.close(); }}</code></pre><h3 id="15TCP的服务器程序读取客户端数据"><a href="#15TCP的服务器程序读取客户端数据" class="headerlink" title="15TCP的服务器程序读取客户端数据"></a>15TCP的服务器程序读取客户端数据</h3><p>   A:TCP的服务器程序读取客户端数据</p><pre><code>/* *  实现TCP客户端,连接到服务器 *  和服务器实现数据交换 *  实现TCP客户端程序的类 java.net.Socket *   *  构造方法: *      Socket(String host, int port)  传递服务器IP和端口号 *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常 *       *    OutputStream  getOutputStream() 返回套接字的输出流 *      作用: 将数据输出,输出到服务器 *       *    InputStream getInputStream() 返回套接字的输入流 *      作用: 从服务器端读取数据 *       *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行 */public class TCPClient {  public static void main(String[] args)throws IOException {    //创建Socket对象,连接服务器    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);    //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器    OutputStream out = socket.getOutputStream();    out.write(&quot;服务器OK&quot;.getBytes());    socket.close();  }}/* *  实现TCP服务器程序 *  表示服务器程序的类 java.net.ServerSocket *  构造方法: *    ServerSocket(int port) 传递端口号 *   *  很重要的事情: 必须要获得客户端的套接字对象Socket *    Socket  accept() */public class TCPServer {  public static void main(String[] args) throws IOException{    ServerSocket server = new ServerSocket(8888);    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象    Socket socket = server.accept();    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据    InputStream in = socket.getInputStream();    byte[] data = new byte[1024];    int len = in.read(data);    System.out.println(new String(data,0,len));  }}</code></pre><h3 id="16TCP的服务器和客户端的数据交换"><a href="#16TCP的服务器和客户端的数据交换" class="headerlink" title="16TCP的服务器和客户端的数据交换"></a>16TCP的服务器和客户端的数据交换</h3><p>   A:TCP的服务器和客户端的数据交换<br>      /*</p><pre><code> *  实现TCP客户端,连接到服务器 *  和服务器实现数据交换 *  实现TCP客户端程序的类 java.net.Socket *   *  构造方法: *      Socket(String host, int port)  传递服务器IP和端口号 *      注意:构造方法只要运行,就会和服务器进行连接,连接失败,抛出异常 *       *    OutputStream  getOutputStream() 返回套接字的输出流 *      作用: 将数据输出,输出到服务器 *       *    InputStream getInputStream() 返回套接字的输入流 *      作用: 从服务器端读取数据 *       *    客户端服务器数据交换,必须使用套接字对象Socket中的获取的IO流,自己new流,不行 */public class TCPClient {  public static void main(String[] args)throws IOException {    //创建Socket对象,连接服务器    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);    //通过客户端的套接字对象Socket方法,获取字节输出流,将数据写向服务器    OutputStream out = socket.getOutputStream();    out.write(&quot;服务器OK&quot;.getBytes());    //读取服务器发回的数据,使用socket套接字对象中的字节输入流    InputStream in = socket.getInputStream();    byte[] data = new byte[1024];    int len = in.read(data);    System.out.println(new String(data,0,len));    socket.close();  }}/* *  实现TCP服务器程序 *  表示服务器程序的类 java.net.ServerSocket *  构造方法: *    ServerSocket(int port) 传递端口号 *   *  很重要的事情: 必须要获得客户端的套接字对象Socket *    Socket  accept() */public class TCPServer {  public static void main(String[] args) throws IOException{    ServerSocket server = new ServerSocket(8888);    //调用服务器套接字对象中的方法accept() 获取客户端套接字对象    Socket socket = server.accept();    //通过客户端套接字对象,socket获取字节输入流,读取的是客户端发送来的数据    InputStream in = socket.getInputStream();    byte[] data = new byte[1024];    int len = in.read(data);    System.out.println(new String(data,0,len));    //服务器向客户端回数据,字节输出流,通过客户端套接字对象获取字节输出流    OutputStream out = socket.getOutputStream();    out.write(&quot;收到,谢谢&quot;.getBytes());    socket.close();    server.close();  }}</code></pre><h3 id="17TCP的中的流对象"><a href="#17TCP的中的流对象" class="headerlink" title="17TCP的中的流对象"></a>17TCP的中的流对象</h3><pre><code>*A:TCP的中的流对象    参见图解TCP中的流对象.jpg  </code></pre><h3 id="18TCP图片上传案例分析"><a href="#18TCP图片上传案例分析" class="headerlink" title="18TCP图片上传案例分析"></a>18TCP图片上传案例分析</h3><pre><code>*A:图片上传案例分析     参见图解TCP上传图片案例.jpg  </code></pre><h3 id="19TCP上传客户端"><a href="#19TCP上传客户端" class="headerlink" title="19TCP上传客户端"></a>19TCP上传客户端</h3><p>   <em>A TCP上传客户端<br>   /</em></p><pre><code>*  实现TCP图片上传客户端*  实现步骤:*    1. Socket套接字连接服务器*    2. 通过Socket获取字节输出流,写图片*    3. 使用自己的流对象,读取图片数据源*         FileInputStream*    4. 读取图片,使用字节输出流,将图片写到服务器*       采用字节数组进行缓冲*    5. 通过Socket套接字获取字节输入流*       读取服务器发回来的上传成功*    6. 关闭资源*/</code></pre><p>   public class TCPClient {<br>    public static void main(String[] args) throws IOException{<br>      Socket socket = new Socket(“127.0.0.1”, 8000);<br>      //获取字节输出流,图片写到服务器<br>      OutputStream out = socket.getOutputStream();<br>      //创建字节输入流,读取本机上的数据源图片<br>      FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>      //开始读写字节数组<br>      int len = 0 ;<br>      byte[] bytes = new byte[1024];<br>      while((len = fis.read(bytes))!=-1){<br>        out.write(bytes, 0, len);<br>      }<br>      //给服务器写终止序列<br>      //socket.shutdownOutput();</p><pre><code>  //获取字节输入流,读取服务器的上传成功  InputStream in = socket.getInputStream();  len = in.read(bytes);  System.out.println(new String(bytes,0,len));  fis.close();  socket.close();}</code></pre><p>   }</p><h3 id="20TCP上传服务器"><a href="#20TCP上传服务器" class="headerlink" title="20TCP上传服务器"></a>20TCP上传服务器</h3><p>   A:TCP上传服务器<br>   /*</p><pre><code>*  TCP图片上传服务器*   1. ServerSocket套接字对象,监听端口8000*   2. 方法accept()获取客户端的连接对象*   3. 客户端连接对象获取字节输入流,读取客户端发送图片*   4. 创建File对象,绑定上传文件夹*       判断文件夹存在, 不存,在创建文件夹*   5. 创建字节输出流,数据目的File对象所在文件夹*   6. 字节流读取图片,字节流将图片写入到目的文件夹中*   7. 将上传成功会写客户端*   8. 关闭资源*       */</code></pre><p>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p><pre><code>  //创建字节输出流,将图片写入到目的文件夹中                           FileOutputStream fos = new FileOutputStream(upload+&quot;t.jpg&quot;);  //读写字节数组  byte[] bytes = new byte[1024];  int len = 0 ;  while((len = in.read(bytes))!=-1){    fos.write(bytes, 0, len);  }  //通过客户端连接对象获取字节输出流  //上传成功写回客户端  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());  fos.close();  socket.close();  server.close();}</code></pre><p>   }</p><h3 id="21TCP图片上传问题解决"><a href="#21TCP图片上传问题解决" class="headerlink" title="21TCP图片上传问题解决"></a>21TCP图片上传问题解决</h3><p>/*</p><ul><li>实现TCP图片上传客户端</li><li>实现步骤:</li><li><ol><li>Socket套接字连接服务器</li></ol></li><li><ol start="2"><li>通过Socket获取字节输出流,写图片</li></ol></li><li><ol start="3"><li>使用自己的流对象,读取图片数据源</li></ol></li><li>FileInputStream</li><li><ol start="4"><li>读取图片,使用字节输出流,将图片写到服务器</li></ol></li><li>采用字节数组进行缓冲</li><li><ol start="5"><li>通过Socket套接字获取字节输入流</li></ol></li><li>读取服务器发回来的上传成功</li><li><ol start="6"><li>关闭资源<br>*/<br>public class TCPClient {<br>public static void main(String[] args) throws IOException{<br>Socket socket = new Socket(“127.0.0.1”, 8000);<br>//获取字节输出流,图片写到服务器<br>OutputStream out = socket.getOutputStream();<br>//创建字节输入流,读取本机上的数据源图片<br>FileInputStream fis = new FileInputStream(“c:\t.jpg”);<br>//开始读写字节数组<br>int len = 0 ;<br>byte[] bytes = new byte[1024];<br>while((len = fis.read(bytes))!=-1){<br>out.write(bytes, 0, len);<br>}<br>//给服务器写终止序列<br>socket.shutdownOutput();//想服务端写入一个结束标志</li></ol><p>//获取字节输入流,读取服务器的上传成功<br>InputStream in = socket.getInputStream();</p><p>len = in.read(bytes);<br>System.out.println(new String(bytes,0,len));</p><p>fis.close();<br>socket.close();<br>}<br>}</p></li></ul><h3 id="TCP上传文件名"><a href="#TCP上传文件名" class="headerlink" title="TCP上传文件名"></a>TCP上传文件名</h3><p>  <em>A:TCP上传文件名<br>   /</em></p><pre><code>*  TCP图片上传服务器*   1. ServerSocket套接字对象,监听端口8000*   2. 方法accept()获取客户端的连接对象*   3. 客户端连接对象获取字节输入流,读取客户端发送图片*   4. 创建File对象,绑定上传文件夹*       判断文件夹存在, 不存,在创建文件夹*   5. 创建字节输出流,数据目的File对象所在文件夹*   6. 字节流读取图片,字节流将图片写入到目的文件夹中*   7. 将上传成功会写客户端*   8. 关闭资源*       */</code></pre><p>   public class TCPServer {<br>    public static void main(String[] args) throws IOException{<br>      ServerSocket server = new ServerSocket(8000);<br>      Socket socket = server.accept();<br>      //通过客户端连接对象,获取字节输入流,读取客户端图片<br>      InputStream in = socket.getInputStream();<br>      //将目的文件夹封装到File对象<br>      File upload = new File(“d:\upload”);<br>      if(!upload.exists())<br>        upload.mkdirs();</p><pre><code>  //防止文件同名被覆盖,从新定义文件名字  //规则:  域名+毫秒值+6位随机数  String filename=&quot;itcast&quot;+System.currentTimeMillis()+new Random().nextInt(999999)+&quot;.jpg&quot;;  //创建字节输出流,将图片写入到目的文件夹中                           FileOutputStream fos = new FileOutputStream(upload+File.separator+filename);  //读写字节数组  byte[] bytes = new byte[1024];  int len = 0 ;  while((len = in.read(bytes))!=-1){    fos.write(bytes, 0, len);  }  //通过客户端连接对象获取字节输出流  //上传成功写回客户端  socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());  fos.close();  socket.close();  server.close();}</code></pre><p>   }</p><h3 id="多线程上传案例"><a href="#多线程上传案例" class="headerlink" title="多线程上传案例"></a>多线程上传案例</h3><p>*A:多线程上传案例<br>  public class TCPThreadServer {<br>    public static void main(String[] args) throws IOException {<br>      ServerSocket server = new ServerSocket(8000);<br>      while (true) {<br>        // 获取到一个客户端,必须开启新线程,为这个客户端服务<br>        Socket socket = server.accept();<br>        new Thread(new Upload(socket)).start();<br>      }<br>    }<br>  }</p><p>  public class Upload implements Runnable {</p><pre><code>private Socket socket;public Upload(Socket socket) {  this.socket = socket;}public void run() {  try {    // 通过客户端连接对象,获取字节输入流,读取客户端图片    InputStream in = socket.getInputStream();    // 将目的文件夹封装到File对象    File upload = new File(&quot;d:\\upload&quot;);    if (!upload.exists())      upload.mkdirs();    // 防止文件同名被覆盖,从新定义文件名字    // 规则: 域名+毫秒值+6位随机数    String filename = &quot;itcast&quot; + System.currentTimeMillis() + new Random().nextInt(999999) + &quot;.jpg&quot;;    // 创建字节输出流,将图片写入到目的文件夹中    FileOutputStream fos = new FileOutputStream(upload + File.separator + filename);    // 读写字节数组    byte[] bytes = new byte[1024];    int len = 0;    while ((len = in.read(bytes)) != -1) {      fos.write(bytes, 0, len);    }    // 通过客户端连接对象获取字节输出流    // 上传成功写回客户端    socket.getOutputStream().write(&quot;上传成功&quot;.getBytes());    fos.close();    socket.close();  } catch (Exception ex) {  }}</code></pre><p>  }</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297959/samples/java%20files/photo-1544833021-2f0c8afb7fd6.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、网络三要素及传输协议&lt;br&gt;2、实现UDP协议的发送端和接收端&lt;br&gt;3、实现TCP协议的客户端和服务器&lt;br&gt;4、TCP上传文件案例&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础29()</title>
    <link href="https://leesen998.github.io/2016/11/30/day31%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/30/day31笔记/</id>
    <published>2016-11-30T11:48:29.000Z</published>
    <updated>2019-01-20T14:42:48.892Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297638/samples/java%20files/photo-1546398770-b134faf3de65.jpg" alt="" style="width:100%"></p><p>1、管家婆项目 </p><a id="more"></a><h3 id="01项目训练目标"><a href="#01项目训练目标" class="headerlink" title="01项目训练目标"></a>01项目训练目标</h3><ul><li>A: 项目训练目标</li><li>a: 项目目标</li><li>综合运用前面所学习的知识点</li><li>熟练View层、Service层、Dao层之间的方法相互调用操作、</li><li>熟练dbutils操作数据库表完成增删改查</li><li>了解公司项目开发的流程，充分的掌握项目需求分析、设计与功能的代码实现。提高同学们独立分析需求与功能实现的能力。            </li></ul><h3 id="02项目中的功能模块"><a href="#02项目中的功能模块" class="headerlink" title="02项目中的功能模块"></a>02项目中的功能模块</h3><ul><li>A: 项目中的功能模块    </li><li>a: 五大模块</li><li>查询账务</li><li>多条件组合查询账务</li><li>添加账务</li><li>编辑账务</li><li>删除账务</li></ul><h3 id="03技术的选择和相关jar包"><a href="#03技术的选择和相关jar包" class="headerlink" title="03技术的选择和相关jar包"></a>03技术的选择和相关jar包</h3><ul><li>A: 技术的选择和相关jar包</li><li>a: apache的commons组件：</li><li>commons-dbutils-1.4.jar：封装并简化了JDBC；</li><li>commons-dbcp-1.4.jar：apache commons提供的数据库连接池组件，命名为DBCP；</li><li>b: commons.pool-1.3.jar：DBCP连接池依赖该jar包；</li><li>mysql-connector-java-5.1.28-bin.jar：MySQL的JDBC驱动包，用JDBC连接MySQL数据库必须使用该JAR包。</li></ul><h3 id="04项目中的工具类"><a href="#04项目中的工具类" class="headerlink" title="04项目中的工具类"></a>04项目中的工具类</h3><ul><li>A: 项目中的工具类</li><li>a: 工具类的介绍    </li><li>每个项目中都会有很多个工具类，不要求每个工具类对能独立写出来，但是要会使用工具类</li><li>JDBCUtils：用来创建数据库连接池对象</li></ul><h3 id="05数据表的设计"><a href="#05数据表的设计" class="headerlink" title="05数据表的设计"></a>05数据表的设计</h3><ul><li>A: 数据表的设计</li><li>a: 数据表的设计(详见：day34_source/表关系.JPG)</li><li>表与表之间是有关系的</li><li>主表和从表的关系</li><li>主表中的主键作为从表中的外键</li></ul><h3 id="06创建数据库数据表写入测试数据"><a href="#06创建数据库数据表写入测试数据" class="headerlink" title="06创建数据库数据表写入测试数据"></a>06创建数据库数据表写入测试数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建数据库数据表写入测试数据</span><br><span class="line">* a: 创建数据库数据表</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建管家婆的数据库</span></span><br><span class="line"><span class="comment">名字 gjp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CREATE DATABASE gjp;</span><br><span class="line"></span><br><span class="line">USE gjp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建数据表,表名账务</span></span><br><span class="line"><span class="comment">字段,列</span></span><br><span class="line"><span class="comment">主键</span></span><br><span class="line"><span class="comment">分类名称  可变字符</span></span><br><span class="line"><span class="comment">金额  double</span></span><br><span class="line"><span class="comment">账户  可变字符 (支付,收入方法)</span></span><br><span class="line"><span class="comment">创建日期 date</span></span><br><span class="line"><span class="comment">账务描述 可变字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">gjp_zhangwu</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">-- 主键</span></span></span><br><span class="line"><span class="function"><span class="params">zwid INT PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="function"><span class="params">-- 分类名称   </span></span></span><br><span class="line"><span class="function"><span class="params">flname VARCHAR(<span class="number">200</span>)</span>,</span></span><br><span class="line"><span class="function">-- 金额</span></span><br><span class="line"><span class="function">money DOUBLE,</span></span><br><span class="line"><span class="function">-- 账户</span></span><br><span class="line"><span class="function">zhanghu <span class="title">VARCHAR</span><span class="params">(<span class="number">100</span>)</span>,</span></span><br><span class="line"><span class="function">-- 创建日期</span></span><br><span class="line"><span class="function">createtime DATE,</span></span><br><span class="line"><span class="function">-- 账务描述</span></span><br><span class="line"><span class="function">description  <span class="title">VARCHAR</span><span class="params">(<span class="number">1000</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line">SELECT * FROM gjp_zhangwu;</span><br><span class="line">* b: 写入数据</span><br><span class="line">-- 写入测试的数据</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">1</span>,<span class="string">'吃饭支出'</span>,<span class="number">247</span>,<span class="string">'交通银行'</span>,<span class="string">'2016-03-02'</span>,<span class="string">'家庭聚餐'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">2</span>,<span class="string">'工资收入'</span>,<span class="number">12345</span>,<span class="string">'现金'</span>,<span class="string">'2016-03-15'</span>,<span class="string">'开工资了'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">3</span>,<span class="string">'服装支出'</span>,<span class="number">1998</span>,<span class="string">'现金'</span>,<span class="string">'2016-04-02'</span>,<span class="string">'买衣服'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">4</span>,<span class="string">'吃饭支出'</span>,<span class="number">325</span>,<span class="string">'现金'</span>,<span class="string">'2016-06-18'</span>,<span class="string">'朋友聚餐'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">5</span>,<span class="string">'股票收入'</span>,<span class="number">8000</span>,<span class="string">'工商银行'</span>,<span class="string">'2016-10-28'</span>,<span class="string">'股票大涨'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">6</span>,<span class="string">'股票收入'</span>,<span class="number">5000</span>,<span class="string">'工商银行'</span>,<span class="string">'2016-10-28'</span>,<span class="string">'股票又大涨'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">7</span>,<span class="string">'工资收入'</span>,<span class="number">5000</span>,<span class="string">'交通银行'</span>,<span class="string">'2016-10-28'</span>,<span class="string">'又开工资了'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">8</span>,<span class="string">'礼金支出'</span>,<span class="number">5000</span>,<span class="string">'现金'</span>,<span class="string">'2016-10-28'</span>,<span class="string">'朋友结婚'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">9</span>,<span class="string">'其他支出'</span>,<span class="number">1560</span>,<span class="string">'现金'</span>,<span class="string">'2016-10-29'</span>,<span class="string">'丢钱了'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">10</span>,<span class="string">'交通支出'</span>,<span class="number">2300</span>,<span class="string">'交通银行'</span>,<span class="string">'2016-10-29'</span>,<span class="string">'油价还在涨啊'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">11</span>,<span class="string">'吃饭支出'</span>,<span class="number">1000</span>,<span class="string">'工商银行'</span>,<span class="string">'2016-10-29'</span>,<span class="string">'又吃饭'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">12</span>,<span class="string">'工资收入'</span>,<span class="number">1000</span>,<span class="string">'现金'</span>,<span class="string">'2016-10-30'</span>,<span class="string">'开资'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">13</span>,<span class="string">'交通支出'</span>,<span class="number">2000</span>,<span class="string">'现金'</span>,<span class="string">'2016-10-30'</span>,<span class="string">'机票好贵'</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">gjp_zhangwu</span><span class="params">(zwid,flname,money,zhangHu,createtime,description)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">14</span>,<span class="string">'工资收入'</span>,<span class="number">5000</span>,<span class="string">'现金'</span>,<span class="string">'2016-10-30'</span>,<span class="string">'又开资'</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="07项目中的分层设计"><a href="#07项目中的分层设计" class="headerlink" title="07项目中的分层设计"></a>07项目中的分层设计</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* A: 项目中的分层设计</span><br><span class="line">* a: 各层功能介绍</span><br><span class="line">* view层作用: 视图层,即项目中的界面</span><br><span class="line">* controller层作用: 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理</span><br><span class="line">* service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理</span><br><span class="line">* dao层作用: 数据访问层, 用来操作数据库表的数据</span><br><span class="line">* db数据库: 这里指MySQL</span><br><span class="line">* domain 实体包: 存放JavaBean</span><br><span class="line">* tools工具包:存放项目中使用到的工具类</span><br><span class="line">* test 测试包: 存放项目功能测试的代码</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="08创建项目-分层-导入jar包"><a href="#08创建项目-分层-导入jar包" class="headerlink" title="08创建项目_分层_导入jar包"></a>08创建项目_分层_导入jar包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建项目_分层_导入jar包</span><br><span class="line">* a: 创建工程包</span><br><span class="line">* cn.itcast.gjp.app: 存放main方法类；</span><br><span class="line">* cn.itcast.gjp.domain: 存放JavaBean；</span><br><span class="line">* cn.itcast.gjp.view: 存放界面，及表现层类；</span><br><span class="line">* cn.itcast.gjp.service: 存放业务层类；</span><br><span class="line">* cn.itcast.gjp.dao: 存放数据访问层类;</span><br><span class="line">* cn.itcast.gjp.tools:存放工具类</span><br><span class="line">* b: 导入jar包</span><br><span class="line">* 在项目根路径下建立文件夹lib</span><br><span class="line">* 导入以下jar包</span><br><span class="line">* mysql-connector-java-<span class="number">5.1</span>.37-bin.jar：数据库驱动</span><br><span class="line">* commons-dbutils-<span class="number">1.6</span>.jar：提供QueryRunner类方便进行增删改查操作</span><br><span class="line">* commons-dbcp-<span class="number">1.4</span>.jar：</span><br><span class="line">* commons-pool-<span class="number">1.5</span>.6.jar：提供高效的数据库连接池技术</span><br><span class="line">* 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</span><br></pre></td></tr></table></figure><h3 id="09创建domain包中的类"><a href="#09创建domain包中的类" class="headerlink" title="09创建domain包中的类"></a>09创建domain包中的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建domain包中的类</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWu</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span>  zwid;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> String flname; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">double</span>  money; </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> String zhanghu;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String createtime; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String description;</span><br><span class="line"> <span class="comment">//注意生成空参构造、有参构造、set和get方法、toString方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10创建JDBCUtils工具类"><a href="#10创建JDBCUtils工具类" class="headerlink" title="10创建JDBCUtils工具类"></a>10创建JDBCUtils工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* A：创建JDBCUtils工具类</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>&#123;</span><br><span class="line"><span class="comment">//创建BasicDataSource对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource datasource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"><span class="comment">//静态代码块,实现必要参数设置</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">datasource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">datasource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/gjp"</span>);</span><br><span class="line">datasource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">datasource.setPassword(<span class="string">"123"</span>);</span><br><span class="line">datasource.setMaxActive(<span class="number">10</span>);</span><br><span class="line">datasource.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">datasource.setMinIdle(<span class="number">2</span>);</span><br><span class="line">datasource.setInitialSize(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> datasource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11创建其他包中的类"><a href="#11创建其他包中的类" class="headerlink" title="11创建其他包中的类"></a>11创建其他包中的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建其他包中的类</span><br><span class="line">* a: cn.itcast.gjp.dao包中创建ZhangWuDao类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  实现对数据表 gjp_zhangwu 数据增删改查操作</span></span><br><span class="line"><span class="comment">*  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line">&#125;</span><br><span class="line">* b: cn.itcast.gjp.service包中创建ZhangWuService类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  业务层类</span></span><br><span class="line"><span class="comment">*  接收上一层,控制层controller的数据</span></span><br><span class="line"><span class="comment">*  经过计算,传递给dao层,操作数据库</span></span><br><span class="line"><span class="comment">*  调用dao层中的类,类成员位置,创建Dao类的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuDao dao = <span class="keyword">new</span> ZhangWuDao();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">* c: cn.itcast.gjp.controller包中建立ZhangWuController类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  控制器层</span></span><br><span class="line"><span class="comment">*  接收视图层的数据,数据传递给service层</span></span><br><span class="line"><span class="comment">*  成员位置,创建service对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuService service = <span class="keyword">new</span> ZhangWuService();</span><br><span class="line">&#125;</span><br><span class="line">* d: cn.itcast.gjp.view包中建立MainView类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  试图层,用户看到和操作的界面</span></span><br><span class="line"><span class="comment">*  数据传递给controller层实现</span></span><br><span class="line"><span class="comment">*  成员位置,创建controller对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainView</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuController controller = <span class="keyword">new</span> ZhangWuController();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">* e: cn.itcast.gjp.app包中建立MainApp类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  主程序类,作用,开启软件程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApp</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> MainView().run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12实现用户的界面菜单"><a href="#12实现用户的界面菜单" class="headerlink" title="12实现用户的界面菜单"></a>12实现用户的界面菜单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现用户的界面菜单</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类中添加run方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  实现界面效果</span></span><br><span class="line"><span class="comment">*  接收用户的输入</span></span><br><span class="line"><span class="comment">*  根据数据,调用不同的功能方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建Scanner类对象,反复键盘输入</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"---------------管家婆家庭记账软件---------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"1.添加账务　2.编辑账务　3.删除账务　4.查询账务　5.退出系统"</span>);</span><br><span class="line">System.out.println(<span class="string">"请输入要操作的功能序号[1-5]:"</span>);</span><br><span class="line"><span class="comment">//接收用户的菜单选择</span></span><br><span class="line"><span class="keyword">int</span> choose = sc.nextInt();</span><br><span class="line"><span class="comment">//对选择的菜单判断,调用不同的功能</span></span><br><span class="line"><span class="keyword">switch</span>(choose)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">   <span class="comment">// 选择添加账务,调用添加账务的方法</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// 选择的编辑账务,调用编辑账务方法</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// 选择的删除账务,调用删除账务方法</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="comment">// 选择的是查询账务,调用查询方法</span></span><br><span class="line"><span class="comment">//selectZhangWu();</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13实现查询的界面菜单"><a href="#13实现查询的界面菜单" class="headerlink" title="13实现查询的界面菜单"></a>13实现查询的界面菜单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现查询的界面菜单</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">*  cn.itcast.gjp.view包中建立MainView类中添加selectZhangWu方法、selectAll方法、select方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法 selectZhangWu()</span></span><br><span class="line"><span class="comment"> * 显示查询的方式 1 所有查询   2 条件查询</span></span><br><span class="line"><span class="comment"> * 接收用户的选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectZhangWu</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"1. 查询所有    2. 条件查询"</span>);</span><br><span class="line"> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> selectChooser = sc.nextInt();</span><br><span class="line"> <span class="comment">//判断根据用户的选择,调用不同的功能</span></span><br><span class="line"> <span class="keyword">switch</span>(selectChooser)&#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="comment">//选择的查询所有,调用查询所有的方法</span></span><br><span class="line"> selectAll();</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="comment">//选的条件查询,调用带有查询条件的方法</span></span><br><span class="line"> select();</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 定义方法,实现查询所有的账务数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 定义方法,实现条件查询账务数据</span></span><br><span class="line"><span class="comment">  * 提供用户的输入日期,开始日期结束日期</span></span><br><span class="line"><span class="comment">  * 就2个日期,传递到controller层</span></span><br><span class="line"><span class="comment">  * 调用controller的方法,传递2个日期参数</span></span><br><span class="line"><span class="comment">  * 获取到controller查询的结果集,打印出来</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="14实现查询所有账务的控制-业务层的实现"><a href="#14实现查询所有账务的控制-业务层的实现" class="headerlink" title="14实现查询所有账务的控制,业务层的实现"></a>14实现查询所有账务的控制,业务层的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现查询所有账务的控制,业务层的实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* a: cn.itcast.gjp.dao包中创建ZhangWuDao类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  实现对数据表 gjp_zhangwu 数据增删改查操作</span></span><br><span class="line"><span class="comment">*  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,查询数据库,获取所有的账务数据</span></span><br><span class="line"><span class="comment"> * 方法,由业务层调用</span></span><br><span class="line"><span class="comment"> * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* b: cn.itcast.gjp.service包中创建ZhangWuService类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  业务层类</span></span><br><span class="line"><span class="comment"> *  接收上一层,控制层controller的数据</span></span><br><span class="line"><span class="comment"> *  经过计算,传递给dao层,操作数据库</span></span><br><span class="line"><span class="comment"> *  调用dao层中的类,类成员位置,创建Dao类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuDao dao = <span class="keyword">new</span> ZhangWuDao();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,实现查询所有的账务数据</span></span><br><span class="line"><span class="comment"> *  此方法,由控制层调用, 去调用dao层的方法</span></span><br><span class="line"><span class="comment"> *  返回存储ZhangWu对象的List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dao.selectAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* c: cn.itcast.gjp.controller包中建立ZhangWuController类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  控制器层</span></span><br><span class="line"><span class="comment"> *  接收视图层的数据,数据传递给service层</span></span><br><span class="line"><span class="comment"> *  成员位置,创建service对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuService service = <span class="keyword">new</span> ZhangWuService();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 控制层类定义方法,实现查询所有的账务数据</span></span><br><span class="line"><span class="comment"> * 方法由试图层调用,方法调用service层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> service.selectAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15实现查询所有账务的dao层的实现"><a href="#15实现查询所有账务的dao层的实现" class="headerlink" title="15实现查询所有账务的dao层的实现"></a>15实现查询所有账务的dao层的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现查询所有账务的dao层的实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* a: cn.itcast.gjp.dao包中创建ZhangWuDao类selectAll方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  实现对数据表 gjp_zhangwu 数据增删改查操作</span></span><br><span class="line"><span class="comment">*  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,查询数据库,获取所有的账务数据</span></span><br><span class="line"><span class="comment"> * 方法,由业务层调用</span></span><br><span class="line"><span class="comment"> * 结果集,将所有的账务数据,存储到Bean对象中,存储到集合中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//查询账务数据的SQL语句</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM gjp_zhangwu"</span>;</span><br><span class="line"><span class="comment">//调用qr对象的方法,query方法,结果集BeanListHandler</span></span><br><span class="line">List&lt;ZhangWu&gt; list = qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(ZhangWu.class));</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"查询所有账务失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16实现查询所有账务的view层的实现"><a href="#16实现查询所有账务的view层的实现" class="headerlink" title="16实现查询所有账务的view层的实现"></a>16实现查询所有账务的view层的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现查询所有账务的view层的实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类selectAll方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义方法,实现查询所有的账务数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//调用控制层中的方法,查询所有的账务数据</span></span><br><span class="line"> List&lt;ZhangWu&gt; list = controller.selectAll();</span><br><span class="line"><span class="comment">//输出表头</span></span><br><span class="line"> System.out.println(<span class="string">"ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明"</span>);</span><br><span class="line"> <span class="comment">//遍历集合,结果输出控制台</span></span><br><span class="line"> <span class="keyword">for</span>(ZhangWu zw : list)&#123;</span><br><span class="line"> System.out.println(zw.getZwid()+<span class="string">"\t\t"</span>+zw.getFlname()+<span class="string">"\t\t"</span>+zw.getZhanghu()+<span class="string">"\t\t"</span>+</span><br><span class="line"> zw.getMoney()+<span class="string">"\t\t"</span>+zw.getCreatetime()+<span class="string">"\t"</span>+zw.getDescription());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17实现条件查询账务的菜单实现"><a href="#17实现条件查询账务的菜单实现" class="headerlink" title="17实现条件查询账务的菜单实现"></a>17实现条件查询账务的菜单实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现条件查询账务的菜单实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类select方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义方法,实现条件查询账务数据</span></span><br><span class="line"><span class="comment">* 提供用户的输入日期,开始日期结束日期</span></span><br><span class="line"><span class="comment">* 就2个日期,传递到controller层</span></span><br><span class="line"><span class="comment">* 调用controller的方法,传递2个日期参数</span></span><br><span class="line"><span class="comment">* 获取到controller查询的结果集,打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"选择条件查询,输入日期格式XXXX-XX-XX"</span>);</span><br><span class="line"> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> System.out.print(<span class="string">"请输入开始日期:"</span>);</span><br><span class="line"> String startDate = sc.nextLine();</span><br><span class="line"> System.out.print(<span class="string">"请输入结果日期:"</span>);</span><br><span class="line"> String endDate = sc.nextLine();</span><br><span class="line"> <span class="comment">//调用controller层的方法,传递日期,获取查询结果集</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18实现条件查询账务的控制层-业务层实现"><a href="#18实现条件查询账务的控制层-业务层实现" class="headerlink" title="18实现条件查询账务的控制层,业务层实现"></a>18实现条件查询账务的控制层,业务层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现条件查询账务的控制层,业务层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* a: cn.itcast.gjp.dao包中创建ZhangWuDao类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现对数据表 gjp_zhangwu 数据增删改查操作</span></span><br><span class="line"><span class="comment"> *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,查询数据库,带有条件去查询账务表</span></span><br><span class="line"><span class="comment"> * 由业务层调用,查询结果集存储到Bean对象,存储到List集合</span></span><br><span class="line"><span class="comment"> * 调用者传递2个日期字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">select</span><span class="params">(String startDate,String endDate)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* b: cn.itcast.gjp.service包中创建ZhangWuService类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  业务层类</span></span><br><span class="line"><span class="comment"> *  接收上一层,控制层controller的数据</span></span><br><span class="line"><span class="comment"> *  经过计算,传递给dao层,操作数据库</span></span><br><span class="line"><span class="comment"> *  调用dao层中的类,类成员位置,创建Dao类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuDao dao = <span class="keyword">new</span> ZhangWuDao();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,实现条件查询账务</span></span><br><span class="line"><span class="comment"> * 方法由控制层调用,传递2个日期字符串</span></span><br><span class="line"><span class="comment"> * 调用dao层的方法,传递2个日期字符串</span></span><br><span class="line"><span class="comment"> * 获取到查询结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">select</span><span class="params">(String startDate,String endDate)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dao.select(startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* c: cn.itcast.gjp.controller包中建立ZhangWuController类</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  控制器层</span></span><br><span class="line"><span class="comment"> *  接收视图层的数据,数据传递给service层</span></span><br><span class="line"><span class="comment"> *  成员位置,创建service对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ZhangWuService service = <span class="keyword">new</span> ZhangWuService();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,实现条件查询账务</span></span><br><span class="line"><span class="comment"> * 方法由试图层调用,传递两个日期的字符串</span></span><br><span class="line"><span class="comment"> * 调用service层的方法,传递两个日期字符串,获取结果集</span></span><br><span class="line"><span class="comment"> * 结果集返回给试图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">select</span><span class="params">(String startDate,String endDate)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> service.select(startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19实现条件查询账务的dao层实现"><a href="#19实现条件查询账务的dao层实现" class="headerlink" title="19实现条件查询账务的dao层实现"></a>19实现条件查询账务的dao层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现条件查询账务的dao层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* a: cn.itcast.gjp.dao包中创建ZhangWuDao类select方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现对数据表 gjp_zhangwu 数据增删改查操作</span></span><br><span class="line"><span class="comment"> *  dbuils工具类完成,类成员创建QueryRunner对象,指定数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,查询数据库,带有条件去查询账务表</span></span><br><span class="line"><span class="comment"> * 由业务层调用,查询结果集存储到Bean对象,存储到List集合</span></span><br><span class="line"><span class="comment"> * 调用者传递2个日期字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ZhangWu&gt; <span class="title">select</span><span class="params">(String startDate,String endDate)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//拼写条件查询的SQL语句</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM gjp_zhangwu WHERE createtime BETWEEN ? AND ?"</span>;</span><br><span class="line"><span class="comment">//定义对象数组,存储?占位符</span></span><br><span class="line">Object[] params = &#123;startDate,endDate&#125;;</span><br><span class="line"><span class="comment">//调用qr对象的方法query查询数据表,获取结果集</span></span><br><span class="line"><span class="keyword">return</span> qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;&gt;(ZhangWu.class),params);</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"条件查询失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20实现条件查询账务的view层实现"><a href="#20实现条件查询账务的view层实现" class="headerlink" title="20实现条件查询账务的view层实现"></a>20实现条件查询账务的view层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">* A: 实现条件查询账务的view层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类selectAll方法优化、抽取print方法、select方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义方法,实现查询所有的账务数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//调用控制层中的方法,查询所有的账务数据</span></span><br><span class="line"> List&lt;ZhangWu&gt; list = controller.selectAll();</span><br><span class="line"> <span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line"> print(list);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> System.out.println(<span class="string">"没有查询到数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义方法,实现条件查询账务数据</span></span><br><span class="line"><span class="comment">* 提供用户的输入日期,开始日期结束日期</span></span><br><span class="line"><span class="comment">* 就2个日期,传递到controller层</span></span><br><span class="line"><span class="comment">* 调用controller的方法,传递2个日期参数</span></span><br><span class="line"><span class="comment">* 获取到controller查询的结果集,打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"选择条件查询,输入日期格式XXXX-XX-XX"</span>);</span><br><span class="line"> Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> System.out.print(<span class="string">"请输入开始日期:"</span>);</span><br><span class="line"> String startDate = sc.nextLine();</span><br><span class="line"> System.out.print(<span class="string">"请输入结果日期:"</span>);</span><br><span class="line"> String endDate = sc.nextLine();</span><br><span class="line"> <span class="comment">//调用controller层的方法,传递日期,获取查询结果集</span></span><br><span class="line"> List&lt;ZhangWu&gt; list = controller.select(startDate, endDate);</span><br><span class="line"> <span class="keyword">if</span>(list.size()!=<span class="number">0</span>)</span><br><span class="line"> print(list);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> System.out.println(<span class="string">"没有查询到数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出账务数据方法,接收List集合,遍历集合,输出表格</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;ZhangWu&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//输出表头</span></span><br><span class="line"> System.out.println(<span class="string">"ID\t\t类别\t\t账户\t\t金额\t\t时间\t\t说明"</span>);</span><br><span class="line"> <span class="comment">//遍历集合,结果输出控制台</span></span><br><span class="line"> <span class="keyword">for</span>(ZhangWu zw : list)&#123;</span><br><span class="line"> System.out.println(zw.getZwid()+<span class="string">"\t\t"</span>+zw.getFlname()+<span class="string">"\t\t"</span>+zw.getZhanghu()+<span class="string">"\t\t"</span>+</span><br><span class="line"> zw.getMoney()+<span class="string">"\t\t"</span>+zw.getCreatetime()+<span class="string">"\t"</span>+zw.getDescription());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21添加账务功能分析"><a href="#21添加账务功能分析" class="headerlink" title="21添加账务功能分析"></a>21添加账务功能分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* A: 添加账务功能分析</span><br><span class="line">* a: 编写MainView类中addZhangWu方法</span><br><span class="line">* 键盘输入新添加的账务信息</span><br><span class="line">* 调用ZhangWuService类中addZhangWu方法，用来指定账务的添加</span><br><span class="line">* 添加完毕后，使用输出语句，提示“添加账务成功！”</span><br><span class="line">* b: 编写ZhangWuService类中addZhangWu方法</span><br><span class="line">* 调用ZhangWuDao类中addZhangWu方法，用来指定账务的添加</span><br><span class="line">* c: 编写ZhangWuDao类中addZhangWu方法</span><br><span class="line">* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成指定账务添加到数据库表中</span><br></pre></td></tr></table></figure><h3 id="22添加账务功能菜单和输入功能实现"><a href="#22添加账务功能菜单和输入功能实现" class="headerlink" title="22添加账务功能菜单和输入功能实现"></a>22添加账务功能菜单和输入功能实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* A: 添加账务功能菜单和输入功能实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类addZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 定义方法addZhangWu</span></span><br><span class="line"><span class="comment">* 添加账务的方法，用户在界面中选择菜单1的时候调用、</span></span><br><span class="line"><span class="comment">* 实现思想：</span></span><br><span class="line"><span class="comment">*   接收键盘输入，5项输入，调用controller层方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"选择的添加账务功能，请输入以下内容"</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"输入分类名称"</span>);</span><br><span class="line">String flname = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入金额"</span>);</span><br><span class="line"><span class="keyword">double</span> money = sc.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入账户"</span>);</span><br><span class="line">String zhanghu = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入日期：格式XXXX-XX-xx"</span>);</span><br><span class="line">String createtime = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入具体描述"</span>);</span><br><span class="line">String description = sc.next();</span><br><span class="line"><span class="comment">//将接收到的数据，调用controller层的方法，传递参数，实现数据添加</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23添加账务功能控制层-业务层实现"><a href="#23添加账务功能控制层-业务层实现" class="headerlink" title="23添加账务功能控制层,业务层实现"></a>23添加账务功能控制层,业务层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* A: 添加账务功能控制层,业务层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.controller包中的ZhangWuController类addZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现账务添加功能</span></span><br><span class="line"><span class="comment"> * 由视图层调用，传递参数(传递过来的参数不能是5个数据，传递的是一个ZhangWu类型的对象)</span></span><br><span class="line"><span class="comment"> * 本方法调用service层的方法，传递ZhangWu对象，获取到添加后的结果集(添加成功影响的行数，int)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line">service.addZhangWu(zw);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.service包中的ZhangWuService类addZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现添加账务</span></span><br><span class="line"><span class="comment"> * 是由控制层调用，传递ZhangWu对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line">dao.addZhangWu(zw);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类addZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现添加账务功能</span></span><br><span class="line"><span class="comment"> * 由业务层调用，传递ZhangWu对象</span></span><br><span class="line"><span class="comment"> * 将ZhangWu对象中的数据，添加到数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24添加账务功能dao层实现"><a href="#24添加账务功能dao层实现" class="headerlink" title="24添加账务功能dao层实现"></a>24添加账务功能dao层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 添加账务功能dao层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类的addZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="comment">//拼接添加数据的sql</span></span><br><span class="line">String sql = <span class="string">"INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES(?,?,?,?,?)"</span>;</span><br><span class="line"><span class="comment">//创建对象数组，处处5个占位符的实际参数</span></span><br><span class="line"><span class="comment">//实际参数来源是传递过来的对象ZhangWu</span></span><br><span class="line">Object[] params = &#123;zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription()&#125;;</span><br><span class="line"><span class="comment">//调用qr对象中的方法update执行添加</span></span><br><span class="line">qr.update(sql, params);</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException ex) &#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"账务添加失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25添加账务功能view层实现"><a href="#25添加账务功能view层实现" class="headerlink" title="25添加账务功能view层实现"></a>25添加账务功能view层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A: 添加账务功能view层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类addZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"选择的添加账务功能，请输入以下内容"</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"输入分类名称"</span>);</span><br><span class="line">String flname = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入金额"</span>);</span><br><span class="line"><span class="keyword">double</span> money = sc.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入账户"</span>);</span><br><span class="line">String zhanghu = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入日期：格式XXXX-XX-xx"</span>);</span><br><span class="line">String createtime = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入具体描述"</span>);</span><br><span class="line">String description = sc.next();</span><br><span class="line"><span class="comment">//将接收到的数据，调用controller层的方法，传递参数，实现数据添加</span></span><br><span class="line"><span class="comment">//将用户输入的所有参数，封装成ZhangWu对象</span></span><br><span class="line">ZhangWu zw = <span class="keyword">new</span> ZhangWu(<span class="number">0</span>, flname, money, zhanghu, createtime, description);</span><br><span class="line">controller.addZhangWu(zw);</span><br><span class="line">System.out.println(<span class="string">"恭喜添加账务成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26编辑账务功能分析"><a href="#26编辑账务功能分析" class="headerlink" title="26编辑账务功能分析"></a>26编辑账务功能分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A: 编辑账务功能分析</span><br><span class="line">* a: 编写MainView类中editZhangWu方法</span><br><span class="line">* 键盘输入要编辑的账务信息ID号</span><br><span class="line">* 键盘输入要修改的账务信息内容</span><br><span class="line">* 调用ZhangWuService类中editZhangWu方法，用来将指定的账务信息进行更新</span><br><span class="line">* 更新完毕后，使用输出语句，提示 “编辑账务成功！”</span><br><span class="line">* b: 编写ZhangWuService类中editZhangWu方法</span><br><span class="line">* 调用ZhangWuDao类中editZhangWu方法，用来将指定的账务信息进行更新</span><br><span class="line">* c: 编写ZhangWuDao类中editZhangWu方法</span><br><span class="line">* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务更新操作</span><br></pre></td></tr></table></figure><h3 id="27编辑账务功能功能之前实现查询所有"><a href="#27编辑账务功能功能之前实现查询所有" class="headerlink" title="27编辑账务功能功能之前实现查询所有"></a>27编辑账务功能功能之前实现查询所有</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* A: 编辑账务功能功能之前实现查询所有</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类editZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用查询所有账务数据的功能，显示出来</span></span><br><span class="line"><span class="comment">//看到所有数据，从中选择一项，进行修改</span></span><br><span class="line">selectAll();</span><br><span class="line">System.out.println(<span class="string">"选择的是编辑功能，请输入数据"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28编辑账务功能菜单实现"><a href="#28编辑账务功能菜单实现" class="headerlink" title="28编辑账务功能菜单实现"></a>28编辑账务功能菜单实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* A: 编辑账务功能菜单实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类editZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用查询所有账务数据的功能，显示出来</span></span><br><span class="line"><span class="comment">//看到所有数据，从中选择一项，进行修改</span></span><br><span class="line">selectAll();</span><br><span class="line">System.out.println(<span class="string">"选择的是编辑功能，请输入数据"</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入ID"</span>);</span><br><span class="line"><span class="keyword">int</span> zwid = sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入分类名称"</span>);</span><br><span class="line">String flname = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入金额"</span>);</span><br><span class="line"><span class="keyword">double</span> money = sc.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入账户"</span>);</span><br><span class="line">String zhanghu = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入日期：格式XXXX-XX-xx"</span>);</span><br><span class="line">String createtime = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入具体描述"</span>);</span><br><span class="line">String description = sc.next();</span><br><span class="line"><span class="comment">//将用户输入的数据，封装到ZhangWu对象中</span></span><br><span class="line"><span class="comment">//用户输入的ID，必须封装到到对象中</span></span><br><span class="line">ZhangWu zw = <span class="keyword">new</span> ZhangWu(zwid, flname, money, zhanghu, createtime, description);</span><br><span class="line"><span class="comment">//调用controller层中的方法，实现编辑账务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29编辑账务功能控制层-业务层实现"><a href="#29编辑账务功能控制层-业务层实现" class="headerlink" title="29编辑账务功能控制层,业务层实现"></a>29编辑账务功能控制层,业务层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* A: 编辑账务功能控制层,业务层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.controller包中的ZhangWuController类editZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现编辑账务功能</span></span><br><span class="line"><span class="comment"> * 由视图层调用，传递参数，也是ZhangWu对象</span></span><br><span class="line"><span class="comment"> * 调用service层的方法，也是ZhangWu对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line">service.editZhangWu(zw);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.service包中的ZhangWuService类editZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现编辑账务</span></span><br><span class="line"><span class="comment"> * 由控制层调用，传递ZhangWu对象</span></span><br><span class="line"><span class="comment"> * 调用dao层的方法，传递ZhangWu对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line">dao.editZhangWu(zw);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="30编辑账务功能dao层实现"><a href="#30编辑账务功能dao层实现" class="headerlink" title="30编辑账务功能dao层实现"></a>30编辑账务功能dao层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A：编辑账务功能dao层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类editZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现编辑功能</span></span><br><span class="line"><span class="comment"> * 由业务层调用，传递ZhangWu对象</span></span><br><span class="line"><span class="comment"> * 将对象中的数据，更新到数据表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">(ZhangWu zw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//更新数据的SQL</span></span><br><span class="line">String sql = <span class="string">"UPDATE zhangwu SET flname=?,money=?,zhanghu=?,createtime=?,description=? WHERE zwid=?"</span>;</span><br><span class="line"><span class="comment">//定义对象数组，封装所有数据</span></span><br><span class="line">Object[] params = &#123;zw.getFlname(),zw.getMoney(),zw.getZhanghu(),zw.getCreatetime(),zw.getDescription(),zw.getZwid()&#125;;</span><br><span class="line"><span class="comment">//调用qr对象方法update执行更新</span></span><br><span class="line">qr.update(sql, params);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"编辑账务失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="31编辑账务功能view层实现"><a href="#31编辑账务功能view层实现" class="headerlink" title="31编辑账务功能view层实现"></a>31编辑账务功能view层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* A: 编辑账务功能view层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类editZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现对账务的编辑功能</span></span><br><span class="line"><span class="comment"> * 实现思想：</span></span><br><span class="line"><span class="comment"> * 接收用户的输入的信息</span></span><br><span class="line"><span class="comment"> *  封装成ZhangWu对象</span></span><br><span class="line"><span class="comment"> *  调用控制层的方法，传递ZhangWu对象，实现编辑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用查询所有账务数据的功能，显示出来</span></span><br><span class="line"><span class="comment">//看到所有数据，从中选择一项，进行修改</span></span><br><span class="line">selectAll();</span><br><span class="line">System.out.println(<span class="string">"选择的是编辑功能，请输入数据"</span>);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入ID"</span>);</span><br><span class="line"><span class="keyword">int</span> zwid = sc.nextInt();</span><br><span class="line">System.out.println(<span class="string">"输入分类名称"</span>);</span><br><span class="line">String flname = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入金额"</span>);</span><br><span class="line"><span class="keyword">double</span> money = sc.nextDouble();</span><br><span class="line">System.out.println(<span class="string">"输入账户"</span>);</span><br><span class="line">String zhanghu = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入日期：格式XXXX-XX-xx"</span>);</span><br><span class="line">String createtime = sc.next();</span><br><span class="line">System.out.println(<span class="string">"输入具体描述"</span>);</span><br><span class="line">String description = sc.next();</span><br><span class="line"><span class="comment">//将用户输入的数据，封装到ZhangWu对象中</span></span><br><span class="line"><span class="comment">//用户输入的ID，必须封装到到对象中</span></span><br><span class="line">ZhangWu zw = <span class="keyword">new</span> ZhangWu(zwid, flname, money, zhanghu, createtime, description);</span><br><span class="line"><span class="comment">//调用controller层中的方法，实现编辑账务</span></span><br><span class="line">controller.editZhangWu(zw);</span><br><span class="line">System.out.println(<span class="string">"账务编辑成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32删除账务功能分析"><a href="#32删除账务功能分析" class="headerlink" title="32删除账务功能分析"></a>32删除账务功能分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* A: 删除账务功能分析</span><br><span class="line">* a: 编写MainView类中deleteZhangWu方法</span><br><span class="line">* 键盘输入要删除的账务信息ID号</span><br><span class="line">* 调用ZhangWuService类中deleteZhangWu方法，用来将指定的账务信息删除</span><br><span class="line">* 删除完毕后，使用输出语句，提示 “删除账务成功！”</span><br><span class="line">* b: 编写ZhangWuService类中deleteZhangWu方法</span><br><span class="line">* 调用ZhangWuDao类中deleteZhangWu方法，用来将指定的账务信息删除</span><br><span class="line">* c: 编写ZhangWuDao类中deleteZhangWu方法</span><br><span class="line">* 通过QueryRunner对象，调用update方法更新数据库表gjp_zhangwu，完成数据库表中指定账务删除操作</span><br></pre></td></tr></table></figure><h3 id="33删除账务功能菜单实现"><a href="#33删除账务功能菜单实现" class="headerlink" title="33删除账务功能菜单实现"></a>33删除账务功能菜单实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 删除账务功能菜单实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类deleteZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现账务删除</span></span><br><span class="line"><span class="comment"> * 实现思想：</span></span><br><span class="line"><span class="comment"> * 接收用户的输入，输入一个主键数据</span></span><br><span class="line"><span class="comment"> *  调用控制层方法，传递一个主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用查询所有账务数据的功能，显示出来</span></span><br><span class="line"><span class="comment">//看到所有数据，从中选择一项，进行修改</span></span><br><span class="line">selectAll();</span><br><span class="line">System.out.println(<span class="string">"选择的是删除功能，请输入序号即可"</span>);</span><br><span class="line"><span class="keyword">int</span> zwid = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line"><span class="comment">//调用控制层方法，传递主键id即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34删除账务功能控制层-业务层实现"><a href="#34删除账务功能控制层-业务层实现" class="headerlink" title="34删除账务功能控制层,业务层实现"></a>34删除账务功能控制层,业务层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* A: 删除账务功能控制层,业务层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.controller包中的ZhangWuController类deleteZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现删除功能</span></span><br><span class="line"><span class="comment"> * 视图层调用，传递int类型主键</span></span><br><span class="line"><span class="comment"> * 调用service层方法，传递int主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">(<span class="keyword">int</span> zwid)</span> </span>&#123;</span><br><span class="line">service.deleteZhangWu(zwid);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.service包中的ZhangWuService类deleteZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现删除账务功能</span></span><br><span class="line"><span class="comment"> * 由控制层调用，传递主键id</span></span><br><span class="line"><span class="comment"> * 调用dao层方法，传递主键id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">(<span class="keyword">int</span> zwid)</span> </span>&#123;</span><br><span class="line">dao.deleteZhangWu(zwid);</span><br><span class="line">&#125;</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">(<span class="keyword">int</span> zwid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35删除账务功能dao实现"><a href="#35删除账务功能dao实现" class="headerlink" title="35删除账务功能dao实现"></a>35删除账务功能dao实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 删除账务功能dao实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.dao包中的ZhangWuDao类deleteZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现删除业务</span></span><br><span class="line"><span class="comment"> * 业务层调用，传递主键id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">(<span class="keyword">int</span> zwid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//拼写删除数据SQL</span></span><br><span class="line">String sql = <span class="string">"DELETE FROM gjp_zhangwu WHERE zwid=?"</span>;</span><br><span class="line">qr.update(sql, zwid);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"删除账务失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36删除账务功能view层实现"><a href="#36删除账务功能view层实现" class="headerlink" title="36删除账务功能view层实现"></a>36删除账务功能view层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* A: 删除账务功能view层实现</span><br><span class="line">* a: 案例核心代码</span><br><span class="line">* cn.itcast.gjp.view包中建立MainView类editZhangWu方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法，实现账务删除</span></span><br><span class="line"><span class="comment"> * 实现思想：</span></span><br><span class="line"><span class="comment"> * 接收用户的输入，输入一个主键数据</span></span><br><span class="line"><span class="comment"> *  调用控制层方法，传递一个主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteZhangWu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用查询所有账务数据的功能，显示出来</span></span><br><span class="line"><span class="comment">//看到所有数据，从中选择一项，进行修改</span></span><br><span class="line">selectAll();</span><br><span class="line">System.out.println(<span class="string">"选择的是删除功能，请输入序号即可"</span>);</span><br><span class="line"><span class="keyword">int</span> zwid = <span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line"><span class="comment">//调用控制层方法，传递主键id即可</span></span><br><span class="line">controller.deleteZhangWu(zwid);</span><br><span class="line">System.out.println(<span class="string">"删除账务成功"</span>);</span><br></pre></td></tr></table></figure><h3 id="37总结"><a href="#37总结" class="headerlink" title="37总结"></a>37总结</h3><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297638/samples/java%20files/photo-1546398770-b134faf3de65.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、管家婆项目 &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础28(DBUtils,连接池)</title>
    <link href="https://leesen998.github.io/2016/11/29/day30%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/29/day30笔记/</id>
    <published>2016-11-29T11:48:29.000Z</published>
    <updated>2019-01-20T14:42:08.803Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297590/samples/java%20files/photo-1545382142-c3d9b8168eeb.jpg" alt="" style="width:100%"></p><p>1、DBUtils<br>2、连接池    </p><a id="more"></a>    <h3 id="01DButils工具类的介绍个三个核心类"><a href="#01DButils工具类的介绍个三个核心类" class="headerlink" title="01DButils工具类的介绍个三个核心类"></a>01DButils工具类的介绍个三个核心类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* A: DButils工具类的介绍个三个核心类</span><br><span class="line">* a: 概述</span><br><span class="line">* DBUtils是java编程中的数据库操作实用工具，小巧简单实用。</span><br><span class="line">* DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。</span><br><span class="line">* DBUtils就是JDBC的简化开发工具包。需要项目导入commons-dbutils-<span class="number">1.6</span>.jar才能够正常使用DBUtils工具。</span><br><span class="line">* b: Dbutils三个核心功能介绍</span><br><span class="line">* QueryRunner中提供对sql语句操作的API.</span><br><span class="line">* update(Connection conn, String sql, Object... params) ，用来完成表数据的增加、删除、更新操作</span><br><span class="line">* query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) ，用来完成表数据的查询操作</span><br><span class="line">* ResultSetHandler接口，用于定义select操作后，怎样封装结果集.</span><br><span class="line">* DbUtils类，它就是一个工具类,定义了关闭资源与事务处理的方法</span><br></pre></td></tr></table></figure><h3 id="02事务的简单介绍-此知识点简单了解，难度较大"><a href="#02事务的简单介绍-此知识点简单了解，难度较大" class="headerlink" title="02事务的简单介绍(此知识点简单了解，难度较大)"></a>02事务的简单介绍(此知识点简单了解，难度较大)</h3><ul><li>A: 事务的简单介绍</li><li>a: 见day32/day32_source/事务.jgp</li></ul><h3 id="03QueryRunner类的update方法介绍"><a href="#03QueryRunner类的update方法介绍" class="headerlink" title="03QueryRunner类的update方法介绍"></a>03QueryRunner类的update方法介绍</h3><ul><li>A：QueryRunner类的update方法介绍</li><li>a: 方法介绍</li><li>update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作</li><li>使用QueryRunner类,实现对数据表的insert delete update</li><li>调用QueryRunner类的方法 update (Connection con,String sql,Object…param)<ul><li>Object…param 可变参数,Object类型,SQL语句会出现?占位符</li><li>数据库连接对象,自定义的工具类传递</li></ul></li></ul><h3 id="04QueryRunner类实现insert添加数据"><a href="#04QueryRunner类实现insert添加数据" class="headerlink" title="04QueryRunner类实现insert添加数据"></a>04QueryRunner类实现insert添加数据</h3><pre><code class="java">* A: QueryRunner类实现insert添加数据* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> SQLException </span>{        insert();                }                    <span class="comment">/*</span><span class="comment">     * 定义方法,使用QueryRunner类的方法update向数据表中,添加数据</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        <span class="comment">//创建QueryRunner类对象</span>        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)"</span>;        <span class="comment">//将三个?占位符的实际参数,写在数组中</span>        Object[] params = {<span class="string">"体育用品"</span>,<span class="number">289.32</span>,<span class="string">"购买体育用品"</span>};        <span class="comment">//调用QueryRunner类的方法update执行SQL语句</span>        <span class="keyword">int</span> row = qr.update(con, sql, params);        System.out.println(row);        DbUtils.closeQuietly(con);    }}</code></pre><h3 id="05QueryRunner类实现update修改数据"><a href="#05QueryRunner类实现update修改数据" class="headerlink" title="05QueryRunner类实现update修改数据"></a>05QueryRunner类实现update修改数据</h3><pre><code class="java">* A: QueryRunner类实现update修改数据* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> SQLException </span>{        update();    }                    <span class="comment">/*</span><span class="comment">     *  定义方法,使用QueryRunner类的方法update将数据表的数据修改</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        <span class="comment">//创建QueryRunner类对象</span>        QueryRunner qr = <span class="keyword">new</span> QueryRunner();            <span class="comment">//写修改数据的SQL语句</span>        String sql = <span class="string">"UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=?"</span>;        <span class="comment">//定义Object数组,存储?中的参数</span>        Object[] params = {<span class="string">"花卉"</span>,<span class="number">100.88</span>,<span class="string">"情人节玫瑰花"</span>,<span class="number">4</span>};        <span class="comment">//调用QueryRunner方法update</span>        <span class="keyword">int</span> row = qr.update(con, sql, params);        System.out.println(row);        DbUtils.closeQuietly(con);    }                }</code></pre><h3 id="06QueryRunner类实现delete删除数据"><a href="#06QueryRunner类实现delete删除数据" class="headerlink" title="06QueryRunner类实现delete删除数据"></a>06QueryRunner类实现delete删除数据</h3><pre><code class="java">* A: QueryRunner类实现delete删除数据* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> SQLException </span>{        delete();    }    <span class="comment">/*</span><span class="comment">     *  定义方法,使用QueryRunner类的方法delete将数据表的数据删除</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        <span class="comment">//创建QueryRunner类对象</span>        QueryRunner qr = <span class="keyword">new</span> QueryRunner();            <span class="comment">//写删除的SQL语句</span>        String sql = <span class="string">"DELETE FROM sort WHERE sid=?"</span>;        <span class="comment">//调用QueryRunner方法update</span>        <span class="keyword">int</span> row = qr.update(con, sql, <span class="number">8</span>);        System.out.println(row);        <span class="comment">/*</span><span class="comment">         *  判断insert,update,delete执行是否成功</span><span class="comment">         *  对返回值row判断</span><span class="comment">         *  if(row&gt;0) 执行成功</span><span class="comment">         */</span>        DbUtils.closeQuietly(con);    }                }</code></pre><h3 id="07JavaBean类"><a href="#07JavaBean类" class="headerlink" title="07JavaBean类"></a>07JavaBean类</h3><pre><code class="java">* A: JavaBean类* a: 概念* JavaBean就是一个类，在开发中常用封装数据。具有如下特性    <span class="number">1</span>.    需要实现接口：java.io.Serializable ，通常实现接口这步骤省略了，不会影响程序。    <span class="number">2</span>.    提供私有字段：<span class="keyword">private</span> 类型 字段名;    <span class="number">3</span>.    提供getter/setter方法：    <span class="number">4</span>.    提供无参构造</code></pre><h3 id="08DBUtils工具类结果集处理的方式"><a href="#08DBUtils工具类结果集处理的方式" class="headerlink" title="08DBUtils工具类结果集处理的方式"></a>08DBUtils工具类结果集处理的方式</h3><pre><code class="java">* A: DBUtils工具类结果集处理的方式* a: QueryRunner实现查询操作*    query(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) ，用来完成表数据的查询操作* b: ResultSetHandler结果集处理类* ArrayHandler    将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值* ArrayListHandler    将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。* BeanHandler    将结果集中第一条记录封装到一个指定的javaBean中。* BeanListHandler    将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中* ColumnListHandler    将结果集中指定的列的字段值，封装到一个List集合中* ScalarHandler    它是用于单数据。例如<span class="function">select <span class="title">count</span><span class="params">(*)</span> from 表操作。</span><span class="function">* MapHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据</span><span class="function">* MapListHandler    将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合</span><span class="function"></span></code></pre><h3 id="09QueryRunner类的方法query"><a href="#09QueryRunner类的方法query" class="headerlink" title="09QueryRunner类的方法query"></a>09QueryRunner类的方法query</h3><pre><code class="java">* A: QueryRunner类的方法query* a: QueryRunner数据查询操作* 调用QueryRunner类方法query(Connection con,String sql,ResultSetHandler r, Object..params)*  ResultSetHandler r 结果集的处理方式,传递ResultSetHandler接口实现类*  Object..params SQL语句中的?占位符*  注意: query方法返回值,返回的是T 泛型, 具体返回值类型,跟随结果集处理方式变化* b: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();}</code></pre><h3 id="10结果集处理ArrayHandler"><a href="#10结果集处理ArrayHandler" class="headerlink" title="10结果集处理ArrayHandler"></a>10结果集处理ArrayHandler</h3><pre><code class="java">* A: 结果集处理ArrayHandler* 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        arrayHandler();    }        <span class="comment">/*</span><span class="comment">     *  结果集第一种处理方法, ArrayHandler</span><span class="comment">     *  将结果集的第一行存储到对象数组中  Object[]</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT * FROM sort"</span>;        <span class="comment">//调用方法query执行查询,传递连接对象,SQL语句,结果集处理方式的实现类</span>        <span class="comment">//返回对象数组</span>        Object[] result = qr.query(con, sql, <span class="keyword">new</span> ArrayHandler());        <span class="keyword">for</span>(Object obj : result){            System.out.print(obj);        }    }    }</code></pre><h3 id="11结果集处理ArrayListHandler"><a href="#11结果集处理ArrayListHandler" class="headerlink" title="11结果集处理ArrayListHandler"></a>11结果集处理ArrayListHandler</h3><pre><code class="java">* A: 结果集处理ArrayListHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        arrayListHandler();    }    <span class="comment">/*</span><span class="comment">     *  结果集第二种处理方法,ArrayListHandler</span><span class="comment">     *  将结果集的每一行,封装到对象数组中, 出现很多对象数组</span><span class="comment">     *  对象数组存储到List集合</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayListHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT * FROM sort"</span>;                <span class="comment">//调用query方法,结果集处理的参数上,传递实现类ArrayListHandler</span>        <span class="comment">//方法返回值 每行是一个对象数组,存储到List</span>        List&lt;Object[]&gt; result=  qr.query(con, sql, <span class="keyword">new</span> ArrayListHandler());        <span class="comment">//集合的遍历</span>        <span class="keyword">for</span>( Object[] objs  : result){            <span class="comment">//遍历对象数组</span>            <span class="keyword">for</span>(Object obj : objs){                System.out.print(obj+<span class="string">"  "</span>);            }            System.out.println();        }    }}</code></pre><h3 id="12结果集处理BeanHandler"><a href="#12结果集处理BeanHandler" class="headerlink" title="12结果集处理BeanHandler"></a>12结果集处理BeanHandler</h3><pre><code class="java">* A: 结果集处理BeanHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        beanHandler();    }    <span class="comment">/*</span><span class="comment">     *  结果集第三种处理方法,BeanHandler</span><span class="comment">     *  将结果集的第一行数据,封装成JavaBean对象</span><span class="comment">     *  注意: 被封装成数据到JavaBean对象, Sort类必须有空参数构造</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT * FROM sort "</span>;        <span class="comment">//调用方法,传递结果集实现类BeanHandler</span>        <span class="comment">//BeanHandler(Class&lt;T&gt; type) </span>        Sort s = qr.query(con, sql, <span class="keyword">new</span> BeanHandler&lt;Sort&gt;(Sort.class));        System.out.println(s);    }}</code></pre><h3 id="13结果集处理BeanListHandler"><a href="#13结果集处理BeanListHandler" class="headerlink" title="13结果集处理BeanListHandler"></a>13结果集处理BeanListHandler</h3><pre><code class="java">* A: 结果集处理BeanListHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{<span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{    beanListHander();}<span class="comment">/*</span><span class="comment"> *  结果集第四种处理方法, BeanListHandler</span><span class="comment"> *  结果集每一行数据,封装JavaBean对象</span><span class="comment"> *  多个JavaBean对象,存储到List集合</span><span class="comment"> */</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanListHander</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{    QueryRunner qr = <span class="keyword">new</span> QueryRunner();    String sql = <span class="string">"SELECT * FROM sort "</span>;    <span class="comment">//调用方法query,传递结果集处理实现类BeanListHandler</span>    List&lt;Sort&gt; list = qr.query(con, sql, <span class="keyword">new</span> BeanListHandler&lt;Sort&gt;(Sort.class));    <span class="keyword">for</span>(Sort s : list){        System.out.println(s);    }}}</code></pre><h3 id="14结果集处理ColumnListHandler"><a href="#14结果集处理ColumnListHandler" class="headerlink" title="14结果集处理ColumnListHandler"></a>14结果集处理ColumnListHandler</h3><pre><code class="java">* A: 结果集处理ColumnListHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        columnListHandler();    }        <span class="comment">/*</span><span class="comment">     *  结果集第五种处理方法,ColumnListHandler</span><span class="comment">     *  结果集,指定列的数据,存储到List集合</span><span class="comment">     *  List&lt;Object&gt; 每个列数据类型不同</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">columnListHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT * FROM sort "</span>;                <span class="comment">//调用方法 query,传递结果集实现类ColumnListHandler</span>        <span class="comment">//实现类构造方法中,使用字符串的列名</span>        List&lt;Object&gt; list = qr.query(con, sql, <span class="keyword">new</span> ColumnListHandler&lt;Object&gt;(<span class="string">"sname"</span>));        <span class="keyword">for</span>(Object obj : list){            System.out.println(obj);        }    }    }</code></pre><h3 id="15结果集处理ScalarHandler"><a href="#15结果集处理ScalarHandler" class="headerlink" title="15结果集处理ScalarHandler"></a>15结果集处理ScalarHandler</h3><pre><code class="java">* A: 结果集处理ScalarHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        scalarHandler();    }        <span class="comment">/*</span><span class="comment">     *  结果集第六种处理方法,ScalarHandler</span><span class="comment">     *  对于查询后,只有1个结果</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalarHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT COUNT(*) FROM sort"</span>;        <span class="comment">//调用方法query,传递结果集处理实现类ScalarHandler</span>        <span class="keyword">long</span> count = qr.query(con, sql, <span class="keyword">new</span> ScalarHandler&lt;Long&gt;());        System.out.println(count);    }}</code></pre><h3 id="16结果集处理MapHandler"><a href="#16结果集处理MapHandler" class="headerlink" title="16结果集处理MapHandler"></a>16结果集处理MapHandler</h3><pre><code class="java">* A: 结果集处理MapHandler* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        mapHandler();    }    <span class="comment">/*</span><span class="comment">     *  结果集第七种处理方法,MapHandler</span><span class="comment">     *  将结果集第一行数据,封装到Map集合中</span><span class="comment">     *  Map&lt;键,值&gt; 键:列名  值:这列的数据</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT  * FROM sort"</span>;        <span class="comment">//调用方法query,传递结果集实现类MapHandler</span>        <span class="comment">//返回值: Map集合,Map接口实现类, 泛型</span>        Map&lt;String,Object&gt; map = qr.query(con, sql, <span class="keyword">new</span> MapHandler());        <span class="comment">//遍历Map集合</span>        <span class="keyword">for</span>(String key : map.keySet()){            System.out.println(key+<span class="string">".."</span>+map.get(key));        }    }}</code></pre><h3 id="17结果集处理MapListHandler"><a href="#17结果集处理MapListHandler" class="headerlink" title="17结果集处理MapListHandler"></a>17结果集处理MapListHandler</h3><pre><code class="java">* A: 结果集处理MapListHandlerr* a: 案例代码<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo1</span> </span>{    <span class="keyword">private</span> <span class="keyword">static</span> Connection con = JDBCUtilsConfig.getConnection();    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException</span>{        mapListHandler();    }    <span class="comment">/*</span><span class="comment">     *  结果集第八种处理方法,MapListHandler</span><span class="comment">     *  将结果集每一行存储到Map集合,键:列名,值:数据</span><span class="comment">     *  Map集合过多,存储到List集合</span><span class="comment">     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapListHandler</span><span class="params">()</span><span class="keyword">throws</span> SQLException</span>{        QueryRunner qr = <span class="keyword">new</span> QueryRunner();        String sql = <span class="string">"SELECT  * FROM sort"</span>;        <span class="comment">//调用方法query,传递结果集实现类MapListHandler</span>        <span class="comment">//返回值List集合, 存储的是Map集合</span>        List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(con, sql, <span class="keyword">new</span> MapListHandler());        <span class="comment">//遍历集合list</span>        <span class="keyword">for</span>( Map&lt;String,Object&gt; map : list ){            <span class="keyword">for</span>(String key : map.keySet()){                System.out.print(key+<span class="string">"..."</span>+map.get(key));            }            System.out.println();        }    }}</code></pre><h3 id="18连接池介绍"><a href="#18连接池介绍" class="headerlink" title="18连接池介绍"></a>18连接池介绍</h3><pre><code class="java">* A: 连接池介绍* a: 连接池介绍* 实际上就是存放连接的池子(容器)* 在开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程* 为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection。* 这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池</code></pre><h3 id="19连接池概念规范和DataSource接口"><a href="#19连接池概念规范和DataSource接口" class="headerlink" title="19连接池概念规范和DataSource接口"></a>19连接池概念规范和DataSource接口</h3><pre><code class="java">* A: 连接池概念规范和DataSource接口    * a: 连接池概念规范* 用池来管理Connection，这样可以重复使用Connection。* 不用自己来创建Connection，而是通过池来获取Connection对象* 使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池* 连接池技术可以完成Connection对象的再次利用* b: DataSource接口* Java为数据库连接池提供了公共的接口：javax.sql.DataSource* 各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池* 常见的连接池：DBCP、C3P0</code></pre><h3 id="20DBCP连接池介绍"><a href="#20DBCP连接池介绍" class="headerlink" title="20DBCP连接池介绍"></a>20DBCP连接池介绍</h3><pre><code class="java">* A: DBCP连接池介绍* a: DBCP连接池介绍* DBCP也是一个开源的连接池，是Apache Common成员之一，在企业开发中也比较常见，tomcat内置的连接池* tomcat服务器简单介绍</code></pre><h3 id="21导入jar包"><a href="#21导入jar包" class="headerlink" title="21导入jar包"></a>21导入jar包</h3><pre><code class="java">* A: 导入jar包* a: jar包介绍    * mysql-connector-java-<span class="number">5.1</span>.37-bin.jar：数据库驱动* commons-dbutils-<span class="number">1.6</span>.jar：提供QueryRunner类方便进行增删改查操作* commons-dbcp-<span class="number">1.4</span>.jar：* commons-pool-<span class="number">1.5</span>.6.jar：提供高效的数据库连接池技术* b: 导入jar包* 在项目根路径下建立文件夹lib* 拷贝以上jar包，选定拷贝的jar包/右键/Build Path/Add to Build Path</code></pre><h3 id="22BasicDataSource类的使用"><a href="#22BasicDataSource类的使用" class="headerlink" title="22BasicDataSource类的使用"></a>22BasicDataSource类的使用</h3><pre><code class="java">* A: BasicDataSource类的使用* a: 案例代码<span class="comment">/*</span><span class="comment"> *  连接池jar包中,定义好一个类 BasicDataSource</span><span class="comment"> *  实现类数据源的规范接口 javax.sql.DataSource</span><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSoruceDemo</span> </span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        <span class="comment">//创建DataSource接口的实现类对象</span>        <span class="comment">//实现类, org.apache.commons.dbcp</span>        BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();        <span class="comment">//连接数据库的4个最基本信息,通过对象方法setXXX设置进来</span>        dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/mybase"</span>);        dataSource.setUsername(<span class="string">"root"</span>);        dataSource.setPassword(<span class="string">"123"</span>);        <span class="keyword">try</span>{        <span class="comment">//调用对象方法getConnection获取数据库的连接</span>            Connection con = dataSource.getConnection();            System.out.println(con);        }<span class="keyword">catch</span>(SQLException ex){<span class="comment">//            System.out.println(ex);</span>            ex.printStackTrace();            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库连接失败"</span>);        }    }}</code></pre><h3 id="23BasicDataSource类的常见配置"><a href="#23BasicDataSource类的常见配置" class="headerlink" title="23BasicDataSource类的常见配置"></a>23BasicDataSource类的常见配置</h3><pre><code class="java">* A: BasicDataSource类的常见配置* a: 常见配置分类    属性            描述必须项            driverClassName    数据库驱动名称        url                数据库的地址        username        用户名        password        密码基本项（扩展）            maxActive        最大连接数量        minIdle            最小空闲连接        maxIdle         最大空闲连接        initialSize        初始化连接</code></pre><h3 id="24实现数据库连接池工具类"><a href="#24实现数据库连接池工具类" class="headerlink" title="24实现数据库连接池工具类"></a>24实现数据库连接池工具类</h3><pre><code class="java">* A: 实现数据库连接池工具类* a: 案例代码<span class="comment">/*</span><span class="comment"> *  使用DBCP实现数据库的连接池</span><span class="comment"> *  连接池配置,自定义类,</span><span class="comment"> *  最基本四项完整</span><span class="comment"> *  对于数据库连接池其他配置,自定义</span><span class="comment"> */</span><span class="keyword">import</span> javax.sql.DataSource;<span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span></span>{    <span class="comment">//创建出BasicDataSource类对象</span>    <span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource datasource = <span class="keyword">new</span> BasicDataSource();    <span class="comment">//静态代码块,对象BasicDataSource对象中的配置,自定义</span>    <span class="keyword">static</span>{        <span class="comment">//数据库连接信息,必须的</span>        datasource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);        datasource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/day33_user"</span>);        datasource.setUsername(<span class="string">"root"</span>);        datasource.setPassword(<span class="string">"123"</span>);        <span class="comment">//对象连接池中的连接数量配置,可选的</span>        datasource.setInitialSize(<span class="number">10</span>);<span class="comment">//初始化的连接数</span>        datasource.setMaxActive(<span class="number">8</span>);<span class="comment">//最大连接数量</span>        datasource.setMaxIdle(<span class="number">5</span>);<span class="comment">//最大空闲数</span>        datasource.setMinIdle(<span class="number">1</span>);<span class="comment">//最小空闲</span>    }    <span class="comment">//定义静态方法,返回BasicDataSource类的对象</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>{        <span class="keyword">return</span> datasource;    }}</code></pre><h3 id="25工具类的测试"><a href="#25工具类的测试" class="headerlink" title="25工具类的测试"></a>25工具类的测试</h3><pre><code class="java">* A: 工具类的测试* a: 案例代码<span class="comment">/*</span><span class="comment"> *  测试写好的工具类,</span><span class="comment"> *  提供的是一个DataSource接口的数据源</span><span class="comment"> *  QueryRunner类构造方法,接收DataSource接口的实现类</span><span class="comment"> *  后面,调用方法update,query,无需传递他们Connection连接对象</span><span class="comment"> */</span><span class="keyword">import</span> java.sql.SQLException;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;<span class="keyword">import</span> org.apache.commons.dbutils.handlers.ArrayListHandler;<span class="keyword">import</span> cn.itcast.jdbcutils.JDBCUtils;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryRunnerDemo</span></span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{        select();    }    <span class="comment">//定义2个方法,实现数据表的添加,数据表查询</span>    <span class="comment">//QueryRunner类对象,写在类成员位置</span>    <span class="keyword">private</span> <span class="keyword">static</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(JDBCUtils.getDataSource());     <span class="comment">//数据表查询</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>{        String sql = <span class="string">"SELECT * FROM sort"</span>;        <span class="keyword">try</span>{        List&lt;Object[]&gt; list = qr.query(sql, <span class="keyword">new</span> ArrayListHandler());        <span class="keyword">for</span>(Object[] objs : list){            <span class="keyword">for</span>(Object obj : objs){                System.out.print(obj+<span class="string">"\t"</span>);            }            System.out.println();        }        }<span class="keyword">catch</span>(SQLException ex){            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据查询失败"</span>);        }    }    <span class="comment">//数据表添加数据</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>{        String sql = <span class="string">"INSERT INTO sort (sname,sprice,sdesc)VALUES(?,?,?)"</span>;        Object[] params = {<span class="string">"水果"</span>,<span class="number">100.12</span>,<span class="string">"刚刚上市的核桃"</span>};        <span class="keyword">try</span>{            <span class="keyword">int</span> row = qr.update(sql, params);            System.out.println(row);        }<span class="keyword">catch</span>(SQLException ex){            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据添加失败"</span>);        }    }}</code></pre><h3 id="26总结"><a href="#26总结" class="headerlink" title="26总结"></a>26总结</h3><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297590/samples/java%20files/photo-1545382142-c3d9b8168eeb.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、DBUtils&lt;br&gt;2、连接池    &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础27(JDBC,DBUtils)</title>
    <link href="https://leesen998.github.io/2016/11/28/day29%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/28/day29笔记/</id>
    <published>2016-11-28T11:48:29.000Z</published>
    <updated>2019-01-20T14:27:57.913Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297625/samples/java%20files/photo-1546868871-08b8ebc35c09.jpg" alt="" style="width:100%"></p><p>1、JDBC<br>2、DBUtils</p><a id="more"></a>    <h3 id="01JDBC概念和数据库驱动程序"><a href="#01JDBC概念和数据库驱动程序" class="headerlink" title="01JDBC概念和数据库驱动程序"></a>01JDBC概念和数据库驱动程序</h3><ul><li>A: JDBC概念和数据库驱动程序</li><li>a: JDBC概述        <ul><li><strong>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API</strong>，<br>可以为多种关系数据库提供统一访问，<strong>它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范</strong></li><li>JDBC提供了一种基准,据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</li><li>JDBC需要连接驱动，驱动是两个设备要进行通信，满足一定通信数据格式，数据格式由设备提供商规定，<br>设备提供商为设备提供驱动软件，通过软件可以与该设备进行通信。</li><li><strong>我们使用的是mysql的驱动mysql-connector-java-5.1.39-bin.jar</strong></li></ul></li><li>b: 总结<ul><li><strong>JDBC是java提供给开发人员的一套操作数据库的接口</strong></li><li><strong>数据库驱动就是实现该接口的实现类</strong></li></ul></li></ul><h3 id="02JDBC原理"><a href="#02JDBC原理" class="headerlink" title="02JDBC原理"></a>02JDBC原理</h3><ul><li>A: JDBC原理</li><li>a: 描述</li><li>Java提供访问数据库规范称为JDBC，而生产厂商提供规范的实现类称为驱动</li><li>DBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！<br>每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547951375/samples/java%20files/01201.png" alt=""></li></ul><h3 id="03准备数据"><a href="#03准备数据" class="headerlink" title="03准备数据"></a>03准备数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A: 准备数据</span><br><span class="line">* a: 创建数据库和表结构</span><br><span class="line">#创建数据库</span><br><span class="line">create database mybase;</span><br><span class="line">#使用数据库</span><br><span class="line">use mybase;</span><br><span class="line">###创建分类表</span><br><span class="line"><span class="function">create table <span class="title">sort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  sid <span class="keyword">int</span> PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="function"><span class="params">  sname varchar(<span class="number">100</span>)</span>,</span></span><br><span class="line"><span class="function">  sprice DOUBLE,</span></span><br><span class="line"><span class="function">  sdesc <span class="title">VARCHAR</span><span class="params">(<span class="number">500</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">* b: 向表中插入数据</span><br><span class="line">#初始化数据</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'家电'</span>,<span class="number">2000</span>, <span class="string">'优惠的促销'</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'家具'</span>,<span class="number">8900</span>, <span class="string">'家具价格上调,原材料涨价'</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'儿童玩具'</span>,<span class="number">290</span>, <span class="string">'赚家长的钱'</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'生鲜'</span>,<span class="number">500.99</span>, <span class="string">'生鲜商品'</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'服装'</span>,<span class="number">24000</span>, <span class="string">'换季销售'</span>)</span></span>;</span><br><span class="line"><span class="function">insert into <span class="title">sort</span><span class="params">(sname,sprice,sdesc)</span> <span class="title">values</span><span class="params">(<span class="string">'洗涤'</span>,<span class="number">50</span>, <span class="string">'洗发水促销'</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="04JDBC的开发步骤"><a href="#04JDBC的开发步骤" class="headerlink" title="04JDBC的开发步骤"></a>04JDBC的开发步骤</h3><ul><li>A: JDBC的开发步骤</li><li>a: 步骤介绍<br>1.注册驱动<br>告知JVM使用的是哪一个数据库的驱动<br>2.获得连接<br>使用JDBC中的类,完成对MySQL数据库的连接<br>3.获得语句执行平台<br>通过连接对象获取对SQL语句的执行者对象<br>4.执行sql语句<br>使用执行者对象,向数据库执行SQL语句<br>获取到数据库的执行后的结果<br>5.处理结果<br>6.释放资源  一堆close()</li></ul><h3 id="05导入mysql数据库驱动程序jar包"><a href="#05导入mysql数据库驱动程序jar包" class="headerlink" title="05导入mysql数据库驱动程序jar包"></a>05导入mysql数据库驱动程序jar包</h3><ul><li>A: 导入mysql数据库驱动程序jar包</li><li>a: 步骤</li><li>创建lib目录，用于存放当前项目需要的所有jar包</li><li>选择jar包，右键执行build path / Add to Build Path</li></ul><h3 id="06注册数据库驱动程序"><a href="#06注册数据库驱动程序" class="headerlink" title="06注册数据库驱动程序"></a>06注册数据库驱动程序</h3><p><strong>代码：Class.forName(“com.mysql.jdbc.Driver”);</strong><br><strong>JDBC规范定义驱动接口：java.sql.Driver，<br>MySql驱动包提供了实现类：com.mysql.jdbc.Driver</strong><br><strong>DriverManager工具类</strong>，提供注册驱动的方法 registerDriver()，方法的参数是java.sql.Driver，所以我们可以通过如下语句进行注册:<br>DriverManager.registerDriver(new com.mysql.jdbc.Driver());<br>以上代码<strong>不推荐使用</strong>，存在两方面不足<br><strong>1.    硬编码，后期不易于程序扩展和维护</strong><br><strong>2.    驱动被注册两次。</strong></p><p><strong>通常开发我们使用Class.forName() 加载一个使用字符串描述的驱动类</strong>。<br>如果使用Class.forName()将类加载到内存，该类的静态代码将自动执行。<br>通过查询com.mysql.jdbc.Driver源码，我们发现Driver类“主动”将自己进行注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* A: 注册数据库驱动程序</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line"><span class="string">"//1.注册驱动 反射技术,将驱动类加入到内容"</span></span><br><span class="line"><span class="comment">// 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)</span></span><br><span class="line"><span class="comment">// Diver是一个接口,参数传递,MySQL驱动程序中的实现类</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//驱动类源代码,注册2次驱动程序</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07获取数据库的连接对象"><a href="#07获取数据库的连接对象" class="headerlink" title="07获取数据库的连接对象"></a>07获取数据库的连接对象</h3><p><strong>代码：Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydatabase”, ”root”, ”root”);</strong></p><p><strong>获取连接需要方法 DriverManager.getConnection(url,username,password)，三个参数分别表示，url 需要连接数据库的位置（网址） user用户名  password 密码</strong></p><p>url比较复杂，下面是<strong>mysql</strong>的url：<br><strong>jdbc:mysql://localhost:3306/mydatabase</strong></p><p><strong>JDBC规定url的格式由三部分组成，每个部分中间使用冒号分隔。<br>    第一部分是jdbc，这是固定的；<br>    第二部分是数据库名称，那么连接mysql数据库，第二部分当然是mysql了；<br>    第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(mydatabase)组成。</strong><br>url: 数据库地址  &gt;&gt;&gt;&gt;&gt;  <strong>jdbc:mysql://连接主机IP:端口号/数据库名字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* A：获取数据库的连接对象</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line"><span class="comment">//1.注册驱动 反射技术,将驱动类加入到内容</span></span><br><span class="line"><span class="comment">// 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)</span></span><br><span class="line"><span class="comment">// Diver是一个接口,参数传递,MySQL驱动程序中的实现类</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//驱动类源代码,注册2次驱动程序</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获得数据库连接  DriverManager类中静态方法</span></span><br><span class="line"><span class="string">"//static Connection getConnection(String url, String user, String password) "</span> </span><br><span class="line"><span class="comment">//返回值是Connection接口的实现类,在mysql驱动程序</span></span><br><span class="line"><span class="string">"//url: 数据库地址  jdbc:mysql://连接主机IP:端口号/数据库名字"</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line"><span class="comment">//用户名和密码用自己的</span></span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line"><span class="string">"//Connection 接口在java.sql中"</span></span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="string">"//返回值是 Connection 接口的实现类对象,在mysql驱动程序中：com.mysql.jdbc.JDBC4Connection"</span></span><br><span class="line">System.out.println(con);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08获取SQL语句的执行对象对象"><a href="#08获取SQL语句的执行对象对象" class="headerlink" title="08获取SQL语句的执行对象对象"></a>08获取SQL语句的执行对象对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: 获取SQL语句的执行对象对象</span><br><span class="line">* String sql = <span class="string">"某SQL语句"</span>;</span><br><span class="line"><span class="string">"获取Statement语句执行平台：Statement stmt = con.createStatement();"</span></span><br><span class="line"></span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line"><span class="comment">//1.注册驱动 反射技术,将驱动类加入到内容</span></span><br><span class="line"><span class="comment">// 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)</span></span><br><span class="line"><span class="comment">// Diver是一个接口,参数传递,MySQL驱动程序中的实现类</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//驱动类源代码,注册2次驱动程序</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获得数据库连接  DriverManager类中静态方法</span></span><br><span class="line"><span class="comment">//static Connection getConnection(String url, String user, String password)  </span></span><br><span class="line"><span class="comment">//返回值是Connection接口的实现类,在mysql驱动程序</span></span><br><span class="line"><span class="comment">//url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象</span></span><br><span class="line"><span class="string">"// con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库</span></span><br><span class="line"><span class="string">// 返回值是 Statement接口的实现类对象,,在mysql驱动程序中：com.mysql.jdbc.StatementImpl"</span></span><br><span class="line">Statement stat = con.createStatement();</span><br><span class="line">System.out.println(stat);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09执行insert语句获取结果集"><a href="#09执行insert语句获取结果集" class="headerlink" title="09执行insert语句获取结果集"></a>09执行insert语句获取结果集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"某SQL语句"</span>;</span><br><span class="line">获取Statement语句执行平台：Statement stmt = con.createStatement();</span><br><span class="line">常用方法：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span>  --执行insert update delete语句.</span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">sql - SQL 数据操作语言（Data Manipulation Language，DML）语句，如 INSERT、UPDATE 或 DELETE；</span></span><br><span class="line"><span class="function">或者不返回任何内容的 SQL 语句，如 DDL 语句。 </span></span><br><span class="line"><span class="function">返回：</span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">1</span>)</span> 对于 SQL 数据操作语言 <span class="params">(DML)</span> 语句，返回【行计数】:操作成功的数据表有多少行，</span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">2</span>)</span> 对于什么都不返回的 SQL 语句，返回 0 </span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span></span>; --执行select语句.</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span></span>; --执行select返回<span class="keyword">true</span> 执行其他的语句返回<span class="keyword">false</span>.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">* A: 执行insert语句获取结果集</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line"><span class="comment">//1.注册驱动 反射技术,将驱动类加入到内容</span></span><br><span class="line"><span class="comment">// 使用java.sql.DriverManager类静态方法 registerDriver(Driver driver)</span></span><br><span class="line"><span class="comment">// Diver是一个接口,参数传递,MySQL驱动程序中的实现类</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//驱动类源代码,注册2次驱动程序</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获得数据库连接  DriverManager类中静态方法</span></span><br><span class="line"><span class="comment">//static Connection getConnection(String url, String user, String password)  </span></span><br><span class="line"><span class="comment">//返回值是Connection接口的实现类,在mysql驱动程序</span></span><br><span class="line"><span class="comment">//url: 数据库地址  jdbc:mysql://连接主机IP:端口号//数据库名字</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获得语句执行平台, 通过数据库连接对象,获取到SQL语句的执行者对象</span></span><br><span class="line"><span class="comment">// con对象调用方法   Statement createStatement() 获取Statement对象,将SQL语句发送到数据库</span></span><br><span class="line"><span class="comment">// 返回值是 Statement接口的实现类对象,,在mysql驱动程序</span></span><br><span class="line">Statement stat = con.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line"><span class="comment">// 通过执行者对象调用方法执行SQL语句,获取结果</span></span><br><span class="line">&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span>  执行数据库中的SQL语句, insert delete update &lt;&lt;</span></span><br><span class="line"><span class="function">"<span class="comment">// 返回值int,操作成功的数据表多少行"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> row </span>= stat.executeUpdate</span><br><span class="line">(<span class="string">"INSERT INTO sort(sname,sprice,sdesc) VALUES('汽车用品',50000,'疯狂涨价')"</span>);</span><br><span class="line">System.out.println(row);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.释放资源  一堆close()</span></span><br><span class="line">stat.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10执行select语句获取结果集"><a href="#10执行select语句获取结果集" class="headerlink" title="10执行select语句获取结果集"></a>10执行select语句获取结果集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span></span>; --执行select语句.</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span></span>; --执行select返回<span class="keyword">true</span> 执行其他的语句返回<span class="keyword">false</span>.</span><br><span class="line"></span><br><span class="line">ResultSet实际上就是一张二维的表格，我们可以调用其<span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>方法指向某行记录，</span></span><br><span class="line"><span class="function">当第一次调用<span class="title">next</span><span class="params">()</span>方法时，便指向第一行记录的位置，</span></span><br><span class="line"><span class="function">这时就可以使用ResultSet提供的<span class="title">getXXX</span><span class="params">(<span class="keyword">int</span> col)</span>方法<span class="params">(与索引从<span class="number">0</span>开始不同，列从<span class="number">1</span>开始)</span>来获取指定列的数据：</span></span><br><span class="line"><span class="function">rs.<span class="title">next</span><span class="params">()</span></span>;<span class="comment">//指向第一行</span></span><br><span class="line">rs.getInt(<span class="number">1</span>);<span class="comment">//获取第一行第一列的数据</span></span><br><span class="line">常用方法：</span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span> index)</span> / Object <span class="title">getObject</span><span class="params">(String name)</span> 获得任意对象</span></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> / Object <span class="title">getObject</span><span class="params">(String name)</span> 获得字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span> index)</span> / Object <span class="title">getObject</span><span class="params">(String name)</span> 获得整形</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span> index)</span> / Object <span class="title">getObject</span><span class="params">(String name)</span> 获得双精度浮点型</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* A: 执行select语句获取结果集</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//1. 注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//2. 获取连接对象</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="comment">//3 .获取执行SQL 语句对象</span></span><br><span class="line">Statement stat = con.createStatement();</span><br><span class="line"><span class="comment">// 拼写查询的SQL</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM sort"</span>;</span><br><span class="line"><span class="comment">//4. 调用执行者对象方法,执行SQL语句获取结果集</span></span><br><span class="line"><span class="comment">// ResultSet executeQuery(String sql)  执行SQL语句中的select查询</span></span><br><span class="line"><span class="comment">// 返回值ResultSet接口的实现类对象,实现类在mysql驱动中</span></span><br><span class="line">ResultSet rs = stat.executeQuery(sql);</span><br><span class="line"><span class="comment">//5 .处理结果集</span></span><br><span class="line"><span class="comment">// ResultSet接口方法 boolean next() 返回true,有结果集,返回false没有结果集</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"><span class="comment">//获取每列数据,使用是ResultSet接口的方法 getXX方法参数中,建议写String列名</span></span><br><span class="line">System.out.println(rs.getInt(<span class="string">"sid"</span>)+<span class="string">"   "</span>+rs.getString(<span class="string">"sname"</span>)+</span><br><span class="line"><span class="string">"   "</span>+rs.getDouble(<span class="string">"sprice"</span>)+<span class="string">"   "</span>+rs.getString(<span class="string">"sdesc"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">stat.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11SQL注入攻击"><a href="#11SQL注入攻击" class="headerlink" title="11SQL注入攻击"></a>11SQL注入攻击</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* A: SQL注入攻击</span><br><span class="line">* a: 注入问题</span><br><span class="line">* 假设有登录案例SQL语句如下:</span><br><span class="line">* SELECT * FROM 用户表 WHERE NAME = 用户输入的用户名 AND PASSWORD = 用户输的密码;</span><br><span class="line">* 此时，当用户输入正确的账号与密码后，查询到了信息则让用户登录。</span><br><span class="line">但是当用户输入的账号为XXX 密码为：XXX’  OR ‘a’=’a时，则真正执行的代码变为：</span><br><span class="line">* SELECT * FROM 用户表 WHERE NAME = ‘XXX’ AND PASSWORD =’ XXX’  OR ’a’=’a’;</span><br><span class="line">* 此时，上述查询语句时永远可以查询出结果的。那么用户就直接登录成功了，显然我们不希望看到这样的结果，这便是SQL注入问题。</span><br><span class="line">* b: 案例演示</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">users</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"> id INT PRIMARY KEY AUTO_INCREMENT,</span></span></span><br><span class="line"><span class="function"><span class="params"> username VARCHAR(<span class="number">100</span>)</span>,</span></span><br><span class="line"><span class="function"> PASSWORD <span class="title">VARCHAR</span><span class="params">(<span class="number">100</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">INSERT INTO <span class="title">users</span> <span class="params">(username,PASSWORD)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'a'</span>,<span class="string">'1'</span>)</span>,<span class="params">(<span class="string">'b'</span>,<span class="string">'2'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">SELECT * FROM users;</span><br><span class="line"></span><br><span class="line">-- 登录查询</span><br><span class="line">SELECT * FROM users WHERE username=<span class="string">'dsfsdfd'</span> AND PASSWORD=<span class="string">'wrethiyu'</span>  OR <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">SELECT * FROM users WHERE username=<span class="string">'a'</span> AND PASSWORD=<span class="string">'1'</span>OR<span class="string">'1=1'</span></span><br><span class="line">键盘录入：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span><span class="string">'OR'</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="12SQL注入攻击用户登录案例"><a href="#12SQL注入攻击用户登录案例" class="headerlink" title="12SQL注入攻击用户登录案例"></a>12SQL注入攻击用户登录案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* A: SQL注入攻击用户登录案例</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line">Statement stat = con.createStatement();</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String user = sc.nextLine();</span><br><span class="line">String pass = sc.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败</span></span><br><span class="line"><span class="comment">//String sql = "SELECT * FROM users WHERE username='dsfsdfd' AND PASSWORD='wrethiyu' OR 1=1";</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM users WHERE username='"</span>+user+<span class="string">"' AND PASSWORD='"</span>+pass+<span class="string">"'"</span>;</span><br><span class="line">System.out.println(sql);</span><br><span class="line">ResultSet rs = stat.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">System.out.println(rs.getString(<span class="string">"username"</span>)+<span class="string">"   "</span>+rs.getString(<span class="string">"password"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">stat.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13PrepareStatement接口预编译SQL语句"><a href="#13PrepareStatement接口预编译SQL语句" class="headerlink" title="13PrepareStatement接口预编译SQL语句"></a>13PrepareStatement接口预编译SQL语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* A: PrepareStatement接口预编译SQL语句</span><br><span class="line">* a: 预处理对象</span><br><span class="line">* 使用PreparedStatement预处理对象时，建议每条sql语句所有的实际参数，都使用逗号分隔。</span><br><span class="line">* String sql = <span class="string">"insert into sort(sid,sname) values(?,?);"</span>;</span><br><span class="line">* String sql =<span class="string">"SELECT * FROM test0120 where username=? and PASSWORD1=?;"</span>;</span><br><span class="line">*<span class="string">"方法中参数,SQL语句中的参数全部采用问号？占位符"</span></span><br><span class="line">* PreparedStatement预处理对象代码：</span><br><span class="line">* <span class="string">"PreparedStatement psmt = conn.prepareStatement(sql)"</span></span><br><span class="line"></span><br><span class="line">* b: 执行SQL语句的方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span></span>; --执行insert update delete语句.</span><br><span class="line">* <span class="function">ResultSet <span class="title">executeQuery</span><span class="params">()</span></span>; --执行select语句.</span><br><span class="line">* <span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span></span>; --执行select返回<span class="keyword">true</span> 执行其他的语句返回<span class="keyword">false</span>.</span><br><span class="line">* c: 设置实际参数</span><br><span class="line">* <span class="function"><span class="keyword">void</span> <span class="title">setXxx</span><span class="params">(<span class="keyword">int</span> index, Xxx xx)</span> &gt;&gt;&gt; <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(<span class="keyword">int</span> index, Object object)</span></span></span><br><span class="line"><span class="function">* 将指定参数设置为给定Java的xx值。在将此值发送到数据库时，驱动程序将它转换成一个 SQL Xxx类型值。</span></span><br><span class="line"><span class="function">* 例如：</span></span><br><span class="line"><span class="function">* <span class="title">setString</span><span class="params">(<span class="number">2</span>, <span class="string">"家用电器"</span>)</span> 把SQL语句中第2个位置的占位符？ 替换成实际参数 "家用电器"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* d: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Java程序实现用户登录,用户名和密码,数据库检查</span></span><br><span class="line"><span class="comment"> *  防止注入攻击</span></span><br><span class="line"><span class="comment"> *  Statement接口实现类,作用执行SQL语句,返回结果集</span></span><br><span class="line"><span class="comment"> *  有一个子接口PreparedStatement  (SQL预编译存储,多次高效的执行SQL) </span></span><br><span class="line"><span class="comment"> *  PreparedStatement的实现类数据库的驱动中,如何获取接口的实现类</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  是Connection数据库连接对象的方法</span></span><br><span class="line"><span class="comment"> *  PreparedStatement prepareStatement(String sql) </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String user = sc.nextLine();</span><br><span class="line">String pass = sc.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行SQL语句,数据表,查询用户名和密码,如果存在,登录成功,不存在登录失败</span></span><br><span class="line">String sql = <span class="string">"SELECT * FROM users WHERE username=? AND PASSWORD=?"</span>;</span><br><span class="line"><span class="comment">//调用Connection接口的方法prepareStatement,获取PrepareStatement接口的实现类</span></span><br><span class="line"><span class="comment">//方法中参数,SQL语句中的参数全部采用问号占位符</span></span><br><span class="line">PreparedStatement pst =  con.prepareStatement(sql);</span><br><span class="line">System.out.println(pst);</span><br><span class="line"><span class="comment">//调用pst对象set方法,设置问号占位符上的参数</span></span><br><span class="line">pst.setObject(<span class="number">1</span>, user);</span><br><span class="line">pst.setObject(<span class="number">2</span>, pass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法,执行SQL,获取结果集</span></span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">System.out.println(rs.getString(<span class="string">"username"</span>)+<span class="string">"   "</span>+rs.getString(<span class="string">"password"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">pst.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14PrepareStatement接口预编译SQL语句执行修改"><a href="#14PrepareStatement接口预编译SQL语句执行修改" class="headerlink" title="14PrepareStatement接口预编译SQL语句执行修改"></a>14PrepareStatement接口预编译SQL语句执行修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* A: PrepareStatement接口预编译SQL语句执行修改</span><br><span class="line">* 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用PrepareStatement接口,实现数据表的更新操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼写修改的SQL语句,参数采用?占位</span></span><br><span class="line">String sql = <span class="string">"UPDATE sort SET sname=?,sprice=? WHERE sid=?"</span>;</span><br><span class="line"><span class="comment">//调用数据库连接对象con的方法prepareStatement获取SQL语句的预编译对象</span></span><br><span class="line">PreparedStatement pst = con.prepareStatement(sql);</span><br><span class="line"><span class="comment">//调用pst的方法setXXX设置?占位</span></span><br><span class="line">pst.setObject(<span class="number">1</span>, <span class="string">"汽车美容"</span>);</span><br><span class="line">pst.setObject(<span class="number">2</span>, <span class="number">49988</span>);</span><br><span class="line">pst.setObject(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">//调用pst方法执行SQL语句</span></span><br><span class="line">pst.executeUpdate();</span><br><span class="line"></span><br><span class="line">pst.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15PrepareStatement接口预编译SQL语句执行查询"><a href="#15PrepareStatement接口预编译SQL语句执行查询" class="headerlink" title="15PrepareStatement接口预编译SQL语句执行查询"></a>15PrepareStatement接口预编译SQL语句执行查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* A: PrepareStatement接口预编译SQL语句执行查询</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  PrepareStatement接口实现数据表的查询操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"SELECT * FROM sort"</span>;</span><br><span class="line"></span><br><span class="line">PreparedStatement pst = con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用pst对象的方法,执行查询语句,Select</span></span><br><span class="line">ResultSet rs=pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">System.out.println(rs.getString(<span class="string">"sid"</span>)+<span class="string">"  "</span>+rs.getString(<span class="string">"sname"</span>)+<span class="string">"  "</span>+rs.getString(<span class="string">"sprice"</span>)+<span class="string">"  "</span>+rs.getString(<span class="string">"sdesc"</span>));</span><br><span class="line">&#125;</span><br><span class="line">rs.close();</span><br><span class="line">pst.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16JDBC的工具类和测试"><a href="#16JDBC的工具类和测试" class="headerlink" title="16JDBC的工具类和测试"></a>16JDBC的工具类和测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">* A: JDBC的工具类和测试</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">//JDBCUtils工具类代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">JDBCUtils</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection con ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3296/mybase"</span>;</span><br><span class="line">String username=<span class="string">"root"</span>;</span><br><span class="line">String password=<span class="string">"123"</span>;</span><br><span class="line">con = DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex+<span class="string">"数据库连接失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义静态方法,返回数据库的连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con,Statement stat)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(stat!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> stat.close();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(SQLException ex)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> con.close();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(SQLException ex)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection con,Statement stat , ResultSet rs)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> rs.close();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(SQLException ex)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(stat!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> stat.close();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(SQLException ex)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> con.close();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(SQLException ex)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试JDBCUtils工具类的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBCUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Connection con = JDBCUtils.getConnection();</span><br><span class="line">PreparedStatement pst = con.prepareStatement(<span class="string">"SELECT sname FROM sort"</span>);</span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">System.out.println(rs.getString(<span class="string">"sname"</span>));</span><br><span class="line">&#125;</span><br><span class="line">JDBCUtils.close(con, pst, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17数据表数据存储对象"><a href="#17数据表数据存储对象" class="headerlink" title="17数据表数据存储对象"></a>17数据表数据存储对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">* A: 数据表数据存储对象</span><br><span class="line">* a: 准备工作</span><br><span class="line">* 导入jar包</span><br><span class="line">* 拷贝day32定义的工具类JDBCUtils</span><br><span class="line"></span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="comment">//定义实体类Sort</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sid;</span><br><span class="line"><span class="keyword">private</span> String sname;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> sprice;</span><br><span class="line"><span class="keyword">private</span> String sdesc;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> sid, String sname, <span class="keyword">double</span> sprice, String sdesc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sid = sid;</span><br><span class="line"><span class="keyword">this</span>.sname = sname;</span><br><span class="line"><span class="keyword">this</span>.sprice = sprice;</span><br><span class="line"><span class="keyword">this</span>.sdesc = sdesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSid</span><span class="params">(<span class="keyword">int</span> sid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sid = sid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sname = sname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSprice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sprice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSprice</span><span class="params">(<span class="keyword">double</span> sprice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sprice = sprice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSdesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sdesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSdesc</span><span class="params">(String sdesc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sdesc = sdesc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Sort [sid="</span> + sid + <span class="string">", sname="</span> + sname + <span class="string">", sprice="</span> + sprice + <span class="string">", sdesc="</span> + sdesc + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  JDBC读取数据表sort,每行数据封装到Sort类的对象中</span></span><br><span class="line"><span class="comment"> *  很多个Sort类对象,存储到List集合中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//使用JDBC工具类,直接获取数据库连接对象</span></span><br><span class="line">Connection con = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">//连接获取数据库SQL语句执行者对象</span></span><br><span class="line">PreparedStatement pst = con.prepareStatement(<span class="string">"SELECT * FROM sort"</span>);</span><br><span class="line"><span class="comment">//调用查询方法,获取结果集</span></span><br><span class="line">ResultSet rs = pst.executeQuery();</span><br><span class="line"><span class="comment">//创建集合对象</span></span><br><span class="line">List&lt;Sort&gt; list = <span class="keyword">new</span> ArrayList&lt;Sort&gt;();</span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"><span class="comment">//获取到每个列数据,封装到Sort对象中</span></span><br><span class="line">Sort s = <span class="keyword">new</span> Sort(rs.getInt(<span class="string">"sid"</span>),rs.getString(<span class="string">"sname"</span>),rs.getDouble(<span class="string">"sprice"</span>),rs.getString(<span class="string">"sdesc"</span>));</span><br><span class="line"><span class="comment">//封装的Sort对象,存储到集合中</span></span><br><span class="line">list.add(s);</span><br><span class="line">&#125;</span><br><span class="line">JDBCUtils.close(con, pst, rs);</span><br><span class="line"><span class="comment">//遍历List集合</span></span><br><span class="line"><span class="keyword">for</span>(Sort s : list)&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18properties配置文件"><a href="#18properties配置文件" class="headerlink" title="18properties配置文件"></a>18properties配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A: properties配置文件</span><br><span class="line">* a: 相关介绍</span><br><span class="line">* 开发中获得连接的<span class="number">4</span>个参数（驱动、URL、用户名、密码）通常都存在配置文件中，<span class="string">"方便后期维护"</span>，程序如果需要更换数据库，</span><br><span class="line">只需要修改配置文件即可。</span><br><span class="line">* 通常情况下，我们习惯使用<span class="string">"properties文件"</span>，此文件我们将做如下要求：</span><br><span class="line"><span class="number">1</span>.文件位置：任意，<span class="string">"建议src下"</span></span><br><span class="line"><span class="number">2</span>.文件名称：任意，<span class="string">"扩展名为properties"</span></span><br><span class="line"><span class="number">3</span>.文件内容：一行一组数据，<span class="string">"格式是“key=value”"</span>.</span><br><span class="line">a)key命名自定义，<span class="string">"如果是多个单词，习惯使用点分隔。例如：jdbc.driver"</span></span><br><span class="line">b)value值不支持中文，如果<span class="string">"需要使用非英文字符"</span>，<span class="string">"将进行unicode转换。"</span></span><br></pre></td></tr></table></figure><h3 id="19properties文件的创建和编写"><a href="#19properties文件的创建和编写" class="headerlink" title="19properties文件的创建和编写"></a>19properties文件的创建和编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* A: properties文件的创建和编写</span><br><span class="line">* a: properties文件的创建</span><br><span class="line">* src路径下建立database.properties(其实就是一个文本文件)</span><br><span class="line">* b: properties文件的编写(内容如下)</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3296/mybase</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="20加载配置文件-使用类的加载器"><a href="#20加载配置文件-使用类的加载器" class="headerlink" title="20加载配置文件(使用类的加载器)"></a>20加载配置文件(使用类的加载器)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* A: 加载配置文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  加载properties配置文件</span></span><br><span class="line"><span class="comment"> *  IO读取文件,键值对存储到集合</span></span><br><span class="line"><span class="comment"> *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="string">"//使用类的加载器</span></span><br><span class="line"><span class="string">InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream("</span>database.properties<span class="string">");"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"从用来加载类的搜索路径中打开具有指定名称的资源，以读取该资源。"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"database.properties"</span>);</span><br><span class="line">System.out.println(fis);</span><br><span class="line"><span class="string">"//使用类的加载器"</span></span><br><span class="line">InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(<span class="string">"database.properties"</span>);</span><br><span class="line">System.out.println(in);</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">pro.load(in);</span><br><span class="line">System.out.println(in);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21通过配置文件连接数据库"><a href="#21通过配置文件连接数据库" class="headerlink" title="21通过配置文件连接数据库"></a>21通过配置文件连接数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* A: 通过配置文件连接数据库</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  加载properties配置文件</span></span><br><span class="line"><span class="comment"> *  IO读取文件,键值对存储到集合</span></span><br><span class="line"><span class="comment"> *  从集合中以键值对方式获取数据库的连接信息,完成数据库的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"database.properties"</span>);</span><br><span class="line">System.out.println(fis);</span><br><span class="line"><span class="comment">//使用类的加载器</span></span><br><span class="line">InputStream in = PropertiesDemo.class.getClassLoader().getResourceAsStream(<span class="string">"database.properties"</span>);</span><br><span class="line">System.out.println(in);</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">pro.load(in);</span><br><span class="line"><span class="comment">//获取集合中的键值对</span></span><br><span class="line">String driverClass=pro.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">String url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">String username = pro.getProperty(<span class="string">"username"</span>);</span><br><span class="line">String password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line">Connection con = DriverManager.getConnection(url, username, password);</span><br><span class="line">System.out.println(con);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22读取配置文件的工具类"><a href="#22读取配置文件的工具类" class="headerlink" title="22读取配置文件的工具类"></a>22读取配置文件的工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* A: 读取配置文件的工具类</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  编写数据库连接的工具类,JDBC工具类</span></span><br><span class="line"><span class="comment"> *  获取连接对象采用读取配置文件方式</span></span><br><span class="line"><span class="comment"> *  读取文件获取连接,执行一次,static&#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtilsConfig</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection con ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">readConfig();</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line">con = DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据库连接失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">InputStream in = JDBCUtilsConfig.class.getClassLoader().getResourceAsStream(<span class="string">"database.properties"</span>);</span><br><span class="line"> Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"> pro.load(in);</span><br><span class="line"> driverClass=pro.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"> url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line"> username = pro.getProperty(<span class="string">"username"</span>);</span><br><span class="line"> password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23测试工具类"><a href="#23测试工具类" class="headerlink" title="23测试工具类"></a>23测试工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* A: 测试工具类</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBCUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Connection con = JDBCUtilsConfig.getConnection();</span><br><span class="line">System.out.println(con);</span><br><span class="line">String sql = <span class="string">"select * from supermaket;"</span>;</span><br><span class="line">        PreparedStatement pstat = con.prepareStatement(sql);</span><br><span class="line">        ResultSet rs = pstat.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(rs.getObject(<span class="string">"id"</span>)+<span class="string">"     "</span>+</span><br><span class="line">                    rs.getObject(<span class="string">"sname"</span>)+<span class="string">"     "</span>+</span><br><span class="line">                    rs.getObject(<span class="string">"sprice"</span>)+<span class="string">"     "</span>+</span><br><span class="line">                    rs.getObject(<span class="string">"smessage"</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        con.close();</span><br><span class="line">        pstat.close();</span><br><span class="line">        rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24总结"><a href="#24总结" class="headerlink" title="24总结"></a>24总结</h3><ul><li>把今天的知识点总结一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297625/samples/java%20files/photo-1546868871-08b8ebc35c09.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、JDBC&lt;br&gt;2、DBUtils&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础26(MySQL数据库,SQL语句)</title>
    <link href="https://leesen998.github.io/2016/11/27/day28%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/27/day28笔记/</id>
    <published>2016-11-27T11:48:29.000Z</published>
    <updated>2019-01-19T14:23:47.002Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297629/samples/java%20files/photo-1544729812-46958d74295c.jpg" alt="" style="width:100%"></p><p>1.MySQL数据库<br>2.SQL语句</p><a id="more"></a>    <h3 id="01数据库概念"><a href="#01数据库概念" class="headerlink" title="01数据库概念"></a>01数据库概念</h3><ul><li>A: 什么是数据库<br><strong>数据库</strong>就是存储数据的仓库，其<strong>本质是一个文件系统</strong>，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行<strong>增加，修改，删除及查询操作</strong>。</li><li>B: 什么是数据库管理系统<br><strong>数据库管理系统</strong>（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，<br>对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。</li></ul><h3 id="02常见的数据库"><a href="#02常见的数据库" class="headerlink" title="02常见的数据库"></a>02常见的数据库</h3><ul><li>A: 常见的数据库<br>MYSQL    ：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。<br>Oracle    ：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。<br>DB2        ：IBM公司的数据库产品,收费的。常应用在银行系统中.<br>SQLServer：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。<br>SyBase    ：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。<br>SQLite    : 嵌入式的小型数据库，应用在手机端。<br>Java相关的数据库：MYSQL，Oracle．<br>这里使用MySQL数据库。MySQL中可以有多个数据库，数据库是真正存储数据的地方</li></ul><h3 id="03数据库和管理系统"><a href="#03数据库和管理系统" class="headerlink" title="03数据库和管理系统"></a>03数据库和管理系统</h3><pre><code>* A: 数据库管理系统</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----数据库<span class="number">1</span></span><br><span class="line">----数据表<span class="number">1</span>a</span><br><span class="line">----数据表<span class="number">1</span>b</span><br><span class="line">----数据库<span class="number">2</span></span><br><span class="line">-----数据表<span class="number">2</span>a</span><br><span class="line">-----数据表<span class="number">2</span>b</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547815964/samples/java%20files/001km.png" alt=""></p><h3 id="04数据表和Java中类的对应关系"><a href="#04数据表和Java中类的对应关系" class="headerlink" title="04数据表和Java中类的对应关系"></a>04数据表和Java中类的对应关系</h3><pre><code>* A:数据库中以表为组织单位存储数据。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表类似我们的Java类，每个字段都有对应的数据类型。</span><br><span class="line">那么用我们熟悉的java程序来与关系型数据对比，就会发现以下对应关系。</span><br><span class="line"><span class="string">"类"</span>----------<span class="string">"表"</span></span><br><span class="line"><span class="string">"类中属性"</span>----------<span class="string">"表中字段"</span></span><br><span class="line"><span class="string">"对象"</span>----------<span class="string">"表中每条记录"</span></span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547816160/samples/java%20files/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A1%A8.jpg" alt=""></p><h3 id="05数据表和Java中类的对应关系用户表举例"><a href="#05数据表和Java中类的对应关系用户表举例" class="headerlink" title="05数据表和Java中类的对应关系用户表举例"></a>05数据表和Java中类的对应关系用户表举例</h3><pre><code>* A:举例:账务表id        name        age    1        lisi        232        wang        24每一条记录对应一个User的对象[user1  id = 1 name = lisi  age = 23][user2    id = 2 name = wang    age = 24]</code></pre><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547816429/samples/java%20files/fgfg.png" alt=""></p><h3 id="06MySQL数据库安装"><a href="#06MySQL数据库安装" class="headerlink" title="06MySQL数据库安装"></a>06MySQL数据库安装</h3><p>A: 安装步骤参见 day28_source《MySQL安装图解.doc》<br>B: 安装后，MySQL会以windows服务的方式为我们提供数据存储功能。开启和关闭服务的操作：<strong>右键点击我的电脑→管理→服务→可以找到MySQL服务开启或停止。</strong></p><h3 id="07数据库在系统服务"><a href="#07数据库在系统服务" class="headerlink" title="07数据库在系统服务"></a>07数据库在系统服务</h3><ul><li>A：开启服务和关闭服务<br>方式1: 我的电脑—–&gt; (右键)管理—-&gt;服务和应用程序—-&gt;服务—-找到MySQL服务右键启动或关闭<br>方式2: <strong>进入dos窗口 使用命令: net start mysql 开启MySQL服务;  命令:net stop mysql 关闭MySql服务</strong></li></ul><h3 id="08MySQL的登录"><a href="#08MySQL的登录" class="headerlink" title="08MySQL的登录"></a>08MySQL的登录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* A: MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录。</span><br><span class="line">格式<span class="number">1</span>：cmd&gt;  mysql –u用户名 –p密码</span><br><span class="line">例如：mysql -uroot –proot</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>：cmd&gt;  mysql --host=ip地址 --user=用户名 --password=密码</span><br><span class="line">例如：mysql --host=<span class="number">127.0</span>.0.1  --user=root --password=root</span><br></pre></td></tr></table></figure><h3 id="09SQLYog软件介绍"><a href="#09SQLYog软件介绍" class="headerlink" title="09SQLYog软件介绍"></a>09SQLYog软件介绍</h3><pre><code>* A: 具体参见 《SQLYog配置.doc》</code></pre><h3 id="10SQL语句介绍和分类"><a href="#10SQL语句介绍和分类" class="headerlink" title="10SQL语句介绍和分类"></a>10SQL语句介绍和分类</h3><ul><li>A:SQL介绍</li><li>前面学习了接口的代码体现，现在来学习接口的思想，接下里从生活中的例子进行说明。</li><li>举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？</li><li>主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。</li></ul><p><strong>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。<br>创建数据库、创建数据表、向数据表中添加一条条数据信息均需要使用SQL语句</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* B: SQL分类</span><br><span class="line">* 数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等 </span><br><span class="line">* <span class="string">"数据操作语言：简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。关键字：insert，delete，update等"</span></span><br><span class="line">* 数据控制语言：简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，及创建用户。</span><br><span class="line">* <span class="string">"数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等"</span></span><br><span class="line"></span><br><span class="line">* C: SQL通用语法</span><br><span class="line"><span class="string">"SQL语句可以单行或多行书写，以分号结尾"</span></span><br><span class="line">可使用空格和缩进来增强语句的可读性</span><br><span class="line">MySQL数据库的SQL语句<span class="string">"不区分大小写"</span>，<span class="string">"建议关键字使用大写"</span>，例如：SELECT * FROM user。</span><br><span class="line">同样可以<span class="string">"使用/**/的方式完成注释"</span></span><br></pre></td></tr></table></figure><h3 id="11数据表中的数据类型"><a href="#11数据表中的数据类型" class="headerlink" title="11数据表中的数据类型"></a>11数据表中的数据类型</h3><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547820640/samples/java%20files/hdfgg.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* A:MySQL中的我们常使用的数据类型如下 </span><br><span class="line">详细的数据类型如下(不建议详细阅读！)</span><br><span class="line">分类类型名称 说明 </span><br><span class="line">整数类型tinyInt很小的整数</span><br><span class="line">smallint小的整数</span><br><span class="line">mediumint中等大小的整数</span><br><span class="line"><span class="keyword">int</span>(integer)普通大小的整数</span><br><span class="line">小数类型<span class="keyword">float</span>单精度浮点数</span><br><span class="line"><span class="keyword">double</span>双精度浮点数</span><br><span class="line">decimal（m,d）压缩严格的定点数</span><br><span class="line">日期类型yearYYYY  <span class="number">1901</span>~<span class="number">2155</span></span><br><span class="line">timeHH:MM:SS  -<span class="number">838</span>:<span class="number">59</span>:<span class="number">59</span>~<span class="number">838</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">dateYYYY-MM-DD <span class="number">1000</span>-<span class="number">01</span>-<span class="number">01</span>~<span class="number">9999</span>-<span class="number">12</span>-<span class="number">3</span></span><br><span class="line">datetime YYYY-MM-DD HH:MM:SS <span class="number">1000</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>~ <span class="number">9999</span>-<span class="number">12</span>-<span class="number">31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">timestampYYYY-MM-DD HH:MM:SS  <span class="number">1970</span>~<span class="number">01</span>~<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> UTC~<span class="number">2038</span>-<span class="number">01</span>-<span class="number">19</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07</span>UTC</span><br><span class="line">文本、二进制类型CHAR(M)M为<span class="number">0</span>~<span class="number">255</span>之间的整数</span><br><span class="line">VARCHAR(M)M为<span class="number">0</span>~<span class="number">65535</span>之间的整数</span><br><span class="line">TINYBLOB允许长度<span class="number">0</span>~<span class="number">255</span>字节</span><br><span class="line">BLOB允许长度<span class="number">0</span>~<span class="number">65535</span>字节</span><br><span class="line">MEDIUMBLOB允许长度<span class="number">0</span>~<span class="number">167772150</span>字节</span><br><span class="line">LONGBLOB允许长度<span class="number">0</span>~<span class="number">4294967295</span>字节</span><br><span class="line">TINYTEXT允许长度<span class="number">0</span>~<span class="number">255</span>字节</span><br><span class="line">TEXT允许长度<span class="number">0</span>~<span class="number">65535</span>字节</span><br><span class="line">MEDIUMTEXT允许长度<span class="number">0</span>~<span class="number">167772150</span>字节</span><br><span class="line">LONGTEXT允许长度<span class="number">0</span>~<span class="number">4294967295</span>字节</span><br><span class="line">VARBINARY(M)允许长度<span class="number">0</span>~M个字节的变长字节字符串</span><br><span class="line">BINARY(M)允许长度<span class="number">0</span>~M个字节的定长字节字符串</span><br></pre></td></tr></table></figure></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547820640/samples/java%20files/hgdfgfg.png" alt=""></p><h3 id="12创建数据库操作"><a href="#12创建数据库操作" class="headerlink" title="12创建数据库操作"></a>12创建数据库操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建数据库                                                                                                                                                                                                                                                                                    </span><br><span class="line">格式:</span><br><span class="line">* create database 数据库名;</span><br><span class="line">* create database 数据库名 character set 字符集;</span><br><span class="line">例如：</span><br><span class="line">#创建数据库 数据库中数据的编码采用的是安装数据库时指定的默认编码 utf8</span><br><span class="line">CREATE DATABASE day21_1; </span><br><span class="line">#创建数据库 并指定数据库中数据的编码</span><br><span class="line">CREATE DATABASE day21_2 CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">* B: 查看数据库</span><br><span class="line">查看数据库MySQL服务器中的所有的数据库:</span><br><span class="line">show databases;</span><br><span class="line">查看某个数据库的定义的信息:</span><br><span class="line">show create database 数据库名;</span><br><span class="line">例如：</span><br><span class="line">show create database day21_1;</span><br><span class="line"></span><br><span class="line">* C: 删除数据库</span><br><span class="line">drop database 数据库名称;</span><br><span class="line">例如：</span><br><span class="line">drop database day21_2;</span><br><span class="line"></span><br><span class="line">* D: 其他的数据库操作命令</span><br><span class="line">切换数据库：</span><br><span class="line">use 数据库名;</span><br><span class="line">例如：</span><br><span class="line">use day21_1;</span><br><span class="line"></span><br><span class="line">* E: 查看正在使用的数据库:</span><br><span class="line"><span class="function">select <span class="title">database</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="13创建数据表格式"><a href="#13创建数据表格式" class="headerlink" title="13创建数据表格式"></a>13创建数据表格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* A:格式：</span><br><span class="line">create table 表名(</span><br><span class="line">   字段名 类型(长度) 约束,</span><br><span class="line">   字段名 类型(长度) 约束</span><br><span class="line">);</span><br><span class="line">例如：</span><br><span class="line">###创建分类表</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">sort</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  sid INT, #分类ID </span></span></span><br><span class="line"><span class="function"><span class="params">  sname VARCHAR(<span class="number">100</span>)</span> #分类名称</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><h3 id="14约束"><a href="#14约束" class="headerlink" title="14约束"></a>14约束</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* A: 约束的作用:                                                                                            <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">create table 表名<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   列名 类型(长度)</span> 约束,</span></span><br><span class="line"><span class="function">   列名 类型<span class="params">(长度)</span> 约束</span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line">限制每一列能写什么数据,不能写什么数据。</span><br><span class="line"></span><br><span class="line">* B: 哪些约束:</span><br><span class="line">主键约束</span><br><span class="line">非空约束</span><br><span class="line">唯一约束</span><br><span class="line">外键约束</span><br><span class="line">格式：</span><br><span class="line"><span class="number">1</span>.在创建表时创建主键，在字段后面加上  primary key.</span><br><span class="line"><span class="function">create table <span class="title">tablename</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span> primary key,</span></span></span><br><span class="line"><span class="function"><span class="params">.......</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2. 在创建表时创建主键，在表创建的最后来指定主键</span></span><br><span class="line"><span class="function">create table <span class="title">tablename</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">.......，</span></span></span><br><span class="line"><span class="function"><span class="params">primary key(id)</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3.删除主键：alter table 表名 drop primary key</span>;</span><br><span class="line">  alter table sort drop primary key;</span><br><span class="line"><span class="number">4</span>.主键自动增长：一般主键是自增长的字段，不需要指定。</span><br><span class="line">实现添加自增长语句,主键字段后加auto_increment(只适用MySQL)</span><br><span class="line">例如：</span><br><span class="line">###创建分类表</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">sort</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  sid INT PRIMARY KEY auto_increment, #分类ID </span></span></span><br><span class="line"><span class="function"><span class="params">  sname VARCHAR(<span class="number">100</span>)</span> #分类名称</span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><h3 id="15SQL代码的保存"><a href="#15SQL代码的保存" class="headerlink" title="15SQL代码的保存"></a>15SQL代码的保存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* A: 当sql语句执行了，就已经对数据库进行操作了，一般不用保存操作</span><br><span class="line">在SQLyog 中Ctrl + S 保存的是写sql语句。</span><br></pre></td></tr></table></figure><h3 id="16创建用户表"><a href="#16创建用户表" class="headerlink" title="16创建用户表"></a>16创建用户表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* A: 创建用户表:</span><br><span class="line">需求:创建用户表,用户编号,姓名,用户的地址</span><br><span class="line"></span><br><span class="line">* B: SQL语句</span><br><span class="line"><span class="function">CREAT TABLE <span class="title">users</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">uid INT,</span></span></span><br><span class="line"><span class="function"><span class="params">uname VARCHAR(<span class="number">20</span>)</span>,</span></span><br><span class="line"><span class="function">uaddress <span class="title">VARCHAR</span><span class="params">(<span class="number">200</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure><h3 id="17主键约束"><a href="#17主键约束" class="headerlink" title="17主键约束"></a>17主键约束</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* A: 主键是用于标识当前记录的字段。它的特点是非空，唯一。</span><br><span class="line">在开发中一般情况下主键是不具备任何含义，只是用于标识当前记录。</span><br><span class="line">* B: 格式：</span><br><span class="line"><span class="number">1</span>.在创建表时创建主键，在字段后面加上  primary key.</span><br><span class="line"><span class="function">create table <span class="title">tablename</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span> primary key,</span></span></span><br><span class="line"><span class="function"><span class="params">.......</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2. 在创建表时创建主键，在表创建的最后来指定主键</span></span><br><span class="line"><span class="function">create table <span class="title">tablename</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">id <span class="keyword">int</span>，</span></span></span><br><span class="line"><span class="function"><span class="params">.......，</span></span></span><br><span class="line"><span class="function"><span class="params">primary key(id)</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3.删除主键：alter table 表名 drop primary key</span>;</span><br><span class="line">alter table sort drop primary key;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.<span class="string">"主键自动增长"</span>：一般主键是<span class="string">"自增长的字段"</span>，不需要指定。</span><br><span class="line"><span class="string">"实现添加自增长语句,主键字段后加auto_increment(只适用MySQL)"</span></span><br></pre></td></tr></table></figure><h3 id="18常见表的操作"><a href="#18常见表的操作" class="headerlink" title="18常见表的操作"></a>18常见表的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A:<span class="string">"查看表"</span>:<span class="string">"查看数据库中的所有表"</span>：</span><br><span class="line"><span class="string">"格式：show tables;"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"查看表结构"</span>：</span><br><span class="line">格式：desc 表名;</span><br><span class="line">例如：desc sort;</span><br><span class="line"></span><br><span class="line">* B:<span class="string">"删除表"</span> </span><br><span class="line">* <span class="string">"格式：drop table 表名;"</span></span><br><span class="line">例如：drop table sort;</span><br></pre></td></tr></table></figure><h3 id="19修改表结构"><a href="#19修改表结构" class="headerlink" title="19修改表结构"></a>19修改表结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="string">"修改表添加列"</span></span><br><span class="line"><span class="string">"alter table 表名 add 列名 类型(长度) 约束;"</span></span><br><span class="line">例如：</span><br><span class="line">#1，为分类表添加一个新的字段为 分类描述 varchar(20)</span><br><span class="line"><span class="function">ALTER TABLE sort ADD sdesc <span class="title">VARCHAR</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">* B: <span class="string">"修改表修改列的类型长度及约束"</span></span><br><span class="line"><span class="string">"alter table 表名 modify 列名 类型(长度) 约束; "</span></span><br><span class="line">例如：</span><br><span class="line">#2, 为分类表的分类名称字段进行修改，类型varchar(50) 添加约束 not null</span><br><span class="line"><span class="function">ALTER TABLE sort MODIFY sname <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span> NOT NULL</span>;</span><br><span class="line"></span><br><span class="line">* C: <span class="string">"修改表修改列名"</span></span><br><span class="line"><span class="string">"alter table 表名 change 旧列名 新列名 类型(长度) 约束; "</span></span><br><span class="line">例如：</span><br><span class="line">#3, 为分类表的分类名称字段进行更换 更换为 snamesname varchar(30)</span><br><span class="line"><span class="function">ALTER TABLE sort CHANGE sname snamename <span class="title">VARCHAR</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">* D: <span class="string">"修改表删除列"</span></span><br><span class="line"><span class="string">"alter table 表名 drop 列名;"</span></span><br><span class="line">例如：</span><br><span class="line">#4, 删除分类表中snamename这列</span><br><span class="line">ALTER TABLE sort DROP snamename;</span><br><span class="line"></span><br><span class="line">* E: <span class="string">"修改表名"</span></span><br><span class="line"><span class="string">"rename table 表名 to 新表名; "</span></span><br><span class="line">例如：</span><br><span class="line">#5, 为分类表sort 改名成 category</span><br><span class="line">RENAME TABLE sort TO category;</span><br><span class="line"></span><br><span class="line">* F: <span class="string">"修改表的字符集"</span></span><br><span class="line"><span class="string">"salter table 表名 character set 字符集;"</span></span><br><span class="line">例如：</span><br><span class="line">#6, 为分类表 category 的编码表进行修改，修改成 gbk</span><br><span class="line">ALTER TABLE category CHARACTER SET gbk;</span><br></pre></td></tr></table></figure><h3 id="20数据表添加数据-1"><a href="#20数据表添加数据-1" class="headerlink" title="20数据表添加数据_1"></a>20数据表添加数据_1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A:  -- <span class="string">"向表中插入某些列"</span></span><br><span class="line">* 语法：</span><br><span class="line">insert into 表 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3</span>..) values  (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>..);</span><br><span class="line"></span><br><span class="line">* 举例:</span><br><span class="line"><span class="function">INSERT INTO <span class="title">product</span> <span class="params">(id,pname,price)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">1</span>,<span class="string">'笔记本'</span>,<span class="number">5555.99</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT INTO <span class="title">product</span> <span class="params">(id,pname,price)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">2</span>,<span class="string">'智能手机'</span>,<span class="number">9999</span>)</span></span>;</span><br><span class="line">* 注意:</span><br><span class="line">列表,表名问题</span><br><span class="line">对应问题,个数,数据类型</span><br></pre></td></tr></table></figure><h3 id="21数据表添加数据-2"><a href="#21数据表添加数据-2" class="headerlink" title="21数据表添加数据_2"></a>21数据表添加数据_2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="string">"添加数据格式,不考虑主键"</span></span><br><span class="line">insert into 表名 (列名) values (值)</span><br><span class="line">* 举例:</span><br><span class="line"><span class="function">INSERT INTO <span class="title">product</span> <span class="params">(pname,price)</span> <span class="title">VALUE</span><span class="params">(<span class="string">'洗衣机'</span>,<span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* B: <span class="string">"添加数据格式,所有值全给出"</span></span><br><span class="line">格式</span><br><span class="line">insert into 表名 values (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>..); --向表中插入所有列</span><br><span class="line"><span class="function">INSERT INOT product <span class="title">VALUES</span> <span class="params">(<span class="number">4</span>,<span class="string">'微波炉'</span>,<span class="number">300.25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">* C: <span class="string">"添加数据格式,批量写入"</span></span><br><span class="line">格式:</span><br><span class="line">insert into 表名 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3</span>) values (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>),(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>)</span><br><span class="line">举例:</span><br><span class="line"><span class="function">INSERT INTO <span class="title">product</span> <span class="params">(pname,price)</span> VALUES</span></span><br><span class="line"><span class="function"><span class="params">(<span class="string">'智能机器人'</span>,<span class="number">25999.22</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="params">(<span class="string">'彩色电视'</span>,<span class="number">1250.36</span>)</span>,</span></span><br><span class="line"><span class="function"><span class="params">(<span class="string">'沙发'</span>,<span class="number">58899.02</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="22更新数据"><a href="#22更新数据" class="headerlink" title="22更新数据"></a>22更新数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="string">"用来修改指定条件的数据，将满足条件的记录指定列修改为指定值"</span></span><br><span class="line">语法：</span><br><span class="line"><span class="string">"update 表名 set 字段名=值,字段名=值;"</span></span><br><span class="line"><span class="string">"update 表名 set 字段名=值,字段名=值 where 条件;"</span></span><br><span class="line">* B: 注意：</span><br><span class="line">* <span class="string">"</span></span><br><span class="line"><span class="string">列名的类型与修改的值要一致.</span></span><br><span class="line"><span class="string">修改值得时候不能超过最大长度.</span></span><br><span class="line"><span class="string">值如果是字符串或者日期需要加’’.</span></span><br><span class="line"><span class="string">  "</span></span><br><span class="line"></span><br><span class="line">* C: 例如：</span><br><span class="line">#1，将指定的sname字段中的值 修改成 日用品</span><br><span class="line">UPDATE sort SET sname=<span class="string">'日用品'</span>;</span><br><span class="line">#2, 将sid为s002的记录中的sname改成 日用品</span><br><span class="line">UPDATE sort SET sname=<span class="string">'日用品'</span> WHERE sid=<span class="string">'s002'</span>;</span><br><span class="line">UPDATE sort SET sname=<span class="string">'日用品'</span> WHERE sid=<span class="string">'s003'</span>;</span><br><span class="line"></span><br><span class="line">update users set username=<span class="string">'欧珀手机 R19'</span>,userprice=<span class="number">5612</span> where userid =<span class="number">3</span>;</span><br><span class="line"><span class="string">"修改2行"</span>：</span><br><span class="line">update users set username=<span class="string">'欧珀手机 R19'</span>,userprice=<span class="number">5612</span> where userid =<span class="number">3</span> or userid=<span class="number">6</span>;</span><br><span class="line"><span class="string">"修改多行"</span>：</span><br><span class="line">update users set username=<span class="string">'欧珀手机 R19'</span>,userprice=<span class="number">8888</span> <span class="function">where userid <span class="title">in</span> <span class="params">(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">与 AND</span><br><span class="line">或 OR</span><br><span class="line">非 NOT</span><br><span class="line">等于 =</span><br><span class="line">不等于 &lt;&gt;</span><br><span class="line">小于等于 &lt;= </span><br><span class="line"><span class="function">where userid <span class="title">in</span> <span class="params">(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>)</span> 表示<span class="params">()</span>里的数据都采用</span></span><br></pre></td></tr></table></figure><h3 id="23删除数据"><a href="#23删除数据" class="headerlink" title="23删除数据"></a>23删除数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* A: 语法：</span><br><span class="line"><span class="number">1</span>、<span class="string">"delete from 表名 where 条件;"</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="string">"truncate table 表名;"</span></span><br><span class="line"></span><br><span class="line"> * B: 面试题：</span><br><span class="line">删除表中所有记录使用delete from 表名; 还是用truncate table 表名;</span><br><span class="line"><span class="string">"删除方式：delete 一条一条删除，不清空auto_increment记录数。"</span></span><br><span class="line"></span><br><span class="line"><span class="string">" truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。"</span></span><br><span class="line"></span><br><span class="line"> * C: 例如：</span><br><span class="line">DELETE FROM sort WHERE sname=<span class="string">'日用品'</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">"#表数据清空"</span></span><br><span class="line">DELETE FROM sort;</span><br></pre></td></tr></table></figure><h3 id="24命令行乱码问题"><a href="#24命令行乱码问题" class="headerlink" title="24命令行乱码问题"></a>24命令行乱码问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: 问题</span><br><span class="line">我们在dos命令行操作中文时，会报错</span><br><span class="line"><span class="function">insert into <span class="title">user</span><span class="params">(username,password)</span> <span class="title">values</span><span class="params">(‘张三’,’<span class="number">123</span>’)</span></span>;</span><br><span class="line">ERROR <span class="number">1366</span> (HY000): Incorrect string value: <span class="string">'\xD5\xC5\xC8\xFD'</span> <span class="keyword">for</span> column <span class="string">'username'</span> at row <span class="number">1</span></span><br><span class="line">B: 原因:因为mysql的客户端编码的问题我们的是utf8,而系统的cmd窗口编码是gbk</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、解决方案（临时解决方案）:修改mysql客户端编码。</span><br><span class="line">show variables like <span class="string">'character%'</span>; 查看所有mysql的编码</span><br><span class="line">client connetion result 和客户端相关</span><br><span class="line">database server system 和服务器端相关 </span><br><span class="line"><span class="string">"将客户端编码修改为gbk"</span>.</span><br><span class="line"><span class="string">"set character_set_results=gbk; / set names gbk;"</span></span><br><span class="line">以上操作，<span class="string">"只针对当前窗口有效果"</span>，如果关闭了服务器便失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果想要永久修改，通过以下方式:</span><br><span class="line"><span class="string">"在mysql安装目录下有my.ini文件"</span></span><br><span class="line"><span class="string">"default-character-set=gbk 客户端编码设置"</span></span><br><span class="line"><span class="string">"character-set-server=utf8 服务器端编码设置"</span></span><br><span class="line">注意:修改完成配置文件，重启服务</span><br></pre></td></tr></table></figure><h3 id="25数据表和测试数据准备"><a href="#25数据表和测试数据准备" class="headerlink" title="25数据表和测试数据准备"></a>25数据表和测试数据准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* A: 查询语句，在开发中使用的次数最多，此处使用“zhangwu” 账务表。</span><br><span class="line">创建账务表：</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">zhangwu</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  id INT PRIMARY KEY AUTO_INCREMENT, -- 账务ID</span></span></span><br><span class="line"><span class="function"><span class="params">  zname VARCHAR(<span class="number">200</span>)</span>, -- 账务名称</span></span><br><span class="line"><span class="function">  zmoney DOUBLE -- 金额</span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line">* B: 插入表记录：</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">1</span>,<span class="string">'吃饭支出'</span>,<span class="number">247</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">2</span>,<span class="string">'工资收入'</span>,<span class="number">12345</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">3</span>,<span class="string">'服装支出'</span>,<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">4</span>,<span class="string">'吃饭支出'</span>,<span class="number">325</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">5</span>,<span class="string">'股票收入'</span>,<span class="number">8000</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">6</span>,<span class="string">'打麻将支出'</span>,<span class="number">8000</span>)</span></span>;</span><br><span class="line"><span class="function">INSERT  INTO <span class="title">zhangwu</span><span class="params">(id,name,money)</span> <span class="title">VALUES</span> <span class="params">(<span class="number">7</span>,<span class="keyword">null</span>,<span class="number">5000</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="26数据的基本查询"><a href="#26数据的基本查询" class="headerlink" title="26数据的基本查询"></a>26数据的基本查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="string">"查询指定字段信息"</span></span><br><span class="line"><span class="string">"select 字段1,字段2,...from 表名;"</span></span><br><span class="line">例如：</span><br><span class="line">select id,name from zhangwu;</span><br><span class="line"></span><br><span class="line">* B: <span class="string">"查询表中所有字段"</span></span><br><span class="line"><span class="string">"select * from 表名; "</span></span><br><span class="line">例如：</span><br><span class="line">select * from zhangwu; </span><br><span class="line">注意:使用<span class="string">"*"</span>在练习、学习过程中可以使用，<span class="string">"在实际开发中，不推荐使用"</span>。</span><br><span class="line">原因，要查询的字段信息不明确，若字段数量很多，会导致查询速度很慢。</span><br><span class="line"></span><br><span class="line">* C: <span class="string">"distinct用于去除重复记录"</span></span><br><span class="line"><span class="string">"select distinct 字段 from 表名;"</span></span><br><span class="line">例如：</span><br><span class="line">select distinct money from zhangwu;</span><br><span class="line"></span><br><span class="line">* D: <span class="string">"别名查询，使用的as关键字，as可以省略的."</span></span><br><span class="line">别名可以给表中的字段，表设置别名。 当查询语句复杂时，使用别名可以极大的简便操作。</span><br><span class="line"></span><br><span class="line"><span class="string">"表别名格式"</span>: </span><br><span class="line"><span class="string">"select * from 表名 as 别名;"</span></span><br><span class="line">或</span><br><span class="line"><span class="string">"select * from 表名 别名;"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"列别名格式"</span>：</span><br><span class="line"><span class="string">"select 字段名 as 别名 from 表名;"</span></span><br><span class="line">或</span><br><span class="line"><span class="string">"select 字段名 别名 from 表名;"</span></span><br><span class="line">例如</span><br><span class="line">表别名：</span><br><span class="line">select * from zhangwu as zw;</span><br><span class="line">列别名：</span><br><span class="line">select money as m from zhangwu;</span><br><span class="line">select zname as <span class="string">'重新命名列'</span> from zhangwu;</span><br><span class="line">或</span><br><span class="line">select money m from zhangwu;</span><br><span class="line"></span><br><span class="line">我们在sql语句的操作中，可以直接对列进行运算。</span><br><span class="line">例如：将所有账务的金额+<span class="number">10000</span>元进行显示.</span><br><span class="line">SELECT DISTINCT zmoney+<span class="number">1000</span> as <span class="string">'资金求和'</span> FROM zhangwu;</span><br></pre></td></tr></table></figure><h3 id="27数据的条件查询-1"><a href="#27数据的条件查询-1" class="headerlink" title="27数据的条件查询_1"></a>27数据的条件查询_1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> * A:条件查询</span><br><span class="line"><span class="string">"where语句表条件过滤"</span>。满足条件操作，不满足不操作，多用于数据的查询与修改。</span><br><span class="line"></span><br><span class="line"> * B : 格式 :</span><br><span class="line"><span class="string">"select 字段  from 表名  where 条件;"</span></span><br><span class="line"> </span><br><span class="line"> * C: <span class="keyword">while</span>条件的种类如下：</span><br><span class="line">比较运算符</span><br><span class="line">&gt;  &lt;  &lt;=   &gt;=   =  &lt;&gt;---------- 大于、小于、大于(小于)等于、<span class="string">"不等于"</span></span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line">BETWEEN  ...AND...      -----------显示在某一区间的值(<span class="string">"含头含尾"</span>)</span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line">IN(set)         -----------<span class="string">"显示在in列表中的值"</span>，例：in(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="string">"LIKE 通配符"</span>   -----------<span class="string">"模糊查询"</span>，Like语句中有两个通配符：</span><br><span class="line"><span class="string">"% 用来匹配多个字符"</span>；例first_name like ‘a%’;</span><br><span class="line"><span class="string">"_ 用来匹配一个字符"</span>。例first_name like ‘a_’;</span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line">IS NULL ------------判断是否为空</span><br><span class="line">is <span class="keyword">null</span>; 判断为空</span><br><span class="line">is not <span class="keyword">null</span>; 判断不为空</span><br><span class="line">————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">* D 逻辑运算符</span><br><span class="line">and                  ------------ 多个条件同时成立</span><br><span class="line">or------------ 多个条件任一成立</span><br><span class="line">not------------ 不成立，例：<span class="function">where <span class="title">not</span><span class="params">(salary&gt;<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">* E: 例如：</span><br><span class="line">查询所有吃饭支出记录</span><br><span class="line">SELECT * FROM zhangwu WHERE name = <span class="string">'吃饭支出'</span>;</span><br><span class="line"></span><br><span class="line">查询出金额大于<span class="number">1000</span>的信息</span><br><span class="line">SELECT * FROM zhangwu WHERE money &gt;<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">查询出金额在<span class="number">2000</span>-<span class="number">5000</span>之间的账务信息</span><br><span class="line">SELECT * FROM zhangwu WHERE money &gt;=<span class="number">2000</span> AND money &lt;=<span class="number">5000</span>;</span><br><span class="line">或</span><br><span class="line">SELECT * FROM zhangwu WHERE money BETWEEN <span class="number">2000</span> AND <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">查询出金额是<span class="number">1000</span>或<span class="number">5000</span>或<span class="number">3500</span>的商品信息</span><br><span class="line">SELECT * FROM zhangwu WHERE money =<span class="number">1000</span> OR money =<span class="number">5000</span> OR money =<span class="number">3500</span>;</span><br><span class="line">或</span><br><span class="line">SELECT * <span class="function">FROM zhangwu WHERE money <span class="title">IN</span><span class="params">(<span class="number">1000</span>,<span class="number">5000</span>,<span class="number">3500</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547903336/samples/java%20files/02.120.10.jpg" alt=""></p><h3 id="28数据的条件查询-2"><a href="#28数据的条件查询-2" class="headerlink" title="28数据的条件查询_2"></a>28数据的条件查询_2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> * A <span class="string">"模糊查询"</span></span><br><span class="line"><span class="string">"查询出账务名称包含”支出”的账务信息。"</span></span><br><span class="line">SELECT * FROM zhangwu WHERE name LIKE <span class="string">"%支出%"</span>;</span><br><span class="line"></span><br><span class="line"> * B <span class="string">"查询出账务名称中是五个字的账务信息"</span></span><br><span class="line">SELECT * FROM gjp_ledger WHERE ldesc LIKE <span class="string">"_____"</span>; -- 五个下划线_</span><br><span class="line"></span><br><span class="line">* C <span class="string">"查询出账务名称不为null账务信息"</span></span><br><span class="line">SELECT * FROM zhangwu WHERE name IS NOT NULL;</span><br><span class="line">SELECT * <span class="function">FROM zhangwu WHERE <span class="title">NOT</span> <span class="params">(name IS NULL)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="29排序查询"><a href="#29排序查询" class="headerlink" title="29排序查询"></a>29排序查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* A: 排序查询</span><br><span class="line"> 使用格式</span><br><span class="line">* <span class="string">"通过order by语句，可以将查询出的结果进行排序"</span>。<span class="string">"放置在select语句的"</span><span class="string">"最后"</span>。</span><br><span class="line">* <span class="string">"SELECT * FROM 表名 ORDER BY 字段ASC;"</span></span><br><span class="line">* ASC 升序 (默认)</span><br><span class="line">* DESC 降序</span><br><span class="line"></span><br><span class="line">* B: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  查询,对结果集进行排序</span></span><br><span class="line"><span class="comment">  升序,降序,对指定列排序</span></span><br><span class="line"><span class="comment">  order by 列名 [desc][asc]</span></span><br><span class="line"><span class="comment">  desc 降序</span></span><br><span class="line"><span class="comment">  asc  升序排列,可以不写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-- 查询账务表,价格进行升序</span><br><span class="line"><span class="string">"SELECT * FROM zhangwu ORDER BY zmoney ASC"</span></span><br><span class="line"></span><br><span class="line">-- 查询账务表,价格进行降序</span><br><span class="line">SELECT * FROM zhangwu ORDER BY zmoney DESC</span><br><span class="line"></span><br><span class="line">-- 查询账务表,查询所有的支出,对金额降序排列</span><br><span class="line">-- <span class="string">"先过滤条件 where 查询的结果再排序"</span></span><br><span class="line">SELECT * FROM zhangwu WHERE zname LIKE<span class="string">'%支出%'</span> ORDER BY zmoney DESC</span><br></pre></td></tr></table></figure><h3 id="30聚合函数"><a href="#30聚合函数" class="headerlink" title="30聚合函数"></a>30聚合函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* A: 聚合函数</span><br><span class="line">* B: 函数介绍</span><br><span class="line">* 之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，</span><br><span class="line">它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。</span><br><span class="line">* count：统计指定列不为NULL的记录行数；</span><br><span class="line">* sum：计算指定列的数值和，如果指定列；</span><br><span class="line">* max：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串类型不是数值类型，那么计算结果为<span class="number">0</span>排<span class="number">0</span>序运算；</span><br><span class="line">* min：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</span><br><span class="line">* avg：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">* C: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   使用聚合函数查询计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">-- count 求和,对表中的数据的个数求和  count(列名)</span><br><span class="line">-- 查询统计账务表中,一共有多少条数据</span><br><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(*)</span>AS'count' FROM zhangwu</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- sum求和,对一列中数据进行求和计算 <span class="title">sum</span><span class="params">(列名)</span></span></span><br><span class="line"><span class="function">-- 对账务表查询,对所有的金额求和计算</span></span><br><span class="line"><span class="function">SELECT <span class="title">SUM</span><span class="params">(zmoney)</span> FROM zhangwu</span></span><br><span class="line"><span class="function">-- 求和,统计所有支出的总金额</span></span><br><span class="line"><span class="function">SELECT <span class="title">SUM</span><span class="params">(zname)</span> FROM zhangwu WHERE zname LIKE'%收入%'</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">INSERT INTO <span class="title">zhangwu</span> <span class="params">(zname)</span> <span class="title">VALUES</span> <span class="params">(<span class="string">'彩票收入'</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- max 函数,对某列数据,获取最大值</span></span><br><span class="line"><span class="function">SELECT <span class="title">MAX</span><span class="params">(zmoney)</span> FROM zhangwu</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- avg 函数,计算一个列所有数据的平均数</span></span><br><span class="line"><span class="function">SELECT <span class="title">AVG</span><span class="params">(zmoney)</span>FROM zhangwu</span></span><br></pre></td></tr></table></figure><h3 id="31分组查询"><a href="#31分组查询" class="headerlink" title="31分组查询"></a>31分组查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* A: 分组查询</span><br><span class="line">* a: 使用格式</span><br><span class="line">* <span class="string">"分组查询是指使用group by字句对查询信息进行分组"</span>,例如：我们要统计出zhanguw表中所有分类账务的总数量,这时就需要使用group by 来对zhangwu表中的账务信息根据parent进行分组操作。</span><br><span class="line">* </span><br><span class="line"><span class="string">"* SELECT 字段1,字段2… FROM 表名 GROUP BY 字段 HAVING 条件;"</span></span><br><span class="line"></span><br><span class="line">* <span class="string">"分组操作中的having子语句"</span>，<span class="string">"是用于在分组后对数据进行过滤的，作用类似于where条件"</span>。</span><br><span class="line">* b: having与where的区别</span><br><span class="line">*<span class="string">" having是在"</span>【分组后】<span class="string">"对数据进行过滤"</span>.</span><br><span class="line">* <span class="string">"where是在"</span>【分组前】<span class="string">"对数据进行过滤"</span></span><br><span class="line">* having后面可以使用分组函数(统计函数)</span><br><span class="line">* where后面不可以使用分组函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> * B: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询所有的数据</span></span><br><span class="line"><span class="comment">吃饭支出 共计多少</span></span><br><span class="line"><span class="comment">工资收入 共计多少</span></span><br><span class="line"><span class="comment">服装支出 共计多少</span></span><br><span class="line"><span class="comment">股票收入 共计多少</span></span><br><span class="line"><span class="comment">打麻将支出 共计多少钱</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分组查询:  group by 被分组的列名</span></span><br><span class="line"><span class="comment">必须跟随聚合函数</span></span><br><span class="line"><span class="comment">select 查询的时候,被分组的列,要出现在select 选择列的后面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function">SELECT <span class="title">SUM</span><span class="params">(zmoney)</span>,zname FROM zhangwu GROUP BY zname</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">-- 对zname内容进行分组查询求和,但是只要支出</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SELECT <span class="title">SUM</span><span class="params">(zmoney)</span>AS 'getsum',zname FROM zhangwu WHERE zname LIKE'%支出%'</span></span><br><span class="line"><span class="function">GROUP BY zname</span></span><br><span class="line"><span class="function">ORDER BY getsum DESC</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- 对zname内容进行分组查询求和,但是只要支出, 显示金额大于5000</span></span><br><span class="line"><span class="function">-- 结果集是分组查询后,再次进行筛选,不能使用where, 分组后再次过滤,关键字 having</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SELECT <span class="title">SUM</span><span class="params">(zmoney)</span>AS 'getsum',zname FROM zhangwu WHERE zname LIKE'%支出%'</span></span><br><span class="line"><span class="function">GROUP BY zname HAVING getsum&gt;5000</span></span><br></pre></td></tr></table></figure><h3 id="32总结"><a href="#32总结" class="headerlink" title="32总结"></a>32总结</h3>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297629/samples/java%20files/photo-1544729812-46958d74295c.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.MySQL数据库&lt;br&gt;2.SQL语句&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础25(多线程安全问题(同步、死锁)、等待唤醒机制)</title>
    <link href="https://leesen998.github.io/2016/11/26/day27%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/26/day27笔记/</id>
    <published>2016-11-26T11:48:29.000Z</published>
    <updated>2019-01-18T12:18:37.532Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297637/samples/java%20files/photo-1545913719-d41fc6091697.jpg" alt="" style="width:100%"></p><p>1、多线程安全问题<br>2、等待唤醒机制</p><a id="more"></a>    <h3 id="01线程操作共享数据的安全问题"><a href="#01线程操作共享数据的安全问题" class="headerlink" title="01线程操作共享数据的安全问题"></a>01线程操作共享数据的安全问题</h3><p>*A:线程操作共享数据的安全问题<br>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。<br>程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><h3 id="02售票的案例"><a href="#02售票的案例" class="headerlink" title="02售票的案例"></a>02售票的案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">*A:售票的案例</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 多线程并发访问同一个数据资源</span></span><br><span class="line"><span class="comment">  * 3个线程,对一个票资源,出售</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Runnable接口实现类对象</span></span><br><span class="line">    Tickets t = <span class="keyword">new</span> Tickets();</span><br><span class="line">    <span class="comment">//创建3个Thread类对象,传递Runnable接口实现类</span></span><br><span class="line">    Thread t0 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    </span><br><span class="line">    t0.start();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//定义出售的票源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span>( ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//模拟产生安全问题</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                 ex.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">" 出售第 "</span>+ticket--);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="03线程安全问题引发"><a href="#03线程安全问题引发" class="headerlink" title="03线程安全问题引发"></a>03线程安全问题引发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">*A:线程安全问题引发</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多线程并发访问同一个数据资源</span></span><br><span class="line"><span class="comment"> * 3个线程,对一个票资源,出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建Runnable接口实现类对象</span></span><br><span class="line">   Tickets t = <span class="keyword">new</span> Tickets();</span><br><span class="line">   <span class="comment">//创建3个Thread类对象,传递Runnable接口实现类</span></span><br><span class="line">   Thread t0 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">   Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">   Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">   </span><br><span class="line">   t0.start();</span><br><span class="line">   t1.start();</span><br><span class="line">   t2.start();</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  通过线程休眠,出现安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//定义出售的票源</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"> <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//对票数判断,大于0,可以出售,变量--操作</span></span><br><span class="line">       <span class="keyword">if</span>( ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//加了休眠让其他线程有执行机会</span></span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception ex)&#123;&#125;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">" 出售第 "</span>+ticket--);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547729324/samples/java%20files/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F.jpg" alt=""></p><h3 id="04同步代码块解决线程安全问题"><a href="#04同步代码块解决线程安全问题" class="headerlink" title="04同步代码块解决线程安全问题"></a>04同步代码块解决线程安全问题</h3><p>线程同步的方式有两种：<br>    方式1：<strong>同步代码块</strong><br>    方式2：<strong>同步方法</strong></p><p><strong>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">*A:同步代码块解决线程安全问题</span><br><span class="line">  *A:售票的案例</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 多线程并发访问同一个数据资源</span></span><br><span class="line"><span class="comment">   * 3个线程,对一个票资源,出售</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//创建Runnable接口实现类对象</span></span><br><span class="line">     Tickets t = <span class="keyword">new</span> Tickets();</span><br><span class="line">     <span class="comment">//创建3个Thread类对象,传递Runnable接口实现类</span></span><br><span class="line">     Thread t0 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">     Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">     Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">     </span><br><span class="line">     t0.start();</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  通过线程休眠,出现安全问题</span></span><br><span class="line"><span class="string">   *  解决安全问题,Java程序,提供技术,同步技术</span></span><br><span class="line"><span class="string">   *  公式:</span></span><br><span class="line"><span class="string">   *    synchronized(任意对象)&#123;</span></span><br><span class="line"><span class="string">   *      线程要操作的共享数据</span></span><br><span class="line"><span class="string">   *    &#125;</span></span><br><span class="line"><span class="string">   *    同步代码块</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//定义出售的票源</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">       <span class="comment">//线程共享数据,保证安全,加入同步代码块</span></span><br><span class="line">       <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">       <span class="comment">//对票数判断,大于0,可以出售,变量--操作</span></span><br><span class="line">         <span class="keyword">if</span>( ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">              Thread.sleep(<span class="number">10</span>);</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception ex)&#123;&#125;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">" 出售第 "</span>+ticket--);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="05同步代码块的执行原理"><a href="#05同步代码块的执行原理" class="headerlink" title="05同步代码块的执行原理"></a>05同步代码块的执行原理</h3><p>A:同步代码块的执行原理<br>同步代码块: 在代码块声明上 加上synchronized<br><strong>synchronized (锁对象) {<br>可能会产生线程安全问题的代码<br>}</strong></p><p><strong>同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。</strong></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547729324/samples/java%20files/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt=""></p><h3 id="06同步的上厕所原理"><a href="#06同步的上厕所原理" class="headerlink" title="06同步的上厕所原理"></a>06同步的上厕所原理</h3><p>*A:同步的上厕所原理<br>a:不使用同步:线程在执行的过程中会被打扰<br>线程比喻成人<br>线程执行代码就是上一个厕所<br>第一个人正在上厕所,上到一半,被另外一个人拉出来<br>b:使用同步:<br>线程比喻成人<br>线程执行代码就是上一个厕所<br>锁比喻成厕所门<br>第一个人上厕所,会锁门<br>第二个人上厕所,看到门锁上了,等待第一个人上完再去上厕所<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547733286/samples/java%20files/010hg.png" alt=""></p><h3 id="07同步方法"><a href="#07同步方法" class="headerlink" title="07同步方法"></a>07同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">*A:同步方法:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 多线程并发访问同一个数据资源</span></span><br><span class="line"><span class="comment">* 3个线程,对一个票资源,出售</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建Runnable接口实现类对象</span></span><br><span class="line">  Tickets t = <span class="keyword">new</span> Tickets();</span><br><span class="line">  <span class="comment">//创建3个Thread类对象,传递Runnable接口实现类</span></span><br><span class="line">  Thread t0 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">  Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">  Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">  </span><br><span class="line">  t0.start();</span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*A:同步方法</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  采用同步方法形式,解决线程的安全问题</span></span><br><span class="line"><span class="string">  *  好处: 代码简洁</span></span><br><span class="line"><span class="string">  *  将线程共享数据,和同步,抽取到一个方法中</span></span><br><span class="line"><span class="string">  *  在方法的声明上,加入同步关键字</span></span><br><span class="line"><span class="string">  *  </span></span><br><span class="line"><span class="string">  *  问题:</span></span><br><span class="line"><span class="string">  *    同步方法有锁吗,肯定有,同步方法中的对象锁,是本类对象引用 this</span></span><br><span class="line"><span class="string">  *    如果方法是静态的呢,同步有锁吗,绝对不是this</span></span><br><span class="line"><span class="string">  *    锁是本类自己.class 属性</span></span><br><span class="line"><span class="string">  *    静态方法,同步锁,是本类类名.class属性</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义出售的票源</span></span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      payTicket();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>( ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;&#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 出售第 "</span>+ticket--);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="08JDK1-5新特性Lock接口-实现类ReentrantLock"><a href="#08JDK1-5新特性Lock接口-实现类ReentrantLock" class="headerlink" title="08JDK1.5新特性Lock接口,实现类ReentrantLock"></a>08JDK1.5新特性Lock接口,实现类ReentrantLock</h3><p><strong>Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。</strong>此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。 </p><p><strong>锁是控制多个线程对共享资源进行访问的工具</strong>。通常，<strong>锁提供了对共享资源的独占访问。一次只能有一个线程获得锁，对共享资源的所有访问都需要首先获得锁。</strong>不过，某些锁可能允许对共享资源并发访问，如 ReadWriteLock 的读取锁。 </p><p><strong>synchronized 方法或语句</strong>的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：<strong>当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。 </strong></p><p>虽然 synchronized 方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但<strong>有时也需要以更为灵活的方式使用锁</strong>。例如，某些遍历并发访问的数据结果的算法要求使用 “hand-over-hand” 或 “chain locking”：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。 </p><p>随着灵活性的增加，也带来了更多的责任。<strong>不使用块结构锁就失去了使用 synchronized 方法和语句时会出现的锁自动释放功能</strong>。在大多数情况下，应该<strong>使用以下语句</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...; </span><br><span class="line">     l.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         l.unlock();<span class="comment">//最后必须释放锁</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*A:JDK1.5新特性Lock接口</span><br><span class="line">    查阅API，查阅Lock接口描述，Lock 实现提供了比使用 <span class="keyword">synchronized</span> 方法和语句可获得的更广泛的锁定操作。</span><br><span class="line">   Lock接口中的常用方法</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  Lock提供了一个更加面对对象的锁，在该锁中提供了更多的操作锁的功能。</span></span><br><span class="line"><span class="function">  我们使用Lock接口,以及其中的<span class="title">lock</span><span class="params">()</span>方法和<span class="title">unlock</span><span class="params">()</span>方法替代同步，对电影院卖票案例中Ticket</span></span><br></pre></td></tr></table></figure><h3 id="09利用Lock接口实现类ReentrantLock改进售票案例"><a href="#09利用Lock接口实现类ReentrantLock改进售票案例" class="headerlink" title="09利用Lock接口实现类ReentrantLock改进售票案例"></a>09利用Lock接口实现类ReentrantLock改进售票案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">*A:Lock接口改进售票案例</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 多线程并发访问同一个数据资源</span></span><br><span class="line"><span class="comment">   * 3个线程,对一个票资源,出售</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建Runnable接口实现类对象</span></span><br><span class="line">      Tickets t = <span class="keyword">new</span> Tickets();</span><br><span class="line">      <span class="comment">//创建3个Thread类对象,传递Runnable接口实现类</span></span><br><span class="line">      Thread t0 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">      </span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  使用JDK1.5 的接口Lock,替换同步代码块,实现线程的安全性</span></span><br><span class="line"><span class="string">   *  Lock接口方法:</span></span><br><span class="line"><span class="string">   *     lock() 获取锁</span></span><br><span class="line"><span class="string">   *     unlock()释放锁</span></span><br><span class="line"><span class="string">   *  实现类ReentrantLock</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义出售的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在类的成员位置,创建Lock接口的实现类对象</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//调用Lock接口方法lock获取锁</span></span><br><span class="line">          lock.lock();</span><br><span class="line">        <span class="comment">//对票数判断,大于0,可以出售,变量--操作</span></span><br><span class="line">          <span class="keyword">if</span>( ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">               Thread.sleep(<span class="number">10</span>);</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">" 出售第 "</span>+ticket--);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">              </span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">              <span class="comment">////最后必须释放锁,调用Lock接口方法unlock</span></span><br><span class="line">              lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="10线程的死锁原理"><a href="#10线程的死锁原理" class="headerlink" title="10线程的死锁原理"></a>10线程的死锁原理</h3><p>*A:线程的死锁原理<br><strong>当线程任务中出现了多个同步(多个锁)  时，如果同步中嵌套了其他的同步。</strong>这时容易引发一种现象：<strong>程序出现无限等待，这种现象我们称为死锁。</strong>这种情况能避免就避免掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronzied(A锁)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(B锁)&#123;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547729324/samples/java%20files/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86.jpg" alt=""></p><h3 id="11线程的死锁代码实现"><a href="#11线程的死锁代码实现" class="headerlink" title="11线程的死锁代码实现"></a>11线程的死锁代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">*A:线程的死锁代码实现</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> LockA locka = <span class="keyword">new</span> LockA();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LockB lockb = <span class="keyword">new</span> LockB();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      DeadLock dead = <span class="keyword">new</span> DeadLock();</span><br><span class="line">      Thread t0 = <span class="keyword">new</span> Thread(dead);</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(dead);</span><br><span class="line">      t0.start();</span><br><span class="line">      t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//先进入A同步,再进入B同步</span></span><br><span class="line">          <span class="keyword">synchronized</span>(LockA.locka)&#123;</span><br><span class="line">            System.out.println(<span class="string">"if...locka"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(LockB.lockb)&#123;</span><br><span class="line">              System.out.println(<span class="string">"if...lockb"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//先进入B同步,再进入A同步</span></span><br><span class="line">          <span class="keyword">synchronized</span>(LockB.lockb)&#123;</span><br><span class="line">            System.out.println(<span class="string">"else...lockb"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(LockA.locka)&#123;</span><br><span class="line">              System.out.println(<span class="string">"else...locka"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印效果之一：<br>if … locka<br>if … lockb<br>else … lockb<br>if … locka<br>这是因为：<br>Thread t0 = new Thread(dead);<br>Thread t1 = new Thread(dead);<br>2个线程都执行了DeadLock程序的内容，即<strong>2个线程可以共享DeadLock中同一锁对象LockA.locka，和LockB.lockb</strong></p><p><strong>在线程1执行完if语句后，进入else语句执行完B同步，正准备执行A同步时，这时线程2突然抢占了资源，执行了if语句中的A同步，准备执行B同步;</strong></p><p>即这时<strong>线程1获得了B同步的锁对象LockB.lockb；而线程2获得了A同步的锁对象LockA.locka，导致线程1没有A同步的锁对象，无法执行A同步；线程2没有B同步的锁对象，无法执行B同步,陷入死锁</strong></p><h3 id="12线程等待与唤醒案例介绍"><a href="#12线程等待与唤醒案例介绍" class="headerlink" title="12线程等待与唤醒案例介绍"></a>12线程等待与唤醒案例介绍</h3><p><strong>线程之间的通信</strong>：多个线程在处理<strong>同一个资源</strong>，但是处理的动作（<strong>线程的任务）却不相同</strong><br>通过一定的手段<strong>使各个线程能有效的利用资源</strong>。而这种手段即—— <strong>等待唤醒机制</strong>。<br>*A:线程等待与唤醒案例介绍<br> 等待唤醒机制所涉及到的方法：<br>     <strong>wait（） :等待</strong>，将正在执行的线程<strong>释放其执行资格 和 执行权</strong>，并存储到线程池中。<br>     <strong>notify（）：唤醒</strong>，<strong>唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。</strong><br>     <strong>notifyAll（）： 唤醒全部</strong>：可以将线程池中的所有wait() 线程都唤醒。<br>   其实，所谓<strong>唤醒</strong>的意思就是让 <strong>线程池中的线程具备执行资格</strong>。必须注意的是，<strong>这些方法都是在 同步中才有效</strong>。同时这些方法在使用时必须<strong>标明所属锁</strong>，这样才可以明确出这些方法操作的到底是哪个锁上的线程。</p><h3 id="13线程等待与唤醒案例资源类编写"><a href="#13线程等待与唤醒案例资源类编写" class="headerlink" title="13线程等待与唤醒案例资源类编写"></a>13线程等待与唤醒案例资源类编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*A:线程等待与唤醒案例资源类编写</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义资源类,有2个成员变量</span></span><br><span class="line"><span class="comment"> *  name,sex</span></span><br><span class="line"><span class="comment"> *  同时有2个线程,对资源中的变量操作</span></span><br><span class="line"><span class="comment"> *  1个对name,age赋值</span></span><br><span class="line"><span class="comment"> *  2个对name,age做变量的输出打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14线程等待与唤醒案例输入和输出线程"><a href="#14线程等待与唤醒案例输入和输出线程" class="headerlink" title="14线程等待与唤醒案例输入和输出线程"></a>14线程等待与唤醒案例输入和输出线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A:线程等待与唤醒案例输入和输出线程</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  输入的线程,对资源对象Resource中成员变量赋值</span></span><br><span class="line"><span class="comment">   *  一次赋值 张三,男</span></span><br><span class="line"><span class="comment">   *  下一次赋值 lisi,nv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r=<span class="keyword">new</span> Resource();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           r.name=<span class="string">"张三"</span>;</span><br><span class="line">           r.sex=<span class="string">"男"</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r.name=<span class="string">"lisi"</span>;</span><br><span class="line">            r.sex=<span class="string">"女"</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  输出线程,对资源对象Resource中成员变量,输出值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r=<span class="keyword">new</span> Resource() ;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">         System.out.println(r.name+<span class="string">"..."</span>+r.sex); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="15线程等待与唤醒案例测试类"><a href="#15线程等待与唤醒案例测试类" class="headerlink" title="15线程等待与唤醒案例测试类"></a>15线程等待与唤醒案例测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A:线程等待与唤醒案例测试类</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  开启输入线程和输出线程,实现赋值和打印值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">      </span><br><span class="line">      Input in = <span class="keyword">new</span> Input();</span><br><span class="line">      Output out = <span class="keyword">new</span> Output();</span><br><span class="line">      </span><br><span class="line">      Thread tin = <span class="keyword">new</span> Thread(in);</span><br><span class="line">      Thread tout = <span class="keyword">new</span> Thread(out);</span><br><span class="line">      </span><br><span class="line">      tin.start();</span><br><span class="line">      tout.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="16线程等待与唤醒案例null值解决"><a href="#16线程等待与唤醒案例null值解决" class="headerlink" title="16线程等待与唤醒案例null值解决"></a>16线程等待与唤醒案例null值解决</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">A:线程等待与唤醒案例<span class="keyword">null</span>值解决</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  输入的线程,对资源对象Resource中成员变量赋值</span></span><br><span class="line"><span class="comment">*  一次赋值 张三,男</span></span><br><span class="line"><span class="comment">*  下一次赋值 lisi,nv</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Resource r;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Input</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.r=r;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        r.name=<span class="string">"张三"</span>;</span><br><span class="line">        r.sex=<span class="string">"男"</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         r.name=<span class="string">"lisi"</span></span><br><span class="line">         r.sex=<span class="string">"女"</span></span><br><span class="line">       &#125;</span><br><span class="line">     i++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  输出线程,对资源对象Resource中成员变量,输出值</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Resource r;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Output</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.r=r;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      System.out.println(r.name+<span class="string">"..."</span>+r.sex); </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  开启输入线程和输出线程,实现赋值和打印值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">   </span><br><span class="line">   Input in = <span class="keyword">new</span> Input(r);</span><br><span class="line">   Output out = <span class="keyword">new</span> Output(r);</span><br><span class="line">   </span><br><span class="line">   Thread tin = <span class="keyword">new</span> Thread(in);</span><br><span class="line">   Thread tout = <span class="keyword">new</span> Thread(out);</span><br><span class="line">   </span><br><span class="line">   tin.start();</span><br><span class="line">   tout.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17线程等待与唤醒案例数据安全解决"><a href="#17线程等待与唤醒案例数据安全解决" class="headerlink" title="17线程等待与唤醒案例数据安全解决"></a>17线程等待与唤醒案例数据安全解决</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">A:线程等待与唤醒案例数据安全解决</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  输入的线程,对资源对象Resource中成员变量赋值</span></span><br><span class="line"><span class="comment">  *  一次赋值 张三,男</span></span><br><span class="line"><span class="comment">  *  下一次赋值 lisi,nv</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Resource r;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Input</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.r=r;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          r.name=<span class="string">"张三"</span>;</span><br><span class="line">          r.sex=<span class="string">"男"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           r.name=<span class="string">"lisi"</span></span><br><span class="line">           r.sex=<span class="string">"女"</span></span><br><span class="line">         &#125;</span><br><span class="line">       i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  输出线程,对资源对象Resource中成员变量,输出值</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Resource r;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Output</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.r=r;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">         System.out.println(r.name+<span class="string">"..."</span>+r.sex); </span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  开启输入线程和输出线程,实现赋值和打印值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">     </span><br><span class="line">     Input in = <span class="keyword">new</span> Input(r);</span><br><span class="line">     Output out = <span class="keyword">new</span> Output(r);</span><br><span class="line">     </span><br><span class="line">     Thread tin = <span class="keyword">new</span> Thread(in);</span><br><span class="line">     Thread tout = <span class="keyword">new</span> Thread(out);</span><br><span class="line">     </span><br><span class="line">     tin.start();</span><br><span class="line">     tout.start();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="18线程等待与唤醒案例通信的分析"><a href="#18线程等待与唤醒案例通信的分析" class="headerlink" title="18线程等待与唤醒案例通信的分析"></a>18线程等待与唤醒案例通信的分析</h3><p>*A:线程等待与唤醒案例通信的分析<br><strong>输入</strong>: <strong>赋值后,执行方法wait()永远等待</strong><br><strong>输出</strong>: 变量值打印输出,在输出等待之前,<strong>唤醒【输入】的notify()</strong>,<strong>自己在wait()永远等待</strong><br><strong>输入</strong>: <strong>被唤醒后,重新对变量赋值</strong>,赋值后,<strong>必须唤醒【输出】的线程notify(),自己的wait()</strong><br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547729324/samples/java%20files/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.jpg" alt=""></p><h3 id="19线程等待与唤醒案例的实现"><a href="#19线程等待与唤醒案例的实现" class="headerlink" title="19线程等待与唤醒案例的实现"></a>19线程等待与唤醒案例的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">*A 线程等待与唤醒案例的实现</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  定义资源类,有2个成员变量</span></span><br><span class="line"><span class="comment">  *  name,sex</span></span><br><span class="line"><span class="comment">  *  同时有2个线程,对资源中的变量操作</span></span><br><span class="line"><span class="comment">  *  1个对name,age赋值</span></span><br><span class="line"><span class="comment">  *  2个对name,age做变量的输出打印</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> String sex;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  输入的线程,对资源对象Resource中成员变量赋值</span></span><br><span class="line"><span class="comment">  *  一次赋值 张三,男</span></span><br><span class="line"><span class="comment">  *  下一次赋值 lisi,nv</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r ;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Input</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(r)&#123;</span><br><span class="line">        <span class="comment">//标记是true,等待</span></span><br><span class="line">          <span class="keyword">if</span>(r.flag)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;r.wait();&#125;<span class="keyword">catch</span>(Exception ex)&#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          r.name = <span class="string">"张三"</span>;</span><br><span class="line">          r.sex = <span class="string">"男"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          r.name = <span class="string">"lisi"</span>;</span><br><span class="line">          r.sex = <span class="string">"nv"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将对方线程唤醒,标记改为true</span></span><br><span class="line">        r.flag = <span class="keyword">true</span>;</span><br><span class="line">        r.notify();</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  输出线程,对资源对象Resource中成员变量,输出值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource r ;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Output</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(r)&#123;  </span><br><span class="line">        <span class="comment">//判断标记,是false,等待</span></span><br><span class="line">      <span class="keyword">if</span>(!r.flag)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;r.wait();&#125;<span class="keyword">catch</span>(Exception ex)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      System.out.println(r.name+<span class="string">".."</span>+r.sex);</span><br><span class="line">      <span class="comment">//标记改成false,唤醒对方线程</span></span><br><span class="line">      r.flag = <span class="keyword">false</span>;</span><br><span class="line">      r.notify();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  开启输入线程和输出线程,实现赋值和打印值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">    </span><br><span class="line">    Input in = <span class="keyword">new</span> Input(r);</span><br><span class="line">    Output out = <span class="keyword">new</span> Output(r);</span><br><span class="line">    </span><br><span class="line">    Thread tin = <span class="keyword">new</span> Thread(in);</span><br><span class="line">    Thread tout = <span class="keyword">new</span> Thread(out);</span><br><span class="line">    </span><br><span class="line">    tin.start();</span><br><span class="line">    tout.start();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="20总结"><a href="#20总结" class="headerlink" title="20总结"></a>20总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">同步锁</span><br><span class="line"><span class="string">"多个线程"</span>想保证线程安全，必须要使用<span class="string">"同一个锁对象"</span></span><br><span class="line">同步代码块</span><br><span class="line">         <span class="keyword">synchronized</span> (锁对象)&#123;</span><br><span class="line">    可能产生线程安全问题的代码</span><br><span class="line">&#125;</span><br><span class="line">同步代码块的<span class="string">"锁对象"</span>可以是<span class="string">"任意(Object)的对象"</span></span><br><span class="line"></span><br><span class="line">同步方法</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">              可能产生线程安全问题的代码</span><br><span class="line">&#125;</span><br><span class="line">同步方法中的锁对象是 <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态同步方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      可能产生线程安全问题的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"静态同步方法中的锁对象"</span>是 类名.class</span><br><span class="line"></span><br><span class="line">多线程有几种实现方案，分别是哪几种?</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">a, 继承Thread类</span></span><br><span class="line"><span class="string">b, 实现Runnable接口</span></span><br><span class="line"><span class="string">c, 通过线程池，实现Callable接口</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">同步有几种方式，分别是什么?</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">a,同步代码块</span></span><br><span class="line"><span class="string">b,同步方法</span></span><br><span class="line"><span class="string">  静态同步方法</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"></span><br><span class="line">启动一个线程是run()还是start()?它们的区别?</span><br><span class="line"><span class="string">"启动一个线程是start()</span></span><br><span class="line"><span class="string">区别：</span></span><br><span class="line"><span class="string">start： 启动线程，并调用线程中的run()方法</span></span><br><span class="line"><span class="string">run  : 执行该线程对象要执行的任务</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">                                                                                                 <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span>和<span class="title">wait</span><span class="params">()</span>方法的区别</span></span><br><span class="line"><span class="function">sleep: 不释放锁对象, 释放CPU使用权</span></span><br><span class="line"><span class="function">在休眠的时间内，不能唤醒</span></span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span>: 释放锁对象, 释放CPU使用权</span></span><br><span class="line"><span class="function">在等待的时间内，能唤醒</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">为什么<span class="title">wait</span><span class="params">()</span>,<span class="title">notify</span><span class="params">()</span>,<span class="title">notifyAll</span><span class="params">()</span>等方法都定义在Object类中</span></span><br><span class="line"><span class="function">锁对象可以是任意类型的对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297637/samples/java%20files/photo-1545913719-d41fc6091697.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、多线程安全问题&lt;br&gt;2、等待唤醒机制&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础24(多线程及其创建方式、线程池)</title>
    <link href="https://leesen998.github.io/2016/11/20/day26%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/20/day26笔记/</id>
    <published>2016-11-20T11:48:29.000Z</published>
    <updated>2019-01-17T12:37:52.685Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297630/samples/java%20files/photo-1544819576-6b293e16c95c.jpg" alt="" style="width:100%"></p><p>1、多线程(Thread线程类、Runnable接口)<br>2、线程池(ExecutorService：线程池类)</p><a id="more"></a><h3 id="01进程概念"><a href="#01进程概念" class="headerlink" title="01进程概念"></a>01进程概念</h3><p>*A:进程概念</p><p>   a:<strong>进程</strong>：进程指正在运行的程序。确切的来说，<strong>当一个程序进入内存运行，即变成一个进程</strong>，进程是处于运行过程中的程序，并且具有一定独立功能。<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692697/samples/java%20files/2019.117.png" alt=""></p><h3 id="02线程的概念"><a href="#02线程的概念" class="headerlink" title="02线程的概念"></a>02线程的概念</h3><p> *A:线程的概念</p><p>a:<strong>线程</strong>：<strong>线程是进程中的一个执行单元(执行路径)</strong>，负责当前进程中程序的执行，<br>         <strong> 一个进程中至少有一个线程。一个进程中是可以有多个线程的，</strong><br>          这个应用程序也可以称之为<strong>多线程程序</strong>。<br>    简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692698/samples/java%20files/201901171.png" alt=""></p><h3 id="03深入线程的概念"><a href="#03深入线程的概念" class="headerlink" title="03深入线程的概念"></a>03深入线程的概念</h3><p>A:深入线程的概念<br>什么是多线程呢？<br> 即就是一个程序中有<strong>多个线程在同时执行</strong>。<br> 一个核心的CPU在多个线程之间进行着随即切换动作,<br>由于切换时间很短(毫秒甚至是纳秒级别),导致我们感觉不出来</p><p><strong>单线程程序</strong>：即，<strong>若有多个任务只能依次执行</strong>。<br>当上一个任务执行结束后，下一个任务开始执行。<br>如去网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。<br><strong>多线程程序：即，若有多个任务可以同时执行。</strong><br>如，去网吧上网，网吧能够让多个人同时上网。<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547693060/samples/java%20files/2019175.png" alt=""></p><h3 id="04迅雷的多线程下载"><a href="#04迅雷的多线程下载" class="headerlink" title="04迅雷的多线程下载"></a>04迅雷的多线程下载</h3><p>   A:迅雷的多线程下载<br>     多线程,每个线程都读一个文件<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692698/samples/java%20files/201901171.png" alt=""></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692697/samples/java%20files/%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BD%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86.jpg" alt=""></p><h3 id="05线程的运行模式"><a href="#05线程的运行模式" class="headerlink" title="05线程的运行模式"></a>05线程的运行模式</h3><p>A:线程的运行模式<br>a:<strong>分时调度</strong><br>  所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><p>b:<strong>抢占式调度</strong><br> <strong>优先让优先级高的线程使用 CPU，如果线程的优先级相同，<br>那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</strong><br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692698/samples/java%20files/201901172.png" alt=""><br> 大部分操作系统都支持<strong>多进程并发运行</strong>，现在的操作系统几乎都支持同时运行多个程序。<br> 比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。<br> 此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p> 实际上，<strong>CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。</strong><br> 对于CPU的一个核而言，某个时刻，只能执行一个线程，<br> 而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br> 其实，<strong>多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高</strong>。</p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547692698/samples/java%20files/201901173.png" alt=""></p><h3 id="06main的主线程"><a href="#06main的主线程" class="headerlink" title="06main的主线程"></a>06main的主线程</h3><p><strong>jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程 : thread “main”</strong>。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*A:main的主线程</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  程序中的主线程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="number">0</span>/<span class="number">0</span>);</span><br><span class="line">      function();</span><br><span class="line">      System.out.println(Math.abs(-<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>;i++)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="07-Thread-类和Runnable-接口介绍"><a href="#07-Thread-类和Runnable-接口介绍" class="headerlink" title="07 Thread 类和Runnable 接口介绍"></a>07 Thread 类和Runnable 接口介绍</h3><p>A:Thread类介绍:<br>Thread是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。</p><p> 发现创建新执行线程有两种方法。<br> a<strong>:一种方法是将类声明为 Thread 的子类</strong>。<br> <strong>该子类应重写 Thread 类的 run 方法</strong>。创建对象，开启线程。<strong>run方法相当于其他线程的main方法。</strong></p><p> b:<strong>另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法</strong>。<br> <strong>然后创建Runnable的子类对象</strong>，传入到某个线程的构造方法中，开启线程。</p><p>创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。例如，计算大于某一规定值的质数的线程可以写成： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> minPrime;</span><br><span class="line">        PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">             . . .</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后，<strong>下列代码会创建并启动一个线程</strong>,<strong>必须用start()方法</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure><hr><p> 创建线程的另一种方法是<strong>声明实现 Runnable 接口的类</strong>。<strong>该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动</strong>。采用这种风格的同一个例子如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">         . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>然后，<strong>下列代码会创建并启动一个线程</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure><h3 id="08实现线程程序继承Thread"><a href="#08实现线程程序继承Thread" class="headerlink" title="08实现线程程序继承Thread"></a>08实现线程程序继承Thread</h3><p>线程对象调用 run方法和调用start方法区别？<br>线程对象<strong>调用run方法不开启线程</strong>。<strong>仅是对象调用方法</strong>。<br>线程对象<strong>调用start开启线程</strong>，并让<strong>jvm调用run方法</strong>在开启的线程中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">*A:实现线程程序继承Thread</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建和启动一个线程</span></span><br><span class="line"><span class="comment">    *   创建Thread子类对象</span></span><br><span class="line"><span class="comment">    *   子类对象调用方法start()</span></span><br><span class="line"><span class="comment">    *      让线程程序执行,JVM调用线程中的run</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SubThread st = <span class="keyword">new</span> SubThread();</span><br><span class="line">       SubThread st1 = <span class="keyword">new</span> SubThread();</span><br><span class="line">       st.start();</span><br><span class="line">       st1.start();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">         System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  定义子类,继承Thread </span></span><br><span class="line"><span class="comment">    *  重写方法run </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">         System.out.println(<span class="string">"run..."</span>+i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="09线程执行的随机性"><a href="#09线程执行的随机性" class="headerlink" title="09线程执行的随机性"></a>09线程执行的随机性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">*A:线程执行的随机性</span><br><span class="line"> *</span><br><span class="line">   代码分析:</span><br><span class="line">      整个程序就只有三个线程,</span><br><span class="line">      一个是主线程</span><br><span class="line">        启动另外两个线程</span><br><span class="line">         st.start();</span><br><span class="line">         st1.start();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">           System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">      一个是st(Thread-<span class="number">0</span>)线程</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"run..."</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">      一个是st1(Thread-<span class="number">1</span>)线程下 </span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SubThread st = <span class="keyword">new</span> SubThread();</span><br><span class="line">      SubThread st1 = <span class="keyword">new</span> SubThread();</span><br><span class="line">      st.start();</span><br><span class="line">      st1.start();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  定义子类,继承Thread </span></span><br><span class="line"><span class="comment">   *  重写方法run </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)&#123;</span><br><span class="line">        System.out.println(<span class="string">"run..."</span>+i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547696080/samples/java%20files/%E7%BA%BF%E7%A8%8B%E9%9A%8F%E6%9C%BA%E6%80%A7.jpg" alt=""></p><h3 id="10为什么要继承Thread"><a href="#10为什么要继承Thread" class="headerlink" title="10为什么要继承Thread"></a>10为什么要继承Thread</h3><p>*A:什么要继承Thread<br>a:我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？<br>   继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那<strong>为什么不直接创建Thread类的对象呢？</strong><br>   如下代码：<br>    Thread t1 = new Thread();<br>    t1.start();//<strong>这样做没有错，但是该start调用的是Thread类中的run方法</strong><br>              //<strong>而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码</strong>。<br>Thread类run方法中的任务并不是我们所需要的，<strong>只有重写这个run方法</strong>。既然Thread类已经定义了线程任务的编写位置（run方法），那么只要在编写位置（run方法）中定义任务代码即可。所以进行了重写run方法动作</p><p>b:创建线程的目的是什么？<br> 是<strong>为了建立程序单独的执行路径，让多部分代码实现同时执行</strong>。也就是说<strong>线程创建并执行需要给定线程要执行的任务</strong>。<br> 对于之前所讲的主线程，它的任务定义在main函数中。<br><strong>自定义线程需要执行的任务都定义在run方法中</strong>。</p><h3 id="11多线程内存图解"><a href="#11多线程内存图解" class="headerlink" title="11多线程内存图解"></a>11多线程内存图解</h3><p>*A:多线程内存图解<br>  多线程执行时，到底在内存中是如何运行的呢？<br>多线程执行时，<strong>在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间</strong>。<strong>进行方法的压栈和弹栈。</strong><br>当执行线程的任务结束了，线程自动在栈内存中释放了。<strong>但是当所有的执行线程都结束了，那么进程就结束了。</strong><br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547696783/samples/java%20files/1132.png" alt=""></p><h3 id="12获取线程名字Thread类方法getName"><a href="#12获取线程名字Thread类方法getName" class="headerlink" title="12获取线程名字Thread类方法getName"></a>12获取线程名字Thread类方法getName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*A:获取线程名字Thread类方法getName </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  获取线程名字,父类Thread方法</span></span><br><span class="line"><span class="comment">  *    String getName()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NameThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(<span class="string">"小强"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(getName());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  每个线程,都有自己的名字</span></span><br><span class="line"><span class="string">  *  运行方法main线程,名字就是"</span>main<span class="string">"</span></span><br><span class="line"><span class="string">  *  其他新键的线程也有名字,默认 "</span>Thread-<span class="number">0</span><span class="string">","</span>Thread-<span class="number">1</span><span class="string">"</span></span><br><span class="line"><span class="string">  *  </span></span><br><span class="line"><span class="string">  *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是</span></span><br><span class="line"><span class="string">  *  Thread类对象</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     NameThread nt = <span class="keyword">new</span> NameThread();</span><br><span class="line">     nt.start();</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="13获取线程名字Thread类方法currentThread"><a href="#13获取线程名字Thread类方法currentThread" class="headerlink" title="13获取线程名字Thread类方法currentThread"></a>13获取线程名字Thread类方法currentThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*A:获取线程名字Thread类方法currentThread</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  获取线程名字,父类Thread方法</span></span><br><span class="line"><span class="comment">  *    String getName()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(getName());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> *</span><br><span class="line">  *  每个线程,都有自己的名字</span><br><span class="line">  *  运行方法main线程,名字就是<span class="string">"main"</span></span><br><span class="line">  *  其他新键的线程也有名字,默认 <span class="string">"Thread-0"</span>,<span class="string">"Thread-1"</span></span><br><span class="line">  *  </span><br><span class="line">  *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是</span><br><span class="line">  *  Thread类对象</span><br><span class="line">  *  Thread类中,静态方法</span><br><span class="line">  *   <span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span>返回正在执行的线程对象</span></span><br><span class="line"><span class="function">  *</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> class ThreadDemo </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     NameThread nt = <span class="keyword">new</span> NameThread();</span><br><span class="line">     nt.start();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/*Thread t =Thread.currentThread();</span></span><br><span class="line"><span class="comment">     System.out.println(t.getName());*/</span></span><br><span class="line">     System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="14线程名字设置"><a href="#14线程名字设置" class="headerlink" title="14线程名字设置"></a>14线程名字设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A:线程名字设置</span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  获取线程名字,父类Thread方法</span></span><br><span class="line"><span class="string">    *    String getName()</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">NameThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(<span class="string">"小强"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(getName());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  每个线程,都有自己的名字</span></span><br><span class="line"><span class="string">    *  运行方法main线程,名字就是"</span>main<span class="string">"</span></span><br><span class="line"><span class="string">    *  其他新键的线程也有名字,默认 "</span>Thread-<span class="number">0</span><span class="string">","</span>Thread-<span class="number">1</span><span class="string">"</span></span><br><span class="line"><span class="string">    *  </span></span><br><span class="line"><span class="string">    *  JVM开启主线程,运行方法main,主线程也是线程,是线程必然就是</span></span><br><span class="line"><span class="string">    *  Thread类对象</span></span><br><span class="line"><span class="string">    *  Thread类中,静态方法</span></span><br><span class="line"><span class="string">    *   static Thread currentThread()返回正在执行的线程对象</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       NameThread nt = <span class="keyword">new</span> NameThread();</span><br><span class="line">       nt.setName(<span class="string">"旺财"</span>);</span><br><span class="line">       nt.start();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="15Thread类方法sleep"><a href="#15Thread类方法sleep" class="headerlink" title="15Thread类方法sleep"></a>15Thread类方法sleep</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A:Thread类方法sleep</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">     <span class="comment">/*for(int i = 0 ; i &lt; 5 ;i++)&#123;</span></span><br><span class="line"><span class="comment">       Thread.sleep(50);</span></span><br><span class="line"><span class="comment">       System.out.println(i);</span></span><br><span class="line"><span class="comment">     &#125;*/</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> SleepThread().start();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">         Thread.sleep(<span class="number">500</span>);<span class="comment">//睡眠500ms,500ms已到并且cpu切换到该线程继续向下执行</span></span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="16实现线程的另一种方式实现Runnable接口"><a href="#16实现线程的另一种方式实现Runnable接口" class="headerlink" title="16实现线程的另一种方式实现Runnable接口"></a>16实现线程的另一种方式实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">A:实现线程的另一种方式实现Runnable接口</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  实现接口方式的线程</span></span><br><span class="line"><span class="string">   *    创建Thread类对象,构造方法中,传递Runnable接口实现类</span></span><br><span class="line"><span class="string">   *    调用Thread类方法start()</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     SubRunnable sr = <span class="keyword">new</span> SubRunnable();</span><br><span class="line">     Thread t = <span class="keyword">new</span> Thread(sr);</span><br><span class="line">     t.start();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">"main..."</span>+i);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  实现线程成功的另一个方式,接口实现</span></span><br><span class="line"><span class="string">   *  实现接口Runnable,重写run方法</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">       System.out.println(<span class="string">"run..."</span>+i);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="17实现Runnable接口方式的原理和好处"><a href="#17实现Runnable接口方式的原理和好处" class="headerlink" title="17实现Runnable接口方式的原理和好处"></a>17实现Runnable接口方式的原理和好处</h3><p>A:实现接口方式的原理<br>为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？<br><strong>实现Runnable接口，避免了继承Thread类的单继承局限性</strong>。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。<br><strong>创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务</strong>。</p><p>B:实现接口方式的好处<br> 第二种方式实现Runnable接口避免了单继承的局限性，所以<strong>较为常用</strong>。<br> 实现Runnable接口的方式，更加的符合面向对象，<strong>线程分为两部分，一部分线程对象，一部分线程任务。</strong><br> <strong>继承Thread类，线程对象和线程任务耦合在一起</strong>。<br> 一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。<br> <strong>实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦</strong>。<br> (降低紧密性或者依赖性,创建线程和执行任务不绑定)</p><h3 id="18匿名内部类实现线程程序"><a href="#18匿名内部类实现线程程序" class="headerlink" title="18匿名内部类实现线程程序"></a>18匿名内部类实现线程程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">*A:匿名内部类实现线程程序 </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用匿名内部类,实现多线程程序</span></span><br><span class="line"><span class="comment"> *  前提: 继承或者接口实现</span></span><br><span class="line"><span class="comment"> *  new 父类或者接口()&#123;</span></span><br><span class="line"><span class="comment"> *     重写抽象方法</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承方式  XXX extends Thread&#123; public void run()&#123;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"!!!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现接口方式  XXX implements Runnable&#123; public void run()&#123;&#125;&#125;</span></span><br><span class="line">    </span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"###"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@@@"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19线程的状态图"><a href="#19线程的状态图" class="headerlink" title="19线程的状态图"></a>19线程的状态图</h3><p>   A:线程的状态图<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547696080/samples/java%20files/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" alt=""></p><h3 id="20线程池的原理"><a href="#20线程池的原理" class="headerlink" title="20线程池的原理"></a>20线程池的原理</h3><p><strong>线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用</strong>，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</p><p>A:线程池的原理<br>  1.在java中，如果每个请求到达就创建一个新线程，开销是相当大的。</p><p>  2.在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，<br>  甚至可能要比在处理实际的用户请求的时间和资源要多的多。</p><p>  3.除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。<br>    如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。<br>    为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，<br>    尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。<br>  <strong>线程池主要用来解决线程生命周期开销问题和资源不足问题</strong>。<br>  <strong>通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，<br>  所以消除了线程创建所带来的延迟。</strong>这样，就可以立即为请求服务，使用应用程序响应更快。<br>  另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547712953/samples/java%20files/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h3 id="21JDK5实现线程池"><a href="#21JDK5实现线程池" class="headerlink" title="21JDK5实现线程池"></a>21JDK5实现线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</span><br><span class="line">Executors：线程池创建<span class="string">"工厂类"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span>：返回线程池对象</span></span><br><span class="line"><span class="function">ExecutorService：线程池类</span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span>：获取线程池中的某一个线程对象，并执行</span></span><br><span class="line"><span class="function">Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使用线程池中线程对象的步骤：</span></span><br><span class="line"><span class="function">创建线程池对象</span></span><br><span class="line"><span class="function">创建Runnable接口子类对象</span></span><br><span class="line"><span class="function">提交Runnable接口子类对象</span></span><br><span class="line"><span class="function">关闭线程池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> A:JDK5实现线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function">创建一个可重用固定线程数的线程池，以共享的<span class="params">(无界队列方式)</span>来运行这些线程。</span></span><br><span class="line"><span class="function">在任意点，在<span class="params">(大多数)</span> nThreads 线程会处于<span class="params">(处理任务的活动状态)</span>。</span></span><br><span class="line"><span class="function">如果在所有线程处于活动状态时提交附加任务，<span class="params">(则在有可用线程之前），（附加任务将在队列中等待）。</span></span></span><br><span class="line"><span class="function"><span class="params">如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。</span></span></span><br><span class="line"><span class="function"><span class="params">（在某个线程被显式地关闭之前），（池中的线程将一直存在）。 </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">参数：</span></span></span><br><span class="line"><span class="function"><span class="params">nThreads - （池中的线程数） </span></span></span><br><span class="line"><span class="function"><span class="params">返回：</span></span></span><br><span class="line"><span class="function"><span class="params">新创建的线程池 </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    *</span></span></span><br><span class="line"><span class="function"><span class="params">       *  JDK1<span class="number">.5</span>新特性,实现线程池程序</span></span></span><br><span class="line"><span class="function"><span class="params">       *  使用工厂类 Executors中的静态方法创建线程对象,指定线程的个数</span></span></span><br><span class="line"><span class="function"><span class="params">       *   <span class="keyword">static</span> ExecutorService newFixedThreadPool(<span class="keyword">int</span> 个数)</span> 返回线程池对象</span></span><br><span class="line"><span class="function">       *   返回的是ExecutorService接口的实现类 <span class="params">(线程池对象)</span></span></span><br><span class="line"><span class="function">       *   </span></span><br><span class="line"><span class="function">       *   接口实现类对象,调用方法<span class="title">submit</span> <span class="params">(Ruunable r)</span> 提交线程执行任务</span></span><br><span class="line"><span class="function">       *          </span></span><br><span class="line"><span class="function">       *</span></span><br><span class="line"><span class="function">      <span class="keyword">public</span> class ThreadPoolDemo </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="string">"//调用工厂类的静态方法,创建线程池对象"</span></span><br><span class="line">          <span class="string">"//返回线程池对象,是返回的接口"</span></span><br><span class="line">          ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">            <span class="string">"//调用接口实现类对象es中的方法submit提交线程任务"</span></span><br><span class="line">          <span class="string">"//将Runnable接口实现类对象,传递"</span></span><br><span class="line">          es.submit(<span class="keyword">new</span> ThreadPoolRunnable());</span><br><span class="line">          es.submit(<span class="keyword">new</span> ThreadPoolRunnable());</span><br><span class="line"><span class="string">"//如果线程池大小为2，第3个线程则会等待在前2个线程结束之后才运行"</span></span><br><span class="line">          es.submit(<span class="keyword">new</span> ThreadPoolRunnable());</span><br><span class="line">  <span class="string">"注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中"</span></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line"><span class="comment">//es.shutdown();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">" 线程提交任务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="22实现线程的Callable接口方式"><a href="#22实现线程的Callable接口方式" class="headerlink" title="22实现线程的Callable接口方式"></a>22实现线程的Callable接口方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Callable接口：与Runnable接口功能相似，用来指定线程的任务。</span><br><span class="line">其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。</span><br><span class="line">ExecutorService：线程池类</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span>：获取线程池中的某一个线程对象，并执行线程中的<span class="title">call</span><span class="params">()</span>方法</span></span><br><span class="line"><span class="function">Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使用线程池中线程对象的步骤：</span></span><br><span class="line"><span class="function">创建线程池对象</span></span><br><span class="line"><span class="function">创建Callable接口子类对象</span></span><br><span class="line"><span class="function">提交Callable接口子类对象</span></span><br><span class="line"><span class="function">关闭线程池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  A:实现线程的Callable接口方式</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function">  *  实现线程程序的第三个方式,实现Callable接口方式</span></span><br><span class="line"><span class="function">  *  实现步骤</span></span><br><span class="line"><span class="function">  *    工厂类 Executors静态方法<span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span>：</span></span><br><span class="line"><span class="function">  *    利用newFixedThreadPool方法,创建线程池对象</span></span><br><span class="line"><span class="function">  *    线程池对象ExecutorService接口实现类,调用方法submit提交线程任务</span></span><br><span class="line"><span class="function">  *  Future&lt;?&gt;  <span class="title">submit</span><span class="params">(Callable c)</span></span></span><br><span class="line"><span class="function">  *</span></span><br><span class="line"><span class="function">     <span class="keyword">public</span> class ThreadPoolDemo1 </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="string">"//提交线程任务的方法submit方法返回 Future接口的实现类"</span></span><br><span class="line">        Future&lt;String&gt; f = es.submit(<span class="keyword">new</span> ThreadPoolCallable());</span><br><span class="line">        String s = f.get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Callable 接口的实现类,作为线程提交任务出现</span></span><br><span class="line"><span class="comment">      * 使用方法返回值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="23线程实现异步计算"><a href="#23线程实现异步计算" class="headerlink" title="23线程实现异步计算"></a>23线程实现异步计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">A:线程实现异步计算</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 使用多线程技术,求和</span></span><br><span class="line"><span class="comment">   * 两个线程,1个线程计算1+100,另一个线程计算1+200的和</span></span><br><span class="line"><span class="comment">   * 多线程的异步计算</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      Future&lt;Integer&gt; f1 =es.submit(<span class="keyword">new</span> GetSumCallable(<span class="number">100</span>));</span><br><span class="line">      Future&lt;Integer&gt; f2 =es.submit(<span class="keyword">new</span> GetSumCallable(<span class="number">200</span>));</span><br><span class="line">      System.out.println(f1.get());</span><br><span class="line">      System.out.println(f2.get());</span><br><span class="line">      es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetSumCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetSumCallable</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;=a ; i++)&#123;</span><br><span class="line">        sum = sum + i ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">创建线程的方式</span><br><span class="line">方式<span class="number">1</span>，继承Thread线程类</span><br><span class="line">步骤</span><br><span class="line"><span class="number">1</span>，自定义类继承Thread类</span><br><span class="line"><span class="number">2</span>，在自定义类中重写Thread类的run方法</span><br><span class="line"><span class="number">3</span>，创建自定义类对象(线程对象)</span><br><span class="line"><span class="number">4</span>，调用start方法，启动线程，通过JVM，调用线程中的run方法</span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>，实现Runnable接口</span><br><span class="line">步骤</span><br><span class="line"><span class="number">1</span>，创建线程任务类 实现Runnable接口</span><br><span class="line"><span class="number">2</span>，在线程任务类中 重写接口中的run方法</span><br><span class="line"><span class="number">3</span>，创建线程任务类对象</span><br><span class="line"><span class="number">4</span>，创建线程对象，把线程任务类对象作为Thread类构造方法的参数使用</span><br><span class="line"><span class="number">5</span>，调用start方法，启动线程，通过JVM，调用线程任务类中的run方法</span><br><span class="line"></span><br><span class="line">方式<span class="number">3</span>和<span class="number">4</span> 线程池：</span><br><span class="line">&gt;&gt;&gt;&gt;<span class="number">1</span>、通过Runnable接口，run()方法没有返回值</span><br><span class="line">通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</span><br><span class="line">Executors：线程池创建<span class="string">"工厂类"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span>：返回线程池对象</span></span><br><span class="line"><span class="function">ExecutorService：线程池类</span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span>：获取线程池中的某一个线程对象，并执行</span></span><br><span class="line"><span class="function">Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使用线程池中线程对象的步骤：</span></span><br><span class="line"><span class="function">创建线程池对象</span></span><br><span class="line"><span class="function">创建Runnable接口子类对象</span></span><br><span class="line"><span class="function">提交Runnable接口子类对象</span></span><br><span class="line"><span class="function">关闭线程池</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt;&gt;&gt;&gt;2、通过Callable接口，<span class="title">call</span><span class="params">()</span>方法有返回值</span></span><br><span class="line"><span class="function">ExecutorService：线程池类</span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span>：获取线程池中的某一个线程对象，并执行线程中的<span class="title">call</span><span class="params">()</span>方法</span></span><br><span class="line"><span class="function">Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使用线程池中线程对象的步骤：</span></span><br><span class="line"><span class="function">创建线程池对象</span></span><br><span class="line"><span class="function">创建Callable接口子类对象</span></span><br><span class="line"><span class="function">提交Callable接口子类对象</span></span><br><span class="line"><span class="function">关闭线程池</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547297630/samples/java%20files/photo-1544819576-6b293e16c95c.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、多线程(Thread线程类、Runnable接口)&lt;br&gt;2、线程池(ExecutorService：线程池类)&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础23(Properties集合,序列化流与反序列化流,打印流)</title>
    <link href="https://leesen998.github.io/2016/11/19/day25%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/19/day25笔记/</id>
    <published>2016-11-19T11:48:29.000Z</published>
    <updated>2019-01-16T14:36:01.522Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281637/samples/java%20files/photo-1545105366-5d6173ec720a.jpg" alt="" style="width:100%"></p><p>1、Properties集合<br>2、序列化流与反序列化流<br>3、打印流<br>4、commons-IO</p><a id="more"></a><h3 id="01Properties集合的特点"><a href="#01Properties集合的特点" class="headerlink" title="01Properties集合的特点"></a>01Properties集合的特点</h3><ul><li>A: Properties集合的特点</li><li>a: Properties类介绍<ul><li>Properties 类表示了一个<strong>持久的属性集</strong>。Properties 可<strong>保存在流中或从流中加载</strong>。属性列表中每个键及其对应值都是一个字符串</li></ul></li><li>b: 特点<ul><li>Hashtable的子类，<strong>map集合中的方法都可以用</strong>。</li><li><strong>该集合没有泛型。键值都是字符串。</strong></li><li>它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。</li><li><strong>有和流技术相结合的方法</strong>。</li></ul></li><li>c: 方法介绍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* <span class="title">load</span><span class="params">(InputStream inputStream)</span>  </span></span><br><span class="line"><span class="function">* 把指定流所对应的文件中的数据，读取出来，保存到Propertie集合中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* <span class="title">load</span><span class="params">(Reader reader)</span> </span></span><br><span class="line"><span class="function">* 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* <span class="title">store</span><span class="params">(OutputStream outputStream,String commonts)</span> </span></span><br><span class="line"><span class="function">* 把集合中的数据，保存到指定的流所对应的文件中，参数commonts代表对描述信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* <span class="title">stroe</span><span class="params">(Writer writer,String comments)</span> </span></span><br><span class="line"><span class="function">* 以适合使用 <span class="title">load</span><span class="params">(Reader)</span> 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符</span></span><br></pre></td></tr></table></figure><h3 id="02Properties集合存储键值对"><a href="#02Properties集合存储键值对" class="headerlink" title="02Properties集合存储键值对"></a>02Properties集合存储键值对</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* A: Properties集合存储键值对</span><br><span class="line">* a: 方法介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">*  集合对象Properties类,继承Hashtable,实现Map接口</span></span><br><span class="line"><span class="function">*  可以和IO对象结合使用,实现数据的持久存储</span></span><br><span class="line"><span class="function">* 使用Properties集合,存储键值对</span></span><br><span class="line"><span class="function">* setProperty等同与Map接口中的put</span></span><br><span class="line"><span class="function">* <span class="title">setProperty</span><span class="params">(String key, String value)</span></span></span><br><span class="line"><span class="function">* 通过键获取值, <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class PropertiesDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用Properties集合,存储键值对</span></span><br><span class="line"><span class="comment"> * setProperty等同与Map接口中的put</span></span><br><span class="line"><span class="comment"> * setProperty(String key, String value)</span></span><br><span class="line"><span class="comment"> * 通过键获取值, getProperty(String key)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">pro.setProperty(<span class="string">"a"</span>, <span class="string">"1"</span>);</span><br><span class="line">pro.setProperty(<span class="string">"b"</span>, <span class="string">"2"</span>);</span><br><span class="line">pro.setProperty(<span class="string">"c"</span>, <span class="string">"3"</span>);</span><br><span class="line">System.out.println(pro);</span><br><span class="line"></span><br><span class="line">String value = pro.getProperty(<span class="string">"c"</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法stringPropertyNames,将集合中的键存储到Set集合,类似于Map接口的方法keySet</span></span><br><span class="line">Set&lt;String&gt; set = pro.stringPropertyNames();</span><br><span class="line"><span class="keyword">for</span>(String key : set)&#123;</span><br><span class="line">System.out.println(key+<span class="string">"..."</span>+pro.getProperty(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03Properties集合的方法load"><a href="#03Properties集合的方法load" class="headerlink" title="03Properties集合的方法load"></a>03Properties集合的方法load</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: Properties集合的方法load</span><br><span class="line">* a: 方法介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* Properties集合特有方法 load</span></span><br><span class="line"><span class="function">* <span class="title">load</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">* <span class="title">load</span><span class="params">(Reader r)</span></span></span><br><span class="line"><span class="function">* 传递任意的字节或者字符输入流</span></span><br><span class="line"><span class="function">* 流对象读取文件中的键值对,保存到集合</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class PropertiesDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Properties集合特有方法 load</span></span><br><span class="line"><span class="comment"> * load(InputStream in)</span></span><br><span class="line"><span class="comment"> * load(Reader r)</span></span><br><span class="line"><span class="comment"> * 传递任意的字节或者字符输入流</span></span><br><span class="line"><span class="comment"> * 流对象读取文件中的键值对,保存到集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c:\\pro.properties"</span>);</span><br><span class="line"><span class="comment">//调用集合的方法load,传递字符输入流</span></span><br><span class="line">pro.load(fr);</span><br><span class="line">fr.close();</span><br><span class="line">System.out.println(pro);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04Properties集合的方法store"><a href="#04Properties集合的方法store" class="headerlink" title="04Properties集合的方法store"></a>04Properties集合的方法store</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* A: Properties集合的方法store</span><br><span class="line">* a: 方法介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* Properties集合的特有方法store</span></span><br><span class="line"><span class="function">* <span class="title">store</span><span class="params">(OutputStream out,String comments)</span></span></span><br><span class="line"><span class="function">* <span class="title">store</span><span class="params">(Writer w,String comments)</span></span></span><br><span class="line"><span class="function">* 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class PropertiesDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Properties集合的特有方法store</span></span><br><span class="line"><span class="comment"> * store(OutputStream out)</span></span><br><span class="line"><span class="comment"> * store(Writer w)</span></span><br><span class="line"><span class="comment"> * 接收所有的字节或者字符的输出流,将集合中的键值对,写回文件中保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">pro.setProperty(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">pro.setProperty(<span class="string">"age"</span>, <span class="string">"31"</span>);</span><br><span class="line">pro.setProperty(<span class="string">"email"</span>, <span class="string">"123456789@163.com"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\pro.properties"</span>);</span><br><span class="line"><span class="comment">//键值对,存回文件,使用集合的方法store传递字符输出流</span></span><br><span class="line">pro.store(fw, <span class="string">""</span>);</span><br><span class="line">fw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05对象的序列化与反序列化"><a href="#05对象的序列化与反序列化" class="headerlink" title="05对象的序列化与反序列化"></a>05对象的序列化与反序列化</h3><ul><li>A: 对象的序列化与反序列化</li><li>a: 基本概念</li><li>对象的序列化<ul><li>对象中的数据，以流的形式，写入到文件中保存过程称为写出对象，对象的序列化</li><li><strong>ObjectOutputStream将对象写道文件中，实现序列化</strong></li></ul></li><li>对象的反序列化<ul><li>在文件中，以流的形式，将对象读出来，读取对象，<strong>对象的反序列化</strong></li><li><strong>ObjectInputStream 将文件对象读取出来</strong>，<strong>对象的反序列化</strong><br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547641219/samples/java%20files/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96.jpg" alt=""></li></ul></li></ul><h3 id="06ObjectOutputStream流写对象"><a href="#06ObjectOutputStream流写对象" class="headerlink" title="06ObjectOutputStream流写对象"></a>06ObjectOutputStream流写对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">* A: ObjectOutputStream流写对象</span><br><span class="line">* a: 简单介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> *  IO流对象,实现对象Person序列化,和反序列化</span></span><br><span class="line"><span class="function"> *  ObjectOutputStream 写对象,实现序列化</span></span><br><span class="line"><span class="function"> *  ObjectInputStream 读取对象,实现反序列化</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> ObjectOutputStream流构造方法: <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span></span><br><span class="line"><span class="function"> *  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span>  将指定的对象写入 ObjectOutputStream。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Person implements Serializable</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStreamDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//writeObject();</span></span><br><span class="line">readObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ObjectOutputStream</span></span><br><span class="line"><span class="comment"> * 构造方法: ObjectOutputStream(OutputSteam out)</span></span><br><span class="line"><span class="comment"> * 传递任意的字节输出流</span></span><br><span class="line"><span class="comment"> * void writeObject(Object obj)写出对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字节输出流,封装文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\person.txt"</span>);</span><br><span class="line"><span class="comment">//创建写出对象的序列化流的对象,构造方法传递字节输出流</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">25</span>);</span><br><span class="line"><span class="comment">//调用序列化流的方法writeObject,写出对象</span></span><br><span class="line">oos.writeObject(p);</span><br><span class="line">oos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07ObjectInputStream流读取对象"><a href="#07ObjectInputStream流读取对象" class="headerlink" title="07ObjectInputStream流读取对象"></a>07ObjectInputStream流读取对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* A: ObjectInputStream流读取对象</span><br><span class="line">* a: 简单介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* ObjectInputStream</span></span><br><span class="line"><span class="function">* 构造方法:<span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">* 传递任意的字节输入流,输入流封装文件,必须是序列化的文件</span></span><br><span class="line"><span class="function">* Object <span class="title">readObject</span><span class="params">()</span>  读取对象</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  IO流对象,实现对象Person序列化,和反序列化</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  ObjectOutputStream 写对象,实现序列化</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  ObjectInputStream 读取对象,实现反序列化</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class ObjectStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">readObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ObjectInputStream</span></span><br><span class="line"><span class="comment"> * 构造方法:ObjectInputStream(InputStream in)</span></span><br><span class="line"><span class="comment"> * 传递任意的字节输入流,输入流封装文件,必须是序列化的文件</span></span><br><span class="line"><span class="comment"> * Object readObject()  读取对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\person.txt"</span>);</span><br><span class="line"><span class="comment">//创建反序列化流,构造方法中,传递字节输入流</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"><span class="comment">//调用反序列化流的方法 readObject()读取对象</span></span><br><span class="line">Object obj =ois.readObject();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08静态不能序列化"><a href="#08静态不能序列化" class="headerlink" title="08静态不能序列化"></a>08静态不能序列化</h3><ul><li>A: <strong>静态不能序列化</strong></li><li>a: 原因<ul><li>序列化是把对象数据进行持久化存储</li><li><strong>静态不属于对象，而属于类</strong></li></ul></li></ul><h3 id="09transient-瞬态关键字"><a href="#09transient-瞬态关键字" class="headerlink" title="09transient 瞬态关键字"></a>09transient 瞬态关键字</h3><ul><li>A:<strong> transient关键字</strong></li><li>a: 作用<ul><li><strong>被transient修饰的属性不会被序列化</strong></li><li>transient关键字<strong>只能修饰成员变量</strong></li></ul></li></ul><h3 id="10Serializable接口的含义"><a href="#10Serializable接口的含义" class="headerlink" title="10Serializable接口的含义"></a>10Serializable接口的含义</h3><ul><li>A：Serializable接口的含义</li><li>a: 作用<ul><li>给需要<strong>序列化的类上加标记</strong>。该标记中<strong>没有任何抽象方法</strong></li><li><strong>只有实现了 Serializable接口的类的对象才能被序列化</strong></li></ul></li></ul><h3 id="11序列化中的序列号冲突问题"><a href="#11序列化中的序列号冲突问题" class="headerlink" title="11序列化中的序列号冲突问题"></a>11序列化中的序列号冲突问题</h3><ul><li>A: 序列化中的序列号冲突问题</li><li>a: 问题产生原因<ul><li>当一个类实现Serializable接口后，创建对象并将对象写入文件，之后更改了源代码(比如：将成员变量的修饰符有private改成public)，<br>  再次从文件中读取对象时会报异常<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547644890/samples/java%20files/%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E5%86%B2%E7%AA%81.jpg" alt=""></li></ul></li></ul><h3 id="12序列化中自定义的序列号"><a href="#12序列化中自定义的序列号" class="headerlink" title="12序列化中自定义的序列号"></a>12序列化中自定义的序列号</h3><ul><li>A: 序列化中自定义的序列号</li><li><p>a: 定义方式</p><ul><li>private static final long serialVersionUID = 1478652478456L;</li><li>这样<strong>每次编译类时生成的serialVersionUID值都是固定</strong>的     </li></ul></li><li><p>b: 案例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="comment">/*transient阻止成员变量序列化*/</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//类,自定义了序列号,编译器不会计算序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1478652478456L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13打印流和特性"><a href="#13打印流和特性" class="headerlink" title="13打印流和特性"></a>13打印流和特性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* A: 打印流和特性</span><br><span class="line">* a: 概述                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.</span></span><br><span class="line"><span class="function">* 打印流根据流的分类：</span></span><br><span class="line"><span class="function">* 字节打印流PrintStream</span></span><br><span class="line"><span class="function">* 字符打印流PrintWriter</span></span><br><span class="line"><span class="function">* 方法：</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span>: 输出任意类型的数据，</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">println</span><span class="params">(String str)</span>: 输出任意类型的数据，自动写入换行操作</span></span><br><span class="line"><span class="function">* b: 特点</span></span><br><span class="line"><span class="function">* 此流不负责数据源,只负责数据目的</span></span><br><span class="line"><span class="function">* 为其他输出流,添加功能</span></span><br><span class="line"><span class="function">* 永远不会抛出IOException，但是可能抛出别的异常  </span></span><br><span class="line"><span class="function">* 两个打印流的方法,完全一致</span></span><br><span class="line"><span class="function">* 构造方法,就是打印流的输出目的端</span></span><br><span class="line"><span class="function">———————————————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="function">* <span class="title">PrintStream</span><span class="params">()</span> 构造方法</span></span><br><span class="line"><span class="function">  * 接收File类型,接收字符串文件名,接收字节输出流OutputStream</span></span><br><span class="line"><span class="function">* <span class="title">PrintWriter</span><span class="params">()</span> 构造方法</span></span><br><span class="line"><span class="function"> * <span class="params">(接收File类型,接收字符串文件名,接收字节输出流OutputStream, 接收字符输出流Writer)</span></span></span><br><span class="line"><span class="function">———————————————————————————————————————————————————————————————————————————————————————————————</span></span><br></pre></td></tr></table></figure><h3 id="14打印流输出目的是File对象"><a href="#14打印流输出目的是File对象" class="headerlink" title="14打印流输出目的是File对象"></a>14打印流输出目的是File对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A: 打印流输出目的是File对象</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"> * 打印流,向File对象的数据目的写入数据</span><br><span class="line"> * <span class="string">"方法print println  原样输出"</span></span><br><span class="line"> * <span class="string">"write方法走码表"</span></span><br><span class="line"> *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\1.txt"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(file);</span><br><span class="line">pw.println(<span class="keyword">true</span>);<span class="comment">// true</span></span><br><span class="line">pw.println(<span class="number">100</span>);<span class="comment">// 100</span></span><br><span class="line">pw.write(<span class="number">100</span>);<span class="comment">// d</span></span><br><span class="line">pw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15输出语句是char数组"><a href="#15输出语句是char数组" class="headerlink" title="15输出语句是char数组"></a>15输出语句是char数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* A: 输出语句是<span class="keyword">char</span>数组</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">System.out.println(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] ch = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">System.out.println(ch);<span class="comment">//打印 ab</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] b = &#123;&#125;;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* b: 结果分析</span><br><span class="line">* println数组，只有打印字符数组时只有容，其余均打印数组的地址</span><br><span class="line">* 因为api中<span class="string">"定义了打印字符数组"</span>的方法，其底层是在<span class="string">"遍历数组中的元素"</span></span><br><span class="line">* 而其他打印数组的方法，都是将数组对象编程Object，其底层再将对象编程String，调用了String s = String.valueOf(x);方法</span><br></pre></td></tr></table></figure><h3 id="16打印流输出目的是String和流对象"><a href="#16打印流输出目的是String和流对象" class="headerlink" title="16打印流输出目的是String和流对象"></a>16打印流输出目的是String和流对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: 打印流输出目的是String和流对象</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印流,输出目的,是流对象</span></span><br><span class="line"><span class="comment"> * 可以是字节输出流,可以是字符的输出流</span></span><br><span class="line"><span class="comment"> * OutputStream  Writer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//FileOutputStream fos = new FileOutputStream("c:\\3.txt");</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\4.txt"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw);</span><br><span class="line">pw.println(<span class="string">"打印流"</span>);</span><br><span class="line">pw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 打印流,输出目的,String文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="string">"c:\\2.txt"</span>);</span><br><span class="line">pw.println(<span class="number">3.5</span>);</span><br><span class="line">pw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17打印流开启自动刷新"><a href="#17打印流开启自动刷新" class="headerlink" title="17打印流开启自动刷新"></a>17打印流开启自动刷新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* A: 打印流开启自动刷新</span><br><span class="line">* 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/* </span></span><br><span class="line"><span class="string"> * 打印流,可以开启自动刷新功能</span></span><br><span class="line"><span class="string"> * 满足2个条件:</span></span><br><span class="line"><span class="string"> *   1. 输出的数据目的必须是流对象</span></span><br><span class="line"><span class="string"> *       OutputStream  Writer</span></span><br><span class="line"><span class="string"> *   2. 必须调用println,printf,format三个方法中的一个,启用自动刷新</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span><span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line"><span class="comment">//File f = new File("XXX.txt");</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\5.txt"</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(fos,<span class="keyword">true</span>);</span><br><span class="line">pw.println(<span class="string">"i"</span>);</span><br><span class="line">pw.println(<span class="string">"love"</span>);</span><br><span class="line">pw.println(<span class="string">"java"</span>);</span><br><span class="line">pw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18打印流复制文本文件"><a href="#18打印流复制文本文件" class="headerlink" title="18打印流复制文本文件"></a>18打印流复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* A: 打印流复制文本文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> * 打印流实现文本复制</span></span><br><span class="line"><span class="string"> *   读取数据源  BufferedReader+File 读取文本行</span></span><br><span class="line"><span class="string"> *   写入数据目的 PrintWriter+println 自动刷新</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\a.txt"</span>));</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\a.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line = bfr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">pw.println(line);</span><br><span class="line">&#125;</span><br><span class="line">pw.close();</span><br><span class="line">bfr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19commons-io工具类介绍"><a href="#19commons-io工具类介绍" class="headerlink" title="19commons-io工具类介绍"></a>19commons-io工具类介绍</h3><ul><li>A: commons-io工具类介绍</li><li>a: 工具类介绍<ul><li>解压缩commons-io-2.4.zip文件</li><li>commons-io-2.4.jar需要导入到项目中的jar包，里面存放的是class文件</li><li>commons-io-2.4-sources.jar工具类中原代码</li><li>docs是帮助文档</li></ul></li></ul><h3 id="20使用工具类commons-io"><a href="#20使用工具类commons-io" class="headerlink" title="20使用工具类commons_io"></a>20使用工具类commons_io</h3><ul><li>A: 使用工具类commons_io</li><li>a: 导入jar包<ul><li>加入classpath的第三方jar包内的class文件才能在项目中使用</li><li>创建lib文件夹</li><li>将commons-io.jar拷贝到lib文件夹</li><li>右键点击commons-io.jar，Build Path→Add to Build Path<br><strong>idea 是  Add as Libirary</strong></li></ul></li><li>b: 学会如何看源代码,<strong>需要添加source文件</strong>：commons-io-2.4-sources.jar</li></ul><h3 id="21IO工具类FilenameUtils"><a href="#21IO工具类FilenameUtils" class="headerlink" title="21IO工具类FilenameUtils"></a>21IO工具类FilenameUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* A: IO工具类FilenameUtils</span><br><span class="line">* a: 方法介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* <span class="title">getExtension</span><span class="params">(String path)</span>：获取文件的扩展名；</span></span><br><span class="line"><span class="function">* <span class="title">getName</span><span class="params">()</span>：获取文件名；</span></span><br><span class="line"><span class="function">* <span class="title">isExtension</span><span class="params">(String fileName,String ext)</span>：判断fileName是否是ext后缀名；</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function">* </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Commons_IODemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FilenameUtils类的方法</span></span><br><span class="line"><span class="comment"> * static boolean isExtension(String filename,String extension)</span></span><br><span class="line"><span class="comment"> * 判断文件名的后缀是不是extension</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> b = FilenameUtils.isExtension(<span class="string">"Demo.java"</span>, <span class="string">"java"</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FilenameUtils类的方法</span></span><br><span class="line"><span class="comment"> * static String getName(String filename)</span></span><br><span class="line"><span class="comment"> * 获取文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String name = FilenameUtils.getName(<span class="string">"c:\\windows\\"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FilenameUtils类的方法</span></span><br><span class="line"><span class="comment"> * static String getExtension(String filename)</span></span><br><span class="line"><span class="comment"> * 获取文件名的扩展名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> String name = FilenameUtils.getExtension(<span class="string">"c:\\windows"</span>);</span><br><span class="line"> System.out.println(name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22IO工具类FileUtils"><a href="#22IO工具类FileUtils" class="headerlink" title="22IO工具类FileUtils"></a>22IO工具类FileUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">* A: IO工具类FileUtils</span><br><span class="line">* a: 方法介绍                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* <span class="title">readFileToString</span><span class="params">(File file)</span>：读取文件内容，并返回一个String；</span></span><br><span class="line"><span class="function">* <span class="title">writeStringToFile</span><span class="params">(File file，String content)</span>：将内容content写入到file中；</span></span><br><span class="line"><span class="function">* <span class="title">copyDirectoryToDirectory</span><span class="params">(File srcDir,File destDir)</span></span>;文件夹复制</span><br><span class="line">* copyFile(File srcFile,File destFile);文件复制</span><br><span class="line"></span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commons_IODemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FileUtils工具类方法</span></span><br><span class="line"><span class="comment"> * static void copyDirectoryToDirectory(File src,File desc)</span></span><br><span class="line"><span class="comment"> * 复制文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> File(<span class="string">"d:\\demo"</span>), <span class="keyword">new</span> File(<span class="string">"c:\\"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FileUtils工具类的方法</span></span><br><span class="line"><span class="comment"> * static void copyFile(File src,File desc)</span></span><br><span class="line"><span class="comment"> * 复制文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileUtils.copyFile(<span class="keyword">new</span> File(<span class="string">"c:\\k.jpg"</span>),<span class="keyword">new</span> File(<span class="string">"d:\\k.jpg"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FileUtils工具类的方法</span></span><br><span class="line"><span class="comment"> * static void writeStringToFile(File src,String date)</span></span><br><span class="line"><span class="comment"> * 将字符串直接写到文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileUtils.writeStringToFile(<span class="keyword">new</span> File(<span class="string">"c:\\b.txt"</span>),<span class="string">"我爱Java编程"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * FileUtils工具类的方法</span></span><br><span class="line"><span class="comment"> * static String readFileToString(File src)读取文本,返回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"> String s = FileUtils.readFileToString(<span class="keyword">new</span> File(<span class="string">"c:\\a.txt"</span>));</span><br><span class="line"> System.out.println(s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23总结"><a href="#23总结" class="headerlink" title="23总结"></a>23总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">字节流</span></span><br><span class="line"><span class="function">字节输入流 InputStream</span></span><br><span class="line"><span class="function"><span class="title">FileInputStream</span><span class="params">()</span> 操作文件的字节输入流</span></span><br><span class="line"><span class="function"><span class="title">BufferedInputStream</span><span class="params">()</span>高效的字节输入流</span></span><br><span class="line"><span class="function"><span class="title">ObjectInputStream</span><span class="params">()</span> 反序列化流</span></span><br><span class="line"><span class="function">字节输出流 OutputStram</span></span><br><span class="line"><span class="function"><span class="title">FileOutputStream</span><span class="params">()</span> 操作文件的字节输出流</span></span><br><span class="line"><span class="function"><span class="title">BufferedOutputStream</span><span class="params">()</span> 高效的字节输出流</span></span><br><span class="line"><span class="function"><span class="title">ObjectOuputStream</span><span class="params">()</span> 序列化流</span></span><br><span class="line"><span class="function"><span class="title">PrintStream</span><span class="params">()</span> 字节打印流</span></span><br><span class="line"><span class="function">字符流</span></span><br><span class="line"><span class="function">字符输入流 Reader</span></span><br><span class="line"><span class="function"><span class="title">FileReader</span><span class="params">()</span>操作文件的字符输入流</span></span><br><span class="line"><span class="function"><span class="title">BufferedReader</span><span class="params">()</span> 高效的字符输入流</span></span><br><span class="line"><span class="function"><span class="title">InputStreamReader</span><span class="params">()</span> 输入操作的转换流<span class="params">(把字节流封装成字符流)</span></span></span><br><span class="line"><span class="function">字符输出流 Writer</span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">()</span>操作文件的字符输出流</span></span><br><span class="line"><span class="function"><span class="title">BufferedWriter</span><span class="params">()</span> 高效的字符输出流</span></span><br><span class="line"><span class="function"><span class="title">OutputStreamWriter</span><span class="params">()</span> 输出操作的转换流<span class="params">(把字节流封装成字符流)</span></span></span><br><span class="line"><span class="function"><span class="title">PrintWriter</span><span class="params">()</span> 字符打印流</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">方法：</span></span><br><span class="line"><span class="function">读数据方法：</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> 一次读一个字节或字符的方法</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]  <span class="keyword">char</span>[])</span> 一次读一个数组数据的方法</span></span><br><span class="line"><span class="function"><span class="title">readLine</span><span class="params">()</span> 一次读一行字符串的方法<span class="params">(BufferedReader类特有方法)</span></span></span><br><span class="line"><span class="function"><span class="title">readObject</span><span class="params">()</span> 从流中读取对象<span class="params">(ObjectInputStream特有方法)</span></span></span><br><span class="line"><span class="function">写数据方法：</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="keyword">int</span>)</span> 一次写一个字节或字符到文件中</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] <span class="keyword">char</span>[])</span> 一次写一个数组数据到文件中</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(String)</span> 一次写一个字符串内容到文件中</span></span><br><span class="line"><span class="function"><span class="title">writeObject</span><span class="params">(Object )</span> 写对象到流中<span class="params">(ObjectOutputStream类特有方法)</span></span></span><br><span class="line"><span class="function"><span class="title">newLine</span><span class="params">()</span> 写一个换行符号<span class="params">(BufferedWriter类特有方法)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">向文件中写入数据的过程</span></span><br><span class="line"><span class="function">1，创建输出流对象</span></span><br><span class="line"><span class="function">2，写数据到文件</span></span><br><span class="line"><span class="function">3，关闭输出流</span></span><br><span class="line"><span class="function">从文件中读数据的过程</span></span><br><span class="line"><span class="function">1，创建输入流对象</span></span><br><span class="line"><span class="function">2，从文件中读数据</span></span><br><span class="line"><span class="function">3，关闭输入流</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">文件复制的过程</span></span><br><span class="line"><span class="function">1，创建输入流（数据源）</span></span><br><span class="line"><span class="function">2，创建输出流（目的地）</span></span><br><span class="line"><span class="function">3，从输入流中读数据</span></span><br><span class="line"><span class="function">4，通过输出流，把数据写入目的地</span></span><br><span class="line"><span class="function">5，关闭流</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">File类</span></span><br><span class="line"><span class="function">方法</span></span><br><span class="line"><span class="function">获取文件名称<span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">获取文件绝对路径<span class="title">getAbsolutePath</span><span class="params">()</span></span></span><br><span class="line"><span class="function">获取文件大小<span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function">获取当前文件夹中所有File对象  File[] <span class="title">listFiles</span><span class="params">()</span></span></span><br><span class="line"><span class="function">判断是否为文件<span class="title">isFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function">判断是否为文件夹<span class="title">isDirectory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">创建文件夹<span class="title">mkdir</span><span class="params">()</span>  <span class="title">mkdirs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">创建文件<span class="title">createNewFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">异常</span></span><br><span class="line"><span class="function"><span class="keyword">try</span>..<span class="keyword">catch</span>…<span class="keyword">finally</span>捕获处理异常</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> 声明异常</span></span><br><span class="line"><span class="function">throw 抛出异常对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">异常的分类</span></span><br><span class="line"><span class="function">编译期异常 Exception</span></span><br><span class="line"><span class="function">|- 运行期异常 RuntimeException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注意：</span></span><br><span class="line"><span class="function">编译期异常，必须处理，不然无法编译通过</span></span><br><span class="line"><span class="function">运行期异常，程序运行过程中，产生的异常信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Properties：Map集合的一种，它是Hashtable集合的子集合,</span></span><br><span class="line"><span class="function">它键与值都是String类型,它是唯一能与IO流结合使用的集合</span></span><br><span class="line"><span class="function">方法</span></span><br><span class="line"><span class="function"><span class="title">load</span><span class="params">( InputStream in )</span> 从流所对应的文件中，读数据到集合中</span></span><br><span class="line"><span class="function"><span class="title">load</span><span class="params">( Reader in )</span> 从流所对应的文件中，读数据到集合中</span></span><br><span class="line"><span class="function"><span class="title">store</span><span class="params">( OutputStream out , String message )</span> 把集合中的数据，写入到流所对应的文件中</span></span><br><span class="line"><span class="function"><span class="title">store</span><span class="params">( Writer out , String message)</span> 把集合中的数据，写入到流所对应的文件中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">实现文件内容的自动追加</span></span><br><span class="line"><span class="function">构造方法</span></span><br><span class="line"><span class="function"><span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function"><span class="title">FileOutputStream</span><span class="params">(String fileName, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(File, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">(String fileName, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">实现文件内容的自动刷新</span></span><br><span class="line"><span class="function">构造方法</span></span><br><span class="line"><span class="function"><span class="title">PrintStream</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span></span></span><br><span class="line"><span class="function"><span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span></span></span><br><span class="line"><span class="function"><span class="title">PrintWriter</span><span class="params">(Writer out, <span class="keyword">boolean</span> autoFlush)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Commons-IO</span></span><br><span class="line"><span class="function">方法</span></span><br><span class="line"><span class="function"><span class="title">readFileToString</span><span class="params">(File file)</span>：读取文件内容，并返回一个String；</span></span><br><span class="line"><span class="function"><span class="title">writeStringToFile</span><span class="params">(File file，String content)</span>：将内容content写入到file中；</span></span><br><span class="line"><span class="function"><span class="title">copyDirectoryToDirectory</span><span class="params">(File srcDir,File destDir)</span></span>;文件夹复制</span><br><span class="line">copyFileToDirectory (File srcFile,File destFile);文件复制</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281637/samples/java%20files/photo-1545105366-5d6173ec720a.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、Properties集合&lt;br&gt;2、序列化流与反序列化流&lt;br&gt;3、打印流&lt;br&gt;4、commons-IO&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础22(转换流,缓冲流)</title>
    <link href="https://leesen998.github.io/2016/11/18/day24%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/18/day24笔记/</id>
    <published>2016-11-18T11:48:29.000Z</published>
    <updated>2019-01-16T09:06:23.318Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281634/samples/java%20files/photo-1544807375-1768e388cb98.jpg" alt="" style="width:100%"></p><p>1、转换流<br>2、缓冲流</p><a id="more"></a><h3 id="01转换流概述"><a href="#01转换流概述" class="headerlink" title="01转换流概述"></a>01转换流概述</h3><ul><li>A: 转换流概述</li><li>a: 转换流概述</li><li>FileReader、FileWriter是在<strong>默认字符编码和默认字节缓冲区大小</strong>的情况下进行的，对于需要编码转换的情况不太方便。</li><li>OutputStreamWriter 是<strong>字符流</strong>通向<strong>字节流</strong>的<strong>桥梁</strong>：可使用<strong>指定的字符编码表</strong>，将要写入流中的字符编码成字节</li><li>将字符串按照<strong>指定的编码表</strong>转成字节，再使用<strong>字节流</strong>将这些字节写出去</li></ul><h3 id="02转换流-字符转字节的过程-OutputStreamWriter"><a href="#02转换流-字符转字节的过程-OutputStreamWriter" class="headerlink" title="02转换流_字符转字节的过程 OutputStreamWriter"></a>02转换流_字符转字节的过程 OutputStreamWriter</h3><ul><li>A: 转换流_字符转字节的过程</li><li>OutputStreamWriter 是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁：可使用指定的字符编码表，将要写入流中的字符编码成字节。它的作用的就是，将字符串按照指定的编码表转成字节，在使用字节流将这些字节写出去。<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547607307/samples/java%20files/%E8%BD%AC%E6%8D%A2%E6%B5%81.jpg" alt=""></li></ul><h3 id="03OutputStreamWriter写文本文件"><a href="#03OutputStreamWriter写文本文件" class="headerlink" title="03OutputStreamWriter写文本文件"></a>03OutputStreamWriter写文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* A: OutputStreamWriter写文本文件</span><br><span class="line">* a: OutputStreamWriter</span><br><span class="line">* java.io.OutputStreamWriter 继承Writer类</span><br><span class="line">* 就是一个字符输出流，写文本文件</span><br><span class="line">* write()字符，字符数组，字符串    </span><br><span class="line">* 字符通向字节的桥梁，将字符流转字节流</span><br><span class="line">* OutputStreamWriter 使用方式</span><br><span class="line">*                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 构造方法：</span></span><br><span class="line"><span class="function">* <span class="title">OutputStreamWriter</span><span class="params">(OuputStream out)</span>接收所有的字节输出流</span></span><br><span class="line"><span class="function">* 字节输出流：  FileOutputStream       </span></span><br><span class="line"><span class="function">* <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span></span><br><span class="line"><span class="function">* String charsetName 传递编码表名字 GBK  UTF-8 </span></span><br><span class="line"><span class="function">* OutputStreamWriter 有个子类，  FileWriter</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class OutputStreamWriterDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//writeGBK();</span></span><br><span class="line">writeUTF();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 转换流对象OutputStreamWriter写文本</span></span><br><span class="line"><span class="comment"> * 采用UTF-8编码表写入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字节输出流，绑定文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\utf.txt"</span>);</span><br><span class="line"><span class="comment">//创建转换流对象，构造方法保证字节输出流，并指定编码表是UTF-8</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);</span><br><span class="line">osw.write(<span class="string">"你好"</span>);</span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 转换流对象 OutputStreamWriter写文本</span></span><br><span class="line"><span class="comment"> * 文本采用GBK的形式写入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeGBK</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字节输出流，绑定数据文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\gbk.txt"</span>);</span><br><span class="line"><span class="comment">//创建转换流对象，构造方法，绑定字节输出流，使用GBK编码表</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos);</span><br><span class="line"><span class="comment">//转换流写数据</span></span><br><span class="line">osw.write(<span class="string">"你好"</span>);</span><br><span class="line"></span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04转换流-字节转字符流过程-InputSteamReader"><a href="#04转换流-字节转字符流过程-InputSteamReader" class="headerlink" title="04转换流_字节转字符流过程 InputSteamReader"></a>04转换流_字节转字符流过程 InputSteamReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* A: 转换流_字节转字符流过程</span><br><span class="line">* a: InputStreamReader</span><br><span class="line">* java.io.InputStreamReader 继承 Reader</span><br><span class="line">* 字符输入流，读取文本文件</span><br><span class="line">* 字节流向字符的敲了，将字节流转字符流</span><br><span class="line">* 读取的方法:</span><br><span class="line">* read() 读取<span class="number">1</span>个字符，读取字符数组</span><br><span class="line">* 技巧                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* OuputStreamWriter写了文件</span></span><br><span class="line"><span class="function">* InputStreamReader读取文件</span></span><br><span class="line"><span class="function">* <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span>所有字节输出流</span></span><br><span class="line"><span class="function">* <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> 接收所有的字节输入流</span></span><br><span class="line"><span class="function">* 可以传递的字节输入流： FileInputStream</span></span><br><span class="line"><span class="function">* <span class="title">InputStreamReader</span><span class="params">(InputStream in,String charsetName)</span> 传递编码表的名字</span></span><br></pre></td></tr></table></figure><ul><li>b: 图解<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547607307/samples/java%20files/%E8%BD%AC%E6%8D%A2%E6%B5%81.jpg" alt=""></li></ul><h3 id="05InputSteamReader读取文本文件"><a href="#05InputSteamReader读取文本文件" class="headerlink" title="05InputSteamReader读取文本文件"></a>05InputSteamReader读取文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* A: InputSteamReader读取文本文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//readGBK();</span></span><br><span class="line">readUTF();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  转换流,InputSteamReader读取文本</span></span><br><span class="line"><span class="comment"> *  采用UTF-8编码表,读取文件utf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readUTF</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建自己输入流,传递文本文件</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\utf.txt"</span>);</span><br><span class="line"><span class="comment">//创建转换流对象,构造方法中,包装字节输入流,同时写编码表名</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = isr.read(ch);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(ch,<span class="number">0</span>,len));</span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  转换流,InputSteamReader读取文本</span></span><br><span class="line"><span class="comment"> *  采用系统默认编码表,读取GBK文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readGBK</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建自己输入流,传递文本文件</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\gbk.txt"</span>);</span><br><span class="line"><span class="comment">//创建转换流对象,构造方法,包装字节输入流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);</span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = isr.read(ch);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(ch,<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06转换流子类父类的区别"><a href="#06转换流子类父类的区别" class="headerlink" title="06转换流子类父类的区别"></a>06转换流子类父类的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* A: 转换流子类父类的区别</span><br><span class="line">* a: 继承关系</span><br><span class="line">OutputStreamWriter:</span><br><span class="line">|--FileWriter:</span><br><span class="line">InputStreamReader:</span><br><span class="line">|--FileReader;</span><br><span class="line">* b: 区别</span><br><span class="line">* OutputStreamWriter和InputStreamReader是<span class="string">"字符和字节"</span>的桥梁：也可以称之为<span class="string">"字符转换流"</span>。</span><br><span class="line">* <span class="string">"字符转换流原理：字节流+编码表"</span>。</span><br><span class="line">* FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。</span><br><span class="line"><span class="string">"当操作的字符文件，使用的是默认编码表时可以不用父类"</span>，而直接用子类就完成操作了，简化了代码。</span><br><span class="line">* 以下三句话功能相同</span><br><span class="line">* InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>));<span class="comment">//默认字符集。</span></span><br><span class="line">* InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//指定GBK字符集。</span></span><br><span class="line">* FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br></pre></td></tr></table></figure><h3 id="07缓冲流概述"><a href="#07缓冲流概述" class="headerlink" title="07缓冲流概述"></a>07缓冲流概述</h3><ul><li>A: 缓冲流概述</li><li>a: <em>概述</em><ul><li>可提高IO流的读写速度</li><li>分为<strong>字节缓冲流</strong>与<strong>字符缓冲流 </strong></li></ul></li></ul><h3 id="08字节输出流缓冲流BufferedOutputStream"><a href="#08字节输出流缓冲流BufferedOutputStream" class="headerlink" title="08字节输出流缓冲流BufferedOutputStream"></a>08字节输出流缓冲流BufferedOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输出流缓冲流BufferedOutputStream</span><br><span class="line">* a: BufferedOutputStream</span><br><span class="line">* 字节输出流的缓冲流                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* java.io.BufferedOuputStream 作用: 提高原有输出流的写入效率</span></span><br><span class="line"><span class="function">* BufferedOuputStream 继承 OutputStream</span></span><br><span class="line"><span class="function">* 方法,写入 write 字节,字节数组 </span></span><br><span class="line"><span class="function">* 构造方法:</span></span><br><span class="line"><span class="function">* <span class="title">BufferedOuputStream</span><span class="params">(OuputStream out)</span></span></span><br><span class="line"><span class="function">* 可以传递任意的字节输出流, 传递的是哪个字节流,就对哪个字节流提高效率  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class BufferedOutputStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//创建字节输出流,绑定文件</span></span><br><span class="line"><span class="comment">//FileOutputStream fos = new FileOutputStream("c:\\buffer.txt");</span></span><br><span class="line"><span class="comment">//创建字节输出流缓冲流的对象,构造方法中,传递字节输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span></span><br><span class="line">BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\buffer.txt"</span>));</span><br><span class="line"></span><br><span class="line">bos.write(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"HelloWorld"</span>.getBytes();</span><br><span class="line"></span><br><span class="line">bos.write(bytes);</span><br><span class="line"></span><br><span class="line">bos.write(bytes, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">bos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09字节输入流缓冲流BufferedInputStream"><a href="#09字节输入流缓冲流BufferedInputStream" class="headerlink" title="09字节输入流缓冲流BufferedInputStream"></a>09字节输入流缓冲流BufferedInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输入流缓冲流BufferedInputStream</span><br><span class="line">* a: BufferedInputStream</span><br><span class="line">* 字节输入流的缓冲流                                                                                     <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 继承InputStream,标准的字节输入流</span></span><br><span class="line"><span class="function">* 读取方法  <span class="title">read</span><span class="params">()</span> 单个字节,字节数组  </span></span><br><span class="line"><span class="function">* 构造方法:</span></span><br><span class="line"><span class="function">* <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function">* 可以传递任意的字节输入流,传递是谁,就提高谁的效率</span></span><br><span class="line"><span class="function">* 可以传递的字节输入流 FileInputStream</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class BufferedInputStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字节输入流的缓冲流对象,构造方法中包装字节输入流,包装文件</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> </span><br><span class="line">BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\buffer.txt"</span>));</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10四种文件复制方式的效率比较"><a href="#10四种文件复制方式的效率比较" class="headerlink" title="10四种文件复制方式的效率比较"></a>10四种文件复制方式的效率比较</h3><ul><li>A：四种文件复制方式的效率比较</li><li><p>a: 四中复制方式</p><ul><li>字节流读写单个字节                    125250 毫秒</li><li><strong>字节流读写字节数组</strong>                    193    毫秒  OK</li><li>字节流缓冲区流读写单个字节            1210   毫秒</li><li><strong>字节流缓冲区流读写字节数组</strong>            73     毫秒  OK        </li></ul></li><li><p>b: 案例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">copy_4(<span class="keyword">new</span> File(<span class="string">"c:\\q.exe"</span>), <span class="keyword">new</span> File(<span class="string">"d:\\q.exe"</span>));</span><br><span class="line"><span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">System.out.println(e-s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> * 方法,实现文件复制</span></span><br><span class="line"><span class="string"> *  4. 字节流缓冲区流读写字节数组</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_4</span><span class="params">(File src,File desc)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desc));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len = bis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法,实现文件复制</span></span><br><span class="line"><span class="comment"> *  3. 字节流缓冲区流读写单个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_3</span><span class="params">(File src,File desc)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(desc));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>((len = bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(len);</span><br><span class="line">&#125;</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法,实现文件复制</span></span><br><span class="line"><span class="comment"> *  2. 字节流读写字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_2</span><span class="params">(File src,File desc)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(desc);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法,实现文件复制</span></span><br><span class="line"><span class="comment"> *  1. 字节流读写单个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_1</span><span class="params">(File src,File desc)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(desc);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(len);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11字符输出流缓冲流BufferedWriter"><a href="#11字符输出流缓冲流BufferedWriter" class="headerlink" title="11字符输出流缓冲流BufferedWriter"></a>11字符输出流缓冲流BufferedWriter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符输出流缓冲流BufferedWriter</span><br><span class="line">* a: BufferedWriter</span><br><span class="line">* 字符输出流缓冲区流</span><br><span class="line">* java.io.BufferedWriter 继承 Writer</span><br><span class="line">* 写入方法 write () 单个字符,字符数组,字符串</span><br><span class="line"></span><br><span class="line">* 构造方法:</span><br><span class="line">* BufferedWriter(Writer w)传递任意字符输出流</span><br><span class="line">* 传递谁,就高效谁</span><br><span class="line">* 能传递的字符输出流 FileWriter, OutputStreamWriter</span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWrierDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字符输出流,封装文件</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\buffer.txt"</span>);</span><br><span class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">bfw.write(<span class="number">100</span>);</span><br><span class="line">bfw.flush();</span><br><span class="line">bfw.write(<span class="string">"你好"</span>.toCharArray());</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"你好"</span>);</span><br><span class="line"></span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"我好好"</span>);</span><br><span class="line"></span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"大家都好"</span>);</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line">bfw.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12字符输出流缓冲流BufferedWriter特有方法newLine"><a href="#12字符输出流缓冲流BufferedWriter特有方法newLine" class="headerlink" title="12字符输出流缓冲流BufferedWriter特有方法newLine"></a>12字符输出流缓冲流BufferedWriter特有方法newLine</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符输出流缓冲流BufferedWriter特有方法newLine</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">void</span>  <span class="title">newLine</span><span class="params">()</span> 写换行</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* <span class="title">newLine</span><span class="params">()</span>文本中换行, \r\n也是文本换行</span></span><br><span class="line"><span class="function">* 方法具有平台无关性</span></span><br><span class="line"><span class="function">* Windows  \r\n</span></span><br><span class="line"><span class="function">* Linux    \n</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">* <span class="title">newLine</span><span class="params">()</span>运行结果,和操作系统是相互关系</span></span><br><span class="line"><span class="function">* JVM: 安装的是Windows版本,<span class="title">newLine</span><span class="params">()</span>写的就是\r\n</span></span><br><span class="line"><span class="function">* 安装的是Linux版本,<span class="title">newLine</span><span class="params">()</span>写的就是\n</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  将数据源 c:\\a.txt</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  复制到 d:\\a.txt  数据目的</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  字节输入流,绑定数据源</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  字节输出流,绑定数据目的</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  </span></span></span><br><span class="line"><span class="function"><span class="comment"> *  输入,读取1个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  输出,写1个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class BufferedWrierDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建字符输出流,封装文件</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\buffer.txt"</span>);</span><br><span class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">bfw.write(<span class="number">100</span>);</span><br><span class="line">bfw.flush();</span><br><span class="line">bfw.write(<span class="string">"你好"</span>.toCharArray());</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"你好"</span>);</span><br><span class="line">bfw.newLine();</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"我好好"</span>);</span><br><span class="line">bfw.newLine();</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line">bfw.write(<span class="string">"大家都好"</span>);</span><br><span class="line">bfw.flush();</span><br><span class="line"></span><br><span class="line">bfw.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13字符输入流缓冲流BufferedReader"><a href="#13字符输入流缓冲流BufferedReader" class="headerlink" title="13字符输入流缓冲流BufferedReader"></a>13字符输入流缓冲流BufferedReader</h3><ul><li>A: 字符输入流缓冲流BufferedReader</li><li>a: 概述<ul><li>从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取</li><li>public String readLine() 读取一个文本行，包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</li></ul></li></ul><h3 id="14字符输入流缓冲流BufferedReader读取文本行"><a href="#14字符输入流缓冲流BufferedReader读取文本行" class="headerlink" title="14字符输入流缓冲流BufferedReader读取文本行"></a>14字符输入流缓冲流BufferedReader读取文本行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符输入流缓冲流BufferedReader读取文本行</span><br><span class="line">* a: BufferedReader</span><br><span class="line">* 字符输入流缓冲流</span><br><span class="line">* java.io.BufferedReader 继承 Reader</span><br><span class="line">* 读取功能 read() 单个字符,字符数组</span><br><span class="line">* 构造方法:</span><br><span class="line">* BufferedReader(Reader r)</span><br><span class="line">* 可以任意的字符输入流</span><br><span class="line">   FileReader  InputStreamReader       </span><br><span class="line">* BufferedReader自己的功能</span><br><span class="line">* <span class="function">String <span class="title">readLine</span><span class="params">()</span> 读取文本行 \r\n   </span></span><br><span class="line"><span class="function">* 方法读取到流末尾,返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">* b: 小特点</span></span><br><span class="line"><span class="function"> * 获取内容的方法一般都有返回值</span></span><br><span class="line"><span class="function"> * <span class="keyword">int</span> 没有返回的都是负数</span></span><br><span class="line"><span class="function"> * 引用类型 找不到返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"> * <span class="keyword">boolean</span> 找不到返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* c: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class BufferedReaderDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lineNumber = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//创建字符输入流缓冲流对象,构造方法传递字符输入流,包装数据源文件</span></span><br><span class="line">BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\a.txt"</span>));</span><br><span class="line"><span class="comment">//调用缓冲流的方法 readLine()读取文本行</span></span><br><span class="line"><span class="comment">//循环读取文本行, 结束条件 readLine()返回null</span></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line = bfr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">lineNumber++;</span><br><span class="line">System.out.println(lineNumber+<span class="string">"  "</span>+line);</span><br><span class="line">&#125;</span><br><span class="line">bfr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String line = bfr.readLine();</span></span><br><span class="line"><span class="comment">System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">line = bfr.readLine();</span></span><br><span class="line"><span class="comment">System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">line = bfr.readLine();</span></span><br><span class="line"><span class="comment">System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">line = bfr.readLine();</span></span><br><span class="line"><span class="comment">System.out.println(line);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">line = bfr.readLine();</span></span><br><span class="line"><span class="comment">System.out.println(line);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="15字符流缓冲区流复制文本文件"><a href="#15字符流缓冲区流复制文本文件" class="headerlink" title="15字符流缓冲区流复制文本文件"></a>15字符流缓冲区流复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符流缓冲区流复制文本文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  使用缓冲区流对象,复制文本文件</span></span><br><span class="line"><span class="comment"> *  数据源  BufferedReader+FileReader 读取</span></span><br><span class="line"><span class="comment"> *  数据目的 BufferedWriter+FileWriter 写入</span></span><br><span class="line"><span class="comment"> *  读取文本行, 读一行,写一行,写换行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy_1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">BufferedReader bfr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\w.log"</span>));</span><br><span class="line">BufferedWriter bfw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"d:\\w.log"</span>));</span><br><span class="line"><span class="comment">//读取文本行, 读一行,写一行,写换行</span></span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line = bfr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">bfw.write(line);</span><br><span class="line">bfw.newLine();</span><br><span class="line">bfw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bfw.close();</span><br><span class="line">bfr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16IO流对象的操作规律"><a href="#16IO流对象的操作规律" class="headerlink" title="16IO流对象的操作规律"></a>16IO流对象的操作规律</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: IO流对象的操作规律</span><br><span class="line">* a: 明确一：要操作的数据是数据源还是数据目的。</span><br><span class="line">* 源：InputStream    Reader</span><br><span class="line">* 目的：OutputStream Writer</span><br><span class="line">* 先根据需求明确要读，还是要写。</span><br><span class="line"></span><br><span class="line">* b: 明确二：要操作的数据是字节还是文本呢？</span><br><span class="line">* 源：</span><br><span class="line">* 字节：InputStream</span><br><span class="line">* 文本：Reader</span><br><span class="line">* 目的：</span><br><span class="line">* 字节：OutputStream</span><br><span class="line">* 文本：Writer</span><br><span class="line">* c: 明确三：明确数据所在的具体设备。</span><br><span class="line">* 源设备：</span><br><span class="line">* 硬盘：文件  File开头。</span><br><span class="line">* 内存：数组，字符串。</span><br><span class="line">* 键盘：System.in;</span><br><span class="line">* 网络：Socket</span><br><span class="line">* 目的设备：</span><br><span class="line">* 硬盘：文件  File开头。</span><br><span class="line">* 内存：数组，字符串。</span><br><span class="line">* 屏幕：System.out</span><br><span class="line">* 网络：Socket</span><br><span class="line">* 完全可以明确具体要使用哪个流对象。</span><br><span class="line">* d: 明确四：是否需要额外功能呢？</span><br><span class="line">* 额外功能：</span><br><span class="line">* 转换吗？转换流。InputStreamReader OutputStreamWriter</span><br><span class="line">* 高效吗？缓冲区对象。BufferedXXX</span><br><span class="line">* 已经明确到了具体的体系上。</span><br></pre></td></tr></table></figure><h3 id="17总结"><a href="#17总结" class="headerlink" title="17总结"></a>17总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">InputStream</span><br><span class="line">       FileInputStream</span><br><span class="line">       BufferedInputStream</span><br><span class="line"> </span><br><span class="line">OuputStream </span><br><span class="line">   FileOutputStream</span><br><span class="line">   BufferedOuputStream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Writer</span><br><span class="line">  OutputStreamWriter</span><br><span class="line">     FileWriter</span><br><span class="line">      BufferedWriter</span><br><span class="line"></span><br><span class="line">Reader</span><br><span class="line">  InputStreamReader</span><br><span class="line">     FileReader</span><br><span class="line"> BufferedReader</span><br><span class="line">                                                                                               <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">字节流</span></span><br><span class="line"><span class="function">字节输入流 InputStream</span></span><br><span class="line"><span class="function"><span class="title">FileInputStream</span><span class="params">()</span> 操作文件的字节输入流</span></span><br><span class="line"><span class="function"><span class="title">BufferedInputStream</span><span class="params">()</span> 高效的字节输入流</span></span><br><span class="line"><span class="function">字节输出流 OutputStream</span></span><br><span class="line"><span class="function"><span class="title">FileOutputStream</span><span class="params">()</span> 操作文件的字节输出流</span></span><br><span class="line"><span class="function"><span class="title">BufferedOutputStream</span><span class="params">()</span> 高效的字节输出流</span></span><br><span class="line"><span class="function">字符流</span></span><br><span class="line"><span class="function">字符输入流 Reader</span></span><br><span class="line"><span class="function"><span class="title">FileReader</span><span class="params">()</span> 操作文件的字符输入流</span></span><br><span class="line"><span class="function"><span class="title">BufferedReader</span><span class="params">()</span> 高效的字符输入流</span></span><br><span class="line"><span class="function"><span class="title">InputStreamReader</span><span class="params">()</span> 输入操作的转换流<span class="params">(把字节流封装成字符流)</span></span></span><br><span class="line"><span class="function">字符输出流 Writer</span></span><br><span class="line"><span class="function"><span class="title">FileWriter</span><span class="params">()</span> 操作文件的字符输出流</span></span><br><span class="line"><span class="function"><span class="title">BufferedWriter</span><span class="params">()</span> 高效的字符输出流</span></span><br><span class="line"><span class="function"><span class="title">OutputStreamWriter</span><span class="params">()</span> 输出操作的转换流<span class="params">(把字节流封装成字符流)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">方法：</span></span><br><span class="line"><span class="function">读数据方法：</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> 一次读一个字节或字符的方法</span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">(<span class="keyword">byte</span>[]  <span class="keyword">char</span>[])</span> 一次读一个数组数据的方法</span></span><br><span class="line"><span class="function"><span class="title">readLine</span><span class="params">()</span> 一次读一行字符串的方法<span class="params">(BufferedReader类特有方法)</span></span></span><br><span class="line"><span class="function"><span class="title">readObject</span><span class="params">()</span> 从流中读取对象<span class="params">(ObjectInputStream特有方法)</span></span></span><br><span class="line"><span class="function">写数据方法：</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="keyword">int</span>)</span> 一次写一个字节或字符到文件中</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] <span class="keyword">char</span>[])</span> 一次写一个数组数据到文件中</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(String)</span> 一次写一个字符串内容到文件中</span></span><br><span class="line"><span class="function"><span class="title">writeObject</span><span class="params">(Object )</span> 写对象到流中<span class="params">(ObjectOutputStream类特有方法)</span></span></span><br><span class="line"><span class="function"><span class="title">newLine</span><span class="params">()</span> 写一个换行符号<span class="params">(BufferedWriter类特有方法)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">向文件中写入数据的过程</span></span><br><span class="line"><span class="function">1，创建输出流对象</span></span><br><span class="line"><span class="function">2，写数据到文件</span></span><br><span class="line"><span class="function">3，关闭输出流</span></span><br><span class="line"><span class="function">从文件中读数据的过程</span></span><br><span class="line"><span class="function">1，创建输入流对象</span></span><br><span class="line"><span class="function">2，从文件中读数据</span></span><br><span class="line"><span class="function">3，关闭输入流</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">文件复制的过程</span></span><br><span class="line"><span class="function">1，创建输入流（数据源）</span></span><br><span class="line"><span class="function">2，创建输出流（目的地）</span></span><br><span class="line"><span class="function">3，从输入流中读数据</span></span><br><span class="line"><span class="function">4，通过输出流，把数据写入目的地</span></span><br><span class="line"><span class="function">5，关闭流</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281634/samples/java%20files/photo-1544807375-1768e388cb98.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、转换流&lt;br&gt;2、缓冲流&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础：编译时和运行时的区别</title>
    <link href="https://leesen998.github.io/2016/11/18/New%20Document/"/>
    <id>https://leesen998.github.io/2016/11/18/New Document/</id>
    <published>2016-11-18T05:21:53.000Z</published>
    <updated>2018-12-12T09:07:56.709Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1542291563/samples/java%20files/photo-1541631706300-676537664e86.jpg" alt="" style="width:100%"></p><a id="more"></a><p>在java开发设计过程中，了解java运行时和编译时的区别是非常有必要的。如下从几个问题来描述两者的区别</p><p>Q1: 如下代码片段中，A行和B行的区别是什么</p><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2187556549,1140161215&amp;fm=170&amp;s=54126D3A4B624D220CE034DA030050B0&amp;w=600&amp;h=137&amp;img.PNG" alt=""></p><p><strong>A行是在编译时计算值，B行是在运行时计算值</strong>，当该类编译后，如果使用一些反编译器(如jd-gui)反编译后可以看到，实际代码如下：</p><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3687943303,2502274508&amp;fm=170&amp;s=F5186D3B0B664D2044451CDA030080B0&amp;w=600&amp;h=179&amp;img.PNG" alt=""></p><p><strong>java编译时会做一些优化操作，比如替换一些final的不可变更的参数，在这里，由于number1和number2都是final的，那么product1肯定是确定的，这里就会在编译时计算出product1的值</strong>。</p><p>除了如上的一些代码优化话，再什么其他的情况下查看编译后的class文件是非常有用的？</p><p><strong>java中的泛型。泛型是编译时会做优化，通过编译文件可以非常方便的看到其对应的实际类型</strong>，如下例子：</p><p>实际编码如下：</p><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3339368191,4071843396&amp;fm=170&amp;s=E098A43A098CE4CA066C10DE000090B0&amp;w=530&amp;h=269&amp;img.JPG" alt=""></p><p>反编译后的代码如下：</p><p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2640048308,3676203164&amp;fm=170&amp;s=0510643319CF41491EF511DB030080B2&amp;w=600&amp;h=352&amp;img.PNG" alt=""></p><p>可以，在编译后的文件中，Parent类会显示的被实际类型取代。</p><p><strong>重写，重载，泛型，分别是在运行时还是编译时执行的?</strong></p><ol><li><strong>方法重载是在编译时执行的</strong>，因为，在编译的时候，如果调用了一个重载的方法，那么编译时必须确定他调用的方法是哪个。如：</li></ol><p>当调用evaluate(“hello”)时候，我们在编译时就可以确定他调用的method #1.</p><ol start="2"><li><strong>方法的重写是在运行时进行的</strong>。这个也常被称为运行时多态的体现。编译器是没有办法知道它调用的到底是那个方法，相反的，只有在jvm执行过程中，才知晓到底是父子类中的哪个方法被调用了。如下：</li></ol><p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1484266817,2062204854&amp;fm=170&amp;s=D5187D3B4B6245205E6935DA030050B0&amp;w=600&amp;h=159&amp;img.PNG" alt=""></p><p>试想，当有如下一个接口的时候，我们是无法确定到底是调用父类还是子类的方法</p><ol start="3"><li><strong>泛型(类型检测)，这个发生在编译时。编译器会在编译时对泛型类型进行检测，并吧他重写成实际的对象类型(非泛型代码)，这样就可以被JVM执行了。这个过程被称为”类型擦除”</strong>。</li></ol><p>类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</p><p>类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。类型擦除的主要过程如下：</p><p>1). 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</p><p>2). 移除所有的类型参数。</p><p>在编译后变成：</p><ol start="4"><li><strong>注解。注解即有可能是运行时也有可能是编译时</strong>。</li></ol><p>如java中的@Override注解就是典型的编译时注解，他会在编译时会检查一些简单的如拼写的错误(与父类方法不相同)等</p><p>同样的@Test注解是junit框架的注解，他是一个运行时注解，他可以在运行时动态的配置相关信息如timeout等。</p><ol start="5"><li><strong>异常。异常即有可能是运行时异常，也有可能是编译时异常。</strong></li></ol><p>RuntimeException是一个用于指示编译器不需要检查的异常。RuntimeException 是在jvm运行过程中抛出异常的父类。对于运行时异常是不需要再方法中显示的捕获或者处理的，如NullPointerException,ArrayIndexOutOfBoundsException</p><p>已检查的异常是被编译器在编译时候已经检查过的异常，这些异常需要在try/catch块中处理的异常。</p><ol start="6"><li><strong>AOP. Aspects能够在编译时，预编译时以及运行时使用。</strong></li></ol><p>1). 编译时：当你拥有源码的时候，AOP编译器(AspectJ编译器)能够编译源码并生成编织后的class。这些编织进入的额外功能是在编译时放进去的。</p><p>2). 预编译时：织入过程有时候也叫二进制织入，它是用来织入到哪些已经存在的class文件或者jar中的。</p><p>3). 运行时：当被织入的对象已经被加载如jvm中后，可以动态的织入到这些类中一些信息。</p><ol start="7"><li><p><strong>继承：继承是编译时执行的，它是静态的。这个过程编译后就已经确定</strong></p></li><li><p><strong>代理(delegate)：也称动态代理，是在运行时执行</strong>。</p></li></ol><p>你如何理解”组合优于继承”这句话</p><p>继承是一个多态的工具，而非重用工具。在没有多态关联关系的对象间，一些程序员倾向于使用继承来保持重用。但事实是，只有当子类和父类的关系为”is a”的关系时候，继承才会使用。</p><ol><li><p>不要使用继承来实现代码的重用。如果两者之间没有”is a”的关系，那么使用组合来实现重用。当父类的某个方法修改后，子类的相关实现也有可能会被更改。</p></li><li><p>不要为了多态而使用继承。如果你只是为了实现多态而采用继承模式，那么实际上组合模式更加适合你，而且更加简洁和灵活。</p></li></ol><p>这也就是为什么GoF设计模式中常说”组合优于继承”的原因。</p><p>你能区分编译时继承和运行时继承的区别吗？请列举例子说明</p><p>实际上在java中只支持编译时继承。java语言原生是不支持运行时时继承的。一般情况下所谓编译时继承如下：</p><p>如上有两个类，其中Child为Parent的子类。当我们创建一个Parent实例的时候(无论实际对象为Parent还是Child)，编译器在编译期间会将其替换成实际类型。所以继承实际上在编译时就已经确定了。</p><p>而在java中，可以设计通过组合模式来尝试模拟下所谓的运行时继承。</p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1460947953,3373236465&amp;fm=170&amp;s=5D087D334B624D220EF875DA0300D0B1&amp;w=600&amp;h=147&amp;img.PNG" alt=""></p><p>在Child类中，其中有一个Parent实例。通过这种方式，我们动态的child类中代理了parent的相关功能</p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1542291563/samples/java%20files/photo-1541631706300-676537664e86.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础21(字节流,字符流)</title>
    <link href="https://leesen998.github.io/2016/11/16/day23%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/16/day23笔记/</id>
    <published>2016-11-16T11:48:29.000Z</published>
    <updated>2019-01-16T03:22:00.570Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281416/samples/java%20files/photo-1546258115-a6fe51f88baf.jpg" alt="" style="width:100%"></p><p>1、字节流<br>2、字符流</p><a id="more"></a><h3 id="01输入和输出"><a href="#01输入和输出" class="headerlink" title="01输入和输出"></a>01输入和输出</h3><ul><li>A:输入和输出</li><li>a: 参照物</li><li>到底是输入还是输出，都是以Java程序为参照</li><li>b: Output</li><li>把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作</li><li>程序到文件称为输出</li><li>c: Input</li><li>把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作</li><li>文件到程序称为输入</li><li>d: IO操作</li><li>把上面的这种输入和输出动作称为IO操作</li></ul><h3 id="02字节输出流OutputStream"><a href="#02字节输出流OutputStream" class="headerlink" title="02字节输出流OutputStream"></a>02字节输出流OutputStream</h3><ul><li>A: 字节输出流OutputStream</li><li>a.概念</li><li>IO流用来处理设备之间的数据传输</li><li>Java对数据的操作是通过流的方式</li><li>Java用于操作流的类都在IO包中</li><li>流按流向分为两种：输入流，输出流。</li><li>流按操作类型分为两种：<ul><li>字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的</li><li>字符流 : 字符流只能操作纯字符数据，比较方便。</li></ul></li><li>b.IO流常用父类</li><li>字节流的抽象父类：<ul><li>InputStream </li><li>OutputStream</li></ul></li><li>字符流的抽象父类：<ul><li>Reader </li><li>Writer        </li></ul></li><li>c.IO程序书写</li><li>使用前，导入IO包中的类</li><li>使用时，进行IO异常处理</li><li>使用后，释放资源</li><li>d: 方法介绍</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>: 关闭此输出流并释放与此流有关的所有系统资源。</span></span><br><span class="line"><span class="function">*  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>： 将 b.length 个字节从指定的 <span class="keyword">byte</span> 数组写入此输出流</span></span><br><span class="line"><span class="function">*  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> ：将指定 <span class="keyword">byte</span> 数组中从偏移量 off 开始的 len 个字节写入此输出流。</span></span><br><span class="line"><span class="function">* <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> ： 将指定的字节写入此输出流。</span></span><br></pre></td></tr></table></figure><h3 id="03字节输出流FileOutputStream写字节"><a href="#03字节输出流FileOutputStream写字节" class="headerlink" title="03字节输出流FileOutputStream写字节"></a>03字节输出流FileOutputStream写字节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输出流FileOutputStream写字节</span><br><span class="line">* a: FileOutputStream</span><br><span class="line">* 写入数据文件,学习父类方法,使用子类对象                   </span><br><span class="line">* <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">* b: FileOutputStream构造方法</span></span><br><span class="line"><span class="function">* 作用：绑定输出的输出目的 </span></span><br><span class="line"><span class="function">* <span class="title">FileOutputStream</span><span class="params">(File file)</span> </span></span><br><span class="line"><span class="function">* 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br><span class="line"><span class="function">* <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> </span></span><br><span class="line"><span class="function">* 创建一个向指定 File 对象表示的文件中写入数据的文件输出流，以追加的方式写入。</span></span><br><span class="line"><span class="function">* <span class="title">FileOutputStream</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">* 创建一个向具有指定名称的文件中写入数据的输出文件流。</span></span><br><span class="line"><span class="function">* <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> </span></span><br><span class="line"><span class="function">* 创建一个向具有指定 name 的文件中写入数据的输出文件流，以追加的方式写入。</span></span><br><span class="line"><span class="function">* c: 流对象使用步骤</span></span><br><span class="line"><span class="function">*  1. 创建流子类的对象,绑定数据目的</span></span><br><span class="line"><span class="function">*  2. 调用流对象的方法write写</span></span><br><span class="line"><span class="function">*  3. close释放资源</span></span><br><span class="line"><span class="function">* d: 注意事项</span></span><br><span class="line"><span class="function">* 流对象的构造方法,可以创建文件,如果文件存在,直接覆盖</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* e: 案例代码</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function"> *   FileOutputStream</span></span><br><span class="line"><span class="function"> *   写入数据文件,学习父类方法,使用子类对象</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   子类中的构造方法: 作用:绑定输出的输出目的</span></span><br><span class="line"><span class="function"> *     参数:</span></span><br><span class="line"><span class="function"> *       File    封装文件</span></span><br><span class="line"><span class="function"> *       String  字符串的文件名</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   流对象使用步骤</span></span><br><span class="line"><span class="function"> *     1. 创建流子类的对象,绑定数据目的</span></span><br><span class="line"><span class="function"> *     2. 调用流对象的方法write写</span></span><br><span class="line"><span class="function"> *     3. close释放资源</span></span><br><span class="line"><span class="function"> *     </span></span><br><span class="line"><span class="function"> *    流对象的构造方法,可以创建文件,如果文件存在,直接覆盖</span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileOutputStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="comment">//流对象的方法write写数据</span></span><br><span class="line"><span class="comment">//写1个字节</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04字节输出流FileOutputStream写字节数组"><a href="#04字节输出流FileOutputStream写字节数组" class="headerlink" title="04字节输出流FileOutputStream写字节数组"></a>04字节输出流FileOutputStream写字节数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输出流FileOutputStream写字节数组</span><br><span class="line">* a: 方法介绍</span><br><span class="line">*  <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span>： 将 b.length 个字节从指定的 <span class="keyword">byte</span> 数组写入此输出流</span></span><br><span class="line"><span class="function">*  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> ：将指定 <span class="keyword">byte</span> 数组中从偏移量 off 开始的 len 个字节写入此输出流。</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   FileOutputStream</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   写入数据文件,学习父类方法,使用子类对象</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   </span></span></span><br><span class="line"><span class="function"><span class="comment"> *   子类中的构造方法: 作用:绑定输出的输出目的</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     参数:</span></span></span><br><span class="line"><span class="function"><span class="comment"> *       File    封装文件</span></span></span><br><span class="line"><span class="function"><span class="comment"> *       String  字符串的文件名</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   </span></span></span><br><span class="line"><span class="function"><span class="comment"> *   流对象使用步骤</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     1. 创建流子类的对象,绑定数据目的</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     2. 调用流对象的方法write写</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     3. close释放资源</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     </span></span></span><br><span class="line"><span class="function"><span class="comment"> *    流对象的构造方法,可以创建文件,如果文件存在,直接覆盖</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileOutputStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="comment">//流对象的方法write写数据</span></span><br><span class="line"><span class="comment">//写字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">fos.write(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写字节数组的一部分,开始索引,写几个</span></span><br><span class="line">fos.write(bytes, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字节数组的简便方式</span></span><br><span class="line"><span class="comment">//写字符串</span></span><br><span class="line">fos.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05文件的续写和换行符号"><a href="#05文件的续写和换行符号" class="headerlink" title="05文件的续写和换行符号"></a>05文件的续写和换行符号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A: 文件的续写和换行符号</span><br><span class="line">* a: 文件的续写</span><br><span class="line">*  FileOutputStream构造方法, 的第二个参数中,加入<span class="keyword">true</span></span><br><span class="line">* b: 换行符号</span><br><span class="line">* 在文件中,写入换行,符号换行  \r\n</span><br><span class="line">* \r\n 可以写在上一行的末尾, 也可以写在下一行的开头</span><br><span class="line">* c: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  FileOutputStream 文件的续写和换行问题</span></span><br><span class="line"><span class="comment"> *  续写: FileOutputStream构造方法, 的第二个参数中,加入true</span></span><br><span class="line"><span class="comment"> *  在文件中,写入换行,符号换行  \r\n</span></span><br><span class="line"><span class="comment"> *  \r\n 可以写在上一行的末尾, 也可以写在下一行的开头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\b.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);</span><br><span class="line">fos.write(<span class="string">"hello\r\n"</span>.getBytes());</span><br><span class="line">fos.write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06IO中的异常处理"><a href="#06IO中的异常处理" class="headerlink" title="06IO中的异常处理"></a>06IO中的异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* A: IO中的异常处理</span><br><span class="line">* a:IO流的异常处理</span><br><span class="line">* <span class="keyword">try</span> <span class="keyword">catch</span> <span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">* b: 细节</span><br><span class="line">* <span class="number">1</span>. 保证流对象变量,作用域足够</span><br><span class="line">* <span class="number">2</span>. <span class="keyword">catch</span>里面,怎么处理异常</span><br><span class="line">* 输出异常的信息,目的看到哪里出现了问题</span><br><span class="line">* 停下程序,从新尝试</span><br><span class="line">* <span class="number">3</span>. 如果流对象建立失败了,需要关闭资源吗</span><br><span class="line">* <span class="keyword">new</span> 对象的时候,失败了,没有占用系统资源</span><br><span class="line">* 释放资源的时候,对流对象判断<span class="keyword">null</span></span><br><span class="line">* 变量不是<span class="keyword">null</span>,对象建立成功,需要关闭资源</span><br><span class="line"></span><br><span class="line">* c: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//try 外面声明变量,try 里面建立对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"s:\\a.txt"</span>);</span><br><span class="line">fos.write(<span class="number">100</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件写入失败,重试"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fos!=<span class="keyword">null</span>)</span><br><span class="line">  fos.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭资源失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07字节输入流InputStream"><a href="#07字节输入流InputStream" class="headerlink" title="07字节输入流InputStream"></a>07字节输入流InputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输入流InputStream</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">abstract</span>  <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ：</span></span><br><span class="line"><span class="function">* 从输入流中读取数据的下一个字节。</span></span><br><span class="line"><span class="function">* 下一个数据字节；如果已到达文件末尾，则返回 -1。</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span>  </span></span><br><span class="line"><span class="function">* 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">* 将输入流中最多 len 个数据字节读入 <span class="keyword">byte</span> 数组。</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">* 关闭此输入流并释放与该流关联的所有系统资源。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   字节输入流</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     java.io.InputStream 所有字节输入流的超类</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   作用: 读取任意文件,每次只读取1个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   读取的方法  read</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     int  read() 读取1个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     int  read(byte[] b) 读取一定量的字节,存储到数组中</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class InputStreamDemo </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08字节输入流FileInputStream读取字节"><a href="#08字节输入流FileInputStream读取字节" class="headerlink" title="08字节输入流FileInputStream读取字节"></a>08字节输入流FileInputStream读取字节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输入流FileInputStream读取字节</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">abstract</span>  <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ：</span></span><br><span class="line"><span class="function">* 从输入流中读取数据的下一个字节，返回-1表示文件结束</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span>  </span></span><br><span class="line"><span class="function">* 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="function">* 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">* 将输入流中最多 len 个数据字节读入 <span class="keyword">byte</span> 数组。</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">* 关闭此输入流并释放与该流关联的所有系统资源。</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  FileInputStream读取文件</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  </span></span></span><br><span class="line"><span class="function"><span class="comment"> *  构造方法: 为这个流对象绑定数据源</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  </span></span></span><br><span class="line"><span class="function"><span class="comment"> *    参数: </span></span></span><br><span class="line"><span class="function"><span class="comment"> *      File 类型对象</span></span></span><br><span class="line"><span class="function"><span class="comment"> *      String 对象</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   输入流读取文件的步骤</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     1. 创建字节输入流的子类对象</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     2. 调用读取方法read读取</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     3. 关闭资源</span></span></span><br><span class="line"><span class="function"><span class="comment"> *     </span></span></span><br><span class="line"><span class="function"><span class="comment"> *     read()方法,</span></span></span><br><span class="line"><span class="function"><span class="comment"> *       read()执行一次,就会自动读取下一个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> *       返回值,返回的是读取到的字节, 读取到结尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileInputStreamDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="comment">//读取一个字节,调用方法read 返回int</span></span><br><span class="line"><span class="comment">//使用循环方式,读取文件,  循环结束的条件  read()方法返回-1</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//接受read方法的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( (len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09字节输入流FileInputStream读取字节数组"><a href="#09字节输入流FileInputStream读取字节数组" class="headerlink" title="09字节输入流FileInputStream读取字节数组"></a>09字节输入流FileInputStream读取字节数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节输入流FileInputStream读取字节数组</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span>  </span></span><br><span class="line"><span class="function">* 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</span></span><br><span class="line"><span class="function">* 读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">* 将输入流中最多 len 个数据字节读入 <span class="keyword">byte</span> 数组。</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  FileInputStream读取文件</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   读取方法  int read(byte[] b) 读取字节数组</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   数组作用: 缓冲的作用, 提高效率</span></span></span><br><span class="line"><span class="function"><span class="comment"> *   read返回的int,表示什么含义 读取到多少个有效的字节数</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileInputStreamDemo1 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="comment">// 创建字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = fis.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));<span class="comment">// ab</span></span><br><span class="line">System.out.println(len);<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">len = fis.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));<span class="comment">// cd</span></span><br><span class="line">System.out.println(len);<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">len = fis.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));<span class="comment">// ed</span></span><br><span class="line">System.out.println(len);<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">len = fis.read(b);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));<span class="comment">// ed</span></span><br><span class="line">System.out.println(len);<span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10字节输入流FileInputStream读取字节数组的实现原理"><a href="#10字节输入流FileInputStream读取字节数组的实现原理" class="headerlink" title="10字节输入流FileInputStream读取字节数组的实现原理"></a>10字节输入流FileInputStream读取字节数组的实现原理</h3><ul><li>A：字节输入流FileInputStream读取字节数组的实现原理</li><li>a: 原理<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547539019/samples/java%20files/%E8%AF%BB%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%9F%E7%90%86.jpg" alt="">        </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* b: 案例代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aa.txt"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> value;<span class="comment">//每次 fis.read(b) 读取字节的个数</span></span><br><span class="line">        <span class="keyword">while</span> ((value = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(b, <span class="number">0</span>, value, <span class="string">"GBK"</span>));</span><br><span class="line"><span class="comment">//每次只把value长度的byte类型数据 创建为字符串,"GBK"是国标编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"文件有误"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11文件复制原理"><a href="#11文件复制原理" class="headerlink" title="11文件复制原理"></a>11文件复制原理</h3><ul><li>A: 文件复制原理</li></ul><h3 id="12字节流复制文件读取单个字节"><a href="#12字节流复制文件读取单个字节" class="headerlink" title="12字节流复制文件读取单个字节"></a>12字节流复制文件读取单个字节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节流复制文件读取单个字节</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  将数据源 c:\\a.txt</span></span><br><span class="line"><span class="comment"> *  复制到 d:\\a.txt  数据目的</span></span><br><span class="line"><span class="comment"> *  字节输入流,绑定数据源</span></span><br><span class="line"><span class="comment"> *  字节输出流,绑定数据目的</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  输入,读取1个字节</span></span><br><span class="line"><span class="comment"> *  输出,写1个字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个流的对象变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//建立两个流的对象,绑定数据源和数据目的</span></span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\t.zip"</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\t.zip"</span>);</span><br><span class="line"><span class="comment">//字节输入流,读取1个字节,输出流写1个字节</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件复制失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fos!=<span class="keyword">null</span>)</span><br><span class="line">fos.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fis!=<span class="keyword">null</span>)</span><br><span class="line">fis.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13字节流复制文件读取字节数组"><a href="#13字节流复制文件读取字节数组" class="headerlink" title="13字节流复制文件读取字节数组"></a>13字节流复制文件读取字节数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">* A: 字节流复制文件读取字节数组</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  字节流复制文件</span></span><br><span class="line"><span class="comment"> *   采用数组缓冲提高效率</span></span><br><span class="line"><span class="comment"> *   字节数组</span></span><br><span class="line"><span class="comment"> *   FileInputStream 读取字节数组</span></span><br><span class="line"><span class="comment"> *   FileOutputStream 写字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy_1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\t.zip"</span>);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\t.zip"</span>);</span><br><span class="line"><span class="comment">//定义字节数组,缓冲</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line"><span class="comment">//读取数组,写入数组</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件复制失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fos!=<span class="keyword">null</span>)</span><br><span class="line">fos.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fis!=<span class="keyword">null</span>)</span><br><span class="line">fis.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">System.out.println(e-s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14编码表"><a href="#14编码表" class="headerlink" title="14编码表"></a>14编码表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 编码表</span><br><span class="line">* a: 定义：</span><br><span class="line">* 生活中字符和计算机二进制的对应关系表,就是编码表</span><br><span class="line">* b: 分类</span><br><span class="line">* <span class="number">1</span>、ascii： 一个字节中的<span class="number">7</span>位就可以表示。对应的字节都是正数。<span class="number">0</span>-xxxxxxx</span><br><span class="line">* <span class="number">2</span>、<span class="string">"iso-8859-1:拉丁码表"</span> latin，用了一个字节用的<span class="number">8</span>位。<span class="number">1</span>-xxxxxxx  负数。</span><br><span class="line">* <span class="number">3</span>、GB2312:简体中文码表。包含<span class="number">6000</span>-<span class="number">7000</span>中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数</span><br><span class="line">* <span class="string">"GBK:目前最常用的中文码表"</span>，<span class="number">2</span>万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是<span class="number">1</span>，第二字节开头是<span class="number">0</span></span><br><span class="line">* GB18030：最新的中文码表，目前还没有正式使用。</span><br><span class="line">* <span class="number">4</span>、unicode：国际标准码表:无论是什么文字，都用两个字节存储。</span><br><span class="line">* Java中的<span class="keyword">char</span>类型用的就是这个码表。<span class="keyword">char</span> c = <span class="string">'a'</span>;占两个字节。</span><br><span class="line">* Java中的字符串是按照系统默认码表来解析的。简体中文版 字符串默认的码表是GBK。</span><br><span class="line">* <span class="number">5</span>、UTF-<span class="number">8</span>:基于unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化，在每一个字节头加入了编码信息(后期到api中查找)。</span><br><span class="line">* <span class="number">6</span>、<span class="string">"能识别中文的码表：GBK、UTF-8 "</span>；正因为识别中文码表不唯一，涉及到了编码解码问题。</span><br><span class="line">* 对于我们开发而言；常见的编码 GBK  UTF-<span class="number">8</span>  ISO-<span class="number">8859</span>-<span class="number">1</span></span><br><span class="line">* 文字---&gt;(数字) ：编码。 “abc”.getBytes()  <span class="keyword">byte</span>[]</span><br><span class="line">* (数字)---&gt;文字  : 解码。 <span class="keyword">byte</span>[] b=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;  <span class="keyword">new</span> String(b)</span><br></pre></td></tr></table></figure><h3 id="15字符输出流写文本FileWriter类"><a href="#15字符输出流写文本FileWriter类" class="headerlink" title="15字符输出流写文本FileWriter类"></a>15字符输出流写文本FileWriter类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符输出流写文本FileWriter类,只能写<span class="string">"文本文件"</span></span><br><span class="line">* a: 方法介绍</span><br><span class="line">*  <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">*  写入单个字符</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span>  </span></span><br><span class="line"><span class="function">* 写入字符串</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">* 写入字符串的某一部分</span></span><br><span class="line"><span class="function">* <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span>  </span></span><br><span class="line"><span class="function">* 写入字符数组</span></span><br><span class="line"><span class="function">* <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  </span></span><br><span class="line"><span class="function">*  写入字符数组的某一部分</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function"> *   字符输出流</span></span><br><span class="line"><span class="function"> *     java.io.Writer 所有字符输出流的超类</span></span><br><span class="line"><span class="function"> *   写文件,写文本文件</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   写的方法 write</span></span><br><span class="line"><span class="function"> *     <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> 写1个字符</span></span><br><span class="line"><span class="function"> *     <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] c)</span>写字符数组</span></span><br><span class="line"><span class="function"> *     <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span>,<span class="keyword">int</span>)</span>字符数组一部分,开始索引,写几个</span></span><br><span class="line"><span class="function"> *     <span class="title">write</span><span class="params">(String s)</span> 写入字符串</span></span><br><span class="line"><span class="function"> *     </span></span><br><span class="line"><span class="function"> *   Writer类的子类对象 FileWriter</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   构造方法:  写入的数据目的</span></span><br><span class="line"><span class="function"> *     File 类型对象</span></span><br><span class="line"><span class="function"> *     String 文件名</span></span><br><span class="line"><span class="function"> *     </span></span><br><span class="line"><span class="function"> *   字符输出流写数据的时候,必须要运行一个功能,刷新功能</span></span><br><span class="line"><span class="function"> *   <span class="title">flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class WriterDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\1.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1个字符</span></span><br><span class="line">fw.write(<span class="number">100</span>);</span><br><span class="line">fw.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写1个字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] c = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">fw.write(c);</span><br><span class="line">fw.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写字符数组一部分</span></span><br><span class="line">fw.write(c, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">fw.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写如字符串</span></span><br><span class="line">fw.write(<span class="string">"hello"</span>);</span><br><span class="line">fw.flush();</span><br><span class="line"></span><br><span class="line">fw.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16字符输入流读取文本FileReader类"><a href="#16字符输入流读取文本FileReader类" class="headerlink" title="16字符输入流读取文本FileReader类"></a>16字符输入流读取文本FileReader类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符输入流读取文本FileReader类</span><br><span class="line">* a: 方法介绍</span><br><span class="line">*  <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">* 读取单个字符</span></span><br><span class="line"><span class="function">* <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> </span></span><br><span class="line"><span class="function">* 将字符读入数组</span></span><br><span class="line"><span class="function">* <span class="keyword">abstract</span>  <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span>  </span></span><br><span class="line"><span class="function">* 将字符读入数组的某一部分。</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function"> *  字符输入流读取文本文件,所有字符输入流的超类</span></span><br><span class="line"><span class="function"> *    java.io.Reader</span></span><br><span class="line"><span class="function"> *  专门读取文本文件</span></span><br><span class="line"><span class="function"> *  </span></span><br><span class="line"><span class="function"> *  读取的方法 : <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> *   <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> 读取1个字符</span></span><br><span class="line"><span class="function"> *   <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span> 读取字符数组</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   Reader类是抽象类,找到子类对象 FileReader</span></span><br><span class="line"><span class="function"> *   </span></span><br><span class="line"><span class="function"> *   构造方法: 绑定数据源</span></span><br><span class="line"><span class="function"> *     参数:</span></span><br><span class="line"><span class="function"> *        File  类型对象</span></span><br><span class="line"><span class="function"> *        String文件名</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class ReaderDemo </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">**要求文件的默认编码为GBK或者UTF-<span class="number">8</span>，不然会有中文乱码  **</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"c:\\1.txt"</span>);</span><br><span class="line"><span class="comment">/*int len = 0 ;</span></span><br><span class="line"><span class="comment">while((len = fr.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">System.out.print((char)len);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(ch))!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(ch,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17flush方法和close方法区别"><a href="#17flush方法和close方法区别" class="headerlink" title="17flush方法和close方法区别"></a>17flush方法和close方法区别</h3><ul><li>A: flush方法和close方法区别<br>*a: flush()方法</li><li>用来<strong>刷新缓冲区</strong>的,刷新后可以再次写出,流还可以继续使用,只有<strong>字符流FileWriter类</strong>才需要刷新<br>*b: close()方法</li><li>用来<strong>关闭流释放资源</strong>的,如果是带缓冲区的流对象的close()方法,<strong>不但会关闭流,还会再关闭流之前刷新缓冲区,</strong>关闭后不能再写出 </li></ul><h3 id="18字符流复制文本文件"><a href="#18字符流复制文本文件" class="headerlink" title="18字符流复制文本文件"></a>18字符流复制文本文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* A: 字符流复制文本文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  字符流复制文本文件,必须文本文件</span></span><br><span class="line"><span class="comment"> *  字符流查询本机默认的编码表,简体中文GBK</span></span><br><span class="line"><span class="comment"> *  FileReader读取数据源</span></span><br><span class="line"><span class="comment"> *  FileWriter写入到数据目的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy_2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fr = <span class="keyword">new</span> FileReader(<span class="string">"c:\\1.txt"</span>);</span><br><span class="line">fw = <span class="keyword">new</span> FileWriter(<span class="string">"d:\\1.txt"</span>);</span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(( len = fr.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">fw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">System.out.println(ex);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"复制失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fw!=<span class="keyword">null</span>)</span><br><span class="line">fw.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fr!=<span class="keyword">null</span>)</span><br><span class="line">fr.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"释放资源失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19总结"><a href="#19总结" class="headerlink" title="19总结"></a>19总结</h3><p>    IO流的分类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*- 字节流</span><br><span class="line">*- 字节输入流 InputStream 抽象类</span><br><span class="line">*-  FileInputStream 操作文件的字节输入流</span><br><span class="line">*- 字节输出流 OuputStream抽象类</span><br><span class="line">    *- FileOutputStream 操作文件的字节输出流</span><br><span class="line">*- 字符流</span><br><span class="line">*- 字符输入流 Reader抽象类</span><br><span class="line">*- InputStreamReader 输入操作的转换流</span><br><span class="line">*- FileReader 用来操作文件的字符输入流（简便的流）</span><br><span class="line">*- 字符输出流 Writer抽象类</span><br><span class="line">*- OutputStreamWriter 输出操作的转换流</span><br><span class="line">*- FileWriter 用来操作文件的字符输出流（简便的流）</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281416/samples/java%20files/photo-1546258115-a6fe51f88baf.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、字节流&lt;br&gt;2、字符流&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础20(IO,File类,递归)</title>
    <link href="https://leesen998.github.io/2016/11/16/day22%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/16/day22笔记/</id>
    <published>2016-11-16T11:48:29.000Z</published>
    <updated>2019-01-14T14:10:22.524Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281635/samples/java%20files/photo-1544923945-e07f34b7f311.jpg" alt="" style="width:100%"></p><p>1、File<br>2、递归</p><a id="more"></a><h3 id="01IO技术概述"><a href="#01IO技术概述" class="headerlink" title="01IO技术概述"></a>01IO技术概述</h3><ul><li>A:IO技术概述</li><li>a: Output</li><li>把内存中的数据存储到持久化设备上这个动作称为输出（写）Output操作</li><li>b: Input</li><li>把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作</li><li>c: IO操作</li><li>把上面的这种输入和输出动作称为IO操作</li></ul><h3 id="02File类的概述和作用"><a href="#02File类的概述和作用" class="headerlink" title="02File类的概述和作用"></a>02File类的概述和作用</h3><ul><li>A:File类的概述和作用</li><li>a: File的概念</li><li>File类是文件和目录路径名的抽象表示形式</li><li>Java中把文件或者目录（文件夹）都封装成File对象</li><li>我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可</li></ul><h3 id="03File类静态的成员变量"><a href="#03File类静态的成员变量" class="headerlink" title="03File类静态的成员变量"></a>03File类静态的成员变量</h3><ul><li>A:File类静态的成员变量</li><li>a: pathSeparator</li><li>与系统有关的路径分隔符，为了方便，它被表示为一个字符串</li><li>windows中是一个分号； </li><li>Linux中是冒号 :</li><li>b: separator</li><li>与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串</li><li>windows中向右 \</li><li><p>Linux /</p></li><li><p>c: 案例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  java.io.File</span></span><br><span class="line"><span class="comment">*    将操作系统中的,文件,目录(文件夹),路径,封装成File对象</span></span><br><span class="line"><span class="comment">*    提供方法,操作系统中的内容</span></span><br><span class="line"><span class="comment">*    File与系统无关的类</span></span><br><span class="line"><span class="comment">*    文件 file</span></span><br><span class="line"><span class="comment">*    目录 directory</span></span><br><span class="line"><span class="comment">*    路径 path</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//File类静态成员变量</span></span><br><span class="line"><span class="comment">//与系统有关的路径分隔符</span></span><br><span class="line">String separator = File.pathSeparator;</span><br><span class="line">System.out.println(separator);<span class="comment">// windows中是一个分号,</span></span><br><span class="line"><span class="comment">//目录的分割(window中环境变量配置各个路径用分号分割，表示一个完整的路径结束)  Linux中是冒号 :</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与系统有关的默认名称分隔符</span></span><br><span class="line">separator = File.separator;</span><br><span class="line">System.out.println(separator);<span class="comment">// windows中向右 \  目录名称分割  Linux / </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04File类构造方法-1"><a href="#04File类构造方法-1" class="headerlink" title="04File类构造方法_1"></a>04File类构造方法_1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* A: File类构造方法_1</span><br><span class="line">* a: File(String pathname)</span><br><span class="line">* 通过将给定路径名字符串转换为一个File对象,之后可以使用File中的方法</span><br><span class="line">* <span class="string">"windows中的路径或文件名不区分大小写"</span></span><br><span class="line">* d: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File(String pathname)</span></span><br><span class="line"><span class="comment"> *  传递路径名: 可以写到文件夹,可以写到一个文件</span></span><br><span class="line"><span class="comment"> *  c:\\abc   c:\\abc\\Demo.java</span></span><br><span class="line"><span class="comment"> *  将路径封装File类型对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse"</span>);</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="05相对路径和绝对路径"><a href="#05相对路径和绝对路径" class="headerlink" title="05相对路径和绝对路径"></a>05相对路径和绝对路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* A: 相对路径和绝对路径</span><br><span class="line">* a: 绝对路径</span><br><span class="line">* 绝对路径是一个固定的路径,从盘符开始</span><br><span class="line">* b: 相对路径</span><br><span class="line">* 相对路径相对于某个位置,在eclipse下是指当前项目下</span><br><span class="line">* c: 路径</span><br><span class="line">绝对路径</span><br><span class="line">在系统中具有唯一性</span><br><span class="line">c:\\windows\\system32</span><br><span class="line">相对路径</span><br><span class="line">表示路径之间的关系</span><br><span class="line">D:\\develop\\Java\\jdk1.7.0_72\\bin</span><br><span class="line">D:\\develop\\Java\\jre7</span><br><span class="line">路径之间关系</span><br><span class="line">Java 父目录是D:\\develop</span><br><span class="line">Java 子目录是：jdk1.7.0_72</span><br><span class="line">父路径是 唯一性</span><br><span class="line">子目录是可以多个</span><br></pre></td></tr></table></figure><h3 id="06File类的构造方法-2"><a href="#06File类的构造方法-2" class="headerlink" title="06File类的构造方法_2"></a>06File类的构造方法_2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* A: File类的构造方法_2</span><br><span class="line">* a:File(String parent, String child) </span><br><span class="line">* 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 对象</span><br><span class="line"></span><br><span class="line">* b: File(File parent, String child)</span><br><span class="line"></span><br><span class="line">* c: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line">*</span><br><span class="line"> *  File(File parent,String child)</span><br><span class="line"> *  <span class="string">"传递路径,传递File类型父路径,字符串子路径"</span></span><br><span class="line"> *  <span class="string">"好处: 父路径是File类型,父路径可以直接调用File类方法"</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">File parent = <span class="keyword">new</span> File(<span class="string">"d:"</span>);</span><br><span class="line">File file = <span class="keyword">new</span> File(parent,<span class="string">"eclipse"</span>);</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"> *  File(String parent,String child)</span><br><span class="line"> *  <span class="string">"传递路径,传递字符串父路径,字符串子路径</span></span><br><span class="line"><span class="string"> *  好处: 单独操作父路径和子路径"</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:"</span>,<span class="string">"eclipse"</span>);</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="07File类创建文件功能"><a href="#07File类创建文件功能" class="headerlink" title="07File类创建文件功能"></a>07File类创建文件功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* A: File类创建文件功能</span><br><span class="line">* a: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 创建文件 如果存在这样的文件，就不创建了</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileDemo2 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> *  File创建文件的功能</span></span><br><span class="line"><span class="string"> *  boolean createNewFile()</span></span><br><span class="line"><span class="string"> *  创建的文件路径和文件名,在File构造方法中给出</span></span><br><span class="line"><span class="string"> *  文件已经存在了,不再创建</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file.createNewFile();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08File类创建目录功能"><a href="#08File类创建目录功能" class="headerlink" title="08File类创建目录功能"></a>08File类创建目录功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* A: File类创建目录功能</span><br><span class="line">* a: 创建目录</span><br><span class="line">* <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span>:创建单层文件夹 如果存在这样的文件夹，就不创建了</span></span><br><span class="line"><span class="function">* <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span>:创建文件夹,如果父文件夹不存在，会帮你创建出来</span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileDemo2 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> *  File创建文件夹功能</span></span><br><span class="line"><span class="string"> *  boolean mkdirs() 创建多层文件夹</span></span><br><span class="line"><span class="string"> *  创建的路径也在File构造方法中给出</span></span><br><span class="line"><span class="string"> *  文件夹已经存在了,不在创建</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\abc"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file.mkdirs();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09File类删除功能"><a href="#09File类删除功能" class="headerlink" title="09File类删除功能"></a>09File类删除功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* A: File类删除功能</span><br><span class="line">* a: 删除功能</span><br><span class="line">* <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span>:删除文件或者文件夹</span></span><br><span class="line"><span class="function">* B: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileDemo2 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> *  File类的删除功能</span></span><br><span class="line"><span class="string"> *  boolean delete()</span></span><br><span class="line"><span class="string"> *  删除的文件或者是文件夹,在File构造方法中给出</span></span><br><span class="line"><span class="string"> *  删除成功返回true,删除失败返回false</span></span><br><span class="line"><span class="string"> *  删除方法,不走回收站,直接从硬盘中删除</span></span><br><span class="line"><span class="string"> *  删除有风险,运行需谨慎</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\a.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file.delete();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10File类获取功能"><a href="#10File类获取功能" class="headerlink" title="10File类获取功能"></a>10File类获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">* A：File类获取功能</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function">String <span class="title">getName</span><span class="params">()</span>: 返回路径中表示的文件或者文件夹名</span></span><br><span class="line"><span class="function">* 获取路径中的最后部分的名字</span></span><br><span class="line"><span class="function">* <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span>: 返回路径中表示的文件的字节数</span></span><br><span class="line"><span class="function">* String <span class="title">getAbsolutePath</span><span class="params">()</span>: 获取绝对路径,返回String对象</span></span><br><span class="line"><span class="function">* File   <span class="title">getAbsoluteFile</span><span class="params">()</span> : 获取绝对路径,返回File对象</span></span><br><span class="line"><span class="function">* eclipse环境中,写一个相对路径,绝对位置工程根目录</span></span><br><span class="line"><span class="function">* String <span class="title">getParent</span><span class="params">()</span>: 获取父路径,返回String对象</span></span><br><span class="line"><span class="function">* File <span class="title">getParentFile</span><span class="params">()</span>: 获取父路径,返回File对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileDemo3 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File类的获取功能</span></span><br><span class="line"><span class="comment"> * String getParent() 返回String对象</span></span><br><span class="line"><span class="comment"> * File getParentFile()返回File对象</span></span><br><span class="line"><span class="comment"> * 获取父路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse\\eclipse.exe"</span>);</span><br><span class="line">File parent = file.getParentFile();</span><br><span class="line">System.out.println(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File类获取功能</span></span><br><span class="line"><span class="comment"> * String getAbsolutePath() 返回String对象</span></span><br><span class="line"><span class="comment"> * File   getAbsoluteFile() 返回File对象</span></span><br><span class="line"><span class="comment"> * 获取绝对路径</span></span><br><span class="line"><span class="comment"> * eclipse环境中,写的是一个相对路径,绝对位置工程根目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src"</span>);</span><br><span class="line">File absolute = file.getAbsoluteFile();</span><br><span class="line">System.out.println(absolute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File类获取功能</span></span><br><span class="line"><span class="comment"> * long length()</span></span><br><span class="line"><span class="comment"> * 返回路径中表示的文件的字节数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse\\eclipse.exe"</span>);</span><br><span class="line"><span class="keyword">long</span> length = file.length();</span><br><span class="line">System.out.println(length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File类的获取功能</span></span><br><span class="line"><span class="comment"> *  String getName()</span></span><br><span class="line"><span class="comment"> *  返回路径中表示的文件或者文件夹名</span></span><br><span class="line"><span class="comment"> *  获取路径中的最后部分的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse\\eclipse.exe"</span>);</span><br><span class="line">String name = file.getName();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*String path = file.getPath();</span></span><br><span class="line"><span class="comment">System.out.println(path);*/</span></span><br><span class="line"><span class="comment">//System.out.println(file);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11File类判断功能"><a href="#11File类判断功能" class="headerlink" title="11File类判断功能"></a>11File类判断功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">* A: File类判断功能</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span>: 判断File构造方法中封装路径是否存在</span></span><br><span class="line"><span class="function">* 存在返回<span class="keyword">true</span>,不存在返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function">* <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span>: 判断File构造方法中封装的路径是不是文件夹</span></span><br><span class="line"><span class="function">* 如果是文件夹,返回<span class="keyword">true</span>,不是文件返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function">* <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span>: 判断File构造方法中封装的路径是不是文件</span></span><br><span class="line"><span class="function">* 如果是文件,返回<span class="keyword">true</span>,不是文件返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* b: 案例代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FileDemo4 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File判断功能</span></span><br><span class="line"><span class="comment"> *  boolean isDirectory()</span></span><br><span class="line"><span class="comment"> *  判断File构造方法中封装的路径是不是文件夹</span></span><br><span class="line"><span class="comment"> *  如果是文件夹,返回true,不是文件返回false</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  boolean isFile()</span></span><br><span class="line"><span class="comment"> *  判断File构造方法中封装的路径是不是文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse\\eclipse.exe"</span>);</span><br><span class="line"><span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line"><span class="keyword">boolean</span> b = file.isDirectory();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File判断功能</span></span><br><span class="line"><span class="comment"> *  boolean exists()</span></span><br><span class="line"><span class="comment"> *  判断File构造方法中封装路径是否存在</span></span><br><span class="line"><span class="comment"> *  存在返回true,不存在返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file.exists();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12File类list获取功能"><a href="#12File类list获取功能" class="headerlink" title="12File类list获取功能"></a>12File类list获取功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">* A: File类list获取功能</span><br><span class="line">* a: 方法介绍</span><br><span class="line">* String[] list()：获取到File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)</span><br><span class="line">* <span class="string">"返回只有名字"</span></span><br><span class="line">* File[] listFiles()：获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)</span><br><span class="line">* 返回的是目录或者文件的<span class="string">"全路径"</span></span><br><span class="line">* <span class="keyword">static</span> File[] listRoots(): 列出可用的文件系统根 </span><br><span class="line"></span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function_2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//获取系统中的所有根目录</span></span><br><span class="line">File[] fileArr = File.listRoots();</span><br><span class="line"><span class="keyword">for</span>(File f : fileArr)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File类的获取功能</span></span><br><span class="line"><span class="comment"> *  File[] listFiles()</span></span><br><span class="line"><span class="comment"> *  获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)</span></span><br><span class="line"><span class="comment"> *  返回的是目录或者文件的全路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse"</span>);</span><br><span class="line">File[] fileArr = file.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File f : fileArr)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  File类的获取功能</span></span><br><span class="line"><span class="comment"> *  String[] list()</span></span><br><span class="line"><span class="comment"> *  获取到,File构造方法中封装的路径中的文件和文件夹名 (遍历一个目录)</span></span><br><span class="line"><span class="comment"> *  返回只有名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:"</span>);</span><br><span class="line">String[] strArr = file.list();</span><br><span class="line">System.out.println(strArr.length);</span><br><span class="line"><span class="keyword">for</span>(String str : strArr)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13文件过滤器"><a href="#13文件过滤器" class="headerlink" title="13文件过滤器"></a>13文件过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">* A: 文件过滤器</span><br><span class="line">* a: 作用</span><br><span class="line">* <span class="string">"过滤一个目录下的指定扩展名的文件，或者包含某些关键字的文件夹"</span></span><br><span class="line"></span><br><span class="line">* b: 方法介绍</span><br><span class="line">* <span class="keyword">public</span> String[] list(FilenameFilter filter)</span><br><span class="line">* <span class="keyword">public</span> File[] listFiles(FileFilter filter)</span><br><span class="line"></span><br><span class="line">* C: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  自定义过滤器</span></span><br><span class="line"><span class="comment"> *  实现FileFilter接口,重写抽象方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span>  </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pathname 接受到的也是文件的全路径</span></span><br><span class="line"><span class="comment"> * c:\\demo\\1.txt</span></span><br><span class="line"><span class="comment"> * 对路径进行判断,如果是java文件,返回true,不是java文件,返回false</span></span><br><span class="line"><span class="comment"> * 文件的后缀结尾是.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//String name = pathname.getName();</span></span><br><span class="line"><span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".java"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> *  File类的获取,文件获取过滤器</span></span><br><span class="line"><span class="string"> *  遍历目录的时候,可以根据需要,只获取满足条件的文件</span></span><br><span class="line"><span class="string"> *  遍历目录方法 listFiles()重载形式</span></span><br><span class="line"><span class="string"> *  listFiles(FileFilter filter)接口类型</span></span><br><span class="line"><span class="string"> *  传递FileFilter接口的实现类</span></span><br><span class="line"><span class="string"> *  自定义FileFilter接口实现类,重写抽象方法,</span></span><br><span class="line"><span class="string"> *  接口实现类对象传递到遍历方法listFiles</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\demo"</span>);</span><br><span class="line">File[] fileArr = file.listFiles(<span class="keyword">new</span> MyFilter());</span><br><span class="line"><span class="keyword">for</span>(File f : fileArr)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14文件过滤器-原理分析"><a href="#14文件过滤器-原理分析" class="headerlink" title="14文件过滤器_原理分析"></a>14文件过滤器_原理分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* A:文件过滤器_原理分析</span><br><span class="line">* <span class="string">"listFiles()遍历目录的同时，获取到了文件名全路径，调用过滤器的方法accept，</span></span><br><span class="line"><span class="string">  将获取到的路径传递给accept方法的参数pathname"</span></span><br><span class="line">* accept方法接收了参数pathname，参数是listFiles传递来的</span><br><span class="line">* 在accept方法中，进行判断，如果这个路径是Java文件，返回<span class="keyword">true</span>，走着返回<span class="keyword">false</span></span><br><span class="line">* 一旦方法返回了<span class="keyword">true</span></span><br><span class="line">* listFiles将路径保存到File数组中</span><br></pre></td></tr></table></figure><h3 id="15递归遍历全目录"><a href="#15递归遍历全目录" class="headerlink" title="15递归遍历全目录"></a>15递归遍历全目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">* A: 递归遍历全目录</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  对一个目录的下的所有内容,进行完全的遍历</span></span><br><span class="line"><span class="comment"> *  编程技巧,方法的递归调用,自己调用自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"d:\\eclipse"</span>);</span><br><span class="line">getAllDir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,实现目录的全遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllDir</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">System.out.println(dir);</span><br><span class="line"><span class="comment">//调用方法listFiles()对目录,dir进行遍历</span></span><br><span class="line">File[] fileArr = dir.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File f : fileArr)&#123;</span><br><span class="line"><span class="comment">//判断变量f表示的路径是不是文件夹</span></span><br><span class="line"><span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line"><span class="comment">//是一个目录,就要去遍历这个目录</span></span><br><span class="line"><span class="comment">//本方法,getAllDir,就是给个目录去遍历</span></span><br><span class="line"><span class="comment">//继续调用getAllDir,传递他目录</span></span><br><span class="line">getAllDir(f);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16递归概念和注意事项"><a href="#16递归概念和注意事项" class="headerlink" title="16递归概念和注意事项"></a>16递归概念和注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* A:递归概念和注意事项</span><br><span class="line">* a: 递归概念</span><br><span class="line">* 递归，指在当前方法内调用自己的这种现象</span><br><span class="line">* 递归分为两种，直接递归和间接递归</span><br><span class="line">* 直接递归称为方法自身调用自己。间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法</span><br><span class="line">* b: 注意事项</span><br><span class="line">* 递归一定要有出口, 必须可以让程序停下</span><br><span class="line">* 递归次数不能过多</span><br><span class="line">* 构造方法,禁止递归</span><br></pre></td></tr></table></figure><h3 id="17递归求和计算"><a href="#17递归求和计算" class="headerlink" title="17递归求和计算"></a>17递归求和计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* A: 递归求和计算</span><br><span class="line">* a: 题目分析</span><br><span class="line">* <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+(n-<span class="number">1</span>)+n:求<span class="number">1</span>到n的和</span><br><span class="line">* 总结规律：<span class="number">1</span>到n的和等于<span class="number">1</span>到(n-<span class="number">1</span>)的和再加n</span><br><span class="line">* getSum(n-<span class="number">1</span>)+ n</span><br><span class="line">* 递归出口：getSum(<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法的递归调用</span></span><br><span class="line"><span class="comment"> *    方法自己调用自己</span></span><br><span class="line"><span class="comment"> *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化</span></span><br><span class="line"><span class="comment"> *  注意:</span></span><br><span class="line"><span class="comment"> *     递归一定要有出口, 必须可以让程序停下</span></span><br><span class="line"><span class="comment"> *     递归次数不能过多</span></span><br><span class="line"><span class="comment"> *     构造方法,禁止递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = getSum(<span class="number">3</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  计算 1+2+3+100和 = 5050</span></span><br><span class="line"><span class="comment"> *  计算规律:</span></span><br><span class="line"><span class="comment"> *    n+(n-1)+(n-2)</span></span><br><span class="line"><span class="comment"> *    100+(100-1)+(99-1)+...1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n + getSum(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18递归求阶乘"><a href="#18递归求阶乘" class="headerlink" title="18递归求阶乘"></a>18递归求阶乘</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* A: 递归求和计算</span><br><span class="line">* a: 题目分析</span><br><span class="line">* <span class="number">5</span>!=<span class="number">5</span>*<span class="number">4</span>*<span class="number">3</span>*<span class="number">2</span>*<span class="number">1</span></span><br><span class="line">*   =<span class="number">5</span>*<span class="number">4</span>!</span><br><span class="line">* <span class="number">4</span>!=<span class="number">4</span>*<span class="number">3</span>!</span><br><span class="line">* <span class="number">3</span>!=<span class="number">3</span>*<span class="number">2</span>!</span><br><span class="line">* <span class="number">2</span>!=<span class="number">2</span>*<span class="number">1</span>!</span><br><span class="line">* <span class="number">1</span>!=<span class="number">1</span></span><br><span class="line">* n!=n*(n-<span class="number">1</span>)!</span><br><span class="line">* 递归出口：n*getJieCheng(n-<span class="number">1</span>):  getJieCheng(<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法的递归调用</span></span><br><span class="line"><span class="comment"> *    方法自己调用自己</span></span><br><span class="line"><span class="comment"> *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化</span></span><br><span class="line"><span class="comment"> *  注意:</span></span><br><span class="line"><span class="comment"> *     递归一定要有出口, 必须可以让程序停下</span></span><br><span class="line"><span class="comment"> *     递归次数不能过多</span></span><br><span class="line"><span class="comment"> *     构造方法,禁止递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getJieCheng(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> *  计算阶乘 5!</span></span><br><span class="line"><span class="comment"> *   5*4*3*2*1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getJieCheng</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * getJieCheng(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19递归计算斐波那契数列"><a href="#19递归计算斐波那契数列" class="headerlink" title="19递归计算斐波那契数列"></a>19递归计算斐波那契数列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* A: 递归计算斐波那契数列</span><br><span class="line">* a：题目分析</span><br><span class="line">* <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span></span><br><span class="line">* 从第三项开始，后面的每一项都等于前面两项的和，第一项和第二项的值为<span class="number">1</span>，作为程序的出口</span><br><span class="line">* b: 案例代码</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法的递归调用</span></span><br><span class="line"><span class="comment"> *    方法自己调用自己</span></span><br><span class="line"><span class="comment"> *  适合于,方法中运算的主体不变,但是运行的时候,参与运行的方法参数会变化</span></span><br><span class="line"><span class="comment"> *  注意:</span></span><br><span class="line"><span class="comment"> *     递归一定要有出口, 必须可以让程序停下</span></span><br><span class="line"><span class="comment"> *     递归次数不能过多</span></span><br><span class="line"><span class="comment"> *     构造方法,禁止递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(getFBNQ(<span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法递归,计算斐波那契数列</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFBNQ</span><span class="params">(<span class="keyword">int</span> month)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( month == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( month == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> getFBNQ(month-<span class="number">1</span>)+getFBNQ(month-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20遍历目录下的所有java文件"><a href="#20遍历目录下的所有java文件" class="headerlink" title="20遍历目录下的所有java文件"></a>20遍历目录下的所有java文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">* A: 遍历目录下的所有java文件</span><br><span class="line">* a: 案例代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJavaFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断获取的是目录,直接返回true</span></span><br><span class="line"><span class="keyword">if</span>(pathname.isDirectory())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  遍历目录,获取目录下的所有.java文件</span></span><br><span class="line"><span class="comment"> *  遍历多级目录,方法递归实现</span></span><br><span class="line"><span class="comment"> *  遍历的过程中,使用过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">getAllJava(<span class="keyword">new</span> File(<span class="string">"c:\\demo"</span>));</span><br><span class="line"><span class="comment">//new File("c:\\demo").delete();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义方法,实现遍历指定目录</span></span><br><span class="line"><span class="comment"> * 获取目录中所有的.java文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllJava</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line"><span class="comment">//调用File对象方法listFiles()获取,加入过滤器</span></span><br><span class="line">File[] fileArr = dir.listFiles(<span class="keyword">new</span> MyJavaFilter());</span><br><span class="line"><span class="keyword">for</span>(File f : fileArr)&#123;</span><br><span class="line"><span class="comment">//对f路径,判断是不是文件夹</span></span><br><span class="line"><span class="keyword">if</span>(f.isDirectory())&#123;</span><br><span class="line"><span class="comment">//递归进入文件夹遍历</span></span><br><span class="line">getAllJava(f);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21总结"><a href="#21总结" class="headerlink" title="21总结"></a>21总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">递归： 方法定义中调用方法本身的现象</span><br><span class="line">直接递归</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">methodA();</span><br><span class="line">&#125;</span><br><span class="line">间接递归</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">metohdB</span><span class="params">()</span></span>&#123;</span><br><span class="line">methodC();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">methodB();</span><br><span class="line">&#125;</span><br><span class="line">递归注意实现</span><br><span class="line">要有出口，否则就是死递归</span><br><span class="line">次数不能太多，否则就内存溢出</span><br><span class="line"></span><br><span class="line">File: 文件和目录路径名的抽象表示形式</span><br><span class="line">构造方法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span> 通过给定的文件或文件夹的路径，来创建对应的File对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span> 通过给定的父文件夹路径，与给定的文件名称或目录名称来创建对应的File对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,  String child)</span>通过给定的File对象的目录路径，与给定的文件夹名称或文件名称来创建对应的File对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">路径的分类：</span></span><br><span class="line"><span class="function">绝对路径, 带盘盘符E:\Workspace\day20_File\abc.txt</span></span><br><span class="line"><span class="function">相对路径， 不带盘符day20_File\abc.txt</span></span><br><span class="line"><span class="function">注意： 当指定一个文件路径的时候，如果采用的是相对路径，默认的目录为 项目的根目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span>创建文件</span></span><br><span class="line"><span class="function">返回值为<span class="keyword">true</span>， 说明创建文件成功</span></span><br><span class="line"><span class="function">返回值为<span class="keyword">false</span>，说明文件已存在，创建文件失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> 创建单层文件夹</span></span><br><span class="line"><span class="function">创建文件夹成功，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function">创建文件夹失败，返回 <span class="keyword">false</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> 创建多层文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function">删除此抽象路径名表示的文件或目录。</span></span><br><span class="line"><span class="function">如果此路径名表示一个目录，则该目录必须为空才能删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> 判断是否为文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> 判断是否为文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> 判断File对象对应的文件或文件夹是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span> 获取当前File的绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> 获取当前File对象的文件或文件夹名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> 获取当前File对象的文件或文件夹的大小（字节）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">()</span> 获取File所代表目录中所有文件或文件夹的绝对路径</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1547281635/samples/java%20files/photo-1544923945-e07f34b7f311.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、File&lt;br&gt;2、递归&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础19(异常、throw、try...catch、finally、Throwable类))</title>
    <link href="https://leesen998.github.io/2016/11/01/day21%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/11/01/day21笔记/</id>
    <published>2016-11-01T11:48:29.000Z</published>
    <updated>2018-12-11T06:59:30.513Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544254144/samples/java%20files/photo-1542312455-e31bb150371c.jpg" alt="" style="width:100%"></p><p>1、异常概述和继承体系<br>2、异常原因以及处理方式<br>3、运行时期异常<br>4、方法重写的异常处理<br>5、Throwable类常见方法<br>6、自定义异常 </p><a id="more"></a><h3 id="01异常的概述"><a href="#01异常的概述" class="headerlink" title="01异常的概述"></a>01异常的概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* A: 异常的概述</span><br><span class="line">* a:什么是异常</span><br><span class="line">* Java代码在运行时期发生的问题就是异常。</span><br><span class="line">* b:异常类</span><br><span class="line">* 在Java中，把异常信息封装成了一个类。</span><br><span class="line">* 当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。</span><br><span class="line">* c：我们见过的异常：数组角标越界异常ArrayIndexOutOfBoundsException,空指针异常NullPointerException</span><br></pre></td></tr></table></figure><h3 id="02异常的继续体系和错误的区别"><a href="#02异常的继续体系和错误的区别" class="headerlink" title="02异常的继续体系和错误的区别"></a>02异常的继续体系和错误的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* A: 异常的继承体系</span><br><span class="line">Throwable: 它是所有错误与异常的超类（祖宗类）</span><br><span class="line">|- Error 错误</span><br><span class="line">|- Exception 编译期异常,进行编译JAVA程序时出现的问题</span><br><span class="line">|- RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</span><br><span class="line">* B：异常与错误的区别</span><br><span class="line">* a：<span class="string">"异常Exception"</span></span><br><span class="line">* 指程序在<span class="string">"编译、运行期间"</span>发生了某种<span class="string">"异常(XxxException)"</span>，我们可以对异常进行具体的处理。</span><br><span class="line">* 若不处理异常，程序将会结束运行。</span><br><span class="line">* 案例演示：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，</span></span><br><span class="line"><span class="comment">// 由于没有处理异常，导致程序无法继续执行，程序结束。</span></span><br><span class="line">System.out.println(<span class="string">"over"</span>); <span class="comment">// 由于上面代码发生了异常，此句代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* b：<span class="string">"错误Error"</span></span><br><span class="line">* 指程序在<span class="string">"运行期间"</span>发生了某种<span class="string">"错误(XxxError)"</span>，Error错误通常<span class="string">"没有具体的处理方式"</span>，程序将会结束运行。</span><br><span class="line">* Error错误的发生往往都是<span class="string">"系统级别"</span>的问题，都是<span class="string">"jvm所在系统"</span>发生的，并反馈给jvm的。</span><br><span class="line">* 我们无法针对处理，<span class="string">"只能修正代码"</span>。</span><br><span class="line">* 案例演示：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];</span><br><span class="line"><span class="comment">//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，</span></span><br><span class="line"><span class="comment">//导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="03异常对象的产生原因和处理方式"><a href="#03异常对象的产生原因和处理方式" class="headerlink" title="03异常对象的产生原因和处理方式"></a>03异常对象的产生原因和处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* A: 异常对象的产生原因</span><br><span class="line">* 案例代码：</span><br><span class="line">* 工具类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span></span>&#123;</span><br><span class="line"><span class="comment">//对给定的数组通过给定的角标获取元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> element = arr[index];</span><br><span class="line"><span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* 测试类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(arr,<span class="number">4</span>)</span><br><span class="line">System.out.println(<span class="string">"num="</span>+num);</span><br><span class="line">System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">* 原因分析：</span><br><span class="line">* a: 由于没找到<span class="number">4</span>索引，导致运行时发生了异常。这个异常JVM认识：ArrayIndexOutOfBoundsException。</span><br><span class="line">这个异常Java本身有描述：异常的名称、异常的内容、异常的产生位置。</span><br><span class="line">java将这些信息直接封装到异常对象中。<span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="number">4</span>);</span><br><span class="line">* b：<span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="number">4</span>);产生异常对象。JVM将产生的异常抛给调用者main()方法。</span><br><span class="line">* c：main()方法接收到了数组索引越界异常对象。</span><br><span class="line">由于main()方法并没有进行处理异常，main()方法就会继续把异常抛给调用者JVM。</span><br><span class="line">当JVM收到异常后，将异常对象中的名称、异常内容、位置都显示在就控制台上。同时让程序立刻终止。</span><br><span class="line">* B：异常的处理方式</span><br><span class="line">* a：JVM的默认处理方式</span><br><span class="line">* 把异常的名称,原因,位置等信息输出在控制台，同时会结束程序。</span><br><span class="line">* 一旦有异常发生，其后来的代码不能继续执行。</span><br><span class="line">* b：解决程序中异常的手动方式</span><br><span class="line">* a)：编写处理代码 <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">* b)：抛出 <span class="keyword">throws</span></span><br><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="04方法内部抛出对象throw关键字"><a href="#04方法内部抛出对象throw关键字" class="headerlink" title="04方法内部抛出对象throw关键字"></a>04方法内部抛出对象throw关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在java中，提供了一个<span class="keyword">throw</span>关键字，它用来抛出一个指定的异常对象。</span><br><span class="line">* A: 什么时候使用<span class="keyword">throw</span>关键字？</span><br><span class="line">* 当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，</span><br><span class="line">  数据若不合法，就应该告诉调用者，传递合法的数据进来。</span><br><span class="line">  这时需要使用抛出异常的方式来告诉调用者。</span><br><span class="line">* B: 使用<span class="keyword">throw</span>关键字具体操作</span><br><span class="line">* a: 创建一个异常对象。封装一些提示信息(信息可以自己编写)。</span><br><span class="line">* b: 通过关键字<span class="keyword">throw</span>将这个异常对象告知给调用者。<span class="keyword">throw</span> 异常对象；</span><br><span class="line"><span class="keyword">throw</span> 用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</span><br><span class="line">* C: <span class="keyword">throw</span>关键字使用格式</span><br><span class="line">* <span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br><span class="line">* 例如：</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br><span class="line">* D：案例演示</span><br><span class="line">* <span class="keyword">throw</span>的使用</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="05方法声明异常关键字throws"><a href="#05方法声明异常关键字throws" class="headerlink" title="05方法声明异常关键字throws"></a>05方法声明异常关键字throws</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">* A: 声明</span><br><span class="line">* 将问题标识出来，报告给调用者。如果方法内通过<span class="keyword">throw</span>抛出了编译时异常，</span><br><span class="line">而<span class="string">"没有捕获处理"</span>（稍后讲解该方式），那么<span class="string">"必须通过"</span><span class="keyword">throws</span>进行声明，让<span class="string">"调用者去处理"</span>。</span><br><span class="line">* B: 声明异常格式</span><br><span class="line">* 修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>… &#123;   &#125;</span><br><span class="line">* C：注意事项：</span><br><span class="line">* <span class="keyword">throws</span>用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在<span class="keyword">throws</span>后面可以写多个异常类，用逗号隔开。</span><br><span class="line">* D：代码演示：</span><br><span class="line">* 多个异常的处理</span><br><span class="line"></span><br><span class="line"><span class="string">"//方法声明异常关键字"</span> <span class="keyword">throws</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//        func(arr);</span></span><br><span class="line">        func(trt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06try…catch异常处理"><a href="#06try…catch异常处理" class="headerlink" title="06try…catch异常处理"></a>06try…catch异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">* A: 捕获</span><br><span class="line">* Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理</span><br><span class="line">* B: 捕获异常格式</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="string">"//需要被检测的语句。"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line"><span class="string">"//异常的处理语句。"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="string">"//一定会被执行的语句。"</span></span><br><span class="line">&#125;</span><br><span class="line">* C: 格式说明</span><br><span class="line"> * a: <span class="keyword">try</span></span><br><span class="line">* 该代码块中编写可能产生异常的代码。</span><br><span class="line"> * b: <span class="keyword">catch</span></span><br><span class="line">* 用来进行某种异常的捕获，实现对捕获到的异常进行处理。</span><br><span class="line"> * c: <span class="keyword">finally</span>：</span><br><span class="line">* <span class="string">"有一些特定的代码无论异常是否发生，都需要执行"</span>。</span><br><span class="line">* 另外，因为<span class="string">"异常会引发程序【跳转】到"</span><span class="keyword">catch</span>语句处，<span class="string">"导致有些语句执行不到"</span>。</span><br><span class="line">* 而<span class="keyword">finally</span>就是解决这个问题的，在<span class="keyword">finally</span>代码块中存放的<span class="string">"代码都是【一定】会被执行"</span>的。</span><br><span class="line"> * d：<span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="string">"处理掉异常后，程序可以继续执行"</span></span><br><span class="line">* D：案例演示</span><br><span class="line">* 捕获异常格式</span><br><span class="line"></span><br><span class="line"><span class="string">"//try…catch异常处理"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> result = func(arr);<span class="string">"//异常发生后后，程序将发生跳转到catch处执行"</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="string">"//try异常后面的语句不会执行"</span></span><br><span class="line">            System.out.println(<span class="string">"result: "</span>+ result);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序继续执行..."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="07多catch处理"><a href="#07多catch处理" class="headerlink" title="07多catch处理"></a>07多catch处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">* A：一个<span class="keyword">try</span> 多个<span class="keyword">catch</span>组合 </span><br><span class="line">* 对代码进行异常检测，并对检测的异常传递给<span class="keyword">catch</span>处理。对每种异常信息进行不同的捕获处理。</span><br><span class="line">* B：多<span class="keyword">catch</span>处理的格式</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意事项：在捕获异常处理中，变量也是有作用域的，如可以定义多个<span class="keyword">catch</span>中异常变量名为e。</span><br><span class="line"></span><br><span class="line"><span class="string">"//多catch处理"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> result = func(arr);<span class="comment">//异常发生后后，程序将发生跳转到catch出执行</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="comment">//try异常后面的语句不会执行</span></span><br><span class="line"><span class="comment">//            System.out.println("result: "+ result);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(NullPointerException nullex)&#123;</span><br><span class="line">            System.out.println(nullex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException outboundex)&#123;</span><br><span class="line">            System.out.println(outboundex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"程序继续执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> NullPointerException,ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08多catch处理细节"><a href="#08多catch处理细节" class="headerlink" title="08多catch处理细节"></a>08多catch处理细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* A：细节：多个<span class="keyword">catch</span>小括号中，写的是异常类的类名，有没有顺序的概念？</span><br><span class="line">* 有顺序关系。</span><br><span class="line">* B：<span class="string">"平级异常"</span>：</span><br><span class="line">* 抛出的<span class="string">"异常类之间"</span>,<span class="string">"没有"</span><span class="string">"继承关系"</span>,<span class="string">"没有顺序"</span></span><br><span class="line">NullPointerException extends RuntimeException</span><br><span class="line">NoSuchElementException extends RuntimeException</span><br><span class="line">ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException extends RuntimeException</span><br><span class="line">* C：<span class="string">"上下级关系(继承关系)的异常"</span></span><br><span class="line">* 越高级的<span class="string">"父类"</span>,越<span class="string">"写在下面"</span>，《考虑多态的影响》</span><br><span class="line">NullPointerException extends RuntimeException extends Exception</span><br></pre></td></tr></table></figure><h3 id="09finally代码块"><a href="#09finally代码块" class="headerlink" title="09finally代码块"></a>09finally代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">* A: <span class="keyword">finally</span>的特点</span><br><span class="line">  * <span class="string">"无论"</span><span class="keyword">try</span>...<span class="keyword">catch</span>语句<span class="string">"有没有异常出现"</span>，被<span class="keyword">finally</span>控制的<span class="string">"语句体"</span>一定<span class="string">"会执行"</span>，</span><br><span class="line">  * <span class="string">"除非"</span>发生<span class="string">"异常时"</span>在<span class="keyword">catch</span>语句中 有 <span class="string">"System.exit(0)"</span> 或者 <span class="keyword">try</span>语句外部<span class="string">"前面"</span><span class="string">"有异常"</span>出现;</span><br><span class="line">* B：<span class="keyword">finally</span>的作用</span><br><span class="line">  * <span class="keyword">finally</span>,无论程序是否有异常出现,程序必须执行释放资源在</span><br><span class="line">  如：IO流操作和数据库操作中会见到</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> [] trt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> [] ere = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ano = func(ere);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int result = func(arr);//异常发生后后，程序将发生跳转到catch处执行</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"ano: "</span>+ ano);<span class="comment">//try异常后面的语句不会执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"无论有无异常，这里的代码均会执行..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> [] arr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数组对象是空指针"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组元素为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="09finally代码块中有return语句"><a href="#09finally代码块中有return语句" class="headerlink" title="09finally代码块中有return语句"></a>09finally代码块中有return语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">警告： 当 <span class="keyword">finally</span> 子句包含 <span class="keyword">return</span> 语句时， 将会出现一种意想不到的结果。</span><br><span class="line">假设利用 <span class="keyword">return</span>语句从 <span class="keyword">try</span>语句块中退出。在<span class="string">"方法返回前"</span>，<span class="keyword">finally</span> 子句的内容<span class="string">"将【先被】执行"</span>。</span><br><span class="line">如果 <span class="keyword">finally</span> 子句中也有一个 <span class="keyword">return</span> 语句， 这个<span class="string">"返回值"</span>将会<span class="string">"【覆盖】"</span><span class="string">"原始的返回值"</span>。</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = n * n;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">如果调用 f(<span class="number">2</span>), 那么 <span class="keyword">try</span> 语句块的计算结果为 r = <span class="number">4</span>, 并执行 <span class="keyword">return</span> 语句然而，在方法真</span><br><span class="line">正返回前</span><br><span class="line">，还要执行 <span class="keyword">finally</span> 子句。<span class="keyword">finally</span> 子句将使得方法返回 <span class="number">0</span>, 这个返回值覆盖了原</span><br><span class="line">始的返回值 <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="10try…catch…finally代码块详解"><a href="#10try…catch…finally代码块详解" class="headerlink" title="10try…catch…finally代码块详解"></a>10try…catch…finally代码块详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchFinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"//1"</span></span><br><span class="line"><span class="string">"code that might throw exceptions"</span></span><br><span class="line"><span class="string">"//2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"// 3"</span></span><br><span class="line"><span class="string">"show error message"</span></span><br><span class="line"><span class="string">"// 4"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"// 5"</span></span><br><span class="line">in.close()；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//6"</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在上面这段代码中，有下列 <span class="number">3</span> 种情况会执行 <span class="keyword">finally</span> 子句：</span><br><span class="line"><span class="number">1</span> ) <span class="string">"代码【没有】抛出异常"</span>。 在这种情况下， 程序首先执行 <span class="keyword">try</span> 语句块中的<span class="string">"全部代码"</span>，</span><br><span class="line">然后执行 <span class="keyword">finally</span> 子句中的代码 。随后， 继续执行 <span class="keyword">try</span>...<span class="keyword">finally</span>  语句块之<span class="string">"后的"</span>第一条<span class="string">"语句"</span>。</span><br><span class="line">也就是说，执行标注的 <span class="number">1</span>、 <span class="number">2</span>、 <span class="number">5</span>、 <span class="number">6</span> 处。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ) <span class="string">"抛出"</span>一个在 <span class="keyword">catch</span> 子句中<span class="string">"捕获的异常"</span>。在上面的示例中就是 IOException 异常。在这种</span><br><span class="line">情况下，程序将执行 <span class="keyword">try</span>语句块中的所有代码，<span class="string">"直到发生异常为止"</span>。此时，将<span class="string">"跳过"</span> <span class="keyword">try</span>语句块中</span><br><span class="line">的<span class="string">"剩余代码"</span>， 转去<span class="string">"执行与该异常匹配"</span>的 <span class="keyword">catch</span> 子句中的代码， 最后执行 <span class="keyword">finally</span> 子句中的代码。</span><br><span class="line">【分为以下<span class="number">2</span>种情况】：</span><br><span class="line">  A:如果 <span class="keyword">catch</span> 子句<span class="string">"没有抛出异常"</span>， 程序将执行 <span class="keyword">try</span> 语句块之后的第一条语句。</span><br><span class="line">  在这里，执行标注 <span class="number">1</span>、 <span class="number">3</span>、 <span class="number">4</span>、<span class="number">5</span>、 <span class="number">6</span> 处的语句。</span><br><span class="line"></span><br><span class="line">  B:如果 <span class="keyword">catch</span> 子句<span class="string">"抛出了一个异常"</span>， <span class="string">"异常"</span>将被<span class="string">"抛回"</span>这个方法的<span class="string">"调用者"</span>。</span><br><span class="line">  在这里， 执行标注<span class="number">1</span>、 <span class="number">3</span>、 <span class="number">5</span> 处的语句，<span class="string">"注意"</span>语句<span class="number">6</span><span class="string">"将不再执行"</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> ) 代码<span class="string">"抛出了一个异常"</span>， <span class="string">"但这个异常【不是】"</span>由 <span class="keyword">catch</span> 子句<span class="string">"捕获"</span>的。在这种情况下， 程序将</span><br><span class="line">执行 <span class="keyword">try</span> 语句块中的所有语句，<span class="string">"直到有异常被抛出为止"</span>。此时， 将<span class="string">"跳过"</span> <span class="keyword">try</span> 语句块中的<span class="string">"剩余代码"</span>， </span><br><span class="line">然后执行 <span class="keyword">finally</span>子句中的语句， 并将异常抛给这个方法的调用者。</span><br><span class="line">在这里， 执行标注 <span class="number">1</span>、<span class="number">5</span> 处的语句。<span class="string">"注意"</span>语句<span class="number">6</span><span class="string">"将不再执行"</span>。</span><br><span class="line"></span><br><span class="line">即：<span class="keyword">try</span>语句<span class="string">"抛出异常"</span>，但是<span class="keyword">catch</span><span class="string">"没有捕获"</span>的<span class="string">"异常"</span>或者 <span class="keyword">catch</span>语句<span class="string">"自身出现异常"</span>，<span class="number">6</span>处的代码<span class="string">"不会执行"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> 语句<span class="string">"可以只有"</span> <span class="keyword">finally</span> 子句，而<span class="string">"没有"</span><span class="keyword">catch</span> 子句。例如，下面这条 <span class="keyword">try</span> 语句：</span><br><span class="line">InputStream in = ...；</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">in.close()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10调用抛出异常方法try和throws处理方式"><a href="#10调用抛出异常方法try和throws处理方式" class="headerlink" title="10调用抛出异常方法try和throws处理方式"></a>10调用抛出异常方法try和throws处理方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* A: 在实际开发中使用哪种异常处理方式呢，</span><br><span class="line">* 继续向上<span class="keyword">throws</span> Exception 还是用 <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span>处理异常 ？</span><br><span class="line">* 能自己处理的尽量自己处理。(建议用<span class="keyword">try</span>...<span class="keyword">catch</span>)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span></span><br><span class="line"><span class="function">从给定字符串的开始解析文本，以生成一个日期。该方法不使用给定字符串的整个文本。 </span></span><br><span class="line"><span class="function">该方法本身会 <span class="keyword">throws</span> <span class="title">ParseException</span>  <span class="params">(声明可能抛出的异常)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class TryCatch_ThowsDemo </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ParseException ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date dd = sdf.parse(<span class="string">"2088-8-8"</span>);</span><br><span class="line">        System.out.println(dd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11运行时期异常RuntimeException的特点"><a href="#11运行时期异常RuntimeException的特点" class="headerlink" title="11运行时期异常RuntimeException的特点"></a>11运行时期异常RuntimeException的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* A: 运行时期异常的概述: </span><br><span class="line"> * RuntimeException和<span class="string">"他的所有子类异常"</span>,都属于<span class="string">"运行时期异常"</span>。</span><br><span class="line"> 如常见的 NullPointerException,ArrayIndexOutOfBoundsException 等都属于运行时期异常.</span><br><span class="line">* B：运行时期异常的特点</span><br><span class="line"> * a：方法中<span class="string">"抛出运行时期异常"</span>,方法定义中<span class="string">"无需"</span><span class="keyword">throws</span><span class="string">"声明"</span>,调用者也<span class="string">"无需处理此异常"</span>。</span><br><span class="line"> * b：<span class="string">"运行时期异常一旦发生,【一定】是源代码发生了错误，需要程序人员【修改】【源代码】"</span>。</span><br><span class="line">设计原因:</span><br><span class="line">运行异常,不能发生,但是如果发生了,程序人员停止程序修改源代码</span><br><span class="line">运行异常: 一旦发生,不要处理,请你修改源代码,运行异常一旦发生,后面的代码没有执行的意义</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>) 抛出<span class="string">"Exception"</span>，<span class="string">"必须要"</span><span class="keyword">throws</span><span class="string">"声明"</span>，</span><br><span class="line">一声明就<span class="string">"告知"</span><span class="string">"调用者"</span>进行<span class="string">"捕获"</span>，一旦<span class="string">"问题处理了"</span>调用者的<span class="string">"程序会继续执行"</span>。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 抛出<span class="string">"RuntimeExcpetion"</span>,<span class="string">"不需要"</span><span class="keyword">throws</span><span class="string">"声明"</span>的，</span><br><span class="line">这时调用是<span class="string">"不需要编写捕获代码"</span>的，因为调用者根本就不知道有问题。</span><br><span class="line">一旦发生RuntimeException，<span class="string">"调用者程序会停掉"</span>，</span><br><span class="line">并有jvm将信息显示到屏幕，让调用者看到问题，<span class="string">"修正代码"</span>。</span><br></pre></td></tr></table></figure><h3 id="12运行异常的案例"><a href="#12运行异常的案例" class="headerlink" title="12运行异常的案例"></a>12运行异常的案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* A: 计算圆的面积案例</span><br><span class="line">定义方法,计算圆形的面积</span><br><span class="line">传递参数<span class="number">0</span>,或者负数,计算的时候没有问题</span><br><span class="line">但是,违反了真实情况</span><br><span class="line">参数小于=<span class="number">0</span>, 停止程序,不要在计算了</span><br><span class="line">* B：数组索引越界案例</span><br><span class="line">使用数组中不存在的索引</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeExceptionDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = getArea(<span class="number">1</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,计算圆形的面积</span></span><br><span class="line"><span class="comment"> *  传递参数0,或者负数,计算的时候没有问题</span></span><br><span class="line"><span class="comment"> *  但是,违反了真实情况</span></span><br><span class="line"><span class="comment"> *  参数小于=0, 停止程序,不要在计算了</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> 方法中<span class="string">"抛出运行时期异常"</span>,方法定义中<span class="string">"无需"</span><span class="keyword">throws</span><span class="string">"声明"</span>,调用者也<span class="string">"无需处理此异常"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"圆形不存在"</span>);</span><br><span class="line"><span class="keyword">return</span> r*r*Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//对数组的5索引进行判断,如果5索引大于100,请将3索引上的数据/2,否则除以3</span></span><br><span class="line"><span class="comment">//索引根本就没有</span></span><br><span class="line"><span class="keyword">if</span>(arr[<span class="number">3</span>] &gt; <span class="number">100</span>)&#123;</span><br><span class="line">arr[<span class="number">3</span>] = arr[<span class="number">3</span>]/<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[<span class="number">3</span>] = arr[<span class="number">3</span>]/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13方法重写时候异常的处理"><a href="#13方法重写时候异常的处理" class="headerlink" title="13方法重写时候异常的处理"></a>13方法重写时候异常的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* A：方法重写时候异常的处理</span><br><span class="line">* a：<span class="string">"子类"</span>覆盖<span class="string">"父类"</span>方法时，</span><br><span class="line">*   如果<span class="string">"父类"</span>的<span class="string">"方法"</span><span class="string">"声明异常"</span>，<span class="string">"子类"</span><span class="string">"只能"</span>声明<span class="string">"父类异常"</span>或者<span class="string">"父类异常的子类"</span>，或者<span class="string">"不声明"</span>。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123; &#125;  <span class="string">"//抛出父类一样的异常"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="string">"//抛出父类异常的子类"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125; <span class="string">"//不声明异常"</span></span><br><span class="line">&#125;</span><br><span class="line">* b：当<span class="string">"父类方法"</span>声明<span class="string">"多个异常"</span>时，<span class="string">"子类"</span><span class="string">"覆盖"</span>时<span class="string">"只能"</span>声明<span class="string">"多个异常"</span>的<span class="string">"子集"</span>(注意是<span class="string">"子集"</span>)。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="string">"//抛出父类异常中的一部分"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException </span>&#123; &#125; <span class="string">"//抛出父类异常中的一部分"</span></span><br><span class="line">&#125;</span><br><span class="line">* c：当<span class="string">"父类"</span>被覆盖的<span class="string">"方法"</span><span class="string">"没有"</span><span class="string">"异常声明"</span>时，<span class="string">"子类"</span>覆盖时<span class="string">"不能"</span><span class="string">"声明异常"</span>。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; &#125; ！！！error /<span class="string">"错误的方式"</span></span><br><span class="line">&#125;</span><br><span class="line">* B：问题：父类中会存在下列这种情况，接口也有这种情况。</span><br><span class="line">接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</span><br><span class="line">回答：无法进行<span class="keyword">throws</span>声明，只能<span class="keyword">catch</span>的捕获。</span><br><span class="line">万一问题处理不了呢？<span class="keyword">catch</span>中继续<span class="keyword">throw</span>抛出，但是只能将异常转换成RuntimeException子类抛出。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; <span class="comment">//无法声明 throws Exception</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//只能捕获处理</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"哥们，你定义的数组arr是空的!"</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"父方法中没有异常抛出，子类中不能抛出Exception异常"</span>);</span><br><span class="line">    <span class="comment">//我们把异常对象e，采用RuntimeException异常方式抛出</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14Throwable类方法"><a href="#14Throwable类方法" class="headerlink" title="14Throwable类方法"></a>14Throwable类方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">* A: 常见方法</span><br><span class="line">* a：<span class="string">"getMessage()方法"</span></span><br><span class="line">返回该异常的详细信息字符串，即<span class="string">"异常提示信息"</span></span><br><span class="line"></span><br><span class="line">* b：<span class="string">"toString()方法"</span></span><br><span class="line">返回该<span class="string">"异常的名称"</span>与<span class="string">"详细信息字符串"</span></span><br><span class="line"></span><br><span class="line">* c：<span class="string">"printStackTrace()方法"</span></span><br><span class="line">在控制台输出<span class="string">"该异常的名称"</span>与<span class="string">"详细信息字符串"</span>、<span class="string">"异常出现的代码【位置】"</span></span><br><span class="line">* B：案例演示</span><br><span class="line">异常的常用方法代码演示</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p= <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(“出现空指针异常了，请检查对象是否为<span class="keyword">null</span>”);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">String message = e.getMesage();</span><br><span class="line">System.out.println(message ); </span><br><span class="line"></span><br><span class="line">String result = e.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"--------------------------------------------1"</span>);</span><br><span class="line">            System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"--------------------------------------------2"</span>);</span><br><span class="line">            System.out.println(ex.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"---------------------------------------------3"</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=arr.length)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组长度是"</span>+ arr.length +<span class="string">", 数组越界了..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15自定义异常类"><a href="#15自定义异常类" class="headerlink" title="15自定义异常类"></a>15自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">* A: 自定义异常的定义</span><br><span class="line">例如NullPointerException异常类源代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="string">"//调用父类构造方法"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);<span class="string">"//调用父类具有异常信息的构造方法"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* a：通过阅读源码，发现规律：</span><br><span class="line">  每个异常中都<span class="string">"调用了父类的构造方法"</span>，把<span class="string">"异常描述信息"</span><span class="string">"传递"</span>给了<span class="string">"父类"</span>，</span><br><span class="line">  让<span class="string">"父类"</span>帮我们<span class="string">"进行异常信息的封装"</span>。</span><br><span class="line">* b：<span class="string">"格式"</span>：</span><br><span class="line">Class 异常名 extends Exception&#123; <span class="string">"//或继承RuntimeException"</span></span><br><span class="line"><span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 异常名(String s)&#123; </span><br><span class="line"><span class="keyword">super</span>(s); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* c：自定义异常<span class="string">"继承Exception"</span>演示</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="comment">// 如果自定义异常需要异常信息，</span></span><br><span class="line"><span class="comment">//可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* d：自定义异常<span class="string">"继承RuntimeException"</span>演示</span><br><span class="line">* <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyException()&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">MyException(String message)&#123;</span><br><span class="line"><span class="comment">// 如果自定义异常需要异常信息，</span></span><br><span class="line"><span class="comment">//可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">* B：自定义异常的练习</span><br><span class="line">在Person类的有参数构造方法中，进行年龄范围的判断，</span><br><span class="line">若年龄为负数或大于<span class="number">200</span>岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。</span><br><span class="line">要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。</span><br><span class="line"></span><br><span class="line"><span class="string">"//自定义异常类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgeException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//Person类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> AgeException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeException(<span class="string">"年龄输入有误:"</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">        <span class="keyword">this</span>.age =age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名： "</span>+ name + <span class="string">" |年龄: "</span>+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//测试类"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person p= <span class="keyword">new</span> Person(<span class="string">"张楠"</span>, <span class="number">209</span>);</span><br><span class="line">            System.out.println(p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(AgeException aex)&#123;</span><br><span class="line">            aex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">* C：关于构造方法<span class="string">"抛出异常总结"</span></span><br><span class="line">(<span class="number">1</span>) 抛出<span class="string">"Exception"</span>，<span class="string">"必须要"</span><span class="keyword">throws</span><span class="string">"声明"</span>，</span><br><span class="line">一声明就<span class="string">"告知"</span><span class="string">"调用者"</span>进行<span class="string">"捕获"</span>，一旦<span class="string">"问题处理了"</span>调用者的<span class="string">"程序会继续执行"</span>。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 抛出<span class="string">"RuntimeExcpetion"</span>,<span class="string">"不需要"</span><span class="keyword">throws</span><span class="string">"声明"</span>的，</span><br><span class="line">这时调用是<span class="string">"不需要编写捕获代码"</span>的，因为调用者根本就不知道有问题。</span><br><span class="line">一旦发生RuntimeException，<span class="string">"调用者程序会停掉"</span>，</span><br><span class="line">并有jvm将信息显示到屏幕，让调用者看到问题，<span class="string">"修正代码"</span>。</span><br></pre></td></tr></table></figure><h3 id="16总结"><a href="#16总结" class="headerlink" title="16总结"></a>16总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> 异常：就是程序中出现的不正常的现象(错误与异常)</span><br><span class="line"> 异常的继承体系:</span><br><span class="line">Throwable: 它是所有错误与异常的超类（祖宗类）</span><br><span class="line">|- Error 错误，修改java源代码</span><br><span class="line">|- Exception 编译期异常, javac.exe进行编译的时候报错</span><br><span class="line">|- RuntimeException 运行期异常, java出现运行过程中出现的问题</span><br><span class="line"></span><br><span class="line"> 异常处理的两种方式：</span><br><span class="line"> <span class="number">1</span>，出现问题，自己解决 <span class="keyword">try</span>…<span class="keyword">catch</span>…<span class="keyword">finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">可能出现异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名  对象名)&#123;</span><br><span class="line">    异常处理代码 </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">异常操作中一定要执行的代码</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">2</span>，出现问题，别人解决 <span class="keyword">throws</span></span><br><span class="line">格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>,...&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"> 异常分类</span><br><span class="line">异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。</span><br><span class="line"> 严重错误Error，无法通过处理的错误</span><br><span class="line"> 编译时异常Exception，编译时无法编译通过。如日期格式化异常</span><br><span class="line"> 运行时异常RuntimeException，是Exception的子类，运行时可能会报错，可以不处理。如空指针异常</span><br><span class="line"></span><br><span class="line"> 异常基本操作</span><br><span class="line"> 创建异常对象</span><br><span class="line"> 抛出异常</span><br><span class="line"> 处理异常：</span><br><span class="line"> 捕获处理，将异常获取，使用<span class="keyword">try</span>/<span class="keyword">catch</span>做分支处理</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">需要检测的异常；</span><br><span class="line">&#125;  <span class="keyword">catch</span>(异常对象) &#123;</span><br><span class="line">通常我们只使用一个方法：printStackTrace打印异常信息</span><br><span class="line">&#125;</span><br><span class="line"> <span class="string">"声明抛出处理"</span>，<span class="string">"出现异常后不处理"</span>，<span class="string">"声明抛出给调用者处理"</span>。</span><br><span class="line">  方法声明上加<span class="keyword">throws</span>  异常类名</span><br><span class="line"> <span class="string">"注意"</span>：异常的处理，指处理<span class="string">"异常"</span>的<span class="string">"一种可能性"</span>，即有了异常处理的代码，<span class="string">"不一定"</span>会<span class="string">"产生异常"</span>。</span><br><span class="line">如果没有产生异常，则代码正常执行，如果产生了异常，则中断当前执行代码，执行异常处理代码。</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"> 异常注意事项</span><br><span class="line"> 多异常处理</span><br><span class="line">捕获处理：</span><br><span class="line">        <span class="number">1</span>多个异常可以分别处理</span><br><span class="line"><span class="number">2</span>多个异常一次捕获多次处理</span><br><span class="line"><span class="number">3</span>多个异常一次捕获，采用同一种方式处理</span><br><span class="line">声明抛出异常：</span><br><span class="line">声明上使用,一次声明多个异常</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"> <span class="string">"运行时异常"</span>被抛出可以<span class="string">"不处理"</span>。<span class="string">"即不捕获"</span><span class="string">"也不声明抛出"</span></span><br><span class="line"></span><br><span class="line"> 如果<span class="string">"父类"</span>抛出了<span class="string">"多个异常"</span>,<span class="string">"子类覆盖父类方法"</span>时,<span class="string">"只能"</span>抛出相同的异常或者是他的<span class="string">"子集"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">"父类"</span>方法<span class="string">"没有"</span>抛出异常，<span class="string">"子类覆盖父类该方法"</span>时也<span class="string">"不可抛出异常"</span>。</span><br><span class="line">  此时子类产生该异常，只能捕获处理，不能声明抛出</span><br><span class="line"></span><br><span class="line"> 当<span class="string">"多"</span><span class="keyword">catch</span>异常处理时，捕获处理，<span class="string">"前边的类"</span><span class="string">"不能"</span>是<span class="string">"后边类"</span>的<span class="string">"父类"</span></span><br><span class="line"></span><br><span class="line"> 自定义异常</span><br><span class="line">如果Java没有提供你需要的异常，则可以自定义异常类。</span><br><span class="line">定义方法：编译时异常继承Exception，运行时异常继承RuntimeException。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1544254144/samples/java%20files/photo-1542312455-e31bb150371c.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、异常概述和继承体系&lt;br&gt;2、异常原因以及处理方式&lt;br&gt;3、运行时期异常&lt;br&gt;4、方法重写的异常处理&lt;br&gt;5、Throwable类常见方法&lt;br&gt;6、自定义异常 &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础18(Map接口、HashMap集合、LinkedHashMap集合、集合嵌套))</title>
    <link href="https://leesen998.github.io/2016/10/29/day20%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/29/day20笔记/</id>
    <published>2016-10-29T11:48:29.000Z</published>
    <updated>2018-12-19T02:02:26.326Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544080580/samples/java%20files/photo-1541706140-fd57c55e85e6.jpg" alt="" style="width:100%"></p><p>1、Map接口<br>2、HashMap集合、LinkedHashMap集合<br>3、集合的嵌套<br>4、集合应用举例 </p><a id="more"></a><h3 id="01Map集合概述"><a href="#01Map集合概述" class="headerlink" title="01Map集合概述"></a>01Map集合概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A:Map集合概述:</span><br><span class="line">我们通过查看Map接口描述,发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同</span><br><span class="line"> a:Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</span><br><span class="line"></span><br><span class="line"> b:Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</span><br><span class="line"> </span><br><span class="line"><span class="string">"Collection中的集合称为【单列集合】，Map中的集合称为【双列集合】"</span>。</span><br><span class="line">需要注意的是，</span><br><span class="line"><span class="string">"Map中的集合【不能】包含【重复的键】"</span>，【<span class="string">"值】可以重复"</span>；<span class="string">"每个【键】只能对应一个【值】"</span>。</span><br><span class="line"><span class="string">"如果添加【重复的键】，会把之前的【键值】【覆盖】掉"</span></span><br><span class="line">Map</span><br><span class="line"> |--HashMap</span><br><span class="line"> |--LinkedHashMap</span><br></pre></td></tr></table></figure><h3 id="02Map接口中的常用方法"><a href="#02Map接口中的常用方法" class="headerlink" title="02Map接口中的常用方法"></a>02Map接口中的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">A:Map接口中的常用方法 </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  Map接口中的常用方法</span></span><br><span class="line"><span class="comment">    *    使用Map接口的实现类 HashMap</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   function_2();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  移除集合中的键值对,【返回】被【移除】之前的【值】</span></span><br><span class="line"><span class="string">    *  V remove(K)</span></span><br><span class="line"><span class="string">    *  如果集合中【没有】这个【键】,【返回null】，不移除任何元素</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">   map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">   map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">   map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">   System.out.println(map);</span><br><span class="line">   </span><br><span class="line">   String value = map.remove(<span class="number">33</span>);<span class="comment">//null</span></span><br><span class="line">   System.out.println(value);</span><br><span class="line">   System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    * 通过键对象,获取值对象</span></span><br><span class="line"><span class="string">    * V get(K)</span></span><br><span class="line"><span class="string">    * 如果集合中【没有】这个【键】,【返回null】</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建集合对象,作为键的对象整数,值的对象存储字符串</span></span><br><span class="line">   Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">   map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">   map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">   map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">   System.out.println(map);</span><br><span class="line">   </span><br><span class="line">   String value = map.get(<span class="number">4</span>);<span class="comment">//null</span></span><br><span class="line">   System.out.println(value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  将键值对存储到集合中</span></span><br><span class="line"><span class="string">    *  V put(K,V) K 作为键的对象, V作为值的对象</span></span><br><span class="line"><span class="string">    *  返回值：以前与 key 关联的值，如果没有针对 key 的映射关系，则返回 null。</span></span><br><span class="line"><span class="string">    *  存储的是重复的键,将原有的值,覆盖</span></span><br><span class="line"><span class="string">    *  返回值一般情况下返回null,</span></span><br><span class="line"><span class="string">    *  存储重复键的时候,返回被覆盖之前的值</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//创建集合对象,HashMap,存储对象,键是字符串,值是整数</span></span><br><span class="line">   Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">   map.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">   map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">   map.put(<span class="string">"c"</span>, <span class="number">3</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">Java <span class="number">8</span> 为 Map 新增的方法</span><br><span class="line"></span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer action)</span>: </span></span><br><span class="line"><span class="function">该方法是 Java 8 为 Map 新增的 一个遍历 key-value 对的方法 ，</span></span><br><span class="line"><span class="function">通过该方法可以更简洁地遍历 Map 的 key-value 对 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; Object <span class="title">replace</span><span class="params">(Object key, Object value)</span> : </span></span><br><span class="line"><span class="function">将 Map 中指定 key 对应的 value 替换成新value。</span></span><br><span class="line"><span class="function">与传统<span class="title">put</span><span class="params">()</span>方法不同的是，该方法【不可能添加新的 key-value 对】 。</span></span><br><span class="line"><span class="function"> 如果尝试替换的 key 在原 Map 中不存在，该方法不会添加 key-value 对 ， 而是返回 <span class="keyword">null</span> 。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; Object <span class="title">computelfAbsent</span><span class="params">(Object key, Function mappingFunction)</span>: </span></span><br><span class="line"><span class="function">如 果传给该方法的 key 参数在Map 中对应的 value 为 <span class="keyword">null</span> ，</span></span><br><span class="line"><span class="function">则使用 mappingFunction 根据 key 计算一个新的结果，如果计算结</span></span><br><span class="line"><span class="function">果不为 <span class="keyword">null</span> ，则用计算结果覆盖原有的 value。如果原 Map 原来不包括该 key，那么该方法可能</span></span><br><span class="line"><span class="function">会添加一组 key-value 对。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; Object <span class="title">computelfPresent</span><span class="params">(Object key, BiFunction remappingFunction)</span>: </span></span><br><span class="line"><span class="function">如果传给该方法的 key 参数在 Map 中对应的 value 不为 <span class="keyword">null</span> ， </span></span><br><span class="line"><span class="function">该方法将使用 remappingFunction 根据原 key、 value 计算一个</span></span><br><span class="line"><span class="function">新的结果 ，如果计算结果不为 <span class="keyword">null</span> ，则使用该结果覆盖原来的 value</span>; 如果计算结果为 <span class="keyword">null</span> ，则</span><br><span class="line">删除原 key-value 对 。</span><br></pre></td></tr></table></figure><h3 id="03Map集合遍历方式keySet方法"><a href="#03Map集合遍历方式keySet方法" class="headerlink" title="03Map集合遍历方式keySet方法"></a>03Map集合遍历方式keySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">A:Map集合遍历方式<span class="string">"keySet方法"</span></span><br><span class="line"> <span class="number">1</span>.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</span><br><span class="line"> <span class="number">2</span>.遍历键的Set集合，得到每一个键</span><br><span class="line"> <span class="number">3</span>.根据键利用get(key)去Map找所对应的值</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  Map集合的遍历</span></span><br><span class="line"><span class="string">  *    利用键获取值</span></span><br><span class="line"><span class="string">  *    Map接口中定义方法keySet</span></span><br><span class="line"><span class="string">  *    所有的键,存储到Set集合</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  1. 调用map集合的方法keySet,所有的键存储到Set集合中</span></span><br><span class="line"><span class="string">  *  2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)</span></span><br><span class="line"><span class="string">  *  3. 调用map集合方法get,通过键获取到值</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line"> map.put(<span class="string">"a"</span>, <span class="number">11</span>);</span><br><span class="line"> map.put(<span class="string">"b"</span>, <span class="number">12</span>);</span><br><span class="line"> map.put(<span class="string">"c"</span>, <span class="number">13</span>);</span><br><span class="line"> map.put(<span class="string">"d"</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="string">"//1. 调用map集合的方法keySet,所有的键存储到Set集合中"</span></span><br><span class="line"> Set&lt;String&gt; set = map.keySet();</span><br><span class="line"> <span class="string">"//2. 遍历Set集合,获取出Set集合中的所有元素 (Map中的键)"</span></span><br><span class="line"> Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"> <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"> <span class="string">"//it.next返回是Set集合元素,也就是Map中的键</span></span><br><span class="line"><span class="string"> //3. 调用map集合方法get,通过键获取到值"</span></span><br><span class="line"> String key = it.next();</span><br><span class="line"> Integer value = map.get(key);</span><br><span class="line"> System.out.println(key+<span class="string">"...."</span>+value);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> System.out.println(<span class="string">"======================="</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for Each方法更简便</span></span><br><span class="line"> <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line"> Integer value = map.get(key);</span><br><span class="line"> System.out.println(key+<span class="string">"...."</span>+value);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="04Map集合Entry对象"><a href="#04Map集合Entry对象" class="headerlink" title="04Map集合Entry对象"></a>04Map集合Entry对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">在Map类设计时，提供了一个<span class="string">"嵌套接口"</span>：<span class="string">"Entry"</span>。</span><br><span class="line">Entry将<span class="string">"【键值对】的【对应关系】"</span><span class="string">"封装成了对象"</span>，即<span class="string">"键值对对象"</span>。</span><br><span class="line">这样我们在遍历Map集合时，就可以从每一个<span class="string">"键值对（Entry）对象"</span>中获取对应的<span class="string">"键"</span>与对应的<span class="string">"值"</span>。</span><br><span class="line"><span class="string">"entrySet()方法"</span>：用于<span class="string">"返回"</span>Map集合中所有的<span class="string">"键值对(Entry)对象"</span>，以<span class="string">"Set集合"</span>形式返回。</span><br><span class="line">A:Map集合Entry对象</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span></span>&#123;<span class="string">"//Entry是Map的一个【内部接口】，是static的"</span></span><br><span class="line">            <span class="comment">//由Map的子类的内部类实现</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;<span class="comment">//Entry对象指的就是该类的对象</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">              V value;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 在Map类设计时，提供了一个<span class="string">"嵌套接口：Entry"</span>。</span><br><span class="line"> Entry将键值对的对应关系封装成了对象。</span><br><span class="line"> 即<span class="string">"键值对对象"</span>，这样我们在遍历Map集合时，就可以<span class="string">"从每一个键值对（Entry）对象中获取对应的键与对应的值"</span>。</span><br><span class="line">   a:Entry是Map接口中提供的一个<span class="string">"静态内部嵌套接口"</span>。</span><br><span class="line">   b:相关方法</span><br><span class="line">   <span class="string">"getKey()方法"</span>：获取Entry对象中的<span class="string">"键"</span></span><br><span class="line">   <span class="string">"getValue()方法"</span>：获取Entry对象中的<span class="string">"值"</span></span><br><span class="line">   <span class="string">"entrySet()方法"</span>：用于<span class="string">"返回"</span>Map集合中所有的<span class="string">"键值对(Entry)对象"</span>，以<span class="string">"Set集合形式返回"</span>。</span><br></pre></td></tr></table></figure><h3 id="05Map集合遍历方式entrySet方法"><a href="#05Map集合遍历方式entrySet方法" class="headerlink" title="05Map集合遍历方式entrySet方法"></a>05Map集合遍历方式entrySet方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A:Map集合遍历方式<span class="string">"entrySet方法"</span></span><br><span class="line">*</span><br><span class="line"> *  Map集合获取方式</span><br><span class="line"> *  entrySet方法,<span class="string">"键值对映射关系"</span>获取</span><br><span class="line"> *  实现步骤:</span><br><span class="line"> *    <span class="number">1</span>. 调用map集合方法entrySet()将集合中的<span class="string">"映射关系对象"</span>,<span class="string">"存储"</span>到<span class="string">"Set集合"</span></span><br><span class="line"> *<span class="string">"      Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span></span><br><span class="line"><span class="string"> *"</span>   <span class="number">2</span>.<span class="string">" 迭代Set集合"</span></span><br><span class="line"> *    <span class="number">3</span>. 获取出的<span class="string">"Set集合的元素"</span>,是<span class="string">"映射关系对象Map.Entry&lt;K, V&gt;"</span></span><br><span class="line"> *    <span class="number">4</span>. 通过映射关系对象的方法<span class="string">" getKet(), getValue()"</span>获取<span class="string">"键值对"</span></span><br><span class="line"> *    </span><br><span class="line"> *    创建内部类对象 外部类.内部类 = <span class="keyword">new</span> </span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"abc"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"bcd"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"cde"</span>);</span><br><span class="line"><span class="string">"//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合"</span></span><br><span class="line">Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();</span><br><span class="line"><span class="string">"//2. 迭代Set集合"</span></span><br><span class="line">Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="string">"//  3. 获取出的Set集合的元素,是映射关系对象</span></span><br><span class="line"><span class="string">// it.next 获取的是Map.Entry对象"</span></span><br><span class="line">Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line"><span class="string">"//4. 通过映射关系对象方法 getKet, getValue获取键值对"</span></span><br><span class="line">Integer key = entry.getKey();</span><br><span class="line">String value = entry.getValue();</span><br><span class="line">System.out.println(key+<span class="string">"...."</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06Map集合遍历方式增强for循环"><a href="#06Map集合遍历方式增强for循环" class="headerlink" title="06Map集合遍历方式增强for循环"></a>06Map集合遍历方式增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">A:Map集合遍历方式<span class="string">"增强for循环"</span></span><br><span class="line"> A:Map集合遍历方式<span class="string">"entrySet方法"</span></span><br><span class="line">*</span><br><span class="line"> *  Map集合获取方式</span><br><span class="line"> *  entrySet方法,<span class="string">"键值对映射关系"</span>获取</span><br><span class="line"> *  实现步骤:</span><br><span class="line"> *    <span class="number">1</span>. 调用map集合方法entrySet()将集合中的<span class="string">"映射关系对象"</span>,<span class="string">"存储"</span>到<span class="string">"Set集合"</span></span><br><span class="line"> *<span class="string">"      Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span></span><br><span class="line"><span class="string"> *"</span>   <span class="number">2</span>.<span class="string">" 迭代Set集合"</span></span><br><span class="line"> *    <span class="number">3</span>. 获取出的<span class="string">"Set集合的元素"</span>,是<span class="string">"映射关系对象Map.Entry&lt;K, V&gt;"</span></span><br><span class="line"> *    <span class="number">4</span>. 通过映射关系对象的方法<span class="string">" getKet(), getValue()"</span>获取<span class="string">"键值对"</span></span><br><span class="line"> *    </span><br><span class="line"> *    创建内部类对象 外部类.内部类 = <span class="keyword">new</span> </span><br><span class="line"> */</span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line">  <span class="string">"注意"</span>：Map接口<span class="string">"没有"</span>继承自<span class="string">"Iterable&lt;E&gt;接口"</span>，</span><br><span class="line"> <span class="string">"【不能】"</span>直接使用<span class="string">"迭代器或者foreach"</span>进行遍历。<span class="string">"转成Set之后"</span>才可以使用。</span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">  map.put(<span class="number">1</span>, <span class="string">"abc"</span>);</span><br><span class="line">  map.put(<span class="number">2</span>, <span class="string">"bcd"</span>);</span><br><span class="line">  map.put(<span class="number">3</span>, <span class="string">"cde"</span>);</span><br><span class="line">  <span class="comment">//1. 调用map集合方法entrySet()将集合中的映射关系对象,存储到Set集合</span></span><br><span class="line">  Set&lt;Map.Entry &lt;Integer,String&gt; &gt;  set = map.entrySet();</span><br><span class="line">  <span class="comment">//2. 迭代Set集合</span></span><br><span class="line">  Iterator&lt;Map.Entry &lt;Integer,String&gt; &gt; it = set.iterator();</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  <span class="comment">//  3. 获取出的Set集合的元素,是映射关系对象</span></span><br><span class="line">  <span class="comment">// it.next 获取的是什么对象,也是Map.Entry对象</span></span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">  <span class="comment">//4. 通过映射关系对象方法 getKet, getValue获取键值对</span></span><br><span class="line">  Integer key = entry.getKey();</span><br><span class="line">  String value = entry.getValue();</span><br><span class="line">  System.out.println(key+<span class="string">"...."</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"========================="</span>);</span><br><span class="line">  <span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">  System.out.println(entry.getKey()+<span class="string">"..."</span>+entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line">  <span class="string">"注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。"</span></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————</span><br></pre></td></tr></table></figure><h3 id="07HashMap集合存储和遍历"><a href="#07HashMap集合存储和遍历" class="headerlink" title="07HashMap集合存储和遍历"></a>07HashMap集合存储和遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">A:HashMap集合存储和遍历</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  使用HashMap集合,存储自定义的对象</span></span><br><span class="line"><span class="string">  *  自定义对象,作为键,出现,作为值出现</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> function_1();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  * HashMap 存储自定义对象Person,作为键出现</span></span><br><span class="line"><span class="string">  * 键的对象,是Person类型,值是字符串</span></span><br><span class="line"><span class="string">  * 保证键的唯一性,存储到键的对象,【【重写hashCode equals】】，见下面的Person类</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> HashMap&lt;Person, String&gt; map = <span class="keyword">new</span> HashMap&lt;Person, String&gt;();</span><br><span class="line"> map.put(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>), <span class="string">"里约热内卢"</span>);</span><br><span class="line"> map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line"> map.put(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>), <span class="string">"索马里"</span>);</span><br><span class="line"> map.put(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">19</span>), <span class="string">"百慕大"</span>);</span><br><span class="line"> <span class="keyword">for</span>(Person key : map.keySet())&#123;</span><br><span class="line"> String value = map.get(key);</span><br><span class="line"> System.out.println(key+<span class="string">"..."</span>+value);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"> <span class="keyword">for</span>(Map.Entry&lt;Person, String&gt; entry : map.entrySet())&#123;</span><br><span class="line"> System.out.println(entry.getKey()+<span class="string">"..."</span>+entry.getValue());</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  * HashMap 存储自定义的对象Person,作为值出现</span></span><br><span class="line"><span class="string">  * 【【键的对象,是字符串,可以保证唯一性】】</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> HashMap&lt;String, Person&gt; map = <span class="keyword">new</span> HashMap&lt;String, Person&gt;();</span><br><span class="line"> map.put(<span class="string">"beijing"</span>, <span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>));</span><br><span class="line"> map.put(<span class="string">"tianjin"</span>, <span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">18</span>));</span><br><span class="line"> map.put(<span class="string">"shanghai"</span>, <span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">19</span>));</span><br><span class="line"> <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line"> Person value = map.get(key);</span><br><span class="line"> System.out.println(key+<span class="string">"..."</span>+value);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"================="</span>);</span><br><span class="line"> <span class="keyword">for</span>(Map.Entry&lt;String, Person&gt; entry : map.entrySet())&#123;</span><br><span class="line"> String key = entry.getKey();</span><br><span class="line"> Person value = entry.getValue();</span><br><span class="line"> System.out.println(key+<span class="string">"..."</span>+value);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写方法hashCode和equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode()+<span class="keyword">this</span>.age*<span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person) obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,p.name) &amp;&amp; <span class="keyword">this</span>.age==p.age;</span><br><span class="line"><span class="comment">//            return this.name.equals(p.name) &amp;&amp; this.age==p.age;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="08LinkedHashMap的特点"><a href="#08LinkedHashMap的特点" class="headerlink" title="08LinkedHashMap的特点"></a>08LinkedHashMap的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*A:LinkedHashMap的特点</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  LinkedHashMap继承HashMap</span></span><br><span class="line"><span class="string">   *  保证迭代的顺序,有序的HashMap</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LinkedHashMap&lt;String, String&gt; link = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  link.put(<span class="string">"1"</span>, <span class="string">"a"</span>);</span><br><span class="line">  link.put(<span class="string">"13"</span>, <span class="string">"a"</span>);</span><br><span class="line">  link.put(<span class="string">"15"</span>, <span class="string">"a"</span>);</span><br><span class="line">  link.put(<span class="string">"17"</span>, <span class="string">"a"</span>);</span><br><span class="line">  System.out.println(link);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="09Hashtable的特点"><a href="#09Hashtable的特点" class="headerlink" title="09Hashtable的特点"></a>09Hashtable的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">*A:Hashtable的特点</span><br><span class="line">   *</span><br><span class="line">    *  <span class="string">"Map接口实现类 Hashtable"</span></span><br><span class="line">    *  底层数据结果哈希表,特点和HashMap是一样的</span><br><span class="line">    *  <span class="string">"Hashtable"</span> <span class="string">"线程安全"</span>集合,运行<span class="string">"速度慢"</span></span><br><span class="line">    *  <span class="string">"HashMap"</span> <span class="string">"线程不安全"</span>的集合,运行<span class="string">"速度快"</span></span><br><span class="line">    *  </span><br><span class="line">    *  Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代</span><br><span class="line">    *  </span><br><span class="line">    *  <span class="string">"HashMap"</span> <span class="string">"允许存储"</span><span class="string">"null值,null键"</span></span><br><span class="line">    *  <span class="string">"Hashtable"</span> <span class="string">"不允许存储"</span><span class="string">"null值,null键"</span></span><br><span class="line">    *  </span><br><span class="line">    *  Hashtable他的孩子,<span class="string">"子类 Properties 依然活跃"</span>在开发舞台</span><br><span class="line">    *</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Map&lt;String,String&gt; map = <span class="keyword">new</span> Hashtable&lt;String,String&gt;();</span><br><span class="line">   map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="10静态导入"><a href="#10静态导入" class="headerlink" title="10静态导入"></a>10静态导入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">*A:静态导入:如果<span class="string">"本类"</span>中有和<span class="string">"静态导入"</span>的<span class="string">"同名方法"</span>会<span class="string">"优先使用"</span><span class="string">"本类"</span>的</span><br><span class="line">           如果还想使用静态导入的,依然需要类名来调用</span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    * JDK1.5新特性,静态导入</span></span><br><span class="line"><span class="string">    * 减少开发的代码量</span></span><br><span class="line"><span class="string">    * 标准的写法,【导入包】的时候才能使用</span></span><br><span class="line"><span class="string">    * </span></span><br><span class="line"><span class="string">    * import static java.lang.System.out;【最末尾】,【必须】是一个【静态成员】</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line">   <span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticImportDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   out.println(<span class="string">"hello"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">   sort(arr);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">例如：Map.Entry的访问，简化后为Entry</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="string">"//1,创建hashmap集合对象。"</span></span><br><span class="line">Map&lt;Student,String&gt; map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="string">"//取出元素。键值对方式"</span></span><br><span class="line"><span class="comment">//Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();</span></span><br><span class="line">Set&lt;Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet();<span class="comment">//静态导入后，直接用Entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123;</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;Student, String&gt; entry : entrySet) &#123;</span><br><span class="line">Student key = entry.getKey();</span><br><span class="line">String value = entry.getValue();</span><br><span class="line">System.out.println(key.toString()+<span class="string">"....."</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11方法的可变参数"><a href="#11方法的可变参数" class="headerlink" title="11方法的可变参数"></a>11方法的可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">*A:方法的可变参数</span><br><span class="line"> *</span><br><span class="line">  *  JDK1.5新的特性,<span class="string">"方法的可变参数"</span></span><br><span class="line">  *  前提: 方法参数数据类型确定,<span class="string">"参数的个数"</span><span class="string">"任意"</span></span><br><span class="line">  *  可变参数语法: <span class="string">"数据类型...变量名"</span></span><br><span class="line">  *  <span class="string">"可变参数"</span>,<span class="string">"本质"</span>就是一个<span class="string">"数组"</span></span><br><span class="line">  */</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgumentsDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//调用一个带有可变参数的方法,传递参数,可以任意</span></span><br><span class="line"> <span class="comment">//getSum();</span></span><br><span class="line"> <span class="keyword">int</span> sum = getSum(<span class="number">5</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line"> System.out.println(sum);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 定义方法,计算10个整数和</span></span><br><span class="line"><span class="comment">  * 方法的可变参数实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i : a)&#123;</span><br><span class="line"> sum = sum + i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="string">"可变参数"</span>,<span class="string">"本质"</span>就是一个<span class="string">"数组"</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> ... arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i] *= <span class="number">2</span>;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="12可变参数的注意事项"><a href="#12可变参数的注意事项" class="headerlink" title="12可变参数的注意事项"></a>12可变参数的注意事项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*A:可变参数的注意事项    </span><br><span class="line">   *</span><br><span class="line">    * 可变参数的注意事项</span><br><span class="line">    * <span class="number">1</span>. <span class="string">"一个方法中,【可变参数】"</span>只能<span class="string">"有【一个】"</span></span><br><span class="line">    * <span class="number">2</span>. 方法的<span class="string">"参数列表"</span>中<span class="string">"可变参数"</span>和<span class="string">"普通参数"</span><span class="string">"都有"</span>时,<span class="string">"必须"</span>写在参数列表的<span class="string">"末尾位置（最后）"</span></span><br><span class="line">    */</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> ... arr)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="13Collections工具类"><a href="#13Collections工具类" class="headerlink" title="13Collections工具类"></a>13Collections工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">A:Collections工具类</span><br><span class="line">  *</span><br><span class="line">   *  集合操作的工具类</span><br><span class="line">   *    <span class="string">"Collections"</span></span><br><span class="line">   *    均为<span class="string">"静态方法"</span>，通过<span class="string">"Collections.方法名"</span>进行调用</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; c,T...elements)</span></span></span><br><span class="line"><span class="function">将所有指定的元素添加到指定的集合。</span></span><br><span class="line"><span class="function"> 要添加的元素【可以单独指定】或【作为数组指定】。 </span></span><br><span class="line"><span class="function">这种方便方法的行为与c.<span class="title">addAll</span><span class="params">(Arrays.asList(elements)</span>) 相同 ，</span></span><br><span class="line"><span class="function">但是在大多数实现中，【这种方法可能会显着加快】。</span></span><br><span class="line"><span class="function">【单独指定元素】时，此方法为现有集合添加一些元素提供了一种便捷的方法：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Collections.<span class="title">addAll</span><span class="params">(flavors, <span class="string">"Peaches 'n Plutonium"</span>, <span class="string">"Rocky Racoon"</span>)</span></span>; </span><br><span class="line">参数类型</span><br><span class="line">T - 要添加和收集的元素的类</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">c - 要插入 elements的集合</span><br><span class="line">elements - 要插入到 c的元素</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line"><span class="keyword">true</span>如果集合由于调用而更改</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">Element[] array = &#123;<span class="keyword">new</span> Element(<span class="number">1</span>),<span class="keyword">new</span> Element(<span class="number">2</span>),<span class="keyword">new</span> Element(<span class="number">3</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">"将数组转化成List"</span>:</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)<span class="string">"利用ArrayList的构造方法"</span></span><br><span class="line">ArrayList&lt;Element&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Element&gt;(Arrays.asList(array));</span><br><span class="line"></span><br><span class="line">ArrayList(Collection &lt; ? extends E &gt; c) : </span><br><span class="line">构造一个包含特定容器的元素的列表ArrayList，并且根据容器迭代器的顺序返回。 </span><br><span class="line">所以<span class="string">"构造方法"</span>所做的事情如下： </span><br><span class="line"><span class="number">1</span>.将<span class="string">"容器c转换为一个数组"</span> </span><br><span class="line"><span class="number">2</span>.将<span class="string">"数组拷贝到ArrayList中称为”elementData”的数组"</span>中 </span><br><span class="line">ArrayList的构造方法的源码如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="string">"Arrays.asList(array)方法"</span></span><br><span class="line">List&lt;Element&gt; list1 = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line"><span class="string">"asList()返回的列表的大小是固定的"</span>。</span><br><span class="line">事实上，返回的列表<span class="string">"不是java.util.ArrayList"</span>，而是定义在java.util.Arrays中一个<span class="string">"私有静态类"</span>。</span><br><span class="line">我们知道ArrayList的实现本质上是一个数组，而asList()返回的列表是由原始数组支持的固定大小的列表。</span><br><span class="line">这种情况下，如果<span class="string">"添加或删除列表中的元素，程序会抛出异常"</span>UnsupportedOperationException。</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">(<span class="number">3</span>)(java.util.Collections包),<span class="string">"Collections.addAll(list2, array)方法"</span>；</span><br><span class="line">List&lt;element&gt; list2 = <span class="keyword">new</span> ArrayList&lt;element&gt;();</span><br><span class="line">Collections.addAll(list2, array);</span><br><span class="line"></span><br><span class="line"><span class="string">"这种方便方法的行为与c.addAll(Arrays.asList(elements)) 相同 ，</span></span><br><span class="line"><span class="string">但是在大多数实现中，这种方法可能会显着加快"</span>。</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  function_2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   * Collections.shuffle方法</span></span><br><span class="line"><span class="string">   * 对List集合中的元素,进行随机排列</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  list.add(<span class="number">1</span>);</span><br><span class="line">  list.add(<span class="number">5</span>);</span><br><span class="line">  list.add(<span class="number">9</span>);</span><br><span class="line">  list.add(<span class="number">11</span>);</span><br><span class="line">  list.add(<span class="number">8</span>);</span><br><span class="line">  list.add(<span class="number">10</span>);</span><br><span class="line">  list.add(<span class="number">15</span>);</span><br><span class="line">  list.add(<span class="number">20</span>);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调用工具类方法shuffle对集合随机排列</span></span><br><span class="line">  Collections.shuffle(list);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   * Collections.binarySearch静态方法</span></span><br><span class="line"><span class="string">   * 对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素</span></span><br><span class="line"><span class="string">   * ！！！注意：使用该方法前，"</span>必须<span class="string">"先进行"</span>排序<span class="string">"</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  list.add(<span class="number">1</span>);</span><br><span class="line">  list.add(<span class="number">5</span>);</span><br><span class="line">  list.add(<span class="number">8</span>);</span><br><span class="line">  list.add(<span class="number">10</span>);</span><br><span class="line">  list.add(<span class="number">15</span>);</span><br><span class="line">  list.add(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">//调用工具类静态方法binarySearch</span></span><br><span class="line">  <span class="keyword">int</span> index = Collections.binarySearch(list, <span class="number">16</span>);</span><br><span class="line">  System.out.println(index);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  Collections.sort静态方法</span></span><br><span class="line"><span class="string">   *  对于List集合,进行"</span>升序排列<span class="string">"</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//创建List集合</span></span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  list.add(<span class="string">"ewrew"</span>);</span><br><span class="line">  list.add(<span class="string">"qwesd"</span>);</span><br><span class="line">  list.add(<span class="string">"Qwesd"</span>);</span><br><span class="line">  list.add(<span class="string">"bv"</span>);</span><br><span class="line">  list.add(<span class="string">"wer"</span>);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">  <span class="comment">//调用集合工具类的方法sort</span></span><br><span class="line">  Collections.sort(list);</span><br><span class="line">  System.out.println(list);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="14集合的嵌套"><a href="#14集合的嵌套" class="headerlink" title="14集合的嵌套"></a>14集合的嵌套</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">A:集合的嵌套</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Map集合的嵌套,Map中存储的还是Map集合</span></span><br><span class="line"><span class="comment"> *  要求:</span></span><br><span class="line"><span class="comment"> *    传智播客  </span></span><br><span class="line"><span class="comment"> *      Java基础班</span></span><br><span class="line"><span class="comment"> *        001  张三</span></span><br><span class="line"><span class="comment"> *        002  李四</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      Java就业班</span></span><br><span class="line"><span class="comment"> *        001  王五</span></span><br><span class="line"><span class="comment"> *        002  赵六</span></span><br><span class="line"><span class="comment"> *  对以上数据进行对象的存储</span></span><br><span class="line"><span class="comment"> *   001 张三  键值对</span></span><br><span class="line"><span class="comment"> *   Java基础班: 存储学号和姓名的键值对</span></span><br><span class="line"><span class="comment"> *   Java就业班:</span></span><br><span class="line"><span class="comment"> *   传智播客: 存储的是班级</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   基础班Map   &lt;学号,姓名&gt;</span></span><br><span class="line"><span class="comment"> *   传智播客Map  &lt;班级名字, 基础班Map&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMapDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义基础班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javase = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//定义就业班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javaee = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//向班级集合中,存储学生信息</span></span><br><span class="line">javase.put(<span class="string">"001"</span>, <span class="string">"张三"</span>);</span><br><span class="line">javase.put(<span class="string">"002"</span>, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">javaee.put(<span class="string">"001"</span>, <span class="string">"王五"</span>);</span><br><span class="line">javaee.put(<span class="string">"002"</span>, <span class="string">"赵六"</span>);</span><br><span class="line"><span class="comment">//定义传智播客集合容器,键是班级名字,值是两个班级容器</span></span><br><span class="line">HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();</span><br><span class="line">czbk.put(<span class="string">"基础班"</span>, javase);</span><br><span class="line">czbk.put(<span class="string">"就业班"</span>, javaee);</span><br><span class="line"></span><br><span class="line"> keySet(czbk);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15集合的嵌套keySet遍历"><a href="#15集合的嵌套keySet遍历" class="headerlink" title="15集合的嵌套keySet遍历"></a>15集合的嵌套keySet遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">A:集合的嵌套keySet遍历</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  Map集合的嵌套,Map中存储的还是Map集合</span></span><br><span class="line"><span class="comment">    *  要求:</span></span><br><span class="line"><span class="comment">    *    传智播客  </span></span><br><span class="line"><span class="comment">    *      Java基础班</span></span><br><span class="line"><span class="comment">    *        001  张三</span></span><br><span class="line"><span class="comment">    *        002  李四</span></span><br><span class="line"><span class="comment">    *      </span></span><br><span class="line"><span class="comment">    *      Java就业班</span></span><br><span class="line"><span class="comment">    *        001  王五</span></span><br><span class="line"><span class="comment">    *        002  赵六</span></span><br><span class="line"><span class="comment">    *  对以上数据进行对象的存储</span></span><br><span class="line"><span class="comment">    *   001 张三  键值对</span></span><br><span class="line"><span class="comment">    *   Java基础班: 存储学号和姓名的键值对</span></span><br><span class="line"><span class="comment">    *   Java就业班:</span></span><br><span class="line"><span class="comment">    *   传智播客: 存储的是班级</span></span><br><span class="line"><span class="comment">    *   </span></span><br><span class="line"><span class="comment">    *   基础班Map   &lt;学号,姓名&gt;</span></span><br><span class="line"><span class="comment">    *   传智播客Map  &lt;班级名字, 基础班Map&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMapDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义基础班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javase = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//定义就业班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javaee = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//向班级集合中,存储学生信息</span></span><br><span class="line">javase.put(<span class="string">"001"</span>, <span class="string">"张三"</span>);</span><br><span class="line">javase.put(<span class="string">"002"</span>, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">javaee.put(<span class="string">"001"</span>, <span class="string">"王五"</span>);</span><br><span class="line">javaee.put(<span class="string">"002"</span>, <span class="string">"赵六"</span>);</span><br><span class="line"><span class="comment">//定义传智播客集合容器,键是班级名字,值是两个班级容器</span></span><br><span class="line">HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();</span><br><span class="line">czbk.put(<span class="string">"基础班"</span>, javase);</span><br><span class="line">czbk.put(<span class="string">"就业班"</span>, javaee);</span><br><span class="line"></span><br><span class="line"> keySet(czbk);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="string">"//keySet() Iterator 遍历"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keySet</span><span class="params">(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)</span></span>&#123;</span><br><span class="line"><span class="string">"//调用czbk集合方法keySet将键存储到Set集合"</span></span><br><span class="line">Set&lt;String&gt; classNameSet = czbk.keySet();</span><br><span class="line"><span class="string">"//迭代Set集合"</span></span><br><span class="line">Iterator&lt;String&gt; classNameIt = classNameSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(classNameIt.hasNext())&#123;</span><br><span class="line"><span class="string">"//classNameIt.next获取出来的是Set集合元素,czbk集合的键"</span></span><br><span class="line">String classNameKey = classNameIt.next();</span><br><span class="line"><span class="string">"//czbk集合的方法get获取值,值是一个HashMap集合"</span></span><br><span class="line">HashMap&lt;String,String&gt; classMap = czbk.get(classNameKey);</span><br><span class="line"><span class="string">"//调用classMap集合方法keySet,键存储到Set集合"</span></span><br><span class="line">Set&lt;String&gt; studentNum = classMap.keySet();</span><br><span class="line">Iterator&lt;String&gt; studentIt = studentNum.iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(studentIt.hasNext())&#123;</span><br><span class="line"><span class="string">"//studentIt.next获取出来的是classMap的键,学号"</span></span><br><span class="line">String numKey = studentIt.next();</span><br><span class="line"><span class="string">"//调用classMap集合中的get方法获取值"</span></span><br><span class="line">String nameValue = classMap.get(numKey);</span><br><span class="line">System.out.println(classNameKey+<span class="string">".."</span>+numKey+<span class="string">".."</span>+nameValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line"><span class="string">"//keySet() forEach 遍历"</span></span><br><span class="line"><span class="keyword">for</span>(String className: czbk.keySet())&#123;</span><br><span class="line">   HashMap&lt;String, String&gt; hashMap = czbk.get(className);</span><br><span class="line">   <span class="keyword">for</span>(String numKey : hashMap.keySet())&#123;</span><br><span class="line">   String nameValue = hashMap.get(numKey);</span><br><span class="line">   System.out.println(className+<span class="string">".."</span>+numKey+<span class="string">".."</span>+nameValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16集合的嵌套entrySet遍历"><a href="#16集合的嵌套entrySet遍历" class="headerlink" title="16集合的嵌套entrySet遍历"></a>16集合的嵌套entrySet遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">A:集合的嵌套entrySet遍历</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Map集合的嵌套,Map中存储的还是Map集合</span></span><br><span class="line"><span class="comment"> *  要求:</span></span><br><span class="line"><span class="comment"> *    传智播客  </span></span><br><span class="line"><span class="comment"> *      Java基础班</span></span><br><span class="line"><span class="comment"> *        001  张三</span></span><br><span class="line"><span class="comment"> *        002  李四</span></span><br><span class="line"><span class="comment"> *      </span></span><br><span class="line"><span class="comment"> *      Java就业班</span></span><br><span class="line"><span class="comment"> *        001  王五</span></span><br><span class="line"><span class="comment"> *        002  赵六</span></span><br><span class="line"><span class="comment"> *  对以上数据进行对象的存储</span></span><br><span class="line"><span class="comment"> *   001 张三  键值对</span></span><br><span class="line"><span class="comment"> *   Java基础班: 存储学号和姓名的键值对</span></span><br><span class="line"><span class="comment"> *   Java就业班:</span></span><br><span class="line"><span class="comment"> *   传智播客: 存储的是班级</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   基础班Map   &lt;学号,姓名&gt;</span></span><br><span class="line"><span class="comment"> *   传智播客Map  &lt;班级名字, 基础班Map&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMapDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义基础班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javase = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//定义就业班集合</span></span><br><span class="line">HashMap&lt;String, String&gt; javaee = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//向班级集合中,存储学生信息</span></span><br><span class="line">javase.put(<span class="string">"001"</span>, <span class="string">"张三"</span>);</span><br><span class="line">javase.put(<span class="string">"002"</span>, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">javaee.put(<span class="string">"001"</span>, <span class="string">"王五"</span>);</span><br><span class="line">javaee.put(<span class="string">"002"</span>, <span class="string">"赵六"</span>);</span><br><span class="line"><span class="comment">//定义传智播客集合容器,键是班级名字,值是两个班级容器</span></span><br><span class="line">HashMap&lt;String, HashMap&lt;String,String&gt;&gt; czbk =</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, HashMap&lt;String,String&gt;&gt;();</span><br><span class="line">czbk.put(<span class="string">"基础班"</span>, javase);</span><br><span class="line">czbk.put(<span class="string">"就业班"</span>, javaee);</span><br><span class="line"></span><br><span class="line">entrySet(czbk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"//entrySet() Iterator 遍历"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">entrySet</span><span class="params">(HashMap&lt;String,HashMap&lt;String,String&gt;&gt; czbk)</span></span>&#123;</span><br><span class="line"><span class="string">"//调用czbk集合方法entrySet方法,将czbk集合的键值对关系对象,存储到Set集合"</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; </span><br><span class="line">                         classNameSet = czbk.entrySet();</span><br><span class="line"><span class="string">"//迭代器迭代Set集合"</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt;&gt; classNameIt = classNameSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(classNameIt.hasNext())&#123;</span><br><span class="line"><span class="string">"//classNameIt.next方法,取出的是czbk集合的键值对关系对象"</span></span><br><span class="line">Map.Entry&lt;String, HashMap&lt;String,String&gt;&gt; classNameEntry =  classNameIt.next();</span><br><span class="line"><span class="comment">//classNameEntry方法 getKey,getValue</span></span><br><span class="line">String classNameKey = classNameEntry.getKey();</span><br><span class="line"><span class="string">"//获取值,值是一个Map集合"</span></span><br><span class="line">HashMap&lt;String,String&gt; classMap = classNameEntry.getValue();</span><br><span class="line"><span class="string">"//调用班级集合classMap方法entrySet,键值对关系对象存储Set集合"</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; studentSet = classMap.entrySet();</span><br><span class="line"><span class="string">"//迭代Set集合"</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; studentIt = studentSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(studentIt.hasNext())&#123;</span><br><span class="line"><span class="string">"//studentIt方法next获取出的是班级集合的键值对关系对象"</span></span><br><span class="line">Map.Entry&lt;String, String&gt; studentEntry = studentIt.next();</span><br><span class="line"><span class="comment">//studentEntry方法 getKey getValue</span></span><br><span class="line">String numKey = studentEntry.getKey();</span><br><span class="line">String nameValue = studentEntry.getValue();</span><br><span class="line">System.out.println(classNameKey+<span class="string">".."</span>+numKey+<span class="string">".."</span>+nameValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line"><span class="string">"//entrySet() Iterator 遍历"</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, HashMap&lt;String, String&gt;&gt; me : czbk.entrySet()) &#123;</span><br><span class="line">String classNameKey = me.getKey();</span><br><span class="line">HashMap&lt;String, String&gt; numNameMapValue = me.getValue();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; nameMapEntry : numNameMapValue.entrySet()) &#123;</span><br><span class="line">String numKey = nameMapEntry.getKey();</span><br><span class="line">String nameValue = nameMapEntry.getValue();</span><br><span class="line">System.out.println(classNameKey + <span class="string">".."</span> + numKey + <span class="string">".."</span> + nameValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17集合应用举例：斗地主的功能分析"><a href="#17集合应用举例：斗地主的功能分析" class="headerlink" title="17集合应用举例：斗地主的功能分析"></a>17集合应用举例：斗地主的功能分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A:斗地主的功能分析</span><br><span class="line">   a:具体规则：</span><br><span class="line">   <span class="number">1</span>. 组装<span class="number">54</span>张扑克牌</span><br><span class="line">    <span class="number">2</span>. 将<span class="number">54</span>张牌顺序打乱</span><br><span class="line">   <span class="number">3</span>. 三个玩家参与游戏，三人交替摸牌，每人<span class="number">17</span>张牌，最后三张留作底牌。</span><br><span class="line">   <span class="number">4</span>. 查看三人各自手中的牌（按照牌的大小排序）、底牌</span><br><span class="line">   b:分析:</span><br><span class="line">      <span class="number">1</span>.准备牌：</span><br><span class="line">       完成数字与纸牌的映射关系：</span><br><span class="line">       使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</span><br><span class="line">      <span class="number">2</span>.洗牌：</span><br><span class="line">       通过数字完成洗牌发牌</span><br><span class="line">      <span class="number">3</span>.发牌：</span><br><span class="line">       将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后<span class="number">3</span>张牌直接存放于底牌，剩余牌通过对<span class="number">3</span>取模依次发牌。</span><br><span class="line">       存放的过程中要求数字大小与斗地主规则的大小对应。</span><br><span class="line">       将代表不同纸牌的数字分配给不同的玩家与底牌。</span><br><span class="line">      <span class="number">4</span>.看牌：</span><br><span class="line">       通过Map集合找到对应字符展示。</span><br><span class="line">       通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</span><br></pre></td></tr></table></figure><h3 id="18斗地主的准备牌"><a href="#18斗地主的准备牌" class="headerlink" title="18斗地主的准备牌"></a>18斗地主的准备牌</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">A:斗地主的准备牌</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  实现模拟斗地主的功能</span></span><br><span class="line"><span class="comment">  *   1. 组合牌</span></span><br><span class="line"><span class="comment">  *   2. 洗牌</span></span><br><span class="line"><span class="comment">  *   3. 发牌</span></span><br><span class="line"><span class="comment">  *   4. 看牌</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//1. 组合牌</span></span><br><span class="line"> <span class="comment">//创建Map集合,键是编号,值是牌</span></span><br><span class="line"> HashMap&lt;Integer,String&gt; pooker = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"> <span class="comment">//创建List集合,存储编号</span></span><br><span class="line"> ArrayList&lt;Integer&gt; pookerNumber = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> <span class="comment">//定义出13个点数的数组</span></span><br><span class="line"> String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"> <span class="comment">//定义4个花色数组</span></span><br><span class="line"> String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line"> <span class="comment">//定义整数变量,作为键出现</span></span><br><span class="line"> <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line"> <span class="comment">//遍历数组,花色+点数的组合,存储到Map集合</span></span><br><span class="line"> <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line"> <span class="keyword">for</span>(String color : colors)&#123;</span><br><span class="line"> pooker.put(index, color+number);</span><br><span class="line"> pookerNumber.add(index);</span><br><span class="line"> index++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//存储大王,和小王,索引是从0~54,对应大王,小王,...3(牌的顺序从大到小)</span></span><br><span class="line"> pooker.put(<span class="number">0</span>, <span class="string">"大王"</span>);</span><br><span class="line"> pookerNumber.add(<span class="number">0</span>);</span><br><span class="line"> pooker.put(<span class="number">1</span>, <span class="string">"小王"</span>);</span><br><span class="line"> pookerNumber.add(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="19斗地主的洗牌"><a href="#19斗地主的洗牌" class="headerlink" title="19斗地主的洗牌"></a>19斗地主的洗牌</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">A:斗地主的洗牌</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  实现模拟斗地主的功能</span></span><br><span class="line"><span class="comment">   *   1. 组合牌</span></span><br><span class="line"><span class="comment">   *   2. 洗牌</span></span><br><span class="line"><span class="comment">   *   3. 发牌</span></span><br><span class="line"><span class="comment">   *   4. 看牌</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1. 组合牌</span></span><br><span class="line">  <span class="comment">//创建Map集合,键是编号,值是牌</span></span><br><span class="line">  HashMap&lt;Integer,String&gt; pooker = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">  <span class="comment">//创建List集合,存储编号</span></span><br><span class="line">  ArrayList&lt;Integer&gt; pookerNumber = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="comment">//定义出13个点数的数组</span></span><br><span class="line">  String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line">  <span class="comment">//定义4个花色数组</span></span><br><span class="line">  String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line">  <span class="comment">//定义整数变量,作为键出现</span></span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//遍历数组,花色+点数的组合,存储到Map集合</span></span><br><span class="line">  <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">  <span class="keyword">for</span>(String color : colors)&#123;</span><br><span class="line">  pooker.put(index, color+number);</span><br><span class="line">  pookerNumber.add(index);</span><br><span class="line">  index++;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存储大王,和小王</span></span><br><span class="line">  pooker.put(<span class="number">0</span>, <span class="string">"大王"</span>);</span><br><span class="line">  pookerNumber.add(<span class="number">0</span>);</span><br><span class="line">  pooker.put(<span class="number">1</span>, <span class="string">"小王"</span>);</span><br><span class="line">  pookerNumber.add(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//洗牌,将牌的编号打乱</span></span><br><span class="line">  Collections.shuffle(pookerNumber);</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="20斗地主的发牌"><a href="#20斗地主的发牌" class="headerlink" title="20斗地主的发牌"></a>20斗地主的发牌</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">A:斗地主的发牌</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  实现模拟斗地主的功能</span></span><br><span class="line"><span class="comment"> *   1. 组合牌</span></span><br><span class="line"><span class="comment"> *   2. 洗牌</span></span><br><span class="line"><span class="comment"> *   3. 发牌</span></span><br><span class="line"><span class="comment"> *   4. 看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 组合牌</span></span><br><span class="line"><span class="comment">//创建Map集合,键是编号,值是牌</span></span><br><span class="line">HashMap&lt;Integer,String&gt; pooker = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"><span class="comment">//创建List集合,存储编号</span></span><br><span class="line">ArrayList&lt;Integer&gt; pookerNumber = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//定义出13个点数的数组</span></span><br><span class="line">String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"><span class="comment">//定义4个花色数组</span></span><br><span class="line">String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line"><span class="comment">//定义整数变量,作为键出现</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//遍历数组,花色+点数的组合,存储到Map集合</span></span><br><span class="line"><span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line"><span class="keyword">for</span>(String color : colors)&#123;</span><br><span class="line">pooker.put(index, color+number);</span><br><span class="line">pookerNumber.add(index);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储大王,和小王</span></span><br><span class="line">pooker.put(<span class="number">0</span>, <span class="string">"大王"</span>);</span><br><span class="line">pookerNumber.add(<span class="number">0</span>);</span><br><span class="line">pooker.put(<span class="number">1</span>, <span class="string">"小王"</span>);</span><br><span class="line">pookerNumber.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗牌,将牌的编号打乱</span></span><br><span class="line">Collections.shuffle(pookerNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发牌功能,将牌编号,发给玩家集合,底牌集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; player1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; player2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; player3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; bottom = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发牌采用的是集合索引%3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; pookerNumber.size() ; i++)&#123;</span><br><span class="line"><span class="comment">//先将底牌做好</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//存到底牌去</span></span><br><span class="line">bottom.add( pookerNumber.get(i));</span><br><span class="line">   <span class="comment">//对索引%3判断</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家1</span></span><br><span class="line">player1.add( pookerNumber.get(i) );</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家2</span></span><br><span class="line">player2.add( pookerNumber.get(i) );</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家3</span></span><br><span class="line">player3.add( pookerNumber.get(i) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21斗地主的看牌"><a href="#21斗地主的看牌" class="headerlink" title="21斗地主的看牌"></a>21斗地主的看牌</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">A:斗地主的看牌</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  实现模拟斗地主的功能</span></span><br><span class="line"><span class="comment">  *   1. 组合牌</span></span><br><span class="line"><span class="comment">  *   2. 洗牌</span></span><br><span class="line"><span class="comment">  *   3. 发牌</span></span><br><span class="line"><span class="comment">  *   4. 看牌</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouDiZhu</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 组合牌</span></span><br><span class="line"><span class="comment">//创建Map集合,键是编号,值是牌</span></span><br><span class="line">HashMap&lt;Integer,String&gt; pooker = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"><span class="comment">//创建List集合,存储编号</span></span><br><span class="line">ArrayList&lt;Integer&gt; pookerNumber = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//定义出13个点数的数组</span></span><br><span class="line">String[] numbers = &#123;<span class="string">"2"</span>,<span class="string">"A"</span>,<span class="string">"K"</span>,<span class="string">"Q"</span>,<span class="string">"J"</span>,<span class="string">"10"</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"7"</span>,<span class="string">"6"</span>,<span class="string">"5"</span>,<span class="string">"4"</span>,<span class="string">"3"</span>&#125;;</span><br><span class="line"><span class="comment">//定义4个花色数组</span></span><br><span class="line">String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line"><span class="comment">//定义整数变量,作为键出现</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//遍历数组,花色+点数的组合,存储到Map集合</span></span><br><span class="line"><span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line"><span class="keyword">for</span>(String color : colors)&#123;</span><br><span class="line">pooker.put(index, color+number);</span><br><span class="line">pookerNumber.add(index);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储大王,和小王</span></span><br><span class="line">pooker.put(<span class="number">0</span>, <span class="string">"大王"</span>);</span><br><span class="line">pookerNumber.add(<span class="number">0</span>);</span><br><span class="line">pooker.put(<span class="number">1</span>, <span class="string">"小王"</span>);</span><br><span class="line">pookerNumber.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//洗牌,将牌的编号打乱</span></span><br><span class="line">Collections.shuffle(pookerNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发牌功能,将牌编号,发给玩家集合,底牌集合</span></span><br><span class="line">ArrayList&lt;Integer&gt; player1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; player2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; player3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; bottom = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发牌采用的是集合索引%3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; pookerNumber.size() ; i++)&#123;</span><br><span class="line"><span class="comment">//先将底牌做好</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//存到底牌去</span></span><br><span class="line">bottom.add( pookerNumber.get(i));</span><br><span class="line">   <span class="comment">//对索引%3判断</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家1</span></span><br><span class="line">player1.add( pookerNumber.get(i) );</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家2</span></span><br><span class="line">player2.add( pookerNumber.get(i) );</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//索引上的编号,发给玩家3</span></span><br><span class="line">player3.add( pookerNumber.get(i) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对玩家手中的编号排序</span></span><br><span class="line">Collections.sort(player1);</span><br><span class="line">Collections.sort(player2);</span><br><span class="line">Collections.sort(player3);</span><br><span class="line"><span class="comment">//看牌,将玩家手中的编号,到Map集合中查找,根据键找值</span></span><br><span class="line"><span class="comment">//定义方法实现</span></span><br><span class="line">look(<span class="string">"刘德华"</span>,player1,pooker);</span><br><span class="line">look(<span class="string">"张曼玉"</span>,player2,pooker);</span><br><span class="line">look(<span class="string">"林青霞"</span>,player3,pooker);</span><br><span class="line">look(<span class="string">"底牌"</span>,bottom,pooker);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">look</span><span class="params">(String name,ArrayList&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; pooker)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历ArrayList集合,获取元素,作为键,到集合Map中找值</span></span><br><span class="line">System.out.print(name+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer key : player)&#123;</span><br><span class="line">String value = pooker.get(key);</span><br><span class="line">System.out.print(value+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> Map集合: </span><br><span class="line">map集合中的元素都是成对出现，成对存储的</span><br><span class="line">map集合中的元素都是以一对键和值的形式组成存在的，称为键值对</span><br><span class="line">map集合中的键不能重复存储，值可以重复</span><br><span class="line">map集合中的每一个键 对应着一个值</span><br><span class="line"> 方法：</span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span>  把指定的键与指定的值添加到Map集合中</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span> 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值</span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span></span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span> 根据指定的键，在Map集合中获取对应的值</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> 获取Map集合中所有的键，存储到Set集合中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">—————————————————————————————————————————————————————————————————————————————————————— </span></span><br><span class="line"><span class="function"> Map集合遍历的两种方式</span></span><br><span class="line"><span class="function"> 方式1：根据键找值的方式</span></span><br><span class="line"><span class="function"><span class="comment">//a, 获取到Map集合中所有的键，返回对应的Set集合</span></span></span><br><span class="line"><span class="function"><span class="comment">//b, 遍历键的集合，获取到每一个键</span></span></span><br><span class="line"><span class="function"><span class="comment">//c, 通过键，找到对应的值</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取到Map集合中所有的键，返回对应的Set集合</span></span></span><br><span class="line"><span class="function">Set&lt;String&gt; keys </span>= map.keySet();</span><br><span class="line"><span class="comment">//遍历键的集合，获取到每一个键</span></span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line"><span class="comment">//通过键，找到对应的值</span></span><br><span class="line">Student s = map.get(key);</span><br><span class="line">System.out.println( key + <span class="string">"..."</span> + s.getName() + <span class="string">"..."</span> + s.getAge() );</span><br><span class="line">&#125;</span><br><span class="line">——————————————————————————————————————————————————————————</span><br><span class="line"> 方式<span class="number">2</span>：根据键值对对象找键和值的方式</span><br><span class="line"><span class="comment">//a, 获取Map集合中所有的键值对元素,返回对应的Set集合</span></span><br><span class="line"><span class="comment">//b, 遍历键值对元素集合，获取到每一个键值对元素对象</span></span><br><span class="line"><span class="comment">//c, 通过键值对元素对象，获取对应的键，和对应的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Map集合中所有的键值对元素,返回对应的Set集合</span></span><br><span class="line">Set&lt; Map.Entry&lt;String, Student&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//遍历键值对元素集合，获取到每一个键值对元素对象</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Student&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//通过键值对元素对象，获取对应的键，和对应的值</span></span><br><span class="line"><span class="comment">//找键</span></span><br><span class="line">String key = entry.getKey();</span><br><span class="line"><span class="comment">//找值</span></span><br><span class="line">Student s = entry.getValue();</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">System.out.println( key+<span class="string">"..."</span>+s.getName()+<span class="string">"..."</span>+s.getAge() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line"> HashMap:</span><br><span class="line"> 特点：</span><br><span class="line"><span class="string">"是Map集合的子集合</span></span><br><span class="line"><span class="string">底层采用【哈希表】结构</span></span><br><span class="line"><span class="string">HashMap集合中的key不能重复，通过【重写】hashCode() 与 equals()方法来保证【键的唯一】。</span></span><br><span class="line"><span class="string">【不能保证】元素存与取的【顺序】完全一致"</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line"> LinkedHashMap:</span><br><span class="line"> 特点：</span><br><span class="line"><span class="string">"是HashMap集合的子集合</span></span><br><span class="line"><span class="string">底层采用【哈希表+链表】结构</span></span><br><span class="line"><span class="string">LinkedHashMap集合中的key【不能重复】，通过【重写】hashCode() 与 equals()方法来保证【键的唯一】"</span>。</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line"> Collections中的方法：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> 排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span> 集合中的元素存储位置随机打乱</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1544080580/samples/java%20files/photo-1541706140-fd57c55e85e6.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、Map接口&lt;br&gt;2、HashMap集合、LinkedHashMap集合&lt;br&gt;3、集合的嵌套&lt;br&gt;4、集合应用举例 &lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础17(List接口、Set接口以及其实现的集合类，哈希表(Hash table)，Queue接口(队列),Deque 接口(双端队列))</title>
    <link href="https://leesen998.github.io/2016/10/28/day19%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/28/day19笔记/</id>
    <published>2016-10-28T01:48:29.000Z</published>
    <updated>2019-01-10T01:52:02.856Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543368661/samples/java%20files/photo-1541904563-aa0331e9f99a.jpg" alt="" style="width:100%"></p><p>1、List接口<br>2、ArrayList集合、LinkedList集合<br>3、Set接口<br>4、哈希表(Hash table)<br>5、HashSet集合、LinkedHashSet集合、TreeSet集合<br>6、判断集合唯一性原理<br>7、Queue接口(队列)<br>8、PrioritQueue 优先级队列<br>9、Deque 接口(双端队列)、ArrayDeque 实现类</p><a id="more"></a><h3 id="01List接口的特点"><a href="#01List接口的特点" class="headerlink" title="01List接口的特点"></a>01List接口的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:List接口的特点:</span><br><span class="line">a:<span class="string">"它是一个元素【存取有序】的集合。"</span></span><br><span class="line">    例如，存元素的顺序是<span class="number">11</span>、<span class="number">22</span>、<span class="number">33</span>。那么集合中，元素的存储就是按照<span class="number">11</span>、<span class="number">22</span>、<span class="number">33</span>的顺序完成的）。</span><br><span class="line">b:<span class="string">"它是一个【带有索引】的集合"</span>，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</span><br><span class="line"></span><br><span class="line"> c:<span class="string">"集合中【可以有重复】的元素"</span>，通过元素的equals方法，来比较是否为重复的元素。</span><br><span class="line"></span><br><span class="line"> d:List接口的常用子类有：</span><br><span class="line">   ArrayList集合</span><br><span class="line">   LinkedList集合</span><br></pre></td></tr></table></figure><h3 id="02List接口的特有方法"><a href="#02List接口的特有方法" class="headerlink" title="02List接口的特有方法"></a>02List接口的特有方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">A:List接口的特有方法(带索引的方法)</span><br><span class="line">a:增加元素方法</span><br><span class="line"> add(Object e)：<span class="string">"向集合末尾处，添加指定的元素"</span> </span><br><span class="line"> add(<span class="keyword">int</span> index, Object e)   <span class="string">"向集合指定索引处，添加指定的元素，原有元素依次后移"</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  add(int index, E)</span></span><br><span class="line"><span class="comment">   *  将元素插入到列表的指定索引上</span></span><br><span class="line"><span class="comment">   *  带有索引的操作,防止越界问题</span></span><br><span class="line"><span class="comment">   *  java.lang.IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">   *     ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">   *     StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"abc1"</span>);</span><br><span class="line">    list.add(<span class="string">"abc2"</span>);</span><br><span class="line">    list.add(<span class="string">"abc3"</span>);</span><br><span class="line">    list.add(<span class="string">"abc4"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">"itcast"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">  &#125;</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">b:删除元素删除</span><br><span class="line"> remove(Object e)：<span class="string">"将指定元素对象，从集合中删除，返回值为被删除的元素"</span></span><br><span class="line"> remove(<span class="keyword">int</span> index)：<span class="string">"将指定索引处的元素，从集合中删除，返回值为被删除的元素"</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  E remove(int index)</span></span><br><span class="line"><span class="comment">   *  移除指定索引上的元素</span></span><br><span class="line"><span class="comment">   *  返回被删除之前的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    list.add(<span class="number">1.1</span>);</span><br><span class="line">    list.add(<span class="number">1.2</span>);</span><br><span class="line">    list.add(<span class="number">1.3</span>);</span><br><span class="line">    list.add(<span class="number">1.4</span>);</span><br><span class="line">    </span><br><span class="line">    Double d = list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">c:替换元素方法</span><br><span class="line"> set(<span class="keyword">int</span> index, Object e)：<span class="string">"将指定索引处的元素，替换成指定的元素，返回值为替换前的元素"</span></span><br><span class="line">注意：</span><br><span class="line"><span class="string">"指定的索引【必须】是List集合的有效索引"</span>、例如集合长度是<span class="number">4</span>，就不能指定替换索引为<span class="number">4</span>处的元素。</span><br><span class="line">也就是说，set(<span class="keyword">int</span> index, Object element)方法<span class="string">"【不会改变】List集合的【长度】"</span></span><br><span class="line"></span><br><span class="line"> <span class="string">" /*</span></span><br><span class="line"><span class="string">   *  E set(int index, E)</span></span><br><span class="line"><span class="string">   *  修改指定索引上的元素</span></span><br><span class="line"><span class="string">   *  返回【被修改之前】的元素</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    Integer i = list.set(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">  &#125;</span><br><span class="line">d:查询元素方法</span><br><span class="line"> get(<span class="keyword">int</span> index)：获取指定索引处的元素，并返回该元素</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">e:指定元素的索引 indexOf</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">"返回此列表中第一次出现的【指定元素的索引】；如果此列表不包含该元素，则返回 -1。"</span></span><br><span class="line"><span class="function">更确切地讲，返回满足 <span class="params">(o==<span class="keyword">null</span> ? get(i)</span></span>==<span class="keyword">null</span> : o.equals(get(i))) 的<span class="string">"最低索引 i"</span>；</span><br><span class="line">如果没有这样的索引，则返回 -<span class="number">1</span>。</span><br></pre></td></tr></table></figure><h3 id="03迭代器的并发修改异常"><a href="#03迭代器的并发修改异常" class="headerlink" title="03迭代器的并发修改异常"></a>03迭代器的并发修改异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">A:迭代器的并发修改异常</span><br><span class="line"> </span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  迭代器的并发修改异常 java.util.ConcurrentModificationException (并发修改异常)</span></span><br><span class="line"><span class="string">  *  就是在遍历的过程中,使用了集合方法【修改】了【集合的长度】,不允许的</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"abc1"</span>);</span><br><span class="line">    list.add(<span class="string">"abc2"</span>);</span><br><span class="line">    list.add(<span class="string">"abc3"</span>);</span><br><span class="line">    list.add(<span class="string">"abc4"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对集合使用迭代器进行获取,获取时候判断集合中是否存在 "abc3"对象</span></span><br><span class="line">    <span class="comment">//如果有,添加一个元素 "ABC3"</span></span><br><span class="line">    Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      String s = it.next();</span><br><span class="line">      <span class="comment">//对获取出的元素s,进行判断,是不是有"abc3"</span></span><br><span class="line">      <span class="keyword">if</span>(s.equals(<span class="string">"abc3"</span>))&#123;</span><br><span class="line"><span class="string">"添加一个元素 "</span>ABC3<span class="string">",造成集合长度变化，抛出异常"</span></span><br><span class="line">        list.add(<span class="string">"ABC3"</span>);<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="string">"修改指定索引的元素为"</span>ABC3<span class="string">",【没有】造成集合长度变化，正常运行"</span></span><br><span class="line">list.set(list.indexOf(<span class="string">"abc3"</span>),<span class="string">"ABC3"</span>);<span class="comment">//正常运行</span></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">运行上述代码发生了错误 java.util.ConcurrentModificationException这是什么原因呢？</span><br><span class="line">在迭代过程中，使用了集合的方法对元素进行操作。</span><br><span class="line"><span class="string">"导致迭代器并不知道集合中的变化，容易引发数据的不确定性"</span>。</span><br><span class="line"></span><br><span class="line"><span class="string">"并发修改异常解决办法"</span>：</span><br><span class="line"><span class="string">"在迭代时，【不要使用】集合的方法操作元素"</span>。</span><br><span class="line">或者<span class="string">"通过ListIterator迭代器操作元素是可以"</span>的，ListIterator的出现，解决了使用Iterator迭代过程中可能会发生的错误情况。</span><br></pre></td></tr></table></figure><h3 id="04数据的存储结构"><a href="#04数据的存储结构" class="headerlink" title="04数据的存储结构"></a>04数据的存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:数据的存储结构</span><br><span class="line"> a:栈结构:<span class="string">"后进先出/先进后出"</span>(手枪弹夹) FILO (first in last out)</span><br><span class="line"> b:队列结构:<span class="string">"先进先出/后进后出"</span>(银行排队) FIFO(first in first out)</span><br><span class="line"> c:数组结构:</span><br><span class="line">           <span class="string">"【查询快】:通过索引快速找到元素"</span></span><br><span class="line">           <span class="string">"【增删慢】:每次增删都需要开辟新的数组,将老数组中的元素拷贝到新数组中"</span></span><br><span class="line">                 <span class="string">" 开辟新数组耗费资源"</span></span><br><span class="line"> d:链表结构</span><br><span class="line">          <span class="string">" 【查询慢】:每次都需要从链头或者链尾找起"</span></span><br><span class="line">           <span class="string">"【增删快】:只需要修改元素记录的下个元素的地址值即可不需要移动大量元素"</span></span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543844679/samples/java%20files/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="方法调用的内存图"></p><h3 id="05ArrayList集合的自身特点"><a href="#05ArrayList集合的自身特点" class="headerlink" title="05ArrayList集合的自身特点"></a>05ArrayList集合的自身特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:ArrayList集合的自身特点</span><br><span class="line">  底层采用的是数组结构</span><br><span class="line">  ArrayList al=<span class="keyword">new</span> ArrayList();<span class="comment">//创建了一个长度为0的Object类型数组</span></span><br><span class="line">  al.add(<span class="string">"abc"</span>);<span class="string">"//底层会创建一个长度为10的Object数组 "</span>Object[] obj=<span class="keyword">new</span> Object[<span class="number">10</span>]</span><br><span class="line">                <span class="comment">//obj[0]="abc"</span></span><br><span class="line">               <span class="string">"//如果添加的元素的超过10个,底层会开辟一个1.5*10的长度的新数组"</span></span><br><span class="line">               <span class="string">"//把原数组中的元素【拷贝】(Arrays.copyOf)到新数组,再把最后一个元素添加到新数组中"</span></span><br><span class="line">原数组:</span><br><span class="line">  a b c d e f g h k l</span><br><span class="line">添加m:</span><br><span class="line">  a b c d e f g h k l m <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="06LinkedList集合的自身特点"><a href="#06LinkedList集合的自身特点" class="headerlink" title="06LinkedList集合的自身特点"></a>06LinkedList集合的自身特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A:LinkedList集合的自身特点</span><br><span class="line">LinkedList 类是 <span class="string">"List 接口 "</span>的 实现类,LinkedList 还实现了 <span class="string">"Deque 接口"</span>,</span><br><span class="line">可以被当成<span class="string">"双端队列"</span>来使用 ， 因此既可以被当成<span class="string">"栈"</span>来使用，也可以 当成<span class="string">"队列"</span>使用 。</span><br><span class="line"></span><br><span class="line"><span class="string">"底层采用链表结构,每次查询都要从【链头】或【链尾】找起,【查询】相对数组【较慢】"</span></span><br><span class="line"><span class="string">"但是【删除元素】直接【修改元素记录的地址值】即可,不需要大量移动元素，【增删】相对数组【较快】"</span></span><br><span class="line"></span><br><span class="line">LinkedList的<span class="string">"索引"</span>决定是从<span class="string">"链头"</span>开始找还是从<span class="string">"链尾"</span>开始找</span><br><span class="line"><span class="string">"如果该元素【小于】元素长度一半,从【链头】开始找起；如果【大于】元素长度的一半,则从【链尾】找起"</span></span><br><span class="line">实现所有可选的列表操作，并且允许所有元素（包括 <span class="keyword">null</span>）。</span><br><span class="line">除了实现 List 接口外，</span><br><span class="line">LinkedList 类还为在<span class="string">"列表的开头及结尾"</span> get、remove 和 insert 元素提供了统一的命名方法。</span><br><span class="line">这些操作允许将<span class="string">"链接列表"</span>用作<span class="string">"堆栈、队列"</span>或双端队列。</span><br><span class="line"></span><br><span class="line">LinkedList集合数据存储的结构是链表结构。</span><br><span class="line"><span class="string">"方便元素添加、删除的集合"</span>。</span><br><span class="line">实际开发中对一个集合元素的添加与删除经常涉及到<span class="string">"首尾操作"</span>，</span><br><span class="line">而LinkedList提供了大量<span class="string">"首尾操作"</span>的方法</span><br></pre></td></tr></table></figure><h3 id="07LinkedList特有方法"><a href="#07LinkedList特有方法" class="headerlink" title="07LinkedList特有方法"></a>07LinkedList特有方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">具体查看 ：<span class="string">"25 Deque 接口(双端队列)与 ArrayDeque 实现类、LinkedList 实现类"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; lds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="string">"//将元素加入队列的尾部"</span></span><br><span class="line">        lds.offer(<span class="number">23</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="string">"//将一个元素加入【栈】的顶部"</span></span><br><span class="line">        lds.push(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将元素加入【队列】的尾部"</span></span><br><span class="line">        lds.offer(<span class="number">407</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将元素添加到【队列】的头部(相当于【栈】的顶部〉"</span></span><br><span class="line">        lds.addFirst(<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//输出：[56, 111, 23, 407]"</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//以 List 的方式(按【索引访问】的方式〉来遍历集合元素"</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ee:lds)&#123;</span><br><span class="line">            System.out.println(ee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问并不删除顶的元素:56</span></span><br><span class="line">        System.out.println(lds.peekFirst()) ;</span><br><span class="line">        <span class="comment">//访问并不删除队列的最后一个元素:407</span></span><br><span class="line">        System.out.println(lds.peekLast()) ;</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将【栈】顶的元素弹出 ,输出 56"</span></span><br><span class="line">        System.out.println(lds.pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[111, 23, 407]</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问并删除【队列】的最后一个元素: 407</span></span><br><span class="line">        System.out.println(lds.pollLast());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[111, 23]</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">   *A:LinkedList特有方法:获取,添加,删除</span><br><span class="line">   *</span><br><span class="line">     *  LinkedList 链表集合的特有功能</span><br><span class="line">     *    <span class="string">"自身特点: 链表底层实现,查询慢,增删快"</span></span><br><span class="line">     *  </span><br><span class="line">     <span class="string">"*  子类的特有功能,不能多态调用，只能向下强制转换"</span></span><br><span class="line">     *</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        function_3();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       *  E removeFirst() 移除并返回链表的开头</span></span><br><span class="line"><span class="comment">       *  E removeLast() 移除并返回链表的结尾</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        link.add(<span class="string">"1"</span>);</span><br><span class="line">        link.add(<span class="string">"2"</span>);</span><br><span class="line">        link.add(<span class="string">"3"</span>);</span><br><span class="line">        link.add(<span class="string">"4"</span>);</span><br><span class="line">        </span><br><span class="line">        String first = link.removeFirst();</span><br><span class="line">        String last = link.removeLast();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">        System.out.println(last);</span><br><span class="line">      </span><br><span class="line">        System.out.println(link);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * E getFirst() 获取链表的开头</span></span><br><span class="line"><span class="comment">       * E getLast() 获取链表的结尾</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        link.add(<span class="string">"1"</span>);</span><br><span class="line">        link.add(<span class="string">"2"</span>);</span><br><span class="line">        link.add(<span class="string">"3"</span>);</span><br><span class="line">        link.add(<span class="string">"4"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(!link.isEmpty())&#123;</span><br><span class="line">          String first = link.getFirst();</span><br><span class="line">          String last = link.getLast();</span><br><span class="line">          System.out.println(first);</span><br><span class="line">          System.out.println(last);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        link.addLast(<span class="string">"a"</span>);</span><br><span class="line">        link.addLast(<span class="string">"b"</span>);</span><br><span class="line">        link.addLast(<span class="string">"c"</span>);</span><br><span class="line">        link.addLast(<span class="string">"d"</span>);</span><br><span class="line">        </span><br><span class="line">        link.addFirst(<span class="string">"1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       *  addFirst(E) 添加到链表的开头</span></span><br><span class="line"><span class="comment">       *  addLast(E) 添加到链表的结尾</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        link.addLast(<span class="string">"heima"</span>);</span><br><span class="line">        </span><br><span class="line">        link.add(<span class="string">"abc"</span>);</span><br><span class="line">        link.add(<span class="string">"bcd"</span>);</span><br><span class="line">        </span><br><span class="line">        link.addFirst(<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="08-各List实现类的性能分析，集合Vector类的特点"><a href="#08-各List实现类的性能分析，集合Vector类的特点" class="headerlink" title="08 各List实现类的性能分析，集合Vector类的特点,"></a>08 各List实现类的性能分析，集合Vector类的特点,</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Java 提供的 List 就是一个线性表接口，</span><br><span class="line">而ArrayList 、 LinkedList 又是线性表的两种典型实现 : </span><br><span class="line"><span class="string">"ArrayList是基于数组的线性表"</span>，<span class="string">"LinkedList是基于链的线性表"</span>。</span><br><span class="line"> <span class="string">"Queue 代表了队列"</span>，<span class="string">" Deque 代表了双端队列(既可作为【队列】使用，也可作为【栈】使用)"</span> ，</span><br><span class="line"><span class="string">"LinkedList 集合"</span>不仅提供了 <span class="string">"List 的功能"</span>，还提供了<span class="string">"双端队列"</span>、<span class="string">"栈"</span>的功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来对各种实现类的性能进行分析。</span><br><span class="line"></span><br><span class="line"><span class="string">"总体来说"</span>， <span class="string">"ArrayList "</span>的性能<span class="string">"比"</span> <span class="string">"LinkedList"</span> 的性能要<span class="string">"好"</span></span><br><span class="line"><span class="string">"数组"</span>在<span class="string">"随机访问"</span>时<span class="string">"性能"</span><span class="string">"最好"</span> ，</span><br><span class="line">所有的内部以数组作为底层实现的集合在随机访问时性能都比较好 ;</span><br><span class="line">而内部以<span class="string">"链表"</span>作为底层实现的集合在<span class="string">"执行插入、删除操作"</span>时有<span class="string">"较好"</span>的性能 。</span><br><span class="line"></span><br><span class="line">》如果需要<span class="string">"遍历 List 集合元素"</span> ： </span><br><span class="line">对于 ArrayList、 Vector 集合 ， 应该使用<span class="string">"随机访问方法 (get) "</span>来<span class="string">"遍历"</span>集合元素，这样性能更好 ; </span><br><span class="line">对于<span class="string">" LinkedList 集合"</span>，则应该采用<span class="string">"迭代器 （Iterator) "</span>来<span class="string">"遍历"</span>集合元素 。</span><br><span class="line"></span><br><span class="line">》如果需要经常<span class="string">"执行插入、删除操作"</span>来改变包含大量数据的 List 集合的大小：</span><br><span class="line">可考虑<span class="string">"使用LinkedList 集合"</span>。</span><br><span class="line">使用 <span class="string">"ArrayList 、 Vector 集合"</span>可能需要经常<span class="string">"重新分配内部数组的大小"</span>，效果可能<span class="string">"较差"</span>。</span><br><span class="line"></span><br><span class="line">》如果有<span class="string">"多个线程"</span>需要<span class="string">"同时访问"</span> List 集合中的元素，</span><br><span class="line">开发者可考虑使用 <span class="string">"Collections "</span>将集合<span class="string">"包装"</span>成<span class="string">"线程安全"</span>的集合。</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">*B:Vector类的特点</span><br><span class="line">   Vector集合数据存储的结构是数组结构，为JDK中<span class="string">"最早"</span>提供的<span class="string">"集合"</span>,它是<span class="string">"线程同步"</span>的</span><br><span class="line">   Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。</span><br><span class="line">   此接口Enumeration的功能与 Iterator 接口的功能是类似的。</span><br><span class="line">  <span class="string">" Vector集合已被 ArrayList【替代】。枚举Enumeration 已被 迭代器Iterator【替代】"</span>。</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543890854/samples/java%20files/11.png" alt="方法调用的内存图"></p><h3 id="09Set接口的特点"><a href="#09Set接口的特点" class="headerlink" title="09Set接口的特点"></a>09Set接口的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set接口类似于个<span class="string">"罐子"</span>，<span class="string">"程序可以依次把多个对象“丢进”Set集合"</span>，</span><br><span class="line">集合通常<span class="string">"不能"</span>记住<span class="string">"元索的添加顺序"</span>。</span><br><span class="line"><span class="string">"Set集合与Collection基本相同"</span>，<span class="string">"【没有】提供【任何】【额外的方法】"</span>。</span><br><span class="line">实际上Set就是Collection，只是行为略有不同(<span class="string">"Set不允许包含重复元素"</span>)。</span><br><span class="line"></span><br><span class="line">A:Set接口的特点</span><br><span class="line"> a:它是个<span class="string">"【不包含】重复元素"</span>的集合。</span><br><span class="line"> b:Set集合取出元素的方式可以采用：<span class="string">"【迭代器】、【增强for】"</span>。<span class="string">"不能通过索引进行取值"</span>。</span><br><span class="line"> HashSet<span class="string">"没有提供get()方法"</span>，同HashMap一样，<span class="string">"Set内部是无序的"</span>，只能通过迭代的方式获得</span><br><span class="line"> c:Set集合有多个子类，这里我们介绍其中的<span class="string">"HashSet、LinkedHashSet"</span>这两个集合。</span><br></pre></td></tr></table></figure><h3 id="10Set集合存储和迭代-以HashSet为例"><a href="#10Set集合存储和迭代-以HashSet为例" class="headerlink" title="10Set集合存储和迭代(以HashSet为例)"></a>10Set集合存储和迭代(以HashSet为例)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A:Set集合存储和迭代</span><br><span class="line"><span class="string">"HashSet类(散列集) 实现 Set 接口，由哈希表Hash table（实际上是一个 HashMap 实例）支持"</span>。</span><br><span class="line">它<span class="string">"【不保证】 set 的迭代顺序"</span>；<span class="string">"特别是它【不保证】该顺序恒久不变"</span>。</span><br><span class="line">此类允许<span class="string">"使用 null 元素"</span></span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  Set接口,特点不重复元素,没索引</span></span><br><span class="line"><span class="string">   *  </span></span><br><span class="line"><span class="string">   *  Set接口的实现类,HashSet </span></span><br><span class="line"><span class="string">   *  特点: 无序集合,存储和取出的顺序不同,没有索引,不存储重复元素</span></span><br><span class="line"><span class="string">   *  代码的编写上,和ArrayList完全一致</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">      set.add(<span class="string">"cn"</span>);</span><br><span class="line">      set.add(<span class="string">"heima"</span>);</span><br><span class="line">      set.add(<span class="string">"java"</span>);</span><br><span class="line">      set.add(<span class="string">"java"</span>);</span><br><span class="line">      set.add(<span class="string">"itcast"</span>);</span><br><span class="line">      </span><br><span class="line">      Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">      <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"=============="</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(String s : set)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="11哈希表的数据结构"><a href="#11哈希表的数据结构" class="headerlink" title="11哈希表的数据结构"></a>11哈希表的数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:哈希表的数据结构:(参见图解)</span><br><span class="line"></span><br><span class="line"><span class="string">"加载因子:表中填入的记录数 / 哈希表的长度"</span></span><br><span class="line">例如:</span><br><span class="line">加载因子是<span class="number">0.75</span> 代表:</span><br><span class="line">  数组中的<span class="number">16</span>个位置,其中存入<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>个元素</span><br><span class="line"></span><br><span class="line">如果在存入第<span class="number">13</span>个(&gt;<span class="number">12</span>)元素,导致存储链子过长,会降低哈希表的性能,那么此时会<span class="string">"扩充哈希表(再哈希 Rehash)"</span>,</span><br><span class="line">底层会<span class="string">"开辟一个长度为原长度2倍的数组"</span>,把老元素拷贝到新数组中,再把新元素添加数组中</span><br><span class="line">  </span><br><span class="line">当存入<span class="string">"元素数量"</span> &gt; <span class="string">"哈希表长度*加载因子"</span>,就要<span class="string">"扩容"</span>,因此<span class="string">"加载因子决定扩容时机"</span></span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543894671/samples/java%20files/ds_hashtable1.png" alt="方法调用的内存图"></p><h3 id="12字符串对象的哈希值-HashCode"><a href="#12字符串对象的哈希值-HashCode" class="headerlink" title="12字符串对象的哈希值(HashCode)"></a>12字符串对象的哈希值(HashCode)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">A:字符串对象的哈希值</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string">*  对象的哈希值,普通的十进制整数</span></span><br><span class="line"><span class="string">*  父类Object,方法 public int hashCode() 计算结果int整数</span></span><br><span class="line"><span class="string">*/"</span></span><br><span class="line">举例：</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>);</span><br><span class="line">StringBuilder tb = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">int</span> s = sb.hashCode();</span><br><span class="line"><span class="keyword">int</span> t = tb.hashCode();</span><br><span class="line">System.out.println(<span class="string">"s:　"</span> + s);<span class="string">"//StringBuilder没有重写HashCode方法，返回对象的内存地址值"</span></span><br><span class="line">System.out.println(<span class="string">"t:　"</span> + t);<span class="comment">//StringBuilder没有重写HashCode方法，返回对象的内存地址值</span></span><br><span class="line">System.out.println(sb.equals(tb));<span class="string">"//比较的是对象的内存地址值"</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"————————————————————————————————————————1"</span>);</span><br><span class="line">String ss= <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="string">"//String重写HashCode方法，根据内容的值进行计算"</span></span><br><span class="line">String st = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"ss.hashCode():　"</span> + ss.hashCode());</span><br><span class="line">System.out.println(<span class="string">"st.hashCode():　"</span> + st.hashCode());</span><br><span class="line">System.out.println(ss.equals(st));<span class="string">"//比较的是对象的内容是否完全相同"</span></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Person p = <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">int</span> i = p.hashCode();</span><br><span class="line">  System.out.println(i);</span><br><span class="line"></span><br><span class="line">  String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">  String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">  System.out.println(s1.hashCode());<span class="comment">//96354</span></span><br><span class="line">  System.out.println(s2.hashCode());<span class="comment">//96354</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">"两个【不同】字符串的hashCode值完全可能【相同】"</span></span><br><span class="line">  System.out.println(<span class="string">"重地"</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line">  System.out.println(<span class="string">"通话"</span>.hashCode());<span class="comment">//1179395</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String类重写hashCode()方法</span></span><br><span class="line"><span class="comment">//字符串都会存储在底层的value数组中&#123;'a','b','c'&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hash;<span class="comment">//hash初值为0</span></span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13哈希表的存储过程"><a href="#13哈希表的存储过程" class="headerlink" title="13哈希表的存储过程"></a>13哈希表的存储过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">A:哈希表的存储原理</span><br><span class="line">当向哈希表中<span class="string">"存放元素"</span>时，需要根据元素的<span class="string">"特有数据结合相应的算法"</span>，</span><br><span class="line">这个算法其实就是<span class="string">"Object类中的【hashCode方法】"</span>。</span><br><span class="line">由于任何对象都是Object类的子类，所以<span class="string">"任何对象都拥有这个方法"</span>。</span><br><span class="line">即就是<span class="string">"在给哈希表中【存放对象】时，会【调用】对象的【hashCode方法】"</span>，</span><br><span class="line"></span><br><span class="line">这里需要注意：</span><br><span class="line">算出对象在表中的存放位置，如果<span class="string">"两个对象hashCode方法算出【结果一样】"</span>，这样现象称为<span class="string">"哈希冲突"</span>，</span><br><span class="line">这时会调用对象的<span class="string">"equals方法"</span>，比较这<span class="string">"两个对象【是不是】同一个对象"</span>，</span><br><span class="line">(<span class="number">1</span>)如果<span class="string">"equals方法返回的是true"</span>，那么就<span class="string">"不会"</span>把第二个对象存放在哈希表中，</span><br><span class="line">(<span class="number">2</span>)如果<span class="string">"返回的是false"</span>，就会<span class="string">"把这个值存放在哈希表中"</span>。</span><br><span class="line"></span><br><span class="line">总结：<span class="string">"保证HashSet集合元素的唯一"</span>，其实就是根据<span class="string">"对象的 hashCode和 equals 方法"</span>来决定的。</span><br><span class="line">！！！如果我们往集合中存放<span class="string">"自定义的对象"</span>，那么保证其唯一，</span><br><span class="line">就<span class="string">"必须"</span><span class="string">"重写hashCode和equals方法"</span>建立属于当前对象的比较方式。</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">B:哈希表的存储过程</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> String(<span class="string">"abc"</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> String(<span class="string">"abc"</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> String(<span class="string">"bbc"</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> String(<span class="string">"bbc"</span>));</span><br><span class="line">    System.out.println(set); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">存取原理:</span><br><span class="line">每存入一个新的元素都要走以下三步:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.首先调用<span class="string">"本类的hashCode()方法"</span>算出哈希值</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="string">"在容器中找是否与【新元素】【哈希值相同】的【老元素】"</span>,</span><br><span class="line">  <span class="string">"如果没有直接存入"</span></span><br><span class="line">  如果有转到第三步</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.<span class="string">"新元素会与该索引位置下的老元素利用equals方法"</span>一一对比</span><br><span class="line">  一旦<span class="string">"新元素.equals(老元素)"</span>返回<span class="keyword">true</span>,停止对比,<span class="string">"说明重复"</span>,<span class="string">"不再存入"</span></span><br><span class="line">  如果与该索引位置下的老元素都通过equals方法对比返回<span class="keyword">false</span>,说明<span class="string">"没有重复"</span>,<span class="string">"存入"</span></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">举例：</span><br><span class="line">HashSet&lt;String&gt; hset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    hset.add(<span class="string">"abc"</span>);<span class="string">"//hashCode:　96354"</span></span><br><span class="line">    hset.add(<span class="string">"abc"</span>);</span><br><span class="line">    hset.add(<span class="string">"ad%"</span>);<span class="string">"//hashCode:　96354"</span></span><br><span class="line">    hset.add(<span class="string">"yut"</span>);</span><br><span class="line">    System.out.println(hset);</span><br><span class="line"></span><br><span class="line">上述代码：</span><br><span class="line">第<span class="number">1</span>行： <span class="string">"abc"</span>的hashCode　为　<span class="number">96354</span></span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>行： <span class="string">"abc"</span>的hashCode　为　<span class="number">96354</span>，调用新元素.equals(老元素)，</span><br><span class="line">即<span class="string">"abc"</span>.equals(<span class="string">"abc"</span>)结果为<span class="keyword">true</span>,说明<span class="string">"元素重复，不添加到HashSet中"</span>;</span><br><span class="line"></span><br><span class="line">第<span class="number">3</span>行： <span class="string">"ad%"</span>的hashCode 也为　<span class="number">96354</span>，调用新元素.equals(老元素)，</span><br><span class="line">即<span class="string">"ad%"</span>.equals(<span class="string">"abc"</span>)结果为<span class="keyword">false</span>，<span class="string">"没有元素重复，添加到HashSet中"</span>;</span><br></pre></td></tr></table></figure><p>——————————————————————————————————————————————————————————————————————<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543913890/samples/java%20files/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.jpg" alt="方法调用的内存图"><br>——————————————————————————————————————————————————————————————————————<br><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543913890/samples/java%20files/hashtable.png" alt="方法调用的内存图"><br>——————————————————————————————————————————————————————————————————————</p><h3 id="14HashSet存储自定义的对象"><a href="#14HashSet存储自定义的对象" class="headerlink" title="14HashSet存储自定义的对象"></a>14HashSet存储自定义的对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">A:HashSet存储自定义的对象</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  HashSet集合的自身特点:</span></span><br><span class="line"><span class="string">  *    底层数据结构,哈希表</span></span><br><span class="line"><span class="string">  *    存储,取出都比较快</span></span><br><span class="line"><span class="string">  *    线程不安全,运行速度快</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Person对象中的姓名,年龄,相同数据,看作同一个对象</span></span><br><span class="line">    <span class="string">"//判断对象是否重复,依赖对象自己的方法 hashCode(),equals()"</span></span><br><span class="line">    HashSet&lt;Person&gt; setPerson = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">11</span>));</span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));<span class="string">"hashCode方法返回对象的地址值，地址值不同，会存入HashSet"</span></span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));<span class="string">"hashCode方法返回对象的地址值，地址值不同，会存入HashSet"</span></span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">25</span>));</span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">19</span>));</span><br><span class="line">    setPerson.add(<span class="keyword">new</span> Person(<span class="string">"e"</span>,<span class="number">17</span>));</span><br><span class="line"><span class="string">"//每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】,【直接存入】"</span></span><br><span class="line">    System.out.println(setPerson);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name+<span class="string">".."</span>+age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="15自定义对象重写hashCode和equals方法"><a href="#15自定义对象重写hashCode和equals方法" class="headerlink" title="15自定义对象重写hashCode和equals方法"></a>15自定义对象重写hashCode和equals方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> A:自定义对象重写hashCode和equals方法</span><br><span class="line"><span class="string">"给HashSet中存放【自定义类型元素】时，</span></span><br><span class="line"><span class="string">需要【重写】对象中的hashCode和equals方法，建立【自己的比较方式】，</span></span><br><span class="line"><span class="string">才能【保证】HashSet集合中的【对象唯一】"</span></span><br><span class="line"></span><br><span class="line">也就是说，</span><br><span class="line">HashSet集合<span class="string">"判断两个元素相等的标准"</span>是：</span><br><span class="line">两个对象通过<span class="string">"equals()方法"</span>比较<span class="string">"相等"</span>，返回<span class="keyword">true</span>，<span class="string">"并且"</span>两个对象的<span class="string">"hashCode()方法"</span>返回值<span class="string">"也相等"</span>。</span><br><span class="line"><span class="string">"则 HashSet集合中的 两个元素【相同】，【不予添加】"</span></span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">      *  HashSet集合的自身特点:</span></span><br><span class="line"><span class="string">      *    底层数据结构,哈希表</span></span><br><span class="line"><span class="string">      *    存储,取出都比较快</span></span><br><span class="line"><span class="string">      *    线程不安全,运行速度快</span></span><br><span class="line"><span class="string">      */"</span></span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo1</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Person对象中的姓名,年龄,相同数据,看作同一个对象</span></span><br><span class="line">        <span class="string">"//判断对象是否重复,依赖【对象自己】的方法 hashCode,equals"</span></span><br><span class="line">        HashSet&lt;Person&gt; setPerson = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">11</span>));</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">25</span>));</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>,<span class="number">19</span>));</span><br><span class="line">        setPerson.add(<span class="keyword">new</span> Person(<span class="string">"e"</span>,<span class="number">17</span>));</span><br><span class="line">        System.out.println(setPerson);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string">*  没有做重写父类(Obejct类)的hashCode和equals方法,每次运行结果都是不同整数，</span></span><br><span class="line"><span class="string">   因为每个对象的【地址值都不同】,调用【Obejct类】的hashCode方法返回【不同】【哈希值】</span></span><br><span class="line"><span class="string">*  如果子类重写父类hashCode和equals方法,将会得到自定义的哈希值</span></span><br><span class="line"><span class="string">*  存储到HashSet集合的依据：用hashCode和equals方法进行判断</span></span><br><span class="line"><span class="string">*   </span></span><br><span class="line"><span class="string">*  尽可能让不同的属性值产生不同的哈希值(优化hashCode的产生方法),这样就不用再调用equals方法去比较属性</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">*/"</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.hashCode()+age*<span class="number">55</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//方法equals重写父类,保证和父类相同</span></span><br><span class="line">      <span class="comment">//public boolean equals(Object obj)&#123;&#125;</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">          Person p = (Person)obj;</span><br><span class="line">          <span class="keyword">return</span> name.equals(p.name) &amp;&amp; age==p.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">".."</span>+age;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="16LinkedHashSet集合"><a href="#16LinkedHashSet集合" class="headerlink" title="16LinkedHashSet集合"></a>16LinkedHashSet集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A:LinkedHashSet集合</span><br><span class="line"> <span class="string">" /*</span></span><br><span class="line"><span class="string">   *   LinkedHashSet 基于【链表】的【哈希表】实现</span></span><br><span class="line"><span class="string">   *   继承自HashSet："</span>有序<span class="string">"的hashSet</span></span><br><span class="line"><span class="string">   *   </span></span><br><span class="line"><span class="string">   *   LinkedHashSet 自身特性,"</span>具有顺序<span class="string">",存储和取出的顺序相同</span></span><br><span class="line"><span class="string">   *   线程不安全的集合,"</span>运行速度块<span class="string">"</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LinkedHashSet&lt;Integer&gt; link = <span class="keyword">new</span> LinkedHashSet&lt;Integer&gt;();</span><br><span class="line">      link.add(<span class="number">123</span>);</span><br><span class="line">      link.add(<span class="number">44</span>);</span><br><span class="line">      link.add(<span class="number">33</span>);</span><br><span class="line">      link.add(<span class="number">33</span>);</span><br><span class="line">      link.add(<span class="number">66</span>);</span><br><span class="line">      link.add(<span class="number">11</span>);</span><br><span class="line">      System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="17ArrayList-HashSet判断对象是否重复的原理"><a href="#17ArrayList-HashSet判断对象是否重复的原理" class="headerlink" title="17ArrayList,HashSet判断对象是否重复的原理"></a>17ArrayList,HashSet判断对象是否重复的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">ArrayList,HashSet判断对象是否重复的原理</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>： <span class="string">"ArrayList的【contains方法】判断元素是否重复"</span></span><br><span class="line">a:<span class="string">"ArrayList的【contains方法】原理:【底层依赖于】【equals方法】"</span></span><br><span class="line">ArrayList的【contains方法】会使用调用方法时，</span><br><span class="line"> <span class="string">"传入的元素的equals方法依次与集合中的旧元素所比较"</span>，</span><br><span class="line"> 从而根据返回的布尔值判断是否有重复元素。</span><br><span class="line"></span><br><span class="line">b:<span class="string">"当ArrayList存放【自定义类型】时"</span>，由于自定义类型在<span class="string">"未重写equals方法"</span>之前，</span><br><span class="line"> <span class="string">"判断是否重复的依据是内存地址值"</span>，<span class="string">"所以如果想根据【内容】判断是否为重复元素，需要【重写】元素的equals方法"</span>。</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: <span class="string">"HashSet的add/contains等方法判断元素是否重复"</span></span><br><span class="line"><span class="string">"HashSet的【add()方法和contains方法()】【底层】都【依赖】 hashCode()方法与equals方法()"</span></span><br><span class="line"></span><br><span class="line">HashSet集合<span class="string">"判断两个元素相等的标准"</span>是：</span><br><span class="line">两个对象通过<span class="string">"equals()方法"</span>比较<span class="string">"相等"</span>，返回<span class="keyword">true</span>，<span class="string">"并且"</span>两个对象的<span class="string">"hashCode()方法"</span>返回值<span class="string">"也相等"</span>。</span><br><span class="line"><span class="string">"则 HashSet集合中的 两个元素【相同】，【不予添加】"</span></span><br><span class="line"></span><br><span class="line">Set集合<span class="string">"不能"</span>存放重复元素，<span class="string">"其add()方法在添加时会判断是否有重复元素，"</span>有重复【不】添加<span class="string">"，"</span>没重复则添加<span class="string">""</span>。</span><br><span class="line">HashSet集合由于是<span class="string">"无序"</span>的，其判断唯一的依据是元素类型的<span class="string">"hashCode与equals方法的返回结果"</span>。</span><br><span class="line"></span><br><span class="line">规则如下：</span><br><span class="line">先判断新元素与集合内已经有的旧元素的<span class="string">"HashCode值"</span></span><br><span class="line"><span class="number">1</span>): 如果<span class="string">"不同"</span>，说明是<span class="string">"不同元"</span>素，<span class="string">"添加到集合"</span>。</span><br><span class="line"><span class="number">2</span>): 如果<span class="string">"相同"</span>，再<span class="string">"判断equals比较结果"</span>。返回<span class="keyword">true</span>则<span class="string">"相同元素"</span>，<span class="string">"不予添加"</span>；</span><br><span class="line">     返回<span class="keyword">false</span>则<span class="string">"不同元素"</span>，<span class="string">"添加到集合"</span>。</span><br><span class="line">即：两个对象通过<span class="string">"equals()方法"</span>比较<span class="string">"相等"</span>，并且两个对象的<span class="string">"hashCode()方法"</span>返回值<span class="string">"也相等"</span>。</span><br><span class="line">则<span class="string">"不予添加"</span>。</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">总结：</span><br><span class="line">使用<span class="string">"HashSet"</span><span class="string">"存储【自定义类型】"</span>时，</span><br><span class="line">如果<span class="string">"没有重写"</span>该类的hashCode与equals方法，则判断重复时，使用的是<span class="string">"内存地址值"</span>，</span><br><span class="line">如果想通过<span class="string">"【内容】比较元素是否相同"</span>，<span class="string">"需要重写"</span>该元素类的hashcode与equals方法。</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">！！！！！！！！！！！！！！<span class="string">"注意"</span>：</span><br><span class="line">如果向HashSet中添加一个<span class="string">"可变对象"</span>后，</span><br><span class="line">后面程序修改了该<span class="string">"可变对象"</span>的<span class="string">"实例变量"</span>，则可能导致它与集合中<span class="string">"其他对象"</span>的<span class="string">"元素相同"</span>。</span><br><span class="line">(即两个对象通过equals()方法比较返回<span class="keyword">true</span>，两个对象的 hashCode 值也相等)，</span><br><span class="line">这就可能导致HashSet 中包含<span class="string">"两个相同的对象"</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj.getClass()==Example.class)&#123;</span><br><span class="line">            Example ex = (Example) obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count ==ex.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Example[count: "</span>+ <span class="keyword">this</span>.count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Example&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hs.add(<span class="keyword">new</span> Example(<span class="number">5</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Example(-<span class="number">3</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Example(<span class="number">9</span>));</span><br><span class="line">        hs.add(<span class="keyword">new</span> Example(-<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//打印HashSet集合，集合元素没有重复</span></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">        Iterator&lt;Example&gt; it = hs.iterator();</span><br><span class="line">        it.next().count = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为第一个元素的count实例变量赋值</span></span><br><span class="line">        System.out.println(hs);</span><br><span class="line"><span class="comment">//删除值为-3的Example对象</span></span><br><span class="line">        hs.remove(<span class="keyword">new</span> Example(-<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">        System.out.println(<span class="string">"hs是否包含count为-3的Example对象? "</span>+ hs.contains(<span class="keyword">new</span> Example(-<span class="number">3</span>)));</span><br><span class="line">        System.out.println(<span class="string">"hs是否包含count为-2的Example对象? "</span>+ hs.contains(<span class="keyword">new</span> Example(-<span class="number">2</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[Example[count: -<span class="number">2</span>], Example[count: -<span class="number">3</span>], Example[count: <span class="number">5</span>], Example[count: <span class="number">9</span>]]</span><br><span class="line">[Example[count: -<span class="number">3</span>], Example[count: -<span class="number">3</span>], Example[count: <span class="number">5</span>], Example[count: <span class="number">9</span>]]</span><br><span class="line">[Example[count: -<span class="number">3</span>], Example[count: <span class="number">5</span>], Example[count: <span class="number">9</span>]]</span><br><span class="line">hs是否包含count为-<span class="number">3</span>的Example对象? <span class="keyword">false</span></span><br><span class="line">hs是否包含count为-<span class="number">2</span>的Example对象? <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">正如结果所见到的，</span><br><span class="line">HashSet集合的第<span class="number">1</span>个元素和第<span class="number">2</span>个元素<span class="string">"完全相同"</span>，这表明两个元素<span class="string">"已经重复"</span>。此时HashSet会比较混乱:</span><br><span class="line">当试图删除count为-<span class="number">3</span>的Example对象时，</span><br><span class="line">HashSet会计算出该对象的hashCode值，从而找出该对象在集合中的保存位置，</span><br><span class="line">然后把此处的对象与count为-<span class="number">3</span>的Example对象时通过equals()方法进行比较，如果相等则删除该对象：</span><br><span class="line">HashSet<span class="string">"只有"</span>第<span class="number">2</span>个元素才满足该条件(第<span class="number">1</span>个元素</span><br><span class="line"><span class="string">"实际"</span>上保存在count为-<span class="number">2</span>的Example对象对应的位置)，</span><br><span class="line">所以<span class="string">"第2个元素被删除"</span>。至于第一个count为-<span class="number">3</span>的Example对象，它保存在count为-<span class="number">2</span>的Example对象对应的位置，</span><br><span class="line">但使用equals()方法拿它和count为-<span class="number">2</span>的R对象比较时又返回<span class="keyword">false</span>—这将导致HashSet<span class="string">"不能"</span><span class="string">"准确"</span>访问该<span class="string">"元素"</span>。</span><br></pre></td></tr></table></figure><h3 id="18hashCode和equals方法的面试题"><a href="#18hashCode和equals方法的面试题" class="headerlink" title="18hashCode和equals方法的面试题"></a>18hashCode和equals方法的面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> A:hashCode和equals的面试题</span><br><span class="line"> </span><br><span class="line"> 两个对象  Person  p1 p2</span><br><span class="line"> 问题: </span><br><span class="line">(<span class="number">1</span>)<span class="string">"如果两个对象的哈希值相同"</span> p1.hashCode()==p2.hashCode()</span><br><span class="line">  两个对象的equals一定返回<span class="keyword">true</span>吗  p1.equals(p2) 一定是<span class="keyword">true</span>吗</span><br><span class="line">  正确答案:<span class="string">"p1.equals(p2)不一定"</span>是<span class="keyword">true</span></span><br><span class="line">      </span><br><span class="line">(<span class="number">2</span>)<span class="string">"如果两个对象的equals方法返回true"</span>,p1.equals(p2)==<span class="keyword">true</span></span><br><span class="line">  两个对象的<span class="string">"哈希值一定相同"</span>吗</span><br><span class="line">  正确答案: <span class="string">"哈希值一定相同"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">在 Java 应用程序执行期间，<span class="string">"规定"</span>：</span><br><span class="line"><span class="number">1</span>.<span class="string">"如果根据 equals(Object) 方法"</span>，<span class="string">"两个对象是相等"</span>的，</span><br><span class="line">那么对这两个对象中的每个对象调用 <span class="string">"hashCode 方法"</span>都<span class="string">"必须生成相同的整数结果"</span>。 </span><br><span class="line"><span class="number">2</span>.如果根据 equals(java.lang.Object) 方法，<span class="string">"两个对象【不相等】"</span>，</span><br><span class="line">那么对这两个对象中的任一对象上调用<span class="string">" hashCode 方法"</span> <span class="string">"不要求"</span>一定<span class="string">"生成不同的整数结果"</span>。</span><br><span class="line">此时，hashCode值(可以<span class="string">"相同"</span>也<span class="string">"可以不同"</span>) </span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span> 两个对象不同(对象属性值不同) equals返回<span class="keyword">false</span>=====&gt;两个对象调用hashCode()方法<span class="string">"哈希值"</span><span class="string">"可相同"</span></span><br><span class="line"></span><br><span class="line">两个对象调用hashCode()方法哈希值不同=====&gt;equals返回<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.2</span> 两个对象不同(对象属性值不同) equals返回<span class="keyword">false</span>=====&gt;两个对象调用hashCode()方法<span class="string">"哈希值"</span><span class="string">"可不同"</span></span><br><span class="line"></span><br><span class="line">两个对象调用hashCode()方法哈希值相同=====&gt;equals返回<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">"所以说两个对象【哈希值】无论【相同】还是【不同】,equals都可能返回"</span><span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="19TreeSet类"><a href="#19TreeSet类" class="headerlink" title="19TreeSet类"></a>19TreeSet类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">TreeSet 类与散列集HashSet十分类似， 不过， 它比HashSet有所改进。</span><br><span class="line">TreeSet是一个<span class="string">"有序集合"</span>( sorted collection) 。可以以任意顺序将元素插入到集合中。</span><br><span class="line">在对集合进行遍历时， 每个值将<span class="string">"自动地按照排序后"</span>的<span class="string">"顺序"</span>呈现。</span><br><span class="line">TreeSet是SortedSet接口的实现类。</span><br><span class="line"></span><br><span class="line">与<span class="string">"HashSet集合"</span>采用<span class="string">"hash算法"</span>来决定元索的<span class="string">"存储位置"</span>不同，</span><br><span class="line"><span class="string">"TreeSet"</span>采用<span class="string">"红黑树"</span>的数据结构来存储集合元素。</span><br><span class="line">TreeSet支持两种排序方法:<span class="string">"自然排序"</span>和<span class="string">"定制排序"</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator():</span><br><span class="line">如果TreeSet采用了<span class="string">"定制排序"</span>，则该方法返回定制排序所使用的</span><br><span class="line">如果TreeSet采用了<span class="string">"自然排序"</span>，则返回<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span>: 返回集合中的第一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span>: 返回集合中的最后一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span>:返回集合中位于指定元素之前的元素<span class="params">(即小于指定元素的最大元素，</span></span></span><br><span class="line"><span class="function"><span class="params">参考元素不需要是TreeSet集合里的元素)</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span>:返回集合中位于指定元素之后的元素<span class="params">(即大于指定元素的最小元素，</span></span></span><br><span class="line"><span class="function"><span class="params">参考元素不需要是TreeSet集合里的元素)</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement,E toElement)</span>:</span></span><br><span class="line"><span class="function">返回此Set的子集合，范围从<span class="title">fromElement</span> <span class="params">(包含)</span>到<span class="title">toElement</span><span class="params">(不包含)</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span>:</span></span><br><span class="line"><span class="function">返回此Set的子集，由小于toElement的元素组成。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span>:</span></span><br><span class="line"><span class="function">返回此Set的子集，由大于或等于fromElement的元素组成。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">TreeSet并【不是】根据元素的【插入顺序】进行排序的，而是根据元素【实际值的大小】来进行排序的。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class TreeSetDemol </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; tset = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        tset.add(<span class="number">12</span>);</span><br><span class="line">        tset.add(-<span class="number">9</span>);</span><br><span class="line">        tset.add(<span class="number">19</span>);</span><br><span class="line">        tset.add(<span class="number">78</span>);</span><br><span class="line">        tset.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(tset);<span class="comment">//[-9, 3, 12, 19, 78]</span></span><br><span class="line">        System.out.println(tset.first());<span class="comment">//-9</span></span><br><span class="line">        System.out.println(tset.last());<span class="comment">//78</span></span><br><span class="line">        System.out.println(tset.lower(<span class="number">5</span>));<span class="comment">//3</span></span><br><span class="line">        System.out.println(tset.higher(<span class="number">7</span>));<span class="comment">//12</span></span><br><span class="line">        System.out.println(tset.headSet(<span class="number">4</span>));<span class="comment">//[-9, 3]</span></span><br><span class="line">        System.out.println(tset.tailSet(<span class="number">8</span>));<span class="comment">//[12, 19, 78]</span></span><br><span class="line">        System.out.println(tset.subSet(<span class="number">2</span>,<span class="number">13</span>));<span class="comment">//[3, 12]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20TreeSet类的自然排序和定制排序"><a href="#20TreeSet类的自然排序和定制排序" class="headerlink" title="20TreeSet类的自然排序和定制排序"></a>20TreeSet类的自然排序和定制排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 自然排序</span><br><span class="line">TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，</span><br><span class="line">然后将集合元素按升序排列，这种方式就是自然排序。</span><br><span class="line">如果试图把个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序将会抛出异常。</span><br><span class="line">例如：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetErrorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String「<span class="number">1</span>args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          TreeSet ts=<span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//向TreeSet集合中添加两个Err对象</span></span><br><span class="line">        ts.add(<span class="function">aew <span class="title">Err</span><span class="params">()</span>)</span>;</span><br><span class="line">        ts.add (<span class="function">nest <span class="title">Err</span><span class="params">()</span>)</span>;<span class="comment">//(1)</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的程序试图向TreeSet集合中添加两个Err对象，添加第一个对象时，TreeSet里没有任何元素，</span><br><span class="line">所以不会出现任何问题;但是添加第二个Err对象时，</span><br><span class="line">TreeSet就会调用该对象的compareTo(Object obj)方法与集合中的其他元素进行比较：</span><br><span class="line">如果其对应的类没有实现Comparable接口，则会引发</span><br><span class="line">CIassCastException异常。因此，上面的程序会在(<span class="number">1</span>)处引发该异常。</span><br><span class="line"></span><br><span class="line">此外：</span><br><span class="line"><span class="string">"如果希望TreeSet能正常运作，TreeSet【只能】添加【同一种类型】的对象"</span>。</span><br><span class="line">对于TreeSet集合，判断两个对象是否相等的唯一标准是：</span><br><span class="line">两个对象通过<span class="string">"compareTo(Object obj)方法"</span>比较<span class="string">"是否返回0"</span>：</span><br><span class="line">如果通过compareTo(Object obj)方法比较<span class="string">"返回0"</span>，TreeSet则会认为它们<span class="string">"相等"</span>;否则就认为它们不相等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 定制排序</span><br><span class="line">TreeSet 的 自然排序是根据集合元素的大小， TreeSet将它们以升序排列。 </span><br><span class="line">如果需要实现定制排序 ，例如以降序排列 ，则可以通过<span class="string">" Comparator 接口 "</span>的帮助 。 </span><br><span class="line">该接 口 里包含一个 <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T <span class="number">01</span>, T <span class="number">02</span>)</span>方法 ，</span></span><br><span class="line"><span class="function">该方法用于 比较 01 和 02 的大小:</span></span><br><span class="line"><span class="function">如果该方法返回正整数，则表 明 01 大于 02； 如果该方法返回 0，则表 明 0 1 等于 02；</span></span><br><span class="line"><span class="function">如果该方法返回负整数，则表 明 01 小于 02 </span>;</span><br><span class="line"></span><br><span class="line">如果需要实现<span class="string">"定制排序"</span> ，则需要在创建 TreeSet 集合对象时，提供一个 <span class="string">"Comparator 对象"</span>与该 <span class="string">"TreeSet</span></span><br><span class="line"><span class="string">集合"</span><span class="string">"关联"</span> ，由该<span class="string">" Comparator 对象"</span><span class="string">"负责"</span>集合元素的<span class="string">"排序逻辑"</span> 。</span><br><span class="line"> 由于 Comparator 是一个函数式接口 ， 因此可使用 Lambda 表达式来代替 Comparator 对象 。</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeSet定制排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"M&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//此处 Lambda 表达式的目标类型是 Comparator</span></span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet((t1, t2) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            M m1 = (M) t1;</span><br><span class="line">            M m2 = (M) t2;</span><br><span class="line">        <span class="comment">//根据"对象的 a归属性来决定大小， ag. 越大， M 对象反而越小</span></span><br><span class="line">            <span class="keyword">return</span> m1.age&gt; m2.age ? -<span class="number">1</span></span><br><span class="line">                    : m1.age&lt;m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">降序排列： [M&#123;age=<span class="number">9</span>&#125;, M&#123;age=<span class="number">5</span>&#125;, M&#123;age=-<span class="number">3</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="21TreeSet类判断对象是否重复的原理"><a href="#21TreeSet类判断对象是否重复的原理" class="headerlink" title="21TreeSet类判断对象是否重复的原理"></a>21TreeSet类判断对象是否重复的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">对于TreeSet集合，判断<span class="string">"两个对象是否相等"</span>的<span class="string">"唯一标准"</span>是:</span><br><span class="line">两个对象通过<span class="string">"compareTo(Object obj)方法"</span><span class="string">"比较"</span>是否返回<span class="number">0</span>：</span><br><span class="line">如果通过compareTo(Object obj)方法比较<span class="string">"返回0"</span>，TreeSet则会认为它们<span class="string">"相等"</span>;<span class="string">"否则"</span>就认为它们<span class="string">"不相等"</span>。</span><br><span class="line">只和<span class="string">"compareTo(Object obj)方法"</span><span class="string">"结果有关"</span></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exampale</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Exampale</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Exampale</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.age =age;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="string">"equals()方法总是返回 true"</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="string">"compareTo(Object obj)方法总是返回 1"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Exampale&gt; ts= <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        Exampale e1 = <span class="keyword">new</span> Exampale(<span class="number">10</span>);</span><br><span class="line">        ts.add(e1);  (<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//第二次添加同一个对象 ， 输出 true ， 表明添加成功</span></span><br><span class="line">        <span class="keyword">boolean</span> bb = ts.add(e1);  (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面输出 set 集合，将看到有两个元素</span></span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        <span class="comment">//修改 set 集合的第一个元素的 age 变量</span></span><br><span class="line">        ts.first().age = <span class="number">88</span>;</span><br><span class="line">        <span class="comment">//输出 set 集合的最后一个元素的 age 变量，将看到也变成了88</span></span><br><span class="line">        System.out.println(ts.last().age);<span class="comment">//88</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[demo10.Exampale@<span class="number">4554617</span>c, demo10.Exampale@<span class="number">4554617</span>c]</span><br><span class="line"><span class="number">88</span></span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">程序中(<span class="number">1</span>)代码行把同一个对象再次添加到 TreeSet 集合中 ，</span><br><span class="line"><span class="string">"因为 e1 对象的compareTo(Object obj)方法总是返回 1 "</span>， <span class="string">"不返回0 "</span>，</span><br><span class="line">虽然它的 equals()方法总是返回 <span class="keyword">true</span> ，但  <span class="string">"TreeSet "</span></span><br><span class="line">会认为 <span class="string">" e1 对象 "</span>和 <span class="string">"它自己 "</span>也 <span class="string">"不相等 "</span> ，</span><br><span class="line"> 因此,TreeSet 可以添加两个e1对象。</span><br><span class="line"></span><br><span class="line">从图可以看到 TreeSet 对象保存的两个元素(集合里的元素总是<span class="string">"引用"</span>，</span><br><span class="line">但习惯上把被引用的对象称为集合元素) ， 实际上是同一个元素(<span class="string">"同一个引用"</span>) 。</span><br><span class="line">所以当<span class="string">"修改"</span> TreeSet 集合里<span class="string">"第一个元素"</span>的 age 变量后，</span><br><span class="line">该 TreeSet 集合里<span class="string">"最后一个元素"</span>的 age 变量也<span class="string">"随之改变"</span>。</span><br><span class="line"></span><br><span class="line">由此应该注意一个问题 :</span><br><span class="line">当需要把一个对象放入 TreeSet 中，重写该对象对应类的<span class="string">" equals方法"</span>时 ，</span><br><span class="line">应保证该方法与 <span class="string">"compareTo(Object obj)方法"</span>有<span class="string">"一致"</span>的<span class="string">"结果"</span>.</span><br><span class="line">其规则是 : 如果两个对象通过<span class="string">" equals()方法"</span></span><br><span class="line">比较返回 <span class="keyword">true</span> 时，这两个对象通过 <span class="string">"compareTo(Object obj)方法 "</span>比较应<span class="string">"返回 0 "</span>。</span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544445756/samples/java%20files/%E6%8D%95%E8%8E%B7.jpg" alt="方法调用的内存图"></p><h3 id="22各Set实现类的性能分析"><a href="#22各Set实现类的性能分析" class="headerlink" title="22各Set实现类的性能分析"></a>22各Set实现类的性能分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet 和 TreeSet 是 Set 的两个典型实现 ，到底如何选择HashSet 和 TreeSet 呢? </span><br><span class="line"><span class="string">"HashSet "</span>的性能总是<span class="string">"比"</span> <span class="string">"TreeSet"</span> <span class="string">"好"</span>(特别是最常用的<span class="string">"添加、查询元素等操作"</span> ) ，</span><br><span class="line">因为 TreeSet 需要额外的<span class="string">"红黑树算法"</span>来维护集合元素的<span class="string">"次序"</span>。</span><br><span class="line">只有当需要一个保持<span class="string">"排序"</span>的 Set 时，才应该使用 TreeSet ， <span class="string">"否则都应该使用 HashSet"</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinkedHashSet，对于普通的<span class="string">"插入、删除操作"</span>， LinkedHashSet 比 HashSet要<span class="string">"略微慢一点"</span> ，</span><br><span class="line">这是由<span class="string">"维护链表"</span>所带来的额外开销造成的 ，</span><br><span class="line">但<span class="string">"由于有了链表"</span>，<span class="string">"遍历"</span> LinkedHashSet 会<span class="string">"比"</span>HashSet<span class="string">"更快"</span> 。</span><br></pre></td></tr></table></figure><h3 id="23-Queue-队列-集合"><a href="#23-Queue-队列-集合" class="headerlink" title="23 Queue(队列)集合"></a>23 Queue(队列)集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Queue 用于模拟队列这种数据结构 ， 队列通常是指<span class="string">"先进先出"</span> (FIFO ) 的容器 。 </span><br><span class="line">队列的头部保存在队列中存放时间最长的元素 ，队列的尾部保存在队列中存放时间最短的元素。</span><br><span class="line">新元素插入 (offer ) 到队列的尾部，访问元素 (poll) 操作会返回队列头部的元素 。</span><br><span class="line">通常 ，队列不允许随机访问队列中的元素。</span><br><span class="line"></span><br><span class="line">Queue 接口中定义了如下儿个方法。</span><br><span class="line">~ <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span>: 将指定元素加入此队列的【尾部】 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">element</span><span class="params">()</span>: 获取队列【头部】 的元素，但是不删除该元素 。</span></span><br><span class="line"><span class="function">~ <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Object e)</span>: 将指定元素加入此队列的【尾部】。当使用有容量 限制的队列时，此方法通</span></span><br><span class="line"><span class="function">常比 <span class="title">add</span><span class="params">(Object e)</span>方法更好 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">peek</span><span class="params">()</span>: 获取队列【头部】的元素，但是【不删除】该元素。如果此队列为空，则返回 <span class="keyword">null</span> 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">poll</span><span class="params">()</span>: 获取队列【头部】的元素 ， 并【删除】该元素 。如果此队列为 空 ，则返回 <span class="keyword">null</span> 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">remove</span><span class="params">()</span>: 获取 队列【头部】的元素，并删除该元素 。</span></span><br></pre></td></tr></table></figure><h3 id="24-Priority-Queue-优先级队列"><a href="#24-Priority-Queue-优先级队列" class="headerlink" title="24 Priority Queue 优先级队列"></a>24 Priority Queue 优先级队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"PriorityQueue"</span> 是一个比较标准的队列实现类 ，但<span class="string">"不是绝对标准"</span>的<span class="string">"队列"</span>实现，</span><br><span class="line">是因为 PriorityQueue 保存队列元素的顺序并<span class="string">"不是"</span>按<span class="string">"加入队列"</span>的<span class="string">"顺序"</span>，</span><br><span class="line">而是按<span class="string">"队列元素"</span>的<span class="string">"大小"</span>进行<span class="string">"重新排序"</span>（堆结构）。</span><br><span class="line">因此当调用 <span class="string">"peek()方法或者 poll()方法"</span>取出队列中的元素时，</span><br><span class="line">并<span class="string">"不是取出"</span><span class="string">"最先进入队列的元素"</span>，<span class="string">"而是"</span>取出队列中<span class="string">"最小的元素"</span> 。 </span><br><span class="line">从这个意义上来看 ， PriorityQueue 已经违反了队列的最基本规则 : 先进先出 (FIFO )</span><br><span class="line"></span><br><span class="line">优先级队列使用的是<span class="string">"堆（heap)数据结构"</span>。</span><br><span class="line">堆是一个可以<span class="string">"自我调整的二叉树"</span>，对树执行<span class="string">"添加（add) "</span>和<span class="string">"删除（remore) "</span>操作， </span><br><span class="line">可以让<span class="string">"最小的元素（优先级最高）"</span><span class="string">"移动到根"</span>，</span><br><span class="line">都将<span class="string">"优先级最高"</span>的任务从<span class="string">"队列"</span>中<span class="string">"删除"</span>（由于<span class="string">"习惯上将1设为最高优先级"</span>，所以会将<span class="string">"最小的元素删除"</span> )</span><br><span class="line">而不必花费时间对元素进行排序。</span><br><span class="line"></span><br><span class="line">优先级队列（priority queue) 中的元素可以<span class="string">"按照任意的顺序插人"</span>，</span><br><span class="line">却总是<span class="string">"按照排序的顺序进行检索"</span>。</span><br><span class="line">也就是说，无论何时调用 remove 方法，<span class="string">"总会获得"</span>当前<span class="string">"优先级队列"</span>中<span class="string">"最小的元素（优先级最高的元素）"</span>。</span><br><span class="line">然而，优先级队列并没有对所有的元素进行排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; pq =<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.offer(<span class="number">12</span>);</span><br><span class="line">        pq.offer(-<span class="number">10</span>);</span><br><span class="line">        pq.offer(<span class="number">118</span>);</span><br><span class="line">        pq.offer(<span class="number">5</span>);</span><br><span class="line">        pq.offer(<span class="number">120</span>);</span><br><span class="line">        System.out.println(pq);<span class="comment">//[-10, 5, 118, 12, 120]</span></span><br><span class="line">        System.out.println(pq.poll());<span class="comment">//-10</span></span><br><span class="line">        System.out.println(pq);<span class="comment">//[5, 12, 118, 120]</span></span><br><span class="line">        System.out.println(pq.poll());<span class="comment">//5</span></span><br><span class="line">        System.out.println(pq.poll());<span class="comment">//12</span></span><br><span class="line">        System.out.println(pq.poll());<span class="comment">//118</span></span><br><span class="line">System.out.println(pq.poll());<span class="comment">//120</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行上面程序<span class="string">"直接输出"</span> PriorityQueue 集合时，可能看到该队列里的元素<span class="string">"并没有"</span>很好地<span class="string">"按大小进行排序"</span>，</span><br><span class="line">但这只是受到 PriorityQueue 的 toString()方法的返回值的影响 。</span><br><span class="line">实际上 ，</span><br><span class="line">程序<span class="string">"多次调用"</span> PriorityQueue集合对象的<span class="string">" poll()方法"</span>，即可看到元素<span class="string">"按从小到大"</span>的顺序<span class="string">"移出队列"</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PriorityQueue <span class="string">"不允许插入"</span> <span class="keyword">null</span> 元素，</span><br><span class="line">它还<span class="string">"需要"</span>对<span class="string">"队列元素"</span>进行<span class="string">"排序"</span> ，PriorityQueue 的元素有两种排序方式。</span><br><span class="line">》<span class="string">"自然排序"</span> : 采用自然顺序的 PriorityQueue 集合中的元素必须实现了 <span class="string">"Comparable 接口"</span>，</span><br><span class="line">而且应该是<span class="string">"同一个类的多个实例"</span>，否则可能导致 ClassCastException 异常 。</span><br><span class="line"></span><br><span class="line">》<span class="string">"定制排序"</span>:创建 PriorityQueue 队列时，传入一个 <span class="string">"Comparator 对象"</span>，</span><br><span class="line">该对象负责对队列中的所有元素进行排序 。采用定制排序时不要求队列元素实现 Comparable 接口 。</span><br><span class="line">PriorityQueue 队列对元素的要求与 TreeSet 对元素的要求基本 一致</span><br></pre></td></tr></table></figure><h3 id="25-Deque-接口-双端队列-与-ArrayDeque-实现类、LinkedList-实现类"><a href="#25-Deque-接口-双端队列-与-ArrayDeque-实现类、LinkedList-实现类" class="headerlink" title="25 Deque 接口(双端队列)与 ArrayDeque 实现类、LinkedList 实现类"></a>25 Deque 接口(双端队列)与 ArrayDeque 实现类、LinkedList 实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Object e)</span>: 将指定元素插入该双端队列的开头。</span></span><br><span class="line"><span class="function">~ <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Object e)</span>: 将指定元素插入该双端队列的末尾。</span></span><br><span class="line"><span class="function">~ Iterator <span class="title">descendingIterator</span><span class="params">()</span>: 返回该双端队列对应的迭代器，该迭代器将以逆向顺序来法代队列</span></span><br><span class="line"><span class="function">中的元素。</span></span><br><span class="line"><span class="function">~ Object <span class="title">getFirst</span><span class="params">()</span>: 获取但不删除双端队列的第一个元素。</span></span><br><span class="line"><span class="function">~ Object <span class="title">getLast</span><span class="params">()</span> : 获取但不删除双端队列的最后 一个元素 。</span></span><br><span class="line"><span class="function">~ <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(Object e)</span>: 将指定元素插入该双端队列的开头 。</span></span><br><span class="line"><span class="function">~ <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(Object e)</span>: 将指定元素插入该双端队列的末尾 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">peekFirst</span><span class="params">()</span>: 获取但不删除该双端队列的第一个元素</span>;如果此双端队列为空，则返回 <span class="keyword">null</span> 。</span><br><span class="line">~ <span class="function">Object <span class="title">peekLast</span><span class="params">()</span>: 获取但不删除该双端队列的最后 一个元素</span>;如果此双端队列为空，则返回 <span class="keyword">null</span> 。</span><br><span class="line">~ <span class="function">Object <span class="title">pollFirst</span><span class="params">()</span>: 获取并删除该双端队列的第一个元素 :如果此双端队列为 空 ，则返回 <span class="keyword">null</span> o</span></span><br><span class="line"><span class="function">~ Object <span class="title">pollLast</span><span class="params">()</span>: 获取并删除该双端队列的最后一个元素 </span>; 如果此双端队列为空，则返回 <span class="keyword">null</span> 。</span><br><span class="line">~ <span class="function">Object <span class="title">pop</span><span class="params">()</span> <span class="params">(栈方法)</span> : pop 出该双端队列所表示的栈的栈顶元素 。 相当于 <span class="title">removeFirst</span><span class="params">()</span> 。</span></span><br><span class="line"><span class="function">~ <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> <span class="params">(栈方法)</span> : 将 一个元素 push 进该双端队列所表 示 的栈的栈顶 。 相当于</span></span><br><span class="line"><span class="function"><span class="title">addFirst</span><span class="params">(e)</span> 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">removeFirst</span><span class="params">()</span>: 获取并删除该双端队列的第一个元素 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">removeFirstOccurrence</span><span class="params">(Object <span class="number">0</span>)</span>: 删 除该双端队列的第一次出现的元素 。 。</span></span><br><span class="line"><span class="function">~ Object <span class="title">removeLast</span><span class="params">()</span>: 获取并删除该双端队列的最后一个元素 。</span></span><br><span class="line"><span class="function">~ <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object <span class="number">0</span>)</span>: 删除该双端队列的最后一次出现的元素。</span>;</span><br><span class="line"></span><br><span class="line">从上面方法中可以看出，<span class="string">" Deque"</span> 不仅可以 当成<span class="string">"双端队列"</span>使用，而且可以被当成<span class="string">"栈"</span>来使用 ， 因为 该类</span><br><span class="line">里还包含了 pop (出栈〉、 push (入栈)两个方法。</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">Deque 接口提供了 一个典型的实现类: <span class="string">"ArrayDeque"</span> ，</span><br><span class="line">从该名称就可以看出，它是一个<span class="string">"基于数组实现的双端队列"</span>，</span><br><span class="line">创建 Deque 时同样可指定一个 numElements 参数 ，该参数用于指定 Object[]数组的长度:</span><br><span class="line">如果不指定 numElements 参数， Deque 底层数组的长度为 <span class="number">16</span> 。</span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="string">Queue 方法    等效 Deque 方法 </span></span><br><span class="line"><span class="string">add(e) addLast(e) </span></span><br><span class="line"><span class="string">offer(e) offerLast(e) </span></span><br><span class="line"><span class="string">remove() removeFirst() </span></span><br><span class="line"><span class="string">poll() pollFirst() </span></span><br><span class="line"><span class="string">element() getFirst() </span></span><br><span class="line"><span class="string">peek() peekFirst() </span></span><br><span class="line"><span class="string">————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="string">堆栈方法 等效 Deque 方法 </span></span><br><span class="line"><span class="string">push(e) addFirst(e) </span></span><br><span class="line"><span class="string">pop() removeFirst() </span></span><br><span class="line"><span class="string">peek() peekFirst() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">————————————————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">当然 <span class="string">"ArrayDeque"</span> 也可以 当成<span class="string">"队列使用"</span>，此处 ArrayDeque 将按<span class="string">"先进先出"</span>的方式操作集合元素</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDequeDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; ad = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ad.offer(<span class="number">23</span>);</span><br><span class="line">        ad.offer(<span class="number">1</span>);</span><br><span class="line">        ad.offer(<span class="number">56</span>);</span><br><span class="line">        ad.offer(-<span class="number">70</span>);</span><br><span class="line">        ad.offer(<span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="string">"//输出 :[23, 1, 56, -70, 8]"</span></span><br><span class="line">        System.out.println(ad);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////访问队列头部的元素，但并不将其 poll 出队列"钱 "， 输出 : 23</span></span><br><span class="line">        System.out.println(ad.peek());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// poll 出第一个元素，输出 23</span></span><br><span class="line">        System.out.println(ad.poll());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出 :[1, 56, -70, 8]</span></span><br><span class="line">        System.out.println(ad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">展示 <span class="string">"ArrayDeque"</span> 作为<span class="string">"栈"</span>的行为 ，<span class="string">"后进先出"</span>,</span><br><span class="line">因此当程序中需要使用<span class="string">"栈"</span> 这种数据结构时，推荐使用 ArrayDeque</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDequeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; ad = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ad.push(<span class="number">42</span>);</span><br><span class="line">        ad.push(<span class="number">205</span>);</span><br><span class="line">        ad.push(-<span class="number">30</span>);</span><br><span class="line">        ad.push(<span class="number">78</span>);</span><br><span class="line">        ad.push(<span class="number">3</span>);</span><br><span class="line">        ad.push(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//输出 :[11, 3, 78, -30, 205, 42]"</span></span><br><span class="line">        System.out.println(ad);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问第一个元素，但并不将其 pop 出"栈,输出 :11</span></span><br><span class="line">        System.out.println(ad.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出 :[11, 3, 78, -30, 205, 42]</span></span><br><span class="line">        System.out.println(ad);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个元素将其 pop 出"栈,输出 :11</span></span><br><span class="line">        System.out.println(ad.pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出 :[ 3, 78, -30, 205, 42]</span></span><br><span class="line">        System.out.println(ad);</span><br><span class="line">        System.out.println(ad.peekLast());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">LinkedList 类是 <span class="string">"List 接口 "</span>的 实现类,LinkedList 还实现了 <span class="string">"Deque 接口"</span>,</span><br><span class="line">可以被当成<span class="string">"双端队列"</span>来使用 ， 因此既可以被当成<span class="string">"栈"</span>来使用，也可以 当成<span class="string">"队列"</span>使用 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; lds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="string">"//将元素加入队列的尾部"</span></span><br><span class="line">        lds.offer(<span class="number">23</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="string">"//将一个元素加入【栈】的顶部"</span></span><br><span class="line">        lds.push(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将元素加入【队列】的尾部"</span></span><br><span class="line">        lds.offer(<span class="number">407</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将元素添加到【队列】的头部(相当于【栈】的顶部〉"</span></span><br><span class="line">        lds.addFirst(<span class="number">56</span>);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//输出：[56, 111, 23, 407]"</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line"></span><br><span class="line">        <span class="string">"//以 List 的方式(按【索引访问】的方式〉来遍历集合元素"</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ee:lds)&#123;</span><br><span class="line">            System.out.println(ee);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问并不删除顶的元素:56</span></span><br><span class="line">        System.out.println(lds.peekFirst()) ;</span><br><span class="line">        <span class="comment">//访问并不删除队列的最后一个元素:407</span></span><br><span class="line">        System.out.println(lds.peekLast()) ;</span><br><span class="line"></span><br><span class="line">        <span class="string">"//将【栈】顶的元素弹出 ,输出 56"</span></span><br><span class="line">        System.out.println(lds.pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[111, 23, 407]</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问并删除【队列】的最后一个元素: 407</span></span><br><span class="line">        System.out.println(lds.pollLast());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[111, 23]</span></span><br><span class="line">        System.out.println(lds);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">List与Set集合的区别？</span><br><span class="line">List:</span><br><span class="line">它是一个有序的集合(元素存与取的顺序相同)</span><br><span class="line">它可以存储重复的元素</span><br><span class="line">Set:</span><br><span class="line">它是一个无序的集合(元素存与取的顺序可能不同)</span><br><span class="line">它不能存储重复的元素</span><br><span class="line"></span><br><span class="line">List集合中的特有方法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, Object element)</span> 将指定的元素，添加到该集合中的指定位置上</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>返回集合中指定位置的元素。</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> 移除列表中指定位置的元素, 返回的是被移除的元素</span></span><br><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object element)</span>用指定元素替换集合中指定位置的元素,返回值的更新前的元素</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ArrayList:</span></span><br><span class="line"><span class="function">底层数据结构是数组，查询快，增删慢</span></span><br><span class="line"><span class="function">LinkedList:</span></span><br><span class="line"><span class="function">底层数据结构是链表，查询慢，增删快</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">HashSet:</span></span><br><span class="line"><span class="function">元素唯一，不能重复</span></span><br><span class="line"><span class="function">底层结构是 哈希表结构</span></span><br><span class="line"><span class="function">元素的存与取的顺序不能保证一致</span></span><br><span class="line"><span class="function">如何保证元素的唯一的？</span></span><br><span class="line"><span class="function">重写<span class="title">hashCode</span><span class="params">()</span> 与 <span class="title">equals</span><span class="params">()</span>方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">LinkedHashSet:</span></span><br><span class="line"><span class="function">元素唯一不能重复</span></span><br><span class="line"><span class="function">底层结构是 哈希表结构 + 链表结构</span></span><br><span class="line"><span class="function">元素的存与取的顺序一致</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1543368661/samples/java%20files/photo-1541904563-aa0331e9f99a.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、List接口&lt;br&gt;2、ArrayList集合、LinkedList集合&lt;br&gt;3、Set接口&lt;br&gt;4、哈希表(Hash table)&lt;br&gt;5、HashSet集合、LinkedHashSet集合、TreeSet集合&lt;br&gt;6、判断集合唯一性原理&lt;br&gt;7、Queue接口(队列)&lt;br&gt;8、PrioritQueue 优先级队列&lt;br&gt;9、Deque 接口(双端队列)、ArrayDeque 实现类&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础16(集合Collecton,Iterator迭代器,增强for循环,泛型)</title>
    <link href="https://leesen998.github.io/2016/10/26/day18%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/26/day18笔记/</id>
    <published>2016-10-26T01:48:29.000Z</published>
    <updated>2018-12-07T06:00:34.302Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1544080633/samples/java%20files/photo-1542127556-39e356556a8a.jpg" alt="" style="width:100%"></p><p>1、集合<br>2、Iterator迭代器<br>3、增强for循环<br>4、泛型</p><a id="more"></a><h3 id="01集合使用的回顾"><a href="#01集合使用的回顾" class="headerlink" title="01集合使用的回顾"></a>01集合使用的回顾</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> *A:集合使用的回顾</span><br><span class="line">   *a.ArrayList集合存储<span class="number">5</span>个<span class="keyword">int</span>类型元素</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">111</span>);</span><br><span class="line">        list.add(<span class="number">222</span>);</span><br><span class="line">        list.add(<span class="number">333</span>);</span><br><span class="line">        list.add(<span class="number">444</span>);</span><br><span class="line">        list.add(<span class="number">555</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">               System.out.println(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  *b.ArrayList集合存储<span class="number">5</span>个Person类型元素</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//重写toString()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraryListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList &lt;Person&gt; aa = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        aa.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">23</span>));</span><br><span class="line">        aa.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">52</span>));</span><br><span class="line">        aa.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>,<span class="number">36</span>));</span><br><span class="line">        <span class="keyword">for</span>(Person p : aa)&#123;</span><br><span class="line">            System.out.println(p);<span class="comment">//默认调用toString()方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02集合的学习目标"><a href="#02集合的学习目标" class="headerlink" title="02集合的学习目标"></a>02集合的学习目标</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   集合，集合是java中提供的一种容器，可以用来存储多个数据。</span><br><span class="line">    在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。</span><br><span class="line">那么，集合和数组既然都是容器，它们有啥区别呢？</span><br><span class="line">      <span class="string">"数组的长度是固定的。【集合】的【长度】是【可变】的。"</span></span><br><span class="line">     <span class="string">" 集合中存储的元素【必须】是【引用类型数据】"</span></span><br></pre></td></tr></table></figure><h3 id="03集合继承关系图"><a href="#03集合继承关系图" class="headerlink" title="03集合继承关系图"></a>03集合继承关系图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A:集合继承关系图</span><br><span class="line"> a:ArrayList的继承关系:</span><br><span class="line"> 查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而List接口又继承了Collection接口</span><br><span class="line"> <span class="string">"Collection接口为【最顶层】【集合接口】了"</span>。</span><br><span class="line"> 源代码：</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">b:集合继承体系</span><br><span class="line"> <span class="string">"这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写。</span></span><br><span class="line"><span class="string">那么，实现Collection接口的所有子类都会进行方法重写。</span></span><br><span class="line"><span class="string">   Collecton接口常用的子接口有：List接口、Set接口</span></span><br><span class="line"><span class="string">   List接口常用的子类有：ArrayList类、LinkedList类</span></span><br><span class="line"><span class="string">   Set接口常用的子类有：HashSet类、LinkedHashSet类</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">                              Collection 接口     </span></span><br><span class="line"><span class="string">                                   |</span></span><br><span class="line"><span class="string">     ----------------------------------------------------------------</span></span><br><span class="line"><span class="string">     |                                                              |</span></span><br><span class="line"><span class="string">    List接口                                                       Set接口</span></span><br><span class="line"><span class="string">     |                                                              |</span></span><br><span class="line"><span class="string"> ----------------                                             -------------</span></span><br><span class="line"><span class="string"> |              |                                             |            |</span></span><br><span class="line"><span class="string">ArrayList类    LinkedList类                                 HashSet类     LinkedHashSet类</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><h3 id="04集合Collection的方法"><a href="#04集合Collection的方法" class="headerlink" title="04集合Collection的方法"></a>04集合Collection的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">A:集合Collection的方法</span><br><span class="line">    <span class="string">"/*</span></span><br><span class="line"><span class="string">     *  Collection接口中的方法</span></span><br><span class="line"><span class="string">     *  是集合中所有实现类必须拥有的方法</span></span><br><span class="line"><span class="string">     *  使用Collection接口的实现类,程序的演示</span></span><br><span class="line"><span class="string">     *  ArrayList implements List</span></span><br><span class="line"><span class="string">     *  List extends Collection</span></span><br><span class="line"><span class="string">     *  方法的执行,都是实现的重写</span></span><br><span class="line"><span class="string">     */"</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       function_2();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="string">"/*  Collection接口方法</span></span><br><span class="line"><span class="string">      *  Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组</span></span><br><span class="line"><span class="string">      *  返回是一个存储对象的数组, 数组存储的数据类型是Object</span></span><br><span class="line"><span class="string">      */"</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       coll.add(<span class="string">"abc"</span>);</span><br><span class="line">       coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">       coll.add(<span class="string">"itheima"</span>);</span><br><span class="line">       coll.add(<span class="string">"money"</span>);</span><br><span class="line">       coll.add(<span class="string">"123"</span>);</span><br><span class="line">       </span><br><span class="line">       Object[] objs = coll.toArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; objs.length ; i++)&#123;</span><br><span class="line">         System.out.println(objs[i]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="string">"/*</span></span><br><span class="line"><span class="string">      * 学习Java中三种长度表现形式</span></span><br><span class="line"><span class="string">      * ——————————————————————————————————</span></span><br><span class="line"><span class="string">      *   数组.length 属性  返回值 int</span></span><br><span class="line"><span class="string">      * ——————————————————————————————————</span></span><br><span class="line"><span class="string">      *   字符串.length() 方法,返回值int</span></span><br><span class="line"><span class="string">      * ——————————————————————————————————</span></span><br><span class="line"><span class="string">      *   集合.size()方法, 返回值int</span></span><br><span class="line"><span class="string">      */"</span></span><br><span class="line">     </span><br><span class="line">     <span class="string">"/*</span></span><br><span class="line"><span class="string">      * Collection接口方法</span></span><br><span class="line"><span class="string">      * boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true</span></span><br><span class="line"><span class="string">      * 如果此 collection 包含【指定的元素】，则返回 true </span></span><br><span class="line"><span class="string">      * 方法参数是Object类型</span></span><br><span class="line"><span class="string">      */"</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       coll.add(<span class="string">"abc"</span>);</span><br><span class="line">       coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">       coll.add(<span class="string">"itheima"</span>);</span><br><span class="line">       coll.add(<span class="string">"money"</span>);</span><br><span class="line">       coll.add(<span class="string">"123"</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">boolean</span> b = coll.contains(<span class="string">"itcast"</span>);</span><br><span class="line">       System.out.println(b);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="string">"/*</span></span><br><span class="line"><span class="string">      * Collection接口的方法</span></span><br><span class="line"><span class="string">      * void clear() 清空集合中的所有元素</span></span><br><span class="line"><span class="string">      * 集合容器本身依然存在</span></span><br><span class="line"><span class="string">      */"</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//接口多态的方式调用</span></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       coll.add(<span class="string">"abc"</span>);</span><br><span class="line">       coll.add(<span class="string">"bcd"</span>);</span><br><span class="line">       System.out.println(coll);</span><br><span class="line">       </span><br><span class="line">       coll.clear();</span><br><span class="line">       </span><br><span class="line">       System.out.println(coll);</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="05集合Collection的remove方法"><a href="#05集合Collection的remove方法" class="headerlink" title="05集合Collection的remove方法"></a>05集合Collection的remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">05</span>集合Collection的remove方法</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  * Collection接口方法</span></span><br><span class="line"><span class="string">  * boolean remove(Object o)移除集合中指定的元素</span></span><br><span class="line"><span class="string">  * 如果集合中包含多个相同的元素，remove方法只删除出现的第一个元素。</span></span><br><span class="line"><span class="string">  * </span></span><br><span class="line"><span class="string">  * </span></span><br><span class="line"><span class="string">  * 另外：</span></span><br><span class="line"><span class="string">  * boolean removeAll(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="string">  * 移除此 collection 中那些也包含在【指定 collection 】中的【所有元素】（可选操作）。</span></span><br><span class="line"><span class="string">  * 此调用返回后，collection 中将不包含任何与指定 collection 相同的元素。 </span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">   coll.add(<span class="string">"abc"</span>);</span><br><span class="line">   coll.add(<span class="string">"money"</span>);</span><br><span class="line">   coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">   coll.add(<span class="string">"itheima"</span>);</span><br><span class="line">   coll.add(<span class="string">"money"</span>);</span><br><span class="line">   coll.add(<span class="string">"123"</span>);  </span><br><span class="line">   System.out.println(coll);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">boolean</span> b = coll.remove(<span class="string">"money"</span>);</span><br><span class="line">   System.out.println(b);</span><br><span class="line">   System.out.println(coll);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="06迭代器的概述"><a href="#06迭代器的概述" class="headerlink" title="06迭代器的概述"></a>06迭代器的概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:迭代器概述:</span><br><span class="line">a:java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。</span><br><span class="line">我们要取出这些集合中的元素，可通过一种<span class="string">"通用的获取方式"</span>来完成。</span><br><span class="line"></span><br><span class="line">b:<span class="string">"Collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，</span></span><br><span class="line"><span class="string">如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。</span></span><br><span class="line"><span class="string">一直把集合中的所有元素全部取出。这种取出方式专业术语称为【迭代】。</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">c:<span class="string">"每种集合的底层的数据结构不同,例如ArrayList是数组,LinkedList底层是链表,但是无论使用那种集合,</span></span><br><span class="line"><span class="string">我们都会有判断是否有元素以及取出里面的元素的动作,</span></span><br><span class="line"><span class="string">那么Java为我们提供一个【迭代器】定义了【统一的判断元素和取元素的方法】"</span></span><br></pre></td></tr></table></figure><h3 id="07迭代器的实现原理"><a href="#07迭代器的实现原理" class="headerlink" title="07迭代器的实现原理"></a>07迭代器的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> *A:迭代器的实现原理</span><br><span class="line"><span class="string">" /*</span></span><br><span class="line"><span class="string">   *  集合中的迭代器:</span></span><br><span class="line"><span class="string">   *    获取集合中元素方式</span></span><br><span class="line"><span class="string">   *  接口 Iterator : 两个抽象方法</span></span><br><span class="line"><span class="string">   *     boolean hasNext() 判断集合中还有没有可以被取出的元素,如果有返回true</span></span><br><span class="line"><span class="string">   *     next() 取出集合中的下一个元素</span></span><br><span class="line"><span class="string">   * ————————————————————————————————————————————————————————————————————     </span></span><br><span class="line"><span class="string">   *  Iterator接口,找实现类.</span></span><br><span class="line"><span class="string">   *    Collection接口定义了iterator方法： </span></span><br><span class="line"><span class="string">   *       Iterator&lt;E&gt;  iterator()</span></span><br><span class="line"><span class="string">   *     返回在此 collection 的元素上进行迭代的迭代器</span></span><br><span class="line"><span class="string">   *————————————————————————————————————————————————————————————————————          </span></span><br><span class="line"><span class="string">   *    ArrayList类 重写方法 iterator(),返回了Iterator接口的实现类的对象</span></span><br><span class="line"><span class="string">   *    使用ArrayList集合的对象</span></span><br><span class="line"><span class="string">   *     Iterator it =array.iterator(),运行结果就是Iterator接口的实现类ArrayList的对象</span></span><br><span class="line"><span class="string">   *     it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代</span></span><br><span class="line"><span class="string">   */"</span></span><br></pre></td></tr></table></figure><h3 id="08迭代器的代码实现"><a href="#08迭代器的代码实现" class="headerlink" title="08迭代器的代码实现"></a>08迭代器的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*A:迭代器的代码实现</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      coll.add(<span class="string">"abc1"</span>);</span><br><span class="line">      coll.add(<span class="string">"abc2"</span>);</span><br><span class="line">      coll.add(<span class="string">"abc3"</span>);</span><br><span class="line">      coll.add(<span class="string">"abc4"</span>);</span><br><span class="line">      <span class="comment">//迭代器,对集合ArrayList中的元素进行取出</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//调用集合的方法iterator()获取出,Iterator接口的实现类的对象</span></span><br><span class="line">      Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">      <span class="comment">//接口实现类对象,调用方法hasNext()判断集合中是否有元素</span></span><br><span class="line">      <span class="comment">//boolean b = it.hasNext();</span></span><br><span class="line">      <span class="comment">//System.out.println(b);</span></span><br><span class="line">      <span class="comment">//接口的实现类对象,调用方法next()取出集合中的元素</span></span><br><span class="line">      <span class="comment">//String s = it.next();</span></span><br><span class="line">      <span class="comment">//System.out.println(s);</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false</span></span><br><span class="line">      <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        String s = it.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">      &#125;                 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="09迭代器的执行过程"><a href="#09迭代器的执行过程" class="headerlink" title="09迭代器的执行过程"></a>09迭代器的执行过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A:迭代器的执行过程</span><br><span class="line"> a:迭代器的原理:</span><br><span class="line">   <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//cursor记录的索引值不等于集合的长度返回true,否则返回false</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">       <span class="keyword">return</span> cursor != size; <span class="comment">//cursor初值为0</span></span><br><span class="line">                       </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//next()方法作用:</span></span><br><span class="line">    <span class="comment">//①返回cursor指向的当前元素 </span></span><br><span class="line">    <span class="comment">//②cursor++</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">             <span class="keyword">int</span> i = cursor; </span><br><span class="line">             cursor = i + <span class="number">1</span>;  </span><br><span class="line">             <span class="keyword">return</span>  elementData[lastRet = i]; </span><br><span class="line">         </span><br><span class="line">         &#125;</span><br><span class="line"> b:<span class="keyword">for</span>循环迭代写法:</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;String&gt; it2 = coll.iterator(); it2.hasNext();  ) &#123;</span><br><span class="line">     System.out.println(it2.next());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="10集合迭代中的转型"><a href="#10集合迭代中的转型" class="headerlink" title="10集合迭代中的转型"></a>10集合迭代中的转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">A:集合迭代中的转型</span><br><span class="line"> a:在使用集合时，我们需要注意以下几点：</span><br><span class="line">   <span class="string">"集合中存储其实都是【对象的地址】"</span>。</span><br><span class="line">   <span class="string">"集合中可以存储基本数值"</span>：jdk1.5版本以后可以存储了。</span><br><span class="line">     <span class="string">"因为出现了【基本类型】的【包装类】，它提供了【自动装箱】操作（基本类型对象）"</span>，</span><br><span class="line">这样，<span class="string">"集合中的元素就是【基本数值】的【包装类】对象"</span>。</span><br><span class="line"></span><br><span class="line">b:<span class="string">"存储时提升了Object。取出时要使用元素的【特有内容】，必须【向下转型】"</span>。</span><br><span class="line"> <span class="string">"可以【不指定】【集合的存储类型】，即可以添加 Object 对象(任意对象)"</span>，如下所示：</span><br><span class="line"> Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> coll.add(<span class="string">"abc"</span>);</span><br><span class="line"> coll.add(<span class="string">"aabbcc"</span>);</span><br><span class="line"> coll.add(<span class="string">"shitcast"</span>);</span><br><span class="line"> Iterator it = coll.iterator();</span><br><span class="line"> <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  <span class="comment">//由于元素被存放进集合后全部被提升为Object类型</span></span><br><span class="line"> <span class="comment">//当需要使用子类对象特有方法时，需要向下转型</span></span><br><span class="line">  String str = (String) it.next();</span><br><span class="line">  System.out.println(str.length());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="string">" 注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常。"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c:Iterator接口也可以使用&lt;&gt;来控制迭代元素的类型的。代码演示如下：</span><br><span class="line"> Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> coll.add(<span class="string">"abc"</span>);</span><br><span class="line"> coll.add(<span class="string">"aabbcc"</span>);</span><br><span class="line"> coll.add(<span class="string">"shitcast"</span>);</span><br><span class="line"> Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"> <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">  String str =  it.next(); </span><br><span class="line"> <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">  System.out.println(str.length());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="11增强for循环遍历数组"><a href="#11增强for循环遍历数组" class="headerlink" title="11增强for循环遍历数组"></a>11增强for循环遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">*A:增强<span class="keyword">for</span>循环遍历数组</span><br><span class="line">  a:格式:</span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  JDK1.5新特性,增强for循环</span></span><br><span class="line"><span class="string">   *  JDK1.5版本后,出现新的接口 java.lang.Iterable</span></span><br><span class="line"><span class="string">   *    Collection开是继承Iterable</span></span><br><span class="line"><span class="string">   *    Iterable作用,实现增强for循环</span></span><br><span class="line"><span class="string">   *    </span></span><br><span class="line"><span class="string">   *    格式:</span></span><br><span class="line"><span class="string">   *      for( 数据类型  变量名 : 数组或者集合 )&#123;</span></span><br><span class="line"><span class="string">   *         sop(变量);</span></span><br><span class="line"><span class="string">   *      &#125;</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="string">"for each对于对象数组遍历的时候,可以【调用】【对象的方法】"</span></span><br><span class="line">     String[] str = &#123;<span class="string">"abc"</span>,<span class="string">"itcast"</span>,<span class="string">"cn"</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">       System.out.println(s.length());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  实现for循环,遍历数组</span></span><br><span class="line"><span class="string">    *  好处: 代码少了,方便对容器遍历</span></span><br><span class="line"><span class="string">    *  弊端: 没有索引,不能操作容器里面的元素</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">       System.out.println(i+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="12增强for循环遍历集合"><a href="#12增强for循环遍历集合" class="headerlink" title="12增强for循环遍历集合"></a>12增强for循环遍历集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A:增强<span class="keyword">for</span>循环遍历集合  </span><br><span class="line"> <span class="string">" /*</span></span><br><span class="line"><span class="string">   *  增强for循环遍历集合</span></span><br><span class="line"><span class="string">   *  存储自定义Person类型</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; array = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">    array.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>,<span class="number">20</span>));</span><br><span class="line">    array.add(<span class="keyword">new</span> Person(<span class="string">"b"</span>,<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">for</span>(Person p : array)&#123;</span><br><span class="line">      System.out.println(p);<span class="comment">// System.out.println(p.toString());</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13泛型的引入"><a href="#13泛型的引入" class="headerlink" title="13泛型的引入"></a>13泛型的引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的引入</span><br><span class="line"><span class="string">"在前面学习集合时，我们都知道集合中是可以【存放任意对象】的，</span></span><br><span class="line"><span class="string">只要把对象存储集合后，那么这时他们都会被提升成Object类型。</span></span><br><span class="line"><span class="string">当我们在取出每一个对象，并且进行相应的操作，这时必须采用【类型转换】。"</span>比如下面程序：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"abc"</span>);</span><br><span class="line">    list.add(<span class="string">"itcast"</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);<span class="string">"//由于集合没有做任何限定，任何类型都可以存放"</span></span><br><span class="line">                <span class="string">"//自动装箱:Object obj=new Integer(5);"</span></span><br><span class="line">    </span><br><span class="line">    Iterator it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123; </span><br><span class="line">      <span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">      String str = (String) it.next();<span class="comment">//String str=(String)obj;</span></span><br><span class="line">                      <span class="string">"//编译时期仅检查语法错误,String是Object的子类可以向下转型</span></span><br><span class="line"><span class="string">                      //运行时期String str=(String)(new Integer(5))</span></span><br><span class="line"><span class="string">                      //String与Integer没有父子关系所以转换失败</span></span><br><span class="line"><span class="string">                      //程序在运行时发生了问题java.lang.ClassCastException</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">      System.out.println(str.length());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14泛型的定义和使用"><a href="#14泛型的定义和使用" class="headerlink" title="14泛型的定义和使用"></a>14泛型的定义和使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的定义和使用</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> * JDK1.5 出现新的安全机制,保证程序的安全性</span></span><br><span class="line"><span class="string"> *   泛型: 指明了【集合】中【存储数据的类型】  &lt;类型变量&gt;</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    function();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    coll.add(<span class="string">"abc"</span>);</span><br><span class="line">    coll.add(<span class="string">"rtyg"</span>);</span><br><span class="line">    coll.add(<span class="string">"43rt5yhju"</span>);</span><br><span class="line"><span class="comment">//    coll.add(1);</span></span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">      String s = it.next();</span><br><span class="line">      System.out.println(s.length());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15Java中的伪泛型"><a href="#15Java中的伪泛型" class="headerlink" title="15Java中的伪泛型"></a>15Java中的伪泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">A:Java中的【伪泛型】：</span><br><span class="line"><span class="string">"泛型【只在】【编译时】存在,【编译后】就被【擦除】,在编译之前我们就可以限制集合的类型,起到安全作用"</span></span><br><span class="line"><span class="string">"编译后得到的Class文件是【没有】【泛型】的，实际并不存在泛型类，【系统】【不会】生成泛型类"</span></span><br><span class="line">例如:       ArrayList&lt;String&gt; al=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="string">"编译后"</span>:   ArrayList al=<span class="keyword">new</span> ArrayList();</span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">B：<span class="string">"运行时类查询(getClass方法)【只适用】于【原始类型】"</span>。</span><br><span class="line">可以理解为ArrayList&lt;String&gt;类是ArrayList的子类，事实上，ArrayList&lt;String&gt;类也确实像一种特殊的ArrayList类:</span><br><span class="line"><span class="string">"该ArrayList&lt;String&gt;对象【只能】添加【String对象】作为【集合元素】"</span>。</span><br><span class="line">但实际上，</span><br><span class="line"><span class="string">"系统【并没有】为ArrayList&lt;String&gt;生成【新的class文件】，</span></span><br><span class="line"><span class="string"> 而且也【不会】把ArrayList&lt;String&gt;当成【新类】来处理"</span></span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">List&lt;String&gt; l1 =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; ii = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(l1.getClass());<span class="string">"//class java.util.ArrayList"</span></span><br><span class="line">System.out.println(ii.getClass());<span class="string">"//class java.util.ArrayList"</span></span><br><span class="line">System.out.println(l1.getClass() == ii.getClass());<span class="string">"true"</span></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">C： <span class="string">"不管为泛型的【类型形参】传入哪一种一【类型实参】，</span></span><br><span class="line"><span class="string">对于Java来说，它们依然被当成【同一个类处理】，在内存中也【只占用一块内存空间】"</span>，</span><br><span class="line"><span class="string">"因此在【静态方法】、【静态初始化块】或者【静态变量】的【声明和初始化】中【不允许】</span></span><br><span class="line"><span class="string">使用【类型形参】"</span>。下面程序演示了这种<span class="string">"【错误】"</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T age; <span class="string">"【error】"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(T mm)</span></span>&#123; <span class="string">"【error】"</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">D：<span class="string">"由于系统中并不会真正生成泛型类，所以【instanceof运算符】后【不能】使用【泛型类】"</span></span><br><span class="line">List&lt;Integer&gt; ii = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">if</span>(ii <span class="keyword">instanceof</span> ArrayList)&#123;<span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ii <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;)&#123;<span class="string">"【error】"</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="16泛型类"><a href="#16泛型类" class="headerlink" title="16泛型类"></a>16泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">A:泛型类:</span><br><span class="line">a:定义格式：</span><br><span class="line">  修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">  例如，API中的ArrayList集合：</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">注意：<span class="string">"泛型类的【静态方法】、【静态初始化块】或者【静态变量】的</span></span><br><span class="line"><span class="string">    【声明和初始化】中【不允许】使用【类型形参】T"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T age;<span class="string">"【error】"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(T mm)</span></span>&#123;<span class="string">"【error】"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    T gr = <span class="number">1</span>;<span class="string">"【error】"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">b:使用格式：</span><br><span class="line">  <span class="string">"创建对象时，确定泛型的类型"</span></span><br><span class="line">  </span><br><span class="line">  例如，ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  此时，变量E的值就是String类型</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  例如，ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  此时，变量E的值就是Integer类型</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span></span>&#123; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">c:<span class="string">"可以为【任何类，接口】【增加泛型声明】</span></span><br><span class="line"><span class="string">(【井不是】【只有】集合类才可以使用泛型声明，虽然集合类是泛型的重要使用场所)"</span></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info, String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">        <span class="keyword">this</span>.id =id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info =info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id =id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;"</span>+ <span class="string">"id=: "</span> +<span class="keyword">this</span>.id+ <span class="string">"|"</span>+<span class="string">" info=: "</span>+ <span class="keyword">this</span>.info +<span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Apple&lt;Double&gt;();</span><br><span class="line">        Apple&lt;Double&gt; a1= <span class="keyword">new</span> Apple&lt;&gt;(<span class="number">25008.8</span>,<span class="string">"刘鹏001"</span>);</span><br><span class="line">        Apple&lt;Integer&gt; b2 = <span class="keyword">new</span> Apple&lt;&gt;(<span class="number">26000</span>,<span class="string">"周莉002"</span>);</span><br><span class="line">        System.out.println(a1);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">d: <span class="string">"当创建带泛型声明的自定义类，为该类定义【构造器】时，</span></span><br><span class="line"><span class="string">   【构造器名】还是【原来的类名】，【不能】【增加泛型声明】。</span></span><br><span class="line"><span class="string">例如，为Apple&lt;T&gt;类定义构造器，其【构造器名依然是Apple】，而【不是】Apple&lt;T&gt;!</span></span><br><span class="line"><span class="string">【调用】（new对象时）该构造器时却可以使用Apple&lt;T&gt;的形式，当然应该为T形参传入实际的类型参数"</span>。</span><br><span class="line">如：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(T info, String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">        <span class="keyword">this</span>.id =id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="17-泛型类派生子类"><a href="#17-泛型类派生子类" class="headerlink" title="17 泛型类派生子类"></a>17 泛型类派生子类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">A:当创建了带泛型声明的接口、父类之后，可以为该接创建实现类，或从该父类派生子类，</span><br><span class="line"><span class="string">"需要指出的是，当使用这些接口、父类时【不能】再【包含】【类型形参】。例如，下而代码就是【错误】的"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;<span class="string">"//error"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"除非：子类也是泛型类"</span>，即：SubApple&lt;T&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">B:定义方法时可以声明数据形参，调用方法(使用方法)时必须为这些数据形参传入实际的数据:</span><br><span class="line">与此类似的是，</span><br><span class="line"><span class="string">"定义类、接口、方法时可以声明类型形参，使用类、接口、方法时应该为【类型形参】传入【实际的类型】"</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple11</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple11</span> <span class="keyword">extends</span> <span class="title">Apple</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubApple11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubApple11</span><span class="params">(Integer d,String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(d,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="string">"//父类是Apple&lt;Integer&gt;"</span></span><br><span class="line"><span class="string">"返回值类型必须与Apple&lt;Integer&gt;的返回值类型完全相同"</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">super</span>.getInfo() +<span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">C: 调用方法时必须为所有的数据形参传入参数值，</span><br><span class="line"><span class="string">"与调用方法不同的是"</span>，</span><br><span class="line"><span class="string">"使用类、接口时【可以】【不为】类型形参传入【实际的类型参数】，即下面代码也是【正确】的"</span>。</span><br><span class="line"><span class="string">"此时，系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理"</span>。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;<span class="comment">//系统会把Apple&lt;T&gt;类里的T形参当成【Object类型】处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubApple</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubApple</span><span class="params">(Double d,String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(d,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="string">"//super.getInfo()是Object类型"</span></span><br><span class="line">    <span class="keyword">return</span>  (Double) <span class="keyword">super</span>.getInfo() +<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18泛型的方法"><a href="#18泛型的方法" class="headerlink" title="18泛型的方法"></a>18泛型的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的方法</span><br><span class="line">a:<span class="string">"定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;"</span></span><br><span class="line">b:泛型方法的使用:</span><br><span class="line"> <span class="number">1</span>:例如，API中的ArrayList集合中的方法：</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;  &#125; </span><br><span class="line">  <span class="comment">//该方法，用来把集合元素存储到指定数据类型的数组中，返回已存储集合元素的数组</span></span><br><span class="line"></span><br><span class="line"><span class="string">"使用格式：调用方法时，确定泛型的类型"</span></span><br><span class="line">例如:</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      String[] arr = <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line">      String[] result = list.toArray(arr);</span><br><span class="line">   <span class="string">"此时，变量T的值就是String类型。变量T，可以与定义集合的泛型不同"</span></span><br><span class="line">   <span class="keyword">public</span> &lt;String&gt; String[] toArray(String[] a)&#123;  &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  例如:</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">100</span>];</span><br><span class="line">      Integer [] result = list.toArray(arr);</span><br><span class="line">  </span><br><span class="line">  <span class="string">"此时，变量T的值就是Integer类型。变量T，可以与定义集合的泛型不同"</span></span><br><span class="line">  <span class="keyword">public</span> &lt;Integer&gt; Integer[] toArray(Integer[] a)&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19泛型的接口"><a href="#19泛型的接口" class="headerlink" title="19泛型的接口"></a>19泛型的接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的接口:</span><br><span class="line"> <span class="string">"/*</span></span><br><span class="line"><span class="string">  *  带有泛型的接口</span></span><br><span class="line"><span class="string">  *  </span></span><br><span class="line"><span class="string">  *  public interface List &lt;E&gt;&#123;</span></span><br><span class="line"><span class="string">  *    abstract boolean add(E e);</span></span><br><span class="line"><span class="string">  *  &#125;</span></span><br><span class="line"><span class="string">  * ———————————————————————————————————————————————————————————————————— </span></span><br><span class="line"><span class="string">  *A:  实现类,先实现接口,不理会泛型</span></span><br><span class="line"><span class="string">  *  public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123;</span></span><br><span class="line"><span class="string">  *  &#125;</span></span><br><span class="line"><span class="string">  *  调用者 : new ArrayList&lt;String&gt;() 后期创建集合对象的时候,指定数据类型</span></span><br><span class="line"><span class="string">  *  </span></span><br><span class="line"><span class="string">  *  ———————————————————————————————————————————————————————————————————— </span></span><br><span class="line"><span class="string">  *B:  实现类,实现接口的同时,也指定了数据类型</span></span><br><span class="line"><span class="string">  *  public class XXX implements List&lt;String&gt;&#123;</span></span><br><span class="line"><span class="string">  *  &#125;</span></span><br><span class="line"><span class="string">  *  new XXX()</span></span><br><span class="line"><span class="string">  */"</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="20泛型的好处"><a href="#20泛型的好处" class="headerlink" title="20泛型的好处"></a>20泛型的好处</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的好处</span><br><span class="line">a:将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</span><br><span class="line">b:避免了类型强转的麻烦。</span><br><span class="line">演示下列代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"abc"</span>);</span><br><span class="line">    list.add(<span class="string">"itcast"</span>);</span><br><span class="line">    <span class="comment">//list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">     <span class="comment">//集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">       String str = it.next();</span><br><span class="line">       System.out.println(str.length()); <span class="comment">//当使用Iterator&lt;String&gt;      </span></span><br><span class="line">        <span class="comment">//控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="21泛型的继承规则"><a href="#21泛型的继承规则" class="headerlink" title="21泛型的继承规则"></a>21泛型的继承规则</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A：<span class="string">"Manager类 是 Employee类 的【子类】。 但 Pair&lt;Manager&gt; 【不是】Pair&lt;Employee&gt; 的【子类】"</span> ，</span><br><span class="line"><span class="string">"即 Pair&lt;Manager&gt;  与 Pair&lt;Employee&gt; 【没有】【继承关系】"</span></span><br><span class="line"><span class="string">"无论 S 与 T 有什么联系，通常， Pair&lt;S&gt; 与 Pair&lt;T&gt; 没有联系"</span></span><br><span class="line"></span><br><span class="line">如：Integer是Number的子类</span><br><span class="line">List&lt;Integer&gt; ss = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; nn= ss; <span class="string">"// Error"</span></span><br><span class="line"></span><br><span class="line">B：<span class="string">"数组和泛型有所不同：，</span></span><br><span class="line"><span class="string">假设Foo是Bar的一个子类型(子类或者子接口)，那么 Foo[]【依然是】Bar[] 的子类型;</span></span><br><span class="line"><span class="string">但 G&lt;Foo&gt; 【不是】 G&lt;Bar&gt; 的子类型"</span>。</span><br><span class="line">Manager[] managerBuddies = &#123; ceo, cfo &#125;;</span><br><span class="line">Employee[] employeeBuddies = managerBuddies; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h3 id="22泛型的通配符"><a href="#22泛型的通配符" class="headerlink" title="22泛型的通配符"></a>22泛型的通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的通配符</span><br><span class="line"><span class="string">"为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号(?)，</span></span><br><span class="line"><span class="string">将一个问号作为类型实参传给List集合，写作:List&lt;?&gt; 意思是元素类型未知的List 。</span></span><br><span class="line"><span class="string">这个问号(?)被称为【通配符】，它的元素类型可以【匹配任何类型】(Object 类型)"</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="string">"这种带通配符的List仅表示它是【各种泛型List】的【父类】，</span></span><br><span class="line"><span class="string"> 【不能】把【元素】加入到其中，因为其类型是无法确定的"</span></span><br><span class="line">  但是程序【可以调用】get() 方法来返回List&lt;?&gt;集合指定索引处的元素，</span><br><span class="line">  其返回值是一个未知类型，但可以肯定的是，它总是一个【Object类型】</span><br><span class="line">如：</span><br><span class="line">List&lt;?&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="string">"//下面程序引起编译错误"</span></span><br><span class="line">c.add(<span class="keyword">new</span> Object());<span class="string">"//error"</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————————————————————————————— </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  泛型的通配符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  </span><br><span class="line">  HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">  </span><br><span class="line">  array.add(<span class="string">"123"</span>);</span><br><span class="line">  array.add(<span class="string">"456"</span>);</span><br><span class="line">  </span><br><span class="line">  set.add(<span class="number">789</span>);</span><br><span class="line">  set.add(<span class="number">890</span>);</span><br><span class="line">  </span><br><span class="line">  iterator(array);</span><br><span class="line">  iterator(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> *  定义方法,可以同时迭代2个集合</span></span><br><span class="line"><span class="string"> *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet</span></span><br><span class="line"><span class="string"> *  参数: 或者共同实现的接口</span></span><br><span class="line"><span class="string"> *  泛型的通配,匹配所有的数据类型  ?</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</span><br><span class="line">  Iterator&lt;?&gt; it = coll.iterator();</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//it.next()获取的对象是什么类型,就得到什么类型</span></span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">B：设定类型通配符的上限</span><br><span class="line"><span class="string">" List&lt;? extends Shape&gt; 是受限制通配符的例子，此处的问号(?)代表一个未知的类型，就像前面看到的通配符一样。</span></span><br><span class="line"><span class="string">但是此处的这个未知类型【必须】是【Shape的子类型(也可以是Shape本身)】，因此可以</span></span><br><span class="line"><span class="string">把Shape称为这个【通配符的上限】（upper bound）"</span></span><br><span class="line">类似地，</span><br><span class="line"><span class="string">"由于程序【无法确定】这个受限制的通配符的【具体类型】，</span></span><br><span class="line"><span class="string">所以【不能】把【Employee对象或其子类的对象】加入这个泛型集合中。</span></span><br><span class="line"><span class="string">例如，下面代码就是【错误】的。"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator_func</span><span class="params">(ArrayList&lt;? extends Employee&gt; list)</span></span>&#123;     </span><br><span class="line">        list.add(<span class="keyword">new</span> Manager());<span class="string">"//error"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"————————————————————————————————</span></span><br><span class="line"><span class="string">extends通配符的缺陷</span></span><br><span class="line"><span class="string">————————————————————————————————"</span></span><br><span class="line"><span class="string">"当使用 extends 通配符时，我们【无法】向其中【添加】【任何对象】。</span></span><br><span class="line"><span class="string">【只能】从中【取出】对象"</span></span><br><span class="line">例如：Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类</span><br><span class="line">Plate&lt;? extends Fruit&gt; plate = <span class="keyword">new</span> Plate&lt;Apple&gt;();</span><br><span class="line">plate.add(<span class="keyword">new</span> Apple()); <span class="string">"//Compile Error"</span></span><br><span class="line">plate.get();    <span class="comment">// Compile Success</span></span><br><span class="line"></span><br><span class="line">因为编译时只看父类，运行时看子类，在我们还【未具体运行】时，</span><br><span class="line"><span class="number">1</span>）进行<span class="string">"添加操作"</span>时：</span><br><span class="line"><span class="string">"JVM 并不知道我们要往plate里【添加】什么对象，只知道添加的是Fruit的【子类】，【无法确定】"</span>。</span><br><span class="line"><span class="number">2</span>）而执行<span class="string">"取出操作"</span>时，</span><br><span class="line">JVM 知道结果<span class="string">"一定是父类Fruit的子类，可以做自动【向上转型】，用【父类的变量】接收【子类对象】"</span></span><br><span class="line"></span><br><span class="line">即：Fruit apple = plate.get();<span class="comment">//多态的向上转型</span></span><br><span class="line">当然：</span><br><span class="line">如果考虑<span class="string">" Fruit类继承自 Food类"</span>，还可以<span class="string">"继续向上转型"</span>：</span><br><span class="line">即:Food food = plate.get();<span class="comment">//多态的向上转型</span></span><br><span class="line">同样：Object food = plate.get(); </span><br><span class="line">上述<span class="number">3</span>种 赋值 都是<span class="string">"正确"</span>的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"><span class="string">"方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象"</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator_func</span><span class="params">(ArrayList&lt;? extends Employee&gt; list)</span></span>&#123;</span><br><span class="line">        Iterator&lt;? extends Employee&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Employee e = it.next();</span><br><span class="line">            e.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line"></span><br><span class="line">C：设定类型形参的上限</span><br><span class="line">Java泛型不仅允许在使用通配符形参时设定上限，<span class="string">"而且可以在定义类型形参时设定上限，</span></span><br><span class="line"><span class="string">用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。"</span></span><br><span class="line">下面程序示范了这种用法。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    T nn;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericDemo2&lt;Integer&gt; ii= <span class="keyword">new</span> GenericDemo2&lt;&gt;();</span><br><span class="line">        GenericDemo2&lt;Double&gt;  dd = <span class="keyword">new</span> GenericDemo2&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="string">"//下面代码将引发编译异常，下面代码试图把String类型传给T形参</span></span><br><span class="line"><span class="string">//但String不是Number的子类型，所以引起编译错误"</span></span><br><span class="line">        GenericDemo2&lt;String&gt;  ss = <span class="keyword">new</span> GenericDemo2&lt;&gt;();<span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">D：设定类型形参的下限</span><br><span class="line"><span class="string">" List&lt;? super Type&gt;表示传入的未知类型【必须】是【Type本身，或者Type的父类型】"</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">Apple 类 和 Orange 类 继承自 Fruit类，</span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Apple&gt; plate = <span class="keyword">new</span> Plate&lt;Fruit&gt;();</span><br><span class="line"></span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Apple&gt; plate = <span class="keyword">new</span> Plate&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">上面的声明都是对的，因为 Object 是任何一个类的父类，而 Fruit类 是 Apple类  的父类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"————————————————————————————————</span></span><br><span class="line"><span class="string">super通配符的缺陷</span></span><br><span class="line"><span class="string">————————————————————————————————"</span></span><br><span class="line">&lt;? <span class="keyword">super</span> T&gt;</span><br><span class="line">对于使用了 <span class="keyword">super</span> 通配符的情况，我们<span class="string">"只能【存入】【 T 类型】及【 T 类型的子类】对象"</span>。</span><br><span class="line"><span class="string">"【取出】的时候【必须】用【 Object 类型】的属性指向取出的对象"</span>。</span><br><span class="line">例如：</span><br><span class="line">Apple 类 和 Orange 类 继承自 Fruit类，Fruit类继承自 Food类</span><br><span class="line"></span><br><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; plate = <span class="keyword">new</span> Plate&lt;&gt;();</span><br><span class="line">plate.add(<span class="keyword">new</span> Fruit());</span><br><span class="line">plate.add(<span class="keyword">new</span> Apple());</span><br><span class="line">plate.add(<span class="keyword">new</span> Food()); <span class="string">"//Compile Error"</span></span><br><span class="line"></span><br><span class="line">plate 指向的具体类型可以是任何 <span class="string">"Fruit类及其父类"</span>，JVM 在编译的时候肯定<span class="string">"无法判断具体是哪个类型"</span>。</span><br><span class="line">但 JVM 能确定的是，</span><br><span class="line"><span class="string">"任何 Fruit 的子类【都可以】自动【向上转型】为 Fruit 类型"</span>，</span><br><span class="line"><span class="string">"但任何 Fruit 的父类都【无法直接】转为 Fruit 类型，【只能】【向下强转】"</span>。</span><br><span class="line">所以 <span class="string">"只能存入 T 类型及 T 类型的【子类】对象"</span>，<span class="string">"T 类型的子类对象 能自动 【向上转型】为T 类型"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object object = plate.get();</span><br><span class="line">Fruit fruit = plate.get();  <span class="string">"//Error"</span></span><br><span class="line">Food food = plate.get();  <span class="string">"//Error"</span></span><br><span class="line">plate 指向的具体类型可以是任何 <span class="string">"Fruit类及其父类"</span>,</span><br><span class="line">接收类型是不确定的，<span class="string">"只能用Object 类型才能正确接收"</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">——————————————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">总结：</span><br><span class="line">PECS(Producer Extends, Consumer Super)原则</span><br><span class="line">extends 和 <span class="keyword">super</span> 通配符的使用和限制：</span><br><span class="line"></span><br><span class="line">对于 <span class="string">"extends 通配符"</span>，我们<span class="string">"【无法】向其中【加入】任何对象"</span>，但是<span class="string">"我们可以进行正常的取出"</span>。</span><br><span class="line">对于 <span class="keyword">super</span> 通配符，我们<span class="string">"可以存入 【T 类型】对象或 【T 类型的子类】对象"</span>，</span><br><span class="line">但是我们取出的时候<span class="string">"【只能】用【 Object 类】变量指向取出的对象"</span>。</span><br><span class="line"></span><br><span class="line">从上面的总结可以看出，<span class="string">"extends 通配符"</span><span class="string">"偏向于内容的获取"</span>，而 <span class="keyword">super</span> 通配符更<span class="string">"偏向于内容的存入"</span>。</span><br><span class="line"></span><br><span class="line">我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。</span><br><span class="line"></span><br><span class="line">Producer Extends 说的是当你的情景是<span class="string">"生产者类型"</span>，需要<span class="string">"获取资源"</span>以供生产时，</span><br><span class="line">我们建议使用<span class="string">" extends 通配符"</span>，因为使用了 extends 通配符的类型更适合获取资源。</span><br><span class="line"></span><br><span class="line">Consumer Super 说的是当你的场景是<span class="string">"消费者类型"</span>，需要<span class="string">"存入资源"</span>以供消费时，</span><br><span class="line">我们建议使用 <span class="string">"super 通配符"</span>，因为使用 <span class="keyword">super</span> 通配符的类型更适合存入资源。</span><br><span class="line"></span><br><span class="line">但如果你<span class="string">"既想存入，又想取出"</span>，那么你最好还是不要使用 extends 或 <span class="keyword">super</span> 通配符。</span><br></pre></td></tr></table></figure><h3 id="23泛型的限定"><a href="#23泛型的限定" class="headerlink" title="23泛型的限定"></a>23泛型的限定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">A:泛型的限定</span><br><span class="line"><span class="string">" /*</span></span><br><span class="line"><span class="string">*  将的酒店员工,厨师,服务员,经理,分别存储到3个集合中</span></span><br><span class="line"><span class="string">*  定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法</span></span><br><span class="line"><span class="string">*/"</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建3个集合对象</span></span><br><span class="line">  ArrayList&lt;ChuShi&gt; cs = <span class="keyword">new</span> ArrayList&lt;ChuShi&gt;();</span><br><span class="line">  ArrayList&lt;FuWuYuan&gt; fwy = <span class="keyword">new</span> ArrayList&lt;FuWuYuan&gt;();</span><br><span class="line">  ArrayList&lt;JingLi&gt; jl = <span class="keyword">new</span> ArrayList&lt;JingLi&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//每个集合存储自己的元素</span></span><br><span class="line">  cs.add(<span class="keyword">new</span> ChuShi(<span class="string">"张三"</span>, <span class="string">"后厨001"</span>));</span><br><span class="line">  cs.add(<span class="keyword">new</span> ChuShi(<span class="string">"李四"</span>, <span class="string">"后厨002"</span>));</span><br><span class="line">  </span><br><span class="line">  fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">"翠花"</span>, <span class="string">"服务部001"</span>));</span><br><span class="line">  fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">"酸菜"</span>, <span class="string">"服务部002"</span>));</span><br><span class="line">  </span><br><span class="line">  jl.add(<span class="keyword">new</span> JingLi(<span class="string">"小名"</span>, <span class="string">"董事会001"</span>, <span class="number">123456789.32</span>));</span><br><span class="line">  jl.add(<span class="keyword">new</span> JingLi(<span class="string">"小强"</span>, <span class="string">"董事会002"</span>, <span class="number">123456789.33</span>));</span><br><span class="line">  </span><br><span class="line"><span class="comment">//   ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;();</span></span><br><span class="line">  iterator(jl);</span><br><span class="line">  iterator(fwy);</span><br><span class="line">  iterator(cs);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"/*</span></span><br><span class="line"><span class="string"> * 定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法 work</span></span><br><span class="line"><span class="string"> * ? 通配符,迭代器it.next()方法取出来的是Object类型,怎么调用work方法</span></span><br><span class="line"><span class="string"> * 强制转换:  it.next()=Object o ==&gt; Employee</span></span><br><span class="line"><span class="string"> * 方法参数: 控制,可以传递Employee对象,也可以传递Employee的子类的对象</span></span><br><span class="line"><span class="string"> * 【泛型的限定】  本案例,父类固定Employee,但是子类可以无限?</span></span><br><span class="line"><span class="string"> *  ———————————————————————————————————————————————————————————————————— </span></span><br><span class="line"><span class="string"> *   ? extends Employee  限制的是【父类】, 【上限限定】, 可以传递Employee,传递他的【子类】对象</span></span><br><span class="line"><span class="string"> *   ———————————————————————————————————————————————————————————————————— </span></span><br><span class="line"><span class="string"> *   ? super   Employee  限制的是【子类】, 【下限限定】, 可以传递Employee,传递他的【父类】对象</span></span><br><span class="line"><span class="string"> */"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;? extends Employee&gt; array)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">   Iterator&lt;? extends Employee&gt; it = array.iterator();</span><br><span class="line">   <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">     <span class="comment">//获取出的next() 数据类型,是什么Employee</span></span><br><span class="line">     Employee e = it.next();</span><br><span class="line">     e.work();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1544080633/samples/java%20files/photo-1542127556-39e356556a8a.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、集合&lt;br&gt;2、Iterator迭代器&lt;br&gt;3、增强for循环&lt;br&gt;4、泛型&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记——基础15(包装类,System类,Math类,Arrays类)</title>
    <link href="https://leesen998.github.io/2016/10/25/day17%E7%AC%94%E8%AE%B0/"/>
    <id>https://leesen998.github.io/2016/10/25/day17笔记/</id>
    <published>2016-10-25T01:48:29.000Z</published>
    <updated>2018-12-21T11:26:16.532Z</updated>
    
    <content type="html"><![CDATA[<p class="description"></p><p><img src="https://res.cloudinary.com/dpvywdzxv/image/upload/v1543368661/samples/java%20files/photo-1542827634-7aa7281fb965.jpg"></p><p>1、基本类型包装类<br>2、System类<br>3、Math类<br>4、Arrays类<br>5、大数据运算</p><a id="more"></a><h3 id="01基本数据类型对象包装类概述"><a href="#01基本数据类型对象包装类概述" class="headerlink" title="01基本数据类型对象包装类概述"></a>01基本数据类型对象包装类概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*A:基本数据类型对象包装类概述</span><br><span class="line">  *a.基本类型包装类的产生</span><br><span class="line">         在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成<span class="keyword">int</span>类型，考试成绩需要转换成<span class="keyword">double</span>类型等</span><br><span class="line">     *b.八种基本类型对应的包装类</span><br><span class="line">         <span class="keyword">char</span>    Character</span><br><span class="line">         <span class="keyword">int</span>     Integer</span><br><span class="line">         <span class="keyword">byte</span>    Byte</span><br><span class="line">         <span class="keyword">short</span>   Short</span><br><span class="line">         <span class="keyword">long</span>    Long</span><br><span class="line">         <span class="keyword">float</span>   Float</span><br><span class="line">         <span class="keyword">double</span>  Double</span><br><span class="line">         <span class="keyword">boolean</span> Boolean</span><br></pre></td></tr></table></figure><h3 id="02Integer类parseInt方法"><a href="#02Integer类parseInt方法" class="headerlink" title="02Integer类parseInt方法"></a>02Integer类parseInt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  *A:Integer类parseInt方法:</span><br><span class="line">   *a:parseInt()</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(<span class="string">"12"</span>);</span><br><span class="line">    System.out.println(i/<span class="number">2</span>);<span class="comment">//6</span></span><br><span class="line"> </span><br><span class="line">*b:parseInt(String s, <span class="keyword">int</span> radix)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Integer类静态方法parseInt(String s, int radix)</span></span><br><span class="line"><span class="comment">  * radix基数,进制</span></span><br><span class="line"><span class="comment">  * "110",2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制</span></span><br><span class="line"><span class="comment">  *  指定进制的字符串转换为十进制的整数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i = Integer.parseInt(<span class="string">"110"</span>, <span class="number">2</span>);</span><br><span class="line"> System.out.println(i);</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"f"</span>,<span class="number">16</span>);</span><br><span class="line">      System.out.println(a);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="03Integer类int转成字符串"><a href="#03Integer类int转成字符串" class="headerlink" title="03Integer类int转成字符串"></a>03Integer类int转成字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*A:Integer类<span class="keyword">int</span>转成字符串:</span><br><span class="line">     *a:使用+与字符串拼接</span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">        String s = i+<span class="string">""</span>;</span><br><span class="line">        System.out.println(s+<span class="number">1</span>);<span class="comment">//"31"</span></span><br><span class="line">    </span><br><span class="line">     *b:toString(<span class="keyword">int</span> ,<span class="keyword">int</span> 进制),任意进制整数转成任意进制的字符串 (了解)</span><br><span class="line">        String s1 = Integer.toString(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(s1);</span><br></pre></td></tr></table></figure><h3 id="04Integer类构造方法"><a href="#04Integer类构造方法" class="headerlink" title="04Integer类构造方法"></a>04Integer类构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*A:Integer类构造方法</span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">    *  Integer类构造方法</span></span><br><span class="line"><span class="string">    *   Integer (String s)</span></span><br><span class="line"><span class="string">    *   将数字格式的字符串,传递到Integer类的构造方法中</span></span><br><span class="line"><span class="string">    *   创建Integer对象,包装的是一个字符串</span></span><br><span class="line"><span class="string">    *   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue()</span></span><br><span class="line"><span class="string">    */"</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Integer in = <span class="keyword">new</span> Integer(<span class="string">"100"</span>);</span><br><span class="line">   <span class="keyword">int</span> i = in.intValue();</span><br><span class="line">   System.out.println(--i);<span class="comment">//99</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="05Integer类其他方法"><a href="#05Integer类其他方法" class="headerlink" title="05Integer类其他方法"></a>05Integer类其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*A:Integer类其他方法</span><br><span class="line">   <span class="string">"/*</span></span><br><span class="line"><span class="string">* Integer类的3个静态方法</span></span><br><span class="line"><span class="string">* 做进制的转换</span></span><br><span class="line"><span class="string">* 十进制转成二进制  toBinarString(int)</span></span><br><span class="line"><span class="string">* 十进制转成八进制  toOctalString(int)</span></span><br><span class="line"><span class="string">* 十进制转成十六进制 toHexString(int)</span></span><br><span class="line"><span class="string">* 三个方法,返回值都是以String形式出现</span></span><br><span class="line"><span class="string">*/"</span></span><br><span class="line">    a:十进制转二,八,十六进制</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(Integer.toBinaryString(<span class="number">99</span>));</span><br><span class="line">      System.out.println(Integer.toOctalString(<span class="number">99</span>));</span><br><span class="line">      System.out.println(Integer.toHexString(<span class="number">999</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    b:获取<span class="keyword">int</span>的最大值和最小值</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   Integer类的静态成员变量</span></span><br><span class="line"><span class="comment">     *   MAX_VALUE</span></span><br><span class="line"><span class="comment">     *   MIN_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(Integer.MAX_VALUE);</span><br><span class="line">    System.out.println(Integer.MIN_VALUE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="06自动装箱和自动拆箱-valueOf"><a href="#06自动装箱和自动拆箱-valueOf" class="headerlink" title="06自动装箱和自动拆箱,valueOf"></a>06自动装箱和自动拆箱,valueOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> *A:自动装箱与自动拆箱:</span><br><span class="line">   <span class="string">"//JDK1.5新特性</span></span><br><span class="line"><span class="string">//自动装箱,拆箱的 好处: 基本类型和引用类直接运算</span></span><br><span class="line"><span class="string">   //自动装箱:使用Integer.valueOf(整数值)返回一个封装了该整数值的Integer对象</span></span><br><span class="line"><span class="string">   //自动拆箱:使用Integer对象.intValue()返回Integer对象中封装的整数值"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//引用类型 , 引用变量一定指向对象</span></span><br><span class="line"><span class="comment">//自动装箱, 基本数据类型1, 直接变成了对象</span></span><br><span class="line"></span><br><span class="line">Integer in = <span class="number">1</span>; <span class="comment">// Integer in = new Integer(1)</span></span><br><span class="line"><span class="comment">//in 是引用类型,不能和基本类型运算, 自动拆箱,引用类型in,转换基本类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//in+1  ==&gt; in.inValue()+1 = 2    </span></span><br><span class="line"><span class="comment">//in = 2    自动装箱</span></span><br><span class="line">in = in + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(in);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf() 方法"></a>valueOf() 方法</h4><p>继承自Java Number类</p><p>valueOf() 方法用于返回给定参数的<strong>原生 Number 对象值</strong>，<strong>参数可以是原生数据类型, String等。</strong></p><p>该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数。</p><p>语法<br>该方法有以下几种语法格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure></p><p>参数<br>i – Integer 对象的整数。</p><p>s – Integer 对象的字符串。</p><p>radix –<strong>在解析字符串 s 时使用的基数，用于指定使用的进制数</strong>。</p><p>返回值<br>Integer valueOf(int i)：返回一个表示指定的 int 值的 Integer 实例。</p><p>Integer valueOf(String s):返回保存指定的 String 的值的 Integer 对象。</p><p>Integer valueOf(String s, int radix): 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。</p><p>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Integer x =Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">        Double c = Double.valueOf(<span class="number">5</span>);</span><br><span class="line">        Float a = Float.valueOf(<span class="string">"80"</span>);               </span><br><span class="line"></span><br><span class="line">        Integer b = Integer.valueOf(<span class="string">"789"</span>,<span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x); </span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译以上程序，输出结果为：</p><p>9<br>5.0<br>80.0<br>1929</p><p>前言<br>今天在做题时，碰到了一道选择题，就是关于Integer.valueOf()的知识，题目如下：<br>Integer i01=59<br>int i02=59<br>Integer i03 =Integer.valueOf(59)<br>Integer i04 = new Integer(59)</p><p>判断对错：<br>A.System.out.println(i01== i02);<br>B.System.out.println(i01== i03);<br>C.System.out.println(i03== i04);<br>D.System.out.println(i02== i04);</p><p>  </p><p>分析</p><h4 id="选项A"><a href="#选项A" class="headerlink" title="选项A"></a>选项A</h4><p>  选项A中比较的是i01和i02，Integer i01=59这里涉及到自动装箱过程，59是整型常量，经包装使其产生一个引用并存在栈中指向这个整型常量所占的内存，这时i01就是Integer 的引用。<br>  而<strong>int i02=59由于int是基本类型，所以不存在引用问题，直接由编译器将其存放在栈中，换一句话说，i02本身就是59。那么System.out.println(i01== i02)结果任何呢？这里涉及到了拆箱的过程，因为等号一边存在基本类型所以编译器后会把另一边的Integer对象拆箱成int型，这时等号两边比较的就是数值大小，所以是true</strong>。</p><p>好了，到了这里，你有没有想到这样一个问题：如果是Integer i01=59；Integer i02=59；然后System.out.println(i01== i02)的结果是？可能你会说比较数值大小所以相等啊，也有可能说等号两边对象引用，所以比较的是引用，又因为开辟了不同的内存空间，所以引用不同所以返回false。可是正确答案是：true.<br>再来看这个问题：：<br><strong>如果是Integer i01=300；Integer i02=300；然后System.out.println(i01== i02)的结果是？ 这次的答案是false。</strong><br>  解析：当靠想象无法解决问题的时候，这是就要看源代码了！！很重要！我们可以在Integer类中找到这样的嵌套内部类IntegerCache：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;<span class="comment">//静态缓存类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;  <span class="comment">//静态代码块</span></span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>  这个类就是在Integer类装入内存中时，会执行其内部类中静态代码块进行其初始化工作，做的主要工作就是<strong>把一字节的整型数据（-128-127）包装成Integer类并把其对应的引用存入到cache数组</strong>中，这样在方法区中开辟空间存放这些静态Integer变量，同时静态cache数组也存放在这里，供线程享用，这也称<strong>静态缓存</strong>。<br>  所以当用Integer 声明初始化变量时，会先判断所赋值的大小是否在<strong>-128到127</strong>之间，若在，则利用静态缓存中的空间并且返回对应cache数组中对应引用，存放到运行栈中，而<strong>不再重新开辟内存</strong>。<br>  所以对于Integer i01=59；Integer i02=59；<strong>i01 和 i02是引用并且相等都指向缓存中的数据，所以返回true。而对于</strong>Integer i01=300；Integer i02=300；因为其数据大于127，所以虚拟机会在堆中重新new （开辟新空间）一个 Integer 对象存放300，创建2个对象就会产生2个这样的空间，空间的地址肯定不同导致返回到栈中的引用的只不同。所以System.out.println打印出false。</p><p>补充：为什么1个字节的数据范围是-128到127呢，因为Java中数据的表示都是带符号数，所以最高位是用来表示数据的正负，0表示正数，1表示负数，所以正数最大的情况对应的二进制数为：01111111，负数最小对应的二进制数为：10000000.</p><h4 id="B选项"><a href="#B选项" class="headerlink" title="B选项"></a>B选项</h4><p>  从上面的分析，我们已经知道Integer i01=59返回的是指向缓存数据的引用。那么<strong>Integer.valueOf(59)返回的是什么或者操作是什么呢？<br>  这个函数的功能就是把int 型转换成Integer，简单说就是装包</strong>，那他是新创建一个对象吗？还是像之前利用缓存的呢？有了之前的经验，肯定想到的是利用缓存，这样做既提高程序速度，又节约内存，何乐而不为？<br>来看一下源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>  很明显跟之前的思想一致，若在-128到127范围，直接返回该对象的引用，否则在堆中重新new 一个。<br>  到这，System.out.println(i01== i03)的结果毋庸置疑就是true.</p><h4 id="选项C"><a href="#选项C" class="headerlink" title="选项C"></a>选项C</h4><p>  Integer.valueOf(59)返回的是<strong>已缓存的对象的引用</strong>，而<strong>Integer i04 = new Integer(59)是在堆中新开辟的空间</strong>，所以二者的引用的值必然不同，返回false,这道题呢就选C</p><h4 id="选项D"><a href="#选项D" class="headerlink" title="选项D"></a>选项D</h4><p>  System.out.println(i02== i04) i02是整型变量，i04是引用，这里又用到了解包，<strong>虚拟机会把i04指向的数据拆箱为整型变量再与之比较，所以比较的是数值</strong>，59==59，返回true.</p><p>思考<br>  不得不服，Java这的设计真是巧妙，以后应多注意看看源码，其思想使我受益匪浅。<br>出一道题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(<span class="string">"127"</span>)==Integer.valueOf(<span class="string">"127"</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(Integer.valueOf(<span class="string">"128"</span>)==Integer.valueOf(<span class="string">"128"</span>));<span class="comment">//false</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"128"</span>)==Integer.valueOf(<span class="string">"128"</span>));<span class="comment">//true</span></span><br><span class="line"><span class="string">"//parseInt返回的是10进制整数，Integer.valueOf("</span><span class="number">128</span><span class="string">")的Integer对象拆箱成int型，</span></span><br><span class="line"><span class="string"> 这时等号两边比较的就是数值大小，所以是true"</span></span><br></pre></td></tr></table></figure></p><h3 id="07自动装箱和自动拆箱练习题"><a href="#07自动装箱和自动拆箱练习题" class="headerlink" title="07自动装箱和自动拆箱练习题"></a>07自动装箱和自动拆箱练习题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*A:自动装箱与自动拆箱:</span><br><span class="line">  Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i==j);<span class="comment">// false 对象地址</span></span><br><span class="line">System.out.println(i.equals(j));<span class="comment">// true  继承Object重写equals,比较的对象数据</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">500</span>;<span class="comment">//Integer integer=Integer.valueOf(500)</span></span><br><span class="line">                <span class="comment">//integer=new Integer(500);</span></span><br><span class="line">Integer b = <span class="number">500</span>;</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"==================="</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"数据在byte(-128~127)范围内,JVM不会从新new对象"</span></span><br><span class="line">Integer aa = <span class="number">127</span>; <span class="comment">// Integer aa = new Integer(127)</span></span><br><span class="line">Integer bb = <span class="number">127</span>; <span class="comment">// Integer bb = aa;</span></span><br><span class="line">System.out.println(aa==bb); <span class="comment">//true</span></span><br><span class="line">System.out.println(aa.equals(bb));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="08System类方法currentTimeMillis"><a href="#08System类方法currentTimeMillis" class="headerlink" title="08System类方法currentTimeMillis"></a>08System类方法currentTimeMillis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，</span><br><span class="line">提供了对应的一些系统属性信息，和系统操作。</span><br><span class="line">System类<span class="string">"不能手动创建对象"</span>，因为<span class="string">"构造方法"</span>被<span class="keyword">private</span>修饰，</span><br><span class="line"><span class="string">"阻止外界创建对象"</span>。</span><br><span class="line">System类中的<span class="string">"都是"</span><span class="keyword">static</span>方法，<span class="string">"类名访问即可"</span>。</span><br><span class="line">在JDK中，有许多这样的类。</span><br><span class="line"></span><br><span class="line">*A:System类方法currentTimeMillis():用于计算程序的执行时间</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  获取系统当前毫秒值</span></span><br><span class="line"><span class="comment">   *  static long currentTimeMillis()</span></span><br><span class="line"><span class="comment">   *  对程序执行时间测试</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//当前时间x-1970年1月1日零时零分零秒</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> end = System.currentTimeMillis();<span class="comment">//当前时间y-1970年1月1日零时零分零秒</span></span><br><span class="line">  System.out.println(end - start);<span class="comment">//当前时间y-当前时间x </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="09System类方法exit"><a href="#09System类方法exit" class="headerlink" title="09System类方法exit"></a>09System类方法exit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> *A:System类方法exit()方法</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  退出虚拟机,所有程序全停止</span></span><br><span class="line"><span class="comment"> *  static void exit(0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">System.exit(<span class="number">0</span>);<span class="comment">//该方法会在以后的finally代码块中使用(讲到再说)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10System类方法gc"><a href="#10System类方法gc" class="headerlink" title="10System类方法gc"></a>10System类方法gc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A:System类方法gc</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"垃圾收取了"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="string">"*</span></span><br><span class="line"><span class="string">   *  JVM在内存中,收取对象的垃圾</span></span><br><span class="line"><span class="string">   *  当没有更多引用指向该对象时,会自动调用垃圾回收机制回收堆中的对象</span></span><br><span class="line"><span class="string">   *  同时调用回收对象所属类的 【finalize方法()</span></span><br><span class="line"><span class="string">   *  static void gc()</span></span><br><span class="line"><span class="string">   *"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  <span class="keyword">new</span> Person();</span><br><span class="line">  System.gc();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="11System类方法getProperties"><a href="#11System类方法getProperties" class="headerlink" title="11System类方法getProperties"></a>11System类方法getProperties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A:System类方法getProperties(了解)</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  获取当前操作系统的属性:例如操作系统名称,</span></span><br><span class="line"><span class="comment">  *  static Properties getProperties() </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println( System.getProperties() );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="12System类方法arraycopy"><a href="#12System类方法arraycopy" class="headerlink" title="12System类方法arraycopy"></a>12System类方法arraycopy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">" /*</span></span><br><span class="line"><span class="string">   * System类方法,复制数组,这是一个本地方法</span></span><br><span class="line"><span class="string">   * arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="string">   * Object src, 要复制的源数组</span></span><br><span class="line"><span class="string">   * int srcPos, 数组源的起始索引</span></span><br><span class="line"><span class="string">   * Object dest,复制后的目标数组</span></span><br><span class="line"><span class="string">   * int destPos,目标数组起始索引 </span></span><br><span class="line"><span class="string">   * int length, 复制几个</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</span></span><br><span class="line"><span class="string">从 src 引用的【源数组】到 dest 引用的【目标数组】，数组组件的一个【子序列】被复制下来。</span></span><br><span class="line"><span class="string">被复制的组件的编号等于 length 参数。</span></span><br><span class="line"><span class="string">【源数组】中位置在【 srcPos 】到【 srcPos+length-1 】之间的组件</span></span><br><span class="line"><span class="string">被分别复制到【目标数组】中的【 destPos 】到【 destPos+length-1 】位置。"</span></span><br><span class="line"></span><br><span class="line"> A:System类方法arraycopy：</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * System类方法,复制数组</span></span><br><span class="line"><span class="comment">   * arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="comment">   * Object src, 要复制的源数组</span></span><br><span class="line"><span class="comment">   * int srcPos, 数组源的起始索引</span></span><br><span class="line"><span class="comment">   * Object dest,复制后的目标数组</span></span><br><span class="line"><span class="comment">   * int destPos,目标数组起始索引 </span></span><br><span class="line"><span class="comment">   * int length, 复制几个</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] src = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>[] desc = &#123;<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">  System.arraycopy(src, <span class="number">1</span>, desc, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//将src数组的1位置开始(包含1位置)的两个元素,拷贝到desc的1,2位置上</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; desc.length ; i++)&#123;</span><br><span class="line">  System.out.println(desc[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="13Math类的方法-1"><a href="#13Math类的方法-1" class="headerlink" title="13Math类的方法_1"></a>13Math类的方法_1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">A:Math类中的方法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static double sqrt(double d)</span></span><br><span class="line"><span class="comment"> * 返回参数的平方根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = Math.sqrt(-<span class="number">2</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*0</span></span><br><span class="line"><span class="comment"> * static double pow(double a, double b)</span></span><br><span class="line"><span class="comment"> * a的b次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = Math.pow(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static double floor(double d)</span></span><br><span class="line"><span class="comment"> * 返回小于或者等于参数d的最大整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = Math.floor(<span class="number">1.5</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  static double ceil(double d)</span></span><br><span class="line"><span class="comment"> *  返回大于或者等于参数d的最小整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> d = Math.ceil(<span class="number">5.1</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  static int abs(int i)</span></span><br><span class="line"><span class="comment"> *  获取参数的绝对值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = Math.abs(<span class="number">0</span>);</span><br><span class="line">System.out.println(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="14Math类的方法-2"><a href="#14Math类的方法-2" class="headerlink" title="14Math类的方法_2"></a>14Math类的方法_2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A:Math类的方法_2</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  static double round(doubl d)</span></span><br><span class="line"><span class="comment">  *  获取参数的四舍五入,取整数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_6</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">double</span> d = Math.round(<span class="number">5.4195</span>);</span><br><span class="line"> System.out.println(d);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  static double random() 返回随机数 0.0-1.0之间</span></span><br><span class="line"><span class="comment">  *  来源,也是Random类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_5</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ;i++)&#123;</span><br><span class="line"> <span class="keyword">double</span> d = Math.random();</span><br><span class="line"> System.out.println(d);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="15Arrays工具类"><a href="#15Arrays工具类" class="headerlink" title="15Arrays工具类"></a>15Arrays工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">A:Arrays工具类:</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  function_2();</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">56</span>,<span class="number">65</span>,<span class="number">11</span>,<span class="number">98</span>,<span class="number">57</span>,<span class="number">43</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>[] newArray = test(arr);</span><br><span class="line">  System.out.println(Arrays.toString(newArray));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  定义方法,接收输入,存储的是10个人考试成绩</span></span><br><span class="line"><span class="string">   *  将最后三个人的成绩,存储到新的数组中,返回新的数组</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] test(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">  <span class="comment">//对数组排序</span></span><br><span class="line">  Arrays.sort(arr);</span><br><span class="line">  <span class="comment">//将最后三个成绩存储到新的数组中</span></span><br><span class="line">  <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">//成绩数组的最后三个元素,复制到新数组中</span></span><br><span class="line">  <span class="comment">//System.arraycopy(arr, 0, result, 0, 3);</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; <span class="number">3</span> ;i++)&#123;</span><br><span class="line">  result[i] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  static String toString(数组)</span></span><br><span class="line"><span class="string">   *  将数组变成字符串</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  String s = Arrays.toString(arr);</span><br><span class="line">  System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  static int binarySearch(数组, 被查找的元素)</span></span><br><span class="line"><span class="string">   *  数组的二分搜索法</span></span><br><span class="line"><span class="string">   *  返回元素在数组中出现的索引</span></span><br><span class="line"><span class="string">   *  元素不存在, 返回的是  (-插入点-1)</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">18</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> index =  Arrays.binarySearch(arr, <span class="number">10</span>);</span><br><span class="line">      System.out.println(index);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="string">"/*</span></span><br><span class="line"><span class="string">   *  static void sort(数组)</span></span><br><span class="line"><span class="string">   *  对数组升序排列</span></span><br><span class="line"><span class="string">   */"</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  Arrays.sort(arr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="16数组复制练习"><a href="#16数组复制练习" class="headerlink" title="16数组复制练习"></a>16数组复制练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*A:数组复制练习:</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">56</span>,<span class="number">65</span>,<span class="number">11</span>,<span class="number">98</span>,<span class="number">57</span>,<span class="number">43</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span>[] newArray = test(arr);</span><br><span class="line">  System.out.println(Arrays.toString(newArray));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *  定义方法,接收输入,存储的是10个人考试成绩</span></span><br><span class="line"><span class="comment">   *  将最后三个人的成绩,存储到新的数组中,返回新的数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] test(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">  <span class="comment">//对数组排序</span></span><br><span class="line">  Arrays.sort(arr);</span><br><span class="line">  <span class="comment">//将最后三个成绩存储到新的数组中</span></span><br><span class="line">  <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">//成绩数组的最后三个元素,复制到新数组中</span></span><br><span class="line">      <span class="comment">//System.arraycopy(arr, 0, result, 0, 3);</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; <span class="number">3</span> ;i++)&#123;</span><br><span class="line">  result[i] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="17BigInteger类概述和构造方法"><a href="#17BigInteger类概述和构造方法" class="headerlink" title="17BigInteger类概述和构造方法"></a>17BigInteger类概述和构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:BigInteger类概述和构造方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BigInteger类的构造方法</span></span><br><span class="line"><span class="comment"> * 传递字符串,要求数字格式,没有长度限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"8465846668464684562385634168451684568645684564564"</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">BigInteger b1 = <span class="keyword">new</span> BigInteger(<span class="string">"5861694569514568465846668464684562385634168451684568645684564564"</span>);</span><br><span class="line">System.out.println(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18BigInteger类四则运算"><a href="#18BigInteger类四则运算" class="headerlink" title="18BigInteger类四则运算"></a>18BigInteger类四则运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">A:BigInteger类四则运算</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  function_1();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BigInteger对象的四则运算</span></span><br><span class="line"><span class="comment"> * 调用方法计算,计算结果也只能是BigInteger对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> BigInteger b1 = <span class="keyword">new</span> BigInteger(<span class="string">"5665464516451051581613661405146"</span>);</span><br><span class="line"> BigInteger b2 = <span class="keyword">new</span> BigInteger(<span class="string">"965855861461465516451051581613661405146"</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//计算 b1+b2对象的和,调用方法 add</span></span><br><span class="line"> BigInteger bigAdd = b1.add(b2);<span class="comment">//965855867126930032902103163227322810292</span></span><br><span class="line"> System.out.println(bigAdd);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//计算b1-b2对象的差,调用方法subtract</span></span><br><span class="line"> BigInteger bigSub = b1.subtract(b2);</span><br><span class="line"> System.out.println(bigSub);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//计算b1*b2对象的乘积,调用方法multiply</span></span><br><span class="line"> BigInteger bigMul = b1.multiply(b2);</span><br><span class="line"> System.out.println(bigMul);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//计算b2/b1对象商,调用方法divied</span></span><br><span class="line"> BigInteger bigDiv = b2.divide(b1);</span><br><span class="line"> System.out.println(bigDiv);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="19员工案例的子类的编写"><a href="#19员工案例的子类的编写" class="headerlink" title="19员工案例的子类的编写"></a>19员工案例的子类的编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:BigDecimal类概述 </span><br><span class="line">   </span><br><span class="line">  <span class="string">" /*</span></span><br><span class="line"><span class="string">    * 计算结果,未知</span></span><br><span class="line"><span class="string">    * 原因: 计算机二进制中,表示浮点数不精确造成</span></span><br><span class="line"><span class="string">    * 超级大型的浮点数据,提供高精度的浮点运算, BigDecimal</span></span><br><span class="line"><span class="string">   System.out.println(0.09 + 0.01);//0.09999999999999999</span></span><br><span class="line"><span class="string">   System.out.println(1.0 - 0.32);//0.6799999999999999</span></span><br><span class="line"><span class="string">   System.out.println(1.015 * 100);//101.49999999999999</span></span><br><span class="line"><span class="string">   System.out.println(1.301 / 100);//0.013009999999999999 </span></span><br><span class="line"><span class="string">   */"</span></span><br></pre></td></tr></table></figure><h3 id="20BigDecimal类实现加法减法乘法"><a href="#20BigDecimal类实现加法减法乘法" class="headerlink" title="20BigDecimal类实现加法减法乘法"></a>20BigDecimal类实现加法减法乘法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A:BigDecimal类实现加法减法乘法</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *  BigDecimal实现三则运算</span></span><br><span class="line"><span class="comment">  *  + - *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"> BigDecimal b1 =  <span class="keyword">new</span> BigDecimal(<span class="string">"0.09"</span>);</span><br><span class="line"> BigDecimal b2 =  <span class="keyword">new</span> BigDecimal(<span class="string">"0.01"</span>);</span><br><span class="line"> <span class="comment">//计算b1+b2的和,调用方法add</span></span><br><span class="line"> BigDecimal bigAdd = b1.add(b2);</span><br><span class="line"> System.out.println(bigAdd);</span><br><span class="line"> </span><br><span class="line"> BigDecimal b3 = <span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>);</span><br><span class="line"> BigDecimal b4 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.32"</span>);</span><br><span class="line"> <span class="comment">//计算b3-b2的差,调用方法subtract</span></span><br><span class="line"> BigDecimal bigSub = b3.subtract(b4);</span><br><span class="line"> System.out.println(bigSub);</span><br><span class="line"> </span><br><span class="line"> BigDecimal b5 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.015"</span>);</span><br><span class="line"> BigDecimal b6 = <span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>);</span><br><span class="line"> <span class="comment">//计算b5*b6的成绩,调用方法 multiply</span></span><br><span class="line"> BigDecimal bigMul = b5.multiply(b6);</span><br><span class="line"> System.out.println(bigMul);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="21BigDecimal类实现除法"><a href="#21BigDecimal类实现除法" class="headerlink" title="21BigDecimal类实现除法"></a>21BigDecimal类实现除法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A:BigDecimal类实现除法</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BigDecimal实现除法运算</span></span><br><span class="line"><span class="comment"> * divide(BigDecimal divisor, int scale, int roundingMode) </span></span><br><span class="line"><span class="comment"> * int scale : 保留几位小数</span></span><br><span class="line"><span class="comment"> * int roundingMode : 保留模式</span></span><br><span class="line"><span class="comment"> * 保留模式 阅读API文档</span></span><br><span class="line"><span class="comment"> *   static int ROUND_UP  向上+1</span></span><br><span class="line"><span class="comment"> *   static int ROUND_DOWN 直接舍去</span></span><br><span class="line"><span class="comment"> *   static int ROUND_HALF_UP  &gt;= 0.5 向上+1</span></span><br><span class="line"><span class="comment"> *   static int ROUND_HALF_DOWN   &gt; 0.5 向上+1 ,否则直接舍去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0301"</span>);</span><br><span class="line">BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>);</span><br><span class="line"><span class="comment">//计算b1/b2的商,调用方法divied</span></span><br><span class="line">BigDecimal bigDiv = b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//0.01301</span></span><br><span class="line">System.out.println(bigDiv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22小结"><a href="#22小结" class="headerlink" title="22小结"></a>22小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> 基本类型包装类</span><br><span class="line"> <span class="number">8</span>种基本类型对应的包装类</span><br><span class="line">基本类型包装类</span><br><span class="line"><span class="keyword">byte</span>Byte</span><br><span class="line"><span class="keyword">short</span>Short</span><br><span class="line"><span class="keyword">int</span> <span class="string">"Integer  "</span></span><br><span class="line"><span class="keyword">long</span>Long</span><br><span class="line"><span class="keyword">float</span>Float</span><br><span class="line"><span class="keyword">double</span>Double</span><br><span class="line"><span class="keyword">char</span><span class="string">"Character   "</span></span><br><span class="line"><span class="keyword">boolean</span>Boolean</span><br><span class="line"> 自动装箱、自动拆箱</span><br><span class="line"> 自动装箱：基本数值转成对象（<span class="keyword">int</span> &gt;&gt; Integer）</span><br><span class="line"> 自动拆箱：对象转成基本数值（Integer &gt;&gt; <span class="keyword">int</span>）</span><br><span class="line"> 常用方法</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String str)</span>:把字符串转成基本类型<span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> x)</span>:把基本类型<span class="keyword">int</span>转成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> x)</span>:返回一个表示指定的 <span class="keyword">int</span> 值的 Integer 实例。如果不需要新的 Integer 实例，则通常应优先使用该方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span>:以 <span class="keyword">int</span>类型返回该包装类对象的值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> System类: 系统属性信息工具类</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span>：获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span>：用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span>：用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperties</span><span class="params">()</span>：用来获取指系统属性信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Arrays类：数组操作工具类</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> String toString方法，用来返回指定数组元素内容的字符串形式</span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-插入点-1。要求该数组必须是个有序的数组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Math类：数学运算工具类</span></span><br><span class="line"><span class="function"> abs方法,结果都为正数</span></span><br><span class="line"><span class="function"> ceil方法，结果为比参数值大的最小整数的<span class="keyword">double</span>值</span></span><br><span class="line"><span class="function"> floor方法，结果为比参数值小的最大整数的<span class="keyword">double</span>值</span></span><br><span class="line"><span class="function"> max方法，返回两个参数值中较大的值</span></span><br><span class="line"><span class="function"> min方法，返回两个参数值中较小的值</span></span><br><span class="line"><span class="function"> pow方法，返回第一个参数的第二个参数次幂的值</span></span><br><span class="line"><span class="function"> round方法，返回参数值四舍五入的结果</span></span><br><span class="line"><span class="function"> random方法，产生一个大于等于0.0且小于1.0的<span class="keyword">double</span>小数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dpvywdzxv/image/upload/v1543368661/samples/java%20files/photo-1542827634-7aa7281fb965.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、基本类型包装类&lt;br&gt;2、System类&lt;br&gt;3、Math类&lt;br&gt;4、Arrays类&lt;br&gt;5、大数据运算&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="https://leesen998.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="java" scheme="https://leesen998.github.io/tags/java/"/>
    
  </entry>
  
</feed>
